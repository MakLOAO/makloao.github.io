<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Beautifully struggle every day">
<meta property="og:type" content="website">
<meta property="og:title" content="MakaL-0-">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="MakaL-0-">
<meta property="og:description" content="Beautifully struggle every day">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MakaL-0-">
<meta name="twitter:description" content="Beautifully struggle every day">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/4/"/>





  <title>MakaL-0-</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-120154502-1', 'auto');
  ga('send', 'pageview');
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?f15c3fa6d339dfe768bc3d4f2e2f856e";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">MakaL-0-</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">因为图片使用的是图床的，图床被墙了，所以不挂VPN图片加载不了</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/18/JVM性能调优/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MakaLoo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MakaL-0-">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/18/JVM性能调优/" itemprop="url">JVM性能调优</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-18T12:58:34+08:00">
                2019-05-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/05/18/JVM性能调优/" class="leancloud_visitors" data-flag-title="JVM性能调优">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JVM性能调优"><a href="#JVM性能调优" class="headerlink" title="JVM性能调优"></a>JVM性能调优</h1><h2 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h2><ul>
<li>-Xmx：堆最大内存数</li>
<li>-Xms：堆初始化大小</li>
<li>-Xmn：堆新生代初始及最大大小</li>
<li>-Xss：线程栈大小</li>
<li>-XX:PermSize,-XX:MaxPermSize：方法区大小，永久代大小，JDK1.7之前适用</li>
<li>-XX:MaxDirectMemorySize：直接内存，默认大小与-Xmx大小一样</li>
<li>-XX:SurvivorRatio=n：Survivor与Eden大小的比例为2:n，n默认是8</li>
<li><p>-XX：NewRatio=n：年轻代(eden+2*survivor)和年老代比值为1:n</p>
</li>
<li><p>-XX:+HeapDumpOnOutOfMemoryError：虚拟机出现内存溢出异常时Dump出当前内存堆转快照</p>
</li>
</ul>
<h2 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h2><p>对整个堆进行整理，包括年轻代，老年代，永久代，JVM调优要减少Full GC次数</p>
<h3 id="导致Full-GC原因"><a href="#导致Full-GC原因" class="headerlink" title="导致Full GC原因"></a>导致Full GC原因</h3><ul>
<li>老年代被写满</li>
<li>持久代空间不足</li>
<li>System.gc()调用</li>
<li>CMS GC时出现promotion failed和concurrent mode failure</li>
<li>统计得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间</li>
</ul>
<h2 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h2><p>年轻代的GC叫minor GC，老年代的GC叫Full GC</p>
<h3 id="导致Minor-GC原因"><a href="#导致Minor-GC原因" class="headerlink" title="导致Minor GC原因"></a>导致Minor GC原因</h3><ul>
<li>Eden区满，触发新生代Minor GC将Eden和非空闲Survivor存活的对象复制到另一个空闲Survivor中</li>
<li>当Survivor区满，通过Minor GC将对象复制到老年代</li>
</ul>
<h2 id="JVM性能调优方法和步骤"><a href="#JVM性能调优方法和步骤" class="headerlink" title="JVM性能调优方法和步骤"></a>JVM性能调优方法和步骤</h2><ol>
<li>监控GC状态：使用各种JVM工具，查看当前日志，分析当前JVM参数设置，堆内存快照和GC日志，根据实际各区域划分和GC执行时间，判断是否进行优化</li>
<li>生成堆的dump文件</li>
<li>分析dump文件：用Visual VM等待工具</li>
<li>分析结果，判断是否需要优化：如果系统没有超时日志出现，GC频率不高耗时不高，没有必要进行优化</li>
<li>调整GC类型和内存分配</li>
<li>不断分析调整</li>
</ol>
<h3 id="JVM调优参数参考"><a href="#JVM调优参数参考" class="headerlink" title="JVM调优参数参考"></a>JVM调优参数参考</h3><ul>
<li>针对JVM设置，一般可以通过-Xms -Xmx限定最小，最大值，防止垃圾收集器在最小最大之间收缩堆而产生额外的时间，通常把最大最小值设为相同的值</li>
<li>年轻代和老年代根据默认比例（1：2）分配堆内存，同样的，对于年轻代为了防止堆收缩，-XX:newSize,-XX:MaxNewSize设为相同大小</li>
<li>如果应用存在大量临时对象，应选择更大的年轻代，如果存在相对较多的持久对象，应选择年老代</li>
<li>配置较好的机器上（多核，大内存），可以为年老代选择并行收集算法：XX:+UseParallelOldGC</li>
<li>线程堆栈设置：默认1M，建议256K</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/18/垃圾收集器与内存分配策略/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MakaLoo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MakaL-0-">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/18/垃圾收集器与内存分配策略/" itemprop="url">垃圾收集器与内存分配策略</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-18T10:56:34+08:00">
                2019-05-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/05/18/垃圾收集器与内存分配策略/" class="leancloud_visitors" data-flag-title="垃圾收集器与内存分配策略">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>GC（Garbage Collection）考虑三个问题：哪些内存需要回收？什么时候回收？如何回收？</p>
<p>程序计数器，虚拟机栈，本地方法栈随线程而生，随线程而灭，其中栈帧需要的内存是随着方法的进入和退出而有条不紊地执行者出栈和入栈操作，每一个栈帧分配多少内存是在类结构确定下来的时候就已知的，因此这几个区域的内存分配和回收都具备确定性，不需要过多考虑回收的问题。而方法区和堆的内存不一样，一个接口多个实现类需要的内存可能不一样，一个方法中多个分支需要的内存也可能不一样，只有在程序运行期间才知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器关注的是这部分的内存</p>
<h2 id="GC分代"><a href="#GC分代" class="headerlink" title="GC分代"></a>GC分代</h2><p>分代的垃圾回收策略，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。在Java程序运行过程中，会产生大量的对象，其中有些对象是与业务信息有关的，比如Http请求的Session对象，Socket连接，它们的生命周期比较长，但是有些对象，主要是程序运行过程生成的，比如String对象，不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间，花费时间相对会比较长，但实际上，对长周期对象而言，这种遍历是没有效果的，因为可能进行了很多次遍历后他们依旧存在，因此分代垃圾回收采用分治的思想，把不同生命周期的对象放在不同代上，不同代采用适合它们的垃圾回收方式进行回收</p>
<p><img src="https://i.imgur.com/wpsR7Er.png" alt=""></p>
<p>GC分代分为年轻代，年老代和持久代，持久代一般在方法区，保存Java类的类信息，所有新生成的对象都是放在年轻代的，年轻代分为1个Eden区，2个Survivor区，年轻代经历N此垃圾回收后仍然存活的对象，会放到年老代</p>
<h2 id="对象已死吗"><a href="#对象已死吗" class="headerlink" title="对象已死吗"></a>对象已死吗</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>给对象添加一个引用计数器，每当一个地方引用它时，计数器就加1，当引用失效时，计数器就减1，任何时刻计数器为0的对象就是不可能再被使用的</p>
<p>它实现简单，判定效率也很高，但是很难解决对象之间相互循环引用的问题</p>
<p>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class ReferenceCountingGC &#123;</span><br><span class="line"></span><br><span class="line">    public Object instance = null;</span><br><span class="line"></span><br><span class="line">    private static final int _1MB = 1024 * 1024;</span><br><span class="line"></span><br><span class="line">	// 占点内存，以便GC日志看清是否被回收</span><br><span class="line">    private byte[] bigSize = new byte[2 * _1MB];</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ReferenceCountingGC objA = new ReferenceCountingGC();</span><br><span class="line">        ReferenceCountingGC objB = new ReferenceCountingGC();</span><br><span class="line">        objA.instance = objB; // objA.instance引用了objB这片内存</span><br><span class="line">        objB.instance = objA; // objB.instance引用了objA这片内存</span><br><span class="line"></span><br><span class="line">        objA = null;  // 令objA引用null</span><br><span class="line">        objB = null;  // 令objB引用null</span><br><span class="line">		</span><br><span class="line">		// 此时，新创建的2个ReferenceCountingGC实例因为互相引用，其引用计数值仍为1，但没有其他引用引用它们，即它们是不可达的</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象objA和objB都有字段instance，赋值令objA.instance = objB及objB.instance = objA;，除此之外这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但因为它们之间互相引用对方，导致它们的引用计数都不为0，引用计数法无法通知GC收集器回收它们</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>Java的主流实现就是可达性分析算法，这个算法基本思想是通过一系列称为”GC Roots”的对象作为起始点，从这些节点开始往下搜索。搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（图论知识来说，就是从GC Roots到这个对象不可达），证明此对象是不可用的</p>
<p><img src="https://i.imgur.com/BvmXrkL.jpg" alt=""></p>
<p>Java中，GC Roots对象包括下面几种</p>
<ul>
<li>虚拟机栈（栈帧的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈JNI（Native方法）引用的对象</li>
</ul>
<h3 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h3><p>在JDK 1.2之前，Java引用的定义很传统：如果reference类型的数据中存储的数值代表另外一块内存的起始地址，就称这块内存代表一个引用，在1.2之后，Java对引用的概念进行了扩充，将引用分为强引用，软引用，弱引用，虚引用4种</p>
<ul>
<li>强引用：程序代码之中普遍存在的，类似<code>Object obj = new Object()</code>的引用，只要强引用还存在，垃圾收集器就永远不会回收被引用的对象</li>
<li>软引用：描述一些还有用但并非必需的对象，对于软引用关联的对象，在系统将要发生内存溢出溢出之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收完还没有足够的内存，才会抛出内存溢出异常。JDK 1.2后提供了SoftReference类实现软引用</li>
<li>弱引用：也是描述非必需对象的，强度比软引用更弱，只能生存到下次垃圾回收发生之前，WeakReference类实现弱引用</li>
<li>虚引用：最弱的引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通知虚引用来取得一个对象实例，为一个对象设置虚引用的唯一目的是能在这个对象被收集器回收时收到一个系统通知，PhantomReference类实现虚引用</li>
</ul>
<h3 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h3><p>可达性分析算法中不可达的对象，并不一定真的会死亡，要真正宣告一个对象死亡，至少经历两次标记过程，如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法，当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用，虚拟机将这两种情况视为”没有必要执行”</p>
<p>如果这个对象被判定为有必要执行finalize()方法，那么这个对象就会被放置在一个叫F-Queue的队列中，并在稍后由一个虚拟机自动建立的，低优先级的Finalizer线程去执行它，”执行”指虚拟机会触发这个方法，但不承诺会等待它运行结束，原因是：如果一个对象在finalize()方法执行缓慢，或者发生死循环，很可能导致F-Queue队列的其他对象永久处于等待，甚至整个内存回收系统崩溃。稍后GC对F-Queue中的对象进行第二次小规模的标记，对象如果在finalize()方法中重新与引用链上的任何一个对象关联（this赋值给某个类变量或者对象的成员变量），那么第二次标记时它将被移除出”即将回收”的集合，finalize()方法只会被调用一次，它是C/C++的一种妥协，尽量不要使用它，用try-finally或者其他方法会更好</p>
<h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>堆中，尤其是新生代中，常规应用一次垃圾收集一般可以回收70%——95%的空间，而永久代（方法区）的垃圾收集效率远低于此</p>
<p>永久代的垃圾收集主要回收两部分：废弃常量和无用的类，回收废弃常量和回收Java堆中的对象非常类似，常量池中字面量回收为例，假如字符串”abc”已经进入常量池，但是没有任何String对象引用常量池的”abc”，也没有其他地方引用这个字面量，如果这时发生内存回收，且必要的话，”abc”就会被系统清理出常量池，常量池其他类，接口，方法，字段的符号引用也与此类似</p>
<p>判断类是否为无用的类，要满足下面三个条件</p>
<ul>
<li>该类所有实例已经被回收，Java堆中不存在该类任何实例</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
</ul>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象，标记过程前面有说。主要两个不足：<strong>标记和清除的效率都不高，标记清除后会产生大量不连续内存碎片，导致分配较大对象时无法得到足够的内存而触发另一次垃圾收集动作</strong></p>
<p><img src="https://i.imgur.com/XgwMhoQ.jpg" alt=""></p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>为了解决效率问题，它将可用内存按容量划分为大小相等的两块，每次只使用其中一块，当一块内存用完，就将还存活的对象复制到另外一块上，然后把已使用的内存空间一次清理掉，这样使得每次都是对整个半区进行内存回收，内存分配时也不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，但代价是内存缩小为原来一半</p>
<p><img src="https://i.imgur.com/bj18uIw.jpg" alt=""></p>
<p>现在商业虚拟机都采用这种收集算法回收<strong>新生代</strong>，实际应用并不需要1：1比例划分空间<strong>，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间</strong>，每次使用Eden和其中一块Survivor，新建的对象都被分配到Eden区，经过第一次Minor GC后仍存活就放到Survivor区，当回收时，将Eden和Survivor中还存活的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才使用的过Survivor空间，HotSpot虚拟机默认Eden和Survivor大小比例是8：1，也就是每次新生代中可用的内存空间为整个新生代容量的90%(80%+10%)，没办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够时，需要依赖其他内存呢（老年代）进行分配担保</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>复制收集算法在对象存活率比较高时要进行较多的复制操作，效率会变低，在老年代中，对象存活率会很高，不适合复制收集算法<br>根据老年代的特点，可以使用标记-整理算法，标记过程与标记-清除算法的标记过程一样，但后续步骤不是直接对可回收对象进行清理，<strong>而是让所有存活对象都向一端移动，然后直接清理掉端边界以外的内存</strong></p>
<p><img src="https://i.imgur.com/bUyCAGP.jpg" alt=""></p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>根据对象存活周期不同将内存划分为几块，一般是把Java堆分为新生代和老年代，新生代采用复制算法，老年代采用标记-清理或标记-整理算法</p>
<h2 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h2><h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><p>可达性分析中从GC Roots节点找引用链这个操作为例，可作为GC Roots的节点主要在全局性的引用（常量或类静态属性）与执行上下文（栈帧的本地变量表）中，现在很多应用仅仅方法区都有数百兆，如果逐个检查这里面的引用，那么必然消耗很多时间</p>
<p>另外，可达性分析对执行时间的敏感还体现在GC停顿上，因为这项工作必须在一个能确保一致性的快照中进行，一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上，不可能出现分析过程对象引用还在不断变化的情况</p>
<p>目前主流Java虚拟机使用的都是准确式GC，当执行系统停顿下来，并不需要一个不漏地检查完所有执行上下文和全局引用位置，<strong>而是有办法得知哪些地方存放对象引用，HotSpot中，使用一组OopMap数据结构达到这个目的</strong>，在类加载完成时，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，JIT编译过程中，也会特定位置记录下栈和寄存器哪些位置是引用，这样GC扫描时就可以得知这些信息了</p>
<h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>OopMap协助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个很现实的问题是，可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，就会需要大量额外的空间，GC的空间成本就会很高</p>
<p><strong>实际上HotSpot只会在特定的位置记录这些信息，这些位置称为安全点，程序执行并非在所有地方都能停顿下来开始GC，只会在安全点才暂停</strong>，安全点的选择是以程序”是否具有让程序长时间执行的特征”为标准，例如方法调用，循环跳转，异常跳转等，具有这些功能的指令才会产生Safepoint</p>
<p>Safepoint需要考虑的另一个问题是GC发生时所有线程都”跑”到最近安全点再停顿，主流的是主动式中断，思想是：当GC需要中断线程的时候，不直接对线程操作，仅仅简单设置一个标志，各个线程执行时主动轮询这个标志，发现中断标志为真时就自己中断挂起，轮询标志的地方和安全点是重合的</p>
<h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>Safepoint机制保证程序执行时，在不太长时间内就会遇到可进入GC的Safepoint，但是程序不执行时，即没有分配CPU时间时（Sleep或Blocked）状态，这时线程无法响应JVM中断请求，”走”到安全的地方去中断挂起，就需要安全区域(Safe Region)来解决</p>
<p><strong>安全区域指在一段代码片段里，引用关系不会发生变化。</strong>在这个区域任意地方开始的GC都是安全的，线程执行到Safe Region的代码时，首先标识自己已经进入Safe Region，这样当这段时间JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了，在线程离开Safe Region，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成，那程序就继续执行，否则它必须等待直到收到可以安全离开Safe Region的信号为止</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><img src="https://i.imgur.com/dEJKIyM.png" alt=""></p>
<p>上图展示了7种用于不同分代的垃圾收集器，如果两个收集器之间存在连线，表示它们可以搭配使用，虚拟机所处的区域表示它是新生代收集器还是老年代收集器</p>
<h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p><img src="https://i.imgur.com/2JWq5V2.jpg" alt=""></p>
<p>单线程，垃圾收集时必须暂停其他所有工作线程直到收集结束，它是虚拟机运行在Client模式下的默认新生代收集器</p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>Serial的多线程版本，多条线程进行垃圾收集</p>
<p><img src="https://i.imgur.com/F7z6vVG.png" alt=""></p>
<p>左边是ParNew新生代收集器，右边是Serial Old老年代收集器</p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p><img src="https://i.imgur.com/DOlo9pR.png" alt=""></p>
<p>它也是新生代收集器，也是使用复制算法的收集器，也是多线程收集器，与ParNew的主要区别是它的关注点不是缩短垃圾收集时用户线程的停顿时间，而是达到一个可控制的吞吐量，即CPU用于运行用户代码的时间与CPU总消耗时间的比值，吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)</p>
<p>停顿时间越短越适合与用户交互的程序，良好的响应速度能提升用户体验，而提高吞吐量可以高效地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务</p>
<h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>Serial收集器的老年代版本，使用标记-整理算法</p>
<p><img src="https://i.imgur.com/VE81erT.png" alt=""></p>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>Parallel Scavenge收集器的老年代版本</p>
<p><img src="https://i.imgur.com/CQSoHso.png" alt=""></p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>CMS收集器是一种以获取最短回收停顿时间为目标的收集器，尤其重视响应速度，希望停顿时间最短，基于”标记-清除”算法实现，分为4个步骤</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>重新标记</li>
<li>并发清除</li>
</ul>
<p>初始标记和重新标记需要”Stop The World”，初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记就是进行GC Roots Tracing的过程，重新标记是为了修正并发标记期间因用户程序继续运作而导致的标记产生变动的那一部分对象的标记记录，时间上会比初始标记稍长，但比并发标记短很多</p>
<p><img src="https://i.imgur.com/TeagkzV.png" alt=""></p>
<p>三个缺点</p>
<ul>
<li>CMS收集器对CPU资源很敏感，因为它是并发标记的，会占用一部分CPU资源而导致程序变慢，总吞吐量降低</li>
<li>无法处理浮动垃圾，可能出现”Concurent Mode Failure”失败而导致另一次Full GC的产生</li>
<li>基于”标记-清除”算法，产生大量空间碎片</li>
</ul>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p><img src="https://i.imgur.com/Ebhe0SD.png" alt=""></p>
<p>JDK 1.7中HotSpot虚拟机的一个重要进化特征</p>
<p>具备如下特点</p>
<ul>
<li>并行与并发：充分利用多CPU，多核环境，减短Stop-The-World停顿的时间</li>
<li>分代收集：不需要其他收集器就可以独立管理整个GC堆</li>
<li>空间整合：与CMS的”标记-清理”不同，G1从整体来看是基于”标记-整理”算法实现的，局部来看（两个Region之间）是基于”复制”算法实现</li>
<li>可预测的停顿：G1除了追求低停顿，还能建立可预测的停顿时间模型，让使用者明确指定长度M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒</li>
</ul>
<p>G1收集器把JAVA堆内存划分为多个大小相等的独立区域（Region），虽然保留新生代和老年代概念，但新生代和老年代不再是物理隔离了，它们都是一部分Region的集合</p>
<p>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得空间大小以及回收所需时间的经验值），在后台维护一个优先队列，每次根据允许的收集时间优先回收价值最大的Region（这也是Garbage-First名称的来由）</p>
<p>G1收集器中，Region之间的对象引用以及其他收集器中的新生代与老年代的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描的。G1中每个Region都有一个与之对应的Remembered Set，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（分代例子就是检查老年代引用的对象引用了新生代的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中，当进行内存回收时，在GC根节点的枚举范围加入Remembered Set即可保证不对全堆扫描也不会有遗漏</p>
<p>不计算维护Remembered Set的操作，G1收集器的运作大致划分为以下步骤</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记</li>
<li>筛选回收</li>
</ul>
<h2 id="内存分配和回收策略"><a href="#内存分配和回收策略" class="headerlink" title="内存分配和回收策略"></a>内存分配和回收策略</h2><p>使用Serial/Serial Old收集器的内存分配和回收策略</p>
<h3 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h3><p>对象优先在Eden分配，当Eden没有足够空间时，虚拟机将发起一次Minor GC</p>
<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>大对象指需要大量连续内存空间的Java对象，最典型的是字符串和数组</p>
<h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><p>虚拟机给每个对象定义了一个对象年龄计数器，如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳，将被移动到Survivor空间，并且对象年龄设为1，对象在Survivor每经过一次Minor GC，年龄就加1岁，当年龄增加到一定程度（默认15岁），就晋升到老年代</p>
<h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>虚拟机并不是永远要求对象的年龄必须到达指定才晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象直接进入老年代</p>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果成立，那么Minor GC可以确保是安全的，如果不成立，虚拟机会查看HandlePromotionFailure设置值是否允许担保失败，如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于就进行一次Minor GC，尽管这次GC是有风险的，如果小于，进行一次Full GC</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/17/MySQL索引/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MakaLoo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MakaL-0-">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/17/MySQL索引/" itemprop="url">MySQL索引</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-17T17:07:34+08:00">
                2019-05-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/05/17/MySQL索引/" class="leancloud_visitors" data-flag-title="MySQL索引">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h1><h2 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h2><p>建立索引的目的是加快查询速度，数据库索引类似于图书后面的索引，能快速定位到需要查询的内容</p>
<p>索引能加速数据库查询，但需要占用一定存储空间，当基本表更新时，索引也要进行相应的维护，这些都会增加数据库负担</p>
<p>用户不能显式选择索引，索引是关系数据库管理系统的内部实现技术，属于内模式的范畴</p>
<p>用户对基本表建立某列的索引后，类似图书索引，键是索引的值，值是数据行的地址，e.g. 对Person表建立身份证号的索引后，<code>SELECT 姓名,性别,年龄 FROM Person WHERE 身份证号=&#39;xxx&#39;</code>也会用到索引（实际不一定，要看优化器的选择，一般索引不能覆盖我们要查询的信息时，还要通过书签去访问查找整行的数据信息，当访问的数据占整个表数据的蛮大一部分时(一般20%)，优化器会选择通过聚集索引(表扫描)来查找数据）</p>
<h3 id="基本SQL语句"><a href="#基本SQL语句" class="headerlink" title="基本SQL语句"></a>基本SQL语句</h3><h4 id="建立索引"><a href="#建立索引" class="headerlink" title="建立索引"></a>建立索引</h4><p><code>CREATE INDEX indexName ON mytable(column(length));</code></p>
<p>一般可以不指定length<br>如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定length。</p>
<p><code>ALTER TABLE tableName ADD INDEX indexName(columnName)</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable(  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">ID</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,   </span><br><span class="line"> </span><br><span class="line">username <span class="built_in">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">INDEX</span> [indexName] (<span class="keyword">column</span>(<span class="keyword">length</span>))  </span><br><span class="line"> </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>一般来说，关键字KEY通常是INDEX同义词，上面所有创建INDEX的语句的INDEX关键字都可以换成KEY关键字</strong>，即<br><code>ALTER TABLE sakila.city_demo ADD KEY (city(7))</code><br>也是创建索引，索引为长度为7的city列<br><code>ALTER TABLE sakila.city_demo ADD KEY yourIndexName(column(length))</code></p>
<h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><p>唯一索引的索引值必须唯一，但允许有null，如果是组合索引，列值的组合必须唯一</p>
<p><code>CREATE UNIQUE INDEX indexName ON mytable(username(length))</code></p>
<p><code>ALTER table mytable ADD UNIQUE [indexName] (column(length))</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable(  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">ID</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,   </span><br><span class="line"> </span><br><span class="line">username <span class="built_in">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">UNIQUE</span> [indexName] (<span class="keyword">column</span>(<span class="keyword">length</span>))  </span><br><span class="line"> </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><p><code>DROP INDEX [indexName] ON mytable;</code></p>
<h4 id="使用ALTER添加和删除索引"><a href="#使用ALTER添加和删除索引" class="headerlink" title="使用ALTER添加和删除索引"></a>使用ALTER添加和删除索引</h4><p><code>ALTER TABLE testalter_tbl ADD INDEX (c);</code></p>
<p><code>ALTER TABLE testalter_tbl DROP INDEX c;</code></p>
<h4 id="显示索引"><a href="#显示索引" class="headerlink" title="显示索引"></a>显示索引</h4><p><code>SHOW INDEX FROM table_name;</code></p>
<h4 id="一个简单的索引查询例子"><a href="#一个简单的索引查询例子" class="headerlink" title="一个简单的索引查询例子"></a>一个简单的索引查询例子</h4><p>执行<code>SELECT first_name FROM sakila.actor WHERE actor_id = 5;</code><br>如果在actor_id列上建有索引，则MySQL将使用该索引找到actor_id为5的行，也就是说，MySQL先在索引上按值查找，然后返回所有包含该值的数据行</p>
<h2 id="建立高性能索引"><a href="#建立高性能索引" class="headerlink" title="建立高性能索引"></a>建立高性能索引</h2><h3 id="B-树概况"><a href="#B-树概况" class="headerlink" title="B+树概况"></a>B+树概况</h3><p>对B+树的描述如下，可能细节会有些出入，但思想是一样的：</p>
<p><strong>**B+树叶结点包含信息，非叶结点只起索引作用</strong>，非叶结点每个索引项只含有对应子树最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址，叶结点包含所有关键字，即在非叶结点的关键字也会出现在叶结点<br>对B+树可以有两种查找：从最小关键字开始的顺序查找和从根结点开始多路查找，根结点查找非叶结点时如果关键字等于给定值，不会终止查找，而是向下继续查找，直到叶结点上为止</p>
<p><img src="https://i.imgur.com/s6R8vPd.png" alt=""></p>
<h3 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h3><p>索引一般都是B-Tree索引或其变种，InnoDB引擎使用的是B+Tree，InnoDB索引根据主键引用被索引的行</p>
<p>B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同，很适合查找范围数据</p>
<p>B-Tree可以对&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN，以及不以通配符开始的LIKE使用索引</p>
<p><img src="https://i.imgur.com/2QHKCtu.png" alt=""></p>
<p>B-Tree索引能加快访问数据的速度，存储引擎不需要进行全表扫描来获取数据，只需要从索引的根结点开始搜索，通过比较节点页的值和要查找的值找到合适的指针进入下层节点，这些指针实际定义了子节点页中值的上限和下限，<strong>叶结点除了保存索引的值，还保存该索引指向的数据行的地址指针</strong></p>
<p>假如有如下数据表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> People (</span><br><span class="line">  last_name <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">  first_name <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">  dob <span class="built_in">date</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">  gender enum(<span class="string">'m'</span>, <span class="string">'f'</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">  <span class="keyword">key</span>(last_name, first_name, dob)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>索引包含了last_name，first_name和dob列的值，下面是B-Tree(技术上来说是B+Tree)索引的图例</p>
<p><img src="https://i.imgur.com/vhJQkhT.png" alt=""></p>
<p>索引对多个值进行排序的依据是CREATE TABLE语句定义索引时列的顺序，如果两个人姓和名都一样，则根据出生日期来排列顺序</p>
<p>B-Tree索引适用于全键值，键值范围或键前缀查找，其中键前缀查找只适用于根据最左前缀的查找，上述索引对如下类型的查询有效</p>
<ul>
<li>匹配全值：和索引中所有列进行匹配，例如前面提到的索引可用于查找姓名为Cuba Allen，出生于1960-01-01的人</li>
<li>匹配最左前缀：可用于查找所有姓为Allen的人，即只使用索引的第一列</li>
<li>匹配列前缀：也可以只匹配某一列的值的开头部分，可以查找所有以J开头的姓的人，这里也只用了索引的第一列</li>
<li>匹配范围值：查找姓在Allen和Barrymore之间的人，只使用了索引的第一列</li>
<li>精确匹配某一列并范围匹配另外一列：查找所有姓为Allen，并且名以字母K开头的人，即第一列last_name全匹配，第二列first_name范围匹配</li>
<li>只访问索引的查询：查询只访问索引，而无须访问数据行</li>
</ul>
<p>下面是一些关于B-Tree索引的限制：</p>
<ul>
<li>查询必须从索引最左边的列开始，否则无法使用索引，例如不能用索引查询某一天出生的人</li>
<li>不能跳过某一索引列，例如不能利用索引查找last name为Smith且出生于某一天的人</li>
<li>不能使用索引中范围条件右边的列，例如，查询语句为`WHERE last_name=”Smith” AND first_name LIKS ‘J%’ AND dob=’1976-12-23’，该查询只会使用索引中的前两列</li>
</ul>
<p>综上，实际只要知道多个列的索引的存储结构，怎么样的查询会使用到索引其实也就清楚了</p>
<h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，同时在哈希表中保存每个数据行的指针，只有Memory引擎支持显式哈希索引</p>
<p>InnoDB引擎有一个特殊功能叫自适应哈希索引，当InnoDB注意道某些索引值被使用很频繁时，就会在内存中基于B-Tree索引之上再创建一个哈希索引，这是完全自动的，内部的行为</p>
<h3 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h3><p>例如B-Tree索引，是按照顺序存储数据的，所以MySQL也可以用来做ORDER BY和GROUP BY操作，因为数据是有序的，所以B-Tree会将相关列值存储在一起，最后，索引存储了实际的列值，所以某些查询只使用索引就能够完成全部查询，总结下来有如下3个优点：</p>
<ul>
<li>索引大大减少了服务器需要扫描的数据量</li>
<li>索引可以帮助服务器避免排序和临时表</li>
<li>索引可以将随机I/O变成顺序I/O</li>
</ul>
<h4 id="索引的三星系统"><a href="#索引的三星系统" class="headerlink" title="索引的三星系统"></a>索引的三星系统</h4><p>索引将相关记录放到一起则获得一星<br>如果索引数据顺序和查找的排列顺序一致则获得二星<br>如果索引的列包含了查询中需要的全部列则获得三星</p>
<h2 id="高性能的索引策略"><a href="#高性能的索引策略" class="headerlink" title="高性能的索引策略"></a>高性能的索引策略</h2><h3 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h3><p>指索引列不能是表达式的一部分，如</p>
<p><code>SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;</code></p>
<p>上述查询无法使用actor_id的索引，MySQL无法自动解析这个方程式</p>
<p><strong>要始终将索引列单独放在比较符号的一侧</strong></p>
<h3 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h3><p>有时候需要索引很长的索引列，这会让索引变得大且慢，通常可以索引开始的部分字符，这样可以大大节约索引空间，提高索引效率，但会降低索引的选择性。索引选择性指不重复的索引值和数据表的记录总数的比值，索引选择性越高查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行</p>
<p><code>ALTER TABLE sakila.city_demo ADD KEY (city(7))</code><br>创建长度为7的索引名为city的，列名为city的索引</p>
<p><code>ALTER TABLE sakila.city_demo ADD KEY yourIndexName(column(length))</code></p>
<h3 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h3><p>多列索引常见的错误是：为每个列都创建独立的索引，或者按错误顺序创建多列索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t (</span><br><span class="line">	c1 <span class="built_in">INT</span>,</span><br><span class="line">	c2 <span class="built_in">INT</span>,</span><br><span class="line">	c3 <span class="built_in">INT</span>,</span><br><span class="line">	<span class="keyword">KEY</span>(c1),</span><br><span class="line">	<span class="keyword">KEY</span>(c2),</span><br><span class="line">	<span class="keyword">KEY</span>(c3)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>性能不会很好，比起最优索引可能差几个数量级，MySQL 5.0以上引入一个叫索引合并的策略，一定程度上可以使用表上多个单列索引来定位指定的行，例如，表file_actor在字段film_id和actor_id上各有一个单列索引，但对于下面的查询WHERE条件，这两个单列索引都不是很好的选择</p>
<p><code>SELECT film_id, actor_id FROM sakila.film_actor WHERE actor_id = 1 OR film_id = 1;</code></p>
<p>老版本的MySQL会对这个查询使用全表扫描（因为一次只能在一个索引树中查找，因为没有actor_id和film_id的联合索引，所以就全表查找了），除非改写成如下方式</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id, actor_id <span class="keyword">FROM</span> sakila.film_actor <span class="keyword">WHERE</span> actor_id = <span class="number">1</span></span><br><span class="line"><span class="keyword">UNION</span> ALL</span><br><span class="line"><span class="keyword">SELECT</span> film_id, actor_id <span class="keyword">FROM</span> sakila.film_actor <span class="keyword">WHERE</span> film_id = <span class="number">1</span></span><br><span class="line"> <span class="keyword">AND</span> actor_id &lt;&gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>MySQL 5.0以上版本能够同时使用这两个单列索引进行扫描，将结果合并，这种算法有3个变种，OR的联合，AND的相交，组合前两种情况的联合及相交，下面查询使用了两个索引扫描的联合，在EXPLAIN中的Extra列可以看到这一点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT film_id, actor_id FROM sakila.film_actor WHERE actor_id = 1 OR film_id = 1\G;</span><br><span class="line"></span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: film_actor</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: index_merge</span><br><span class="line">possible_keys: PRIMARY,idx_fk_film_id</span><br><span class="line">          key: PRIMARY,idx_fk_film_id</span><br><span class="line">      key_len: 2,2</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 29</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using union(PRIMARY,idx_fk_film_id); Using where</span><br></pre></td></tr></table></figure>
<p>索引合并策略有时候是一种优化结果，但实际上更多时候说明表上的索引建的很糟糕</p>
<ul>
<li>当服务器需要对多个索引做相交操作时（通常是多个AND），意味着需要一个包含所有相关列的多列索引，而不是多个单独的单列索引</li>
<li>当服务器需要对多个索引做联合操作时（通常由多个OR），通常需要消耗大量CPU和内存资源在算法的缓存，排序和合并操作上</li>
<li>优化器不会把这些计算到查询成本中，只关心随机页面读取，导致该执行计划还不如直接走全表扫描，要不就把查询改写成UNION的方式</li>
</ul>
<h3 id="选择合适的索引列顺序"><a href="#选择合适的索引列顺序" class="headerlink" title="选择合适的索引列顺序"></a>选择合适的索引列顺序</h3><p>经验法则：将选择性最高的列放在索引最前列</p>
<p>以下面查询为例<br><code>SELECT * FROM payment WHERE staff_id = 2 AND customer_id = 584;</code></p>
<p>可以通过SUM函数计算选择性的相对大小</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> staff_id)/<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> staff_id_selectivity,</span><br><span class="line"><span class="keyword">COUNT</span>(DINSTINCT customer_id)/<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> customer_id_selectivity,</span><br><span class="line"><span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> payment\G;</span><br></pre></td></tr></table></figure>
<h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>聚簇索引是一种数据存储方式，而不是单独的索引类型，InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行</p>
<p>当表有聚簇索引时，<strong>它的数据行实际上存放在该聚簇索引的叶子页中，术语聚簇表示数据行和相邻的键值紧凑地存储在一起（逻辑相邻，物理不相邻）</strong>，因为无法同时把数据行存放到两个不同的地方，所以一个表只能有一个聚簇索引，下面是一个聚簇索引的记录的存放显示，注意叶子页包含了行的全部数据，但是节点叶只有索引列，这里的索引列是整数值</p>
<p><img src="https://i.imgur.com/EmK7jOp.png" alt=""></p>
<p>innoDB通过主键聚集数据，如果没有定义主键，innoDB会选择一个唯一的非空索引代替，如果没有这样的索引，InnoDB会隐式定义一个主键作为聚簇索引</p>
<p>聚簇索引的优点</p>
<ul>
<li>可以把相关数据保存在一起，例如电子邮箱，可以根据用户ID来聚集数据，这样只需要从磁盘读取少数的页就能够获取某个用户的全部邮件</li>
<li>数据访问更快，聚簇索引将索引和数据保存在同一个B-Tree中，获取数比非聚簇索引查找要快</li>
<li>使用覆盖索引扫描的查询可以直接使用页节点的主键值</li>
</ul>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>一个索引包含所有要查询的字段的值，称为覆盖索引</p>
<h3 id="冗余和重复索引"><a href="#冗余和重复索引" class="headerlink" title="冗余和重复索引"></a>冗余和重复索引</h3><p>重复索引：相同列上按相同顺序创建的相同类型的索引，应该避免重复索引，常见的重复索引有主键+唯一限制+索引，实际上MySQL的唯一限制和主键都是通过索引实现的，所以上面写法其实是创建了三个重复的索引</p>
<p>冗余索引：如果创建了索引(A,B)再创建(A)就是冗余索引，大部分情况不需要冗余索引</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/16/序列化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MakaLoo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MakaL-0-">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/16/序列化/" itemprop="url">序列化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-16T00:01:34+08:00">
                2019-05-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/05/16/序列化/" class="leancloud_visitors" data-flag-title="序列化">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><h2 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h2><p>对象序列化：将内存中保存的对象以二进制数据流的形式进行处理，可以实现对象的保存和网络传输（保存在文件或数据库）</p>
<h2 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h2><p>Java中要序列化的对象，必须实现接口java.io.Serializable，作为序列化的标记，它没有任何方法，它描述的是一种能力</p>
<h2 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h2><p><code>private static final long serialVersionUID = 1L;</code></p>
<p>版本号用于表明类的不同版本的兼容性，默认是上面的值1L，反序列化时，JVM会把传来的字节流的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则出现序列化版本不一致的异常，serialVersionUID默认值依赖于Java编译器的实现，同一个类用不同的Java编译器，可能导致不同的serialVersionUID，可以显式的定义它，有2个用途</p>
<ul>
<li>某些场合希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本有不同的serialVersionUID</li>
<li>当序列化一个类实例后，希望更改一个字段或添加一个字段，不设置serialVersionUID，所作的任何更改都导致无法反序列化旧实例，并在反序列化时抛出一个异常，如果添加了serialVersionUID，在反序列旧实例时，新添加或更改的字段值将设为初始化值，字段被删除将不设置</li>
</ul>
<h2 id="序列化和反序列化过程"><a href="#序列化和反序列化过程" class="headerlink" title="序列化和反序列化过程"></a>序列化和反序列化过程</h2><table>
<thead>
<tr>
<th style="text-align:left">类名</th>
<th style="text-align:left">序列化：ObjectOutputStream</th>
<th style="text-align:left">反序列化：ObjectInputStream</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">类定义</td>
<td style="text-align:left">public class ObjectOutputStream extends OutputStream implements ObjectOutput, ObjectStreamConstants</td>
<td style="text-align:left">public class ObjectInputStream extends InputStream implements ObjectInput, ObjectStreamConstants</td>
</tr>
<tr>
<td style="text-align:left">构造方法</td>
<td style="text-align:left">ObjectOutputStream(OutputStream out)</td>
<td style="text-align:left">ObjectInputStream(InputStream in) </td>
</tr>
<tr>
<td style="text-align:left">构造方法参数说明</td>
<td style="text-align:left">Creates an ObjectOutputStream that writes to the specified OutputStream.</td>
<td style="text-align:left">Creates an ObjectInputStream that reads from the specified InputStream.</td>
</tr>
<tr>
<td style="text-align:left">重要方法</td>
<td style="text-align:left">writeObject(Object obj)</td>
<td style="text-align:left">readObject()</td>
</tr>
<tr>
<td style="text-align:left">重要方法说明</td>
<td style="text-align:left">Write the specified object to the ObjectOutputStream.</td>
<td style="text-align:left">Read an object from the ObjectInputStream.</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"姓名："</span> + <span class="keyword">this</span>.name + <span class="string">"年龄："</span> + <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际开发中很少使用ObjectOutputStream和ObjectInputStream，因为容器会帮助开发者自动实现</p>
<h2 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h2><p>用法：<code>private transient String xxx;</code></p>
<p>默认情况下执行了对象序列化时会将类中全部属性的内容进行全部序列化操作，但有时部分属性不需要进行序列化处理，这时可以在属性上定义使用transient关键字来完成<br>对属性进行序列化后，属性的值是不会被保存下来的，读取对应属性的值是对应的默认值<br>如果类中有一些需要计算保存的属性内容，往往不需要被序列化</p>
<h2 id="序列化的代价"><a href="#序列化的代价" class="headerlink" title="序列化的代价"></a>序列化的代价</h2><p>Serializable接口最大代价是一旦一个类被发布，就大大降改变这个类的实现的灵活性</p>
<h3 id="可能导致InvalidClassException"><a href="#可能导致InvalidClassException" class="headerlink" title="可能导致InvalidClassException"></a>可能导致InvalidClassException</h3><p>如果没有显示声明序列版本UID，对对象需求进行了改动，那么兼容性就会破坏，运行时导致InvalidClassException，比如，增加一个不是很重要的工具方法，自动产生的序列版本UID也会发生变化，则会出现序列版本UID不一致的情况，所以最好还是显式增加序列版本号UID</p>
<h3 id="增加了出现Bug和安全漏洞的可能性"><a href="#增加了出现Bug和安全漏洞的可能性" class="headerlink" title="增加了出现Bug和安全漏洞的可能性"></a>增加了出现Bug和安全漏洞的可能性</h3><p>序列化机制是一个语言之外的对象创建机制，反序列化机制是一个”隐藏的构造器”，具备与其他构造器相同的特点，序列化之后的字节流可以被截取伪造，之后利用readObject()方法反序列会造成不安全的实例</p>
<h3 id="随着类发行新的版本，测试负担会增加"><a href="#随着类发行新的版本，测试负担会增加" class="headerlink" title="随着类发行新的版本，测试负担会增加"></a>随着类发行新的版本，测试负担会增加</h3><p>一个可序列化的类被修订时，需要检查是否”在新版本中序列化一个实例，可以在旧版本中反序列”，如果一个实现序列化的类有很多的子类或者是被修改时，就不得不加以测试</p>
<h2 id="序列化的缺陷"><a href="#序列化的缺陷" class="headerlink" title="序列化的缺陷"></a>序列化的缺陷</h2><ol>
<li>序列化是保存对象的状态，也就是不会关心static静态域，静态域不会被序列化（静态变量在方法区，同一虚拟机访问反序列化的实例时，可以访问到静态变量）</li>
<li>序列化对象时，如果该对象中有引用对象域名，那么也要求该引用对象是可实例化的（即引用对象也要实现序列化接口），否则会报java.io.NotSerializableException错误</li>
<li></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/15/Java内存区域与内存溢出异常/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MakaLoo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MakaL-0-">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/15/Java内存区域与内存溢出异常/" itemprop="url">Java内存区域与内存溢出异常</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-15T10:24:34+08:00">
                2019-05-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/05/15/Java内存区域与内存溢出异常/" class="leancloud_visitors" data-flag-title="Java内存区域与内存溢出异常">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java内存区域与内存溢出异常"><a href="#Java内存区域与内存溢出异常" class="headerlink" title="Java内存区域与内存溢出异常"></a>Java内存区域与内存溢出异常</h1><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p><img src="https://i.imgur.com/uLRBzDt.png" alt=""></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器可以看作当前线程所执行的字节码的行号指示器，在虚拟机概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</p>
<p>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，任一时刻一个处理器只会执行一条线程的指令，因此每个线程都有一个独立的程序计数器，它是线程私有的内存</p>
<p>如果线程执行的是java方法，计数器记录的是正在执行的虚拟机字节码指令的地址，如果执行的是Native方法，技术值为空，此内存区域没有规定任何OutOfMemoryError</p>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>Java虚拟机栈也是线程私有的，它生命周期和线程相同。虚拟机栈描述的是java方法执行的内存模型，每个方法在执行的时候会创建一个栈帧，<strong>用于存储局部变量表，操作数栈，动态链接，方法出口等信息</strong>，每个方法从调用到执行完成的过程，对应一个栈帧在虚拟机栈中入栈到出栈的过程</p>
<p>局部变量表存放编译期可知的各种基本数据类型，对象引用和returnAddress类型，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，方法运行期间不会改变局部变量表的大小</p>
<p>虚拟机栈有两种异常状况：线程请求的栈深度大于虚拟机允许的深度时，抛出StackOverflowError，虚拟机栈动态扩展时无法申请到足够内存，抛出OutOfMemoryError</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>它也是线程私有的，它与虚拟机栈的区别是，虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，本地方法栈为虚拟机使用到的Native方法服务</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，它的唯一目的是<strong>存放对象实例</strong>，几乎所有的对象实例都在这里分配内存</p>
<p>它是垃圾收集器管理的主要区域，它可以是物理上不连续的内存空间，只要逻辑上连续即可，会抛出OutOfMemoryError</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区也是线程共享的内存区域，<strong>用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据</strong></p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>它是方法区的一部分，<strong>用于存放编译期生成的各种字面量和符号引用</strong>，这部分内容在类加载后进入方法区的运行时常量池存放</p>
<p>字面量就是值，符号引用就是一个java类引用了另一个java类比如org.simple.People类引用了org.simple.Language类，编译时People并不知道Language的实际内存地址，只能用符号org.simple.Language表示Language的地址</p>
<h2 id="HopSpot虚拟机对象"><a href="#HopSpot虚拟机对象" class="headerlink" title="HopSpot虚拟机对象"></a>HopSpot虚拟机对象</h2><p>以常用的虚拟机HotSpot和常用的内存区域Java堆为例，探讨HotSpot虚拟机在Java堆中对象分配布局和访问的过程</p>
<h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>虚拟机遇到一条new指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载，解析和初始化过，如果没有就必须先执行类加载过程<br>类加载检查通过后，虚拟机为新生对象分配内存，分配内存即把一块确定大小的内存从Java堆中划分开，如果内存规整，用过的内存在一边，空闲内存在另一边，中间存放指针作为分界点指示器，分配内存只需要把指针挪动即可，称为指针碰撞，如果内存不规整，用空闲列表法分配<br>除了内存分配，还要考虑线程安全的问题，如为对象A分配内存，指针还没修改时候对象B又同时使用原来的指针分配内存，解决方法一种是对分配内存空间同步处理，另一种是内存分配动作把内存分配动作按线程划分在不同的空间中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB），哪个线程需要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定<br>内存分配完成后，虚拟机将分配到的内存空间都初始化为零值（TLAB的话可以提前到TLAB分配时进行），这一步保证了对象实例字段的默认值<br>然后虚拟机堆对象进行必要的设置，比如这个对象是哪个类的实例，如何才能找到类的元数据信息，对象哈希码，GC分代年龄等信息，这些信息存放在对象的对象头中<br>上面工作完成后，从虚拟机视角看，一个新的对象产生了，但从Java视角看，还需要执行&lt;init&gt;方法</p>
<p>总结：一个对象创建步骤如下</p>
<ol>
<li>检查常量池是否有该类的符号引用，没有则类加载</li>
<li>分配内存，策略有空闲表法和指针碰撞</li>
<li>线程安全问题，分配内存动作同步或内存按线程划分（TLAB）</li>
<li>分配的内存空间初始化为0</li>
<li>设置对象头，存放类，元数据，哈希码，GC分代年龄等</li>
<li>Java执行init方法</li>
</ol>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头，实例数据和对齐填充</p>
<ul>
<li>对象头：包括存储对象自身运行时的数据如哈希码，GC分代年龄，锁状态标志，线程持有的锁等，以及类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针确定这个对象是哪个类的实例，如果对象为Java数组，还需要在对象头有一块记录数组长度的数据，对象头在32位/64位机的长度是32位和64位</li>
<li>实例数据部分是对象真正存储的有效信息，也就是代码中定义的各种类型的字段内容，无论是父类继承的还是子类定义的，都会记录下来，它们的存储顺序受虚拟机分配策略参数和字段的影响</li>
<li>对齐填充：不是必然存在的，也没什么含义，只起占位符作用，由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，对象头又正好是8字节的倍数，因此当对象实例数据部分没有对齐时，需要对齐填充补全</li>
</ul>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>Java程序需要通过栈上的reference数据来操作堆上的具体对象，由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，而没有定义这个引用通过何种方式定位访问堆中对象的具体位置，所以对象访问方式取决于虚拟机实现，目前主流的是句柄和直接指针两种</p>
<h4 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h4><p>Java堆划分一块内存作为句柄池，reference中存储的是对象的句柄地址，句柄中包含对象实例数据和类型数据各自的具体地址信息</p>
<p><img src="https://i.imgur.com/kcsapoB.png" alt=""></p>
<p>句柄访问的优点是reference存储的是稳定的句柄地址，对象被移动时（垃圾收集移动对象很普遍）只会改变句柄的实例数据指针，reference本身不需要修改</p>
<h4 id="直接指针访问"><a href="#直接指针访问" class="headerlink" title="直接指针访问"></a>直接指针访问</h4><p>reference存储的直接就是对象地址，由Java堆对象考虑如放置访问类型数据的相关信息</p>
<p><img src="https://i.imgur.com/K0uskT9.png" alt=""></p>
<p>直接指针访问好处是速度快，它节省了一次指针定位的时间开销，HotSpot使用的是直接指针访问</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/14/多态/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MakaLoo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MakaL-0-">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/14/多态/" itemprop="url">Java多态</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-14T15:19:18+08:00">
                2019-05-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/05/14/多态/" class="leancloud_visitors" data-flag-title="Java多态">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>wiki上对多态的定义是这样的：</p>
<blockquote>
<p>在编程语言和类型论中，多型（英语：polymorphism）指为不同数据类型的实体提供统一的接口。 [1]多态类型（英语：polymorphic type）可以将自身所支持的操作套用到其它类型的值上。[2]</p>
<p>计算机程序執行時，相同的訊息可能會送給多個不同的類別之物件，而系統可依據物件所屬類別，引發對應類別的方法，而有不同的行為。簡單來說，所謂多型意指相同的訊息給予不同的物件會引發不同的動作。</p>
<p>多态也可定义为“一种将不同的特殊行为和单个泛化记号相关联的能力”。</p>
<p>多态可分为变量多态与函数多态。变量多态是指：基类型的变量（对于C++是引用或指针）可以被赋值基类型对象，也可以被赋值派生类型的对象。函数多态是指，相同的函数调用界面（函数名与实参表），传送给一个对象变量，可以有不同的行为，这视该对象变量所指向的对象类型而定。因此，变量多态是函数多态的基础。</p>
</blockquote>
<h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>多态通过分离”做什么”和”怎么做”，从另一角度把接口和实现分离，改善代码的组织结构和可读性，创建可扩展的程序</p>
<h2 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h2><p>前提：</p>
<ul>
<li>继承关系</li>
<li>子类重写父类方法</li>
<li>父类引用指向子类（向上转型）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"动物吃饭"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"动物在睡觉"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"动物在奔跑"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">80</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">90</span>;</span><br><span class="line">    String name = <span class="string">"tomCat"</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"猫吃饭"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"猫在睡觉"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">catchMouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"猫在抓老鼠"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo_Test1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;	</span><br><span class="line">	Animal am = <span class="keyword">new</span> Cat(); <span class="comment">// 基类型指向子类对象</span></span><br><span class="line">	am.eat(); 		 <span class="comment">// 猫吃饭</span></span><br><span class="line">	am.sleep(); 	 <span class="comment">// 动物在睡觉</span></span><br><span class="line">	am.run(); 		 <span class="comment">// 动物在奔跑</span></span><br><span class="line">	am.catchMouse(); <span class="comment">// 报错</span></span><br><span class="line">    System.out.println(am.name); <span class="comment">// 报错</span></span><br><span class="line">	System.out.println(am.num);  <span class="comment">// 10</span></span><br><span class="line">	System.out.println(am.age);  <span class="comment">// 20</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成员变量：编译看父类，运行看父类<br>成员方法：编译看父类，运行看子类（动态绑定）<br>静态方法：编译看父类，运行看父类</p>
<p>弊端：多态不能使用子类特有的方法和属性</p>
<p>可以通过强制类型转换<code>Cat cat = (Cat)am</code>，这样，cat指向的是最开始在堆内存中创建的那个Cat类型的对象，这是多态的向下转型</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/14/Spring01-Spring IOC容器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MakaLoo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MakaL-0-">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/14/Spring01-Spring IOC容器/" itemprop="url">Spring01-Spring IOC容器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-14T10:25:34+08:00">
                2019-05-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/05/14/Spring01-Spring IOC容器/" class="leancloud_visitors" data-flag-title="Spring01-Spring IOC容器">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Spring1-Spring-IOC容器"><a href="#Spring1-Spring-IOC容器" class="headerlink" title="Spring1-Spring IOC容器"></a>Spring1-Spring IOC容器</h1><p><a href="https://github.com/MakLOAO/springdemo" target="_blank" rel="noopener">源代码在这</a></p>
<h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><p><img src="https://i.imgur.com/vVYCtCn.png" alt=""></p>
<p>控制反转，应用程序本身不负责依赖对象的创建和维护，而是由外部容器负责创建和维护</p>
<p>DI是其一种实现方式，指由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中</p>
<p>Bean：IOC容器中把所有对象都称为bean</p>
<p>bean配置有基于xml配置和注解</p>
<p>比较基础的spring目录树如下</p>
<p><img src="https://i.imgur.com/aEnB5Ol.png" alt=""></p>
<p>src内有main和test文件夹，main里面有java文件夹和resources文件夹，java保存java源代码，resources保存xml文件等，test文件夹里面是java文件夹，保存测试代码</p>
<h2 id="单元测试的编写"><a href="#单元测试的编写" class="headerlink" title="单元测试的编写"></a>单元测试的编写</h2><ol>
<li>maven导入junit依赖</li>
<li>创建UnitTestBase类，完成对Spring配置文件的加载，销毁</li>
<li>所有单元测试类继承自UnitTestBase，通过它的getBean方法获取想要的对象</li>
<li>子类加注解@RunWith(BlockJUnit4ClassRunner.class)</li>
<li>单元测试方法加注释@Test</li>
<li>右键要执行的单元测试方法执行，或者右键类的任意空位执行所有单元测试方法</li>
</ol>
<h3 id="UnitTestBase类的内容"><a href="#UnitTestBase类的内容" class="headerlink" title="UnitTestBase类的内容"></a>UnitTestBase类的内容</h3><p>InitTestBase主要有构造器，getBean方法和带Before注解的方法和带After注解的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnitTestBase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClassPathXmlApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String springXmlPath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnitTestBase</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnitTestBase</span><span class="params">(String springXmlPath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.springXmlPath = springXmlPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(springXmlPath)) &#123;</span><br><span class="line">            springXmlPath = <span class="string">"classpath*:spring-*.xml"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            context = <span class="keyword">new</span> ClassPathXmlApplicationContext(springXmlPath.split(<span class="string">"[,\\s]+"</span>));</span><br><span class="line">            context.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeansException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        context.destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String beanId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T)context.getBean(beanId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> context.getBean(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="具体的测试类编写"><a href="#具体的测试类编写" class="headerlink" title="具体的测试类编写"></a>具体的测试类编写</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定使用的单元测试类</span></span><br><span class="line"><span class="meta">@RunWith</span>(BlockJUnit4ClassRunner.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOneInterface</span> <span class="keyword">extends</span> <span class="title">UnitTestBase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestOneInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 把classpath作为参数，调用超类的构造函数</span></span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"classpath*:spring-ioc.xml"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 带Test注解的方法，在执行前会调用带有Before注解的方法，执行后调用带有After注解的方法（在超类中）</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        OneInterface oneInterface = <span class="keyword">super</span>.getBean(<span class="string">"oneInterface"</span>);</span><br><span class="line">		<span class="comment">// 通过超类的getBean方法得到bean</span></span><br><span class="line">        System.out.println(oneInterface.hello(<span class="string">"我的输入参数"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Bean容器的初始化"><a href="#Bean容器的初始化" class="headerlink" title="Bean容器的初始化"></a>Bean容器的初始化</h3><p><img src="https://i.imgur.com/6gwo6MH.png" alt=""></p>
<h2 id="Spring注入"><a href="#Spring注入" class="headerlink" title="Spring注入"></a>Spring注入</h2><p>Spring注入指启动Spring容器加载bean配置的时候，完成对变量的赋值，有设值注入（getter，setter）和构造注入（构造注入是依赖构造器参数，bean要有构造函数）xml文件的bean配置为：&lt;bean&gt;&lt;constructor-arg name=”xxx” value(ref)=”xxx” /&gt;&lt;/bean&gt; </p>
<h3 id="Spring设值注入"><a href="#Spring设值注入" class="headerlink" title="Spring设值注入"></a>Spring设值注入</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"xxx"</span> <span class="attr">class</span>=<span class="string">"xxx"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">ref</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- name是属性名，value是基础值，ref是指向某个对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对应的bean必须要有getter和setter</p>
<h3 id="构造注入"><a href="#构造注入" class="headerlink" title="构造注入"></a>构造注入</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"xxx"</span> <span class="attr">class</span>=<span class="string">"xxx"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">ref</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- name是属性名，value是基础值，ref是指向某个对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>必须要有构造器</p>
<h2 id="Bean的配置项"><a href="#Bean的配置项" class="headerlink" title="Bean的配置项"></a>Bean的配置项</h2><ul>
<li>Id：唯一标识</li>
<li>Class：类</li>
<li>Scope：范围，作用域</li>
<li>Constructor：构造器参数</li>
<li>Properties：属性</li>
<li>Autowiring mode：自动装配</li>
<li>lazy-initialization mode：懒装载</li>
<li>Initialization/destruction method：初始化，销毁方法</li>
</ul>
<h3 id="Scope作用域"><a href="#Scope作用域" class="headerlink" title="Scope作用域"></a>Scope作用域</h3><p>singleton：单例，一个bean容器中只存在一份<br>prototype：每次请求都创建新的实例，destroy方式不生效<br>request：每次http请求都会创建一个实例且仅在当前request内有效<br>session：每次http请求创建，当前session内有效</p>
<p><img src="https://i.imgur.com/FCRk9FK.png" alt=""></p>
<h2 id="Bean生命周期"><a href="#Bean生命周期" class="headerlink" title="Bean生命周期"></a>Bean生命周期</h2><ul>
<li>定义</li>
<li>初始化：在IOC容器启动后加载bean时调用</li>
<li>使用</li>
<li>销毁：在IOC容器销毁前调用</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>两种方式</p>
<ul>
<li>bean对应类实现org.springframework.beans.factory.InitializingBean接口，覆盖afterPropertiesSet方法</li>
<li>xml对应bean配置init-method：&lt;bean id=”” class=”” init-method=”” /&gt;，对应类中应有init-method指定的方法</li>
</ul>
<p>实现接口方法模板</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// do something</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><p>两种方法</p>
<ul>
<li>bean对应类实现org.springframework.beans.factory.DisposableBean接口，覆盖destroy方法</li>
<li>xml对应bean配置destroy-method</li>
</ul>
<h3 id="全局初始化和销毁方法"><a href="#全局初始化和销毁方法" class="headerlink" title="全局初始化和销毁方法"></a>全局初始化和销毁方法</h3><p>spring xml中配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span></span></span><br><span class="line"><span class="tag">	   <span class="attr">default-init-method</span>=<span class="string">"xxx"</span> <span class="attr">default-destroy-method</span>=<span class="string">"xxx"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- your bean here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当默认的，内部的和接口的初始化和销毁同时存在的时候，默认的初始化销毁方法被覆盖掉，不会执行，接口的初始化方法先于内部的初始化方法执行</p>
<h2 id="Aware"><a href="#Aware" class="headerlink" title="Aware"></a>Aware</h2><p>spring提供了一些以Aware结尾的接口，实现了Aware接口的bean在被初始化后，可以获取相应资源，通过Aware接口，可以对Spring相应资源进行操作</p>
<h3 id="ApplicationContextAware"><a href="#ApplicationContextAware" class="headerlink" title="ApplicationContextAware"></a>ApplicationContextAware</h3><p>When an ApplicationContext creates an object instance that implements the org.springframework.context.ApplicationContextAware interface, the instance is provided with a reference to that ApplicationContext.</p>
<p>即实现了该接口的类，在容器初始化该类的时候，会调用setApplicationContext，把上下文注入到该类实例中</p>
<h3 id="BeanNameAware"><a href="#BeanNameAware" class="headerlink" title="BeanNameAware"></a>BeanNameAware</h3><p>When an ApplicationContext creates a class that implements the org.springframework.beans.factory.BeanNameAware interface, the class is provided with a reference to the name defined in its associated object definition.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanNameAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The callback is invoked after population of normal bean properties but before an initialization callback such as InitializingBean afterPropertiesSet or a custom init-method.（在bean属性填充后但在初始化bean方法调用前调用）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小DEMO"><a href="#小DEMO" class="headerlink" title="小DEMO"></a>小DEMO</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoocBeanName</span> <span class="keyword">implements</span> <span class="title">BeanNameAware</span>, <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String beanName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanName = name;</span><br><span class="line">        System.out.println(<span class="string">"MoocBeanName："</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(applicationContext.getBean(beanName).hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他Aware接口"><a href="#其他Aware接口" class="headerlink" title="其他Aware接口"></a>其他Aware接口</h3><p>见<a href="https://docs.spring.io/spring/docs/5.0.14.RELEASE/spring-framework-reference/core.html#aware-list" target="_blank" rel="noopener">官方文档</a></p>
<h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><p>在对应xml配置文件的beans的属性中，设置default-autowire=”xxx”，其中xxx为下面几项</p>
<ul>
<li>no：不做任何操作</li>
<li>byName：根据属性名自动装配，此选项将检查容器并根据名字查找于属性完全一致的bean，将其与属性自动装配</li>
<li>byType：找属性类型相同的bean，与该属性自动装配，如果有多个该类型bean，就抛出异常</li>
<li>Constructor：与byType类似，它应用于构造器参数，在IOC容器中查找构造器参数的类型的bean，作为构造器参数传入，如果容器中没有找到与构造器参数类型一致的bean，就抛出异常</li>
</ul>
<h3 id="byName"><a href="#byName" class="headerlink" title="byName"></a>byName</h3><p>xml中配置如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">default-autowire</span>=<span class="string">"byName"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"autoWiringService"</span> <span class="attr">class</span>=<span class="string">"com.mkl.autowiring.AutoWiringService"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"autoWiringDAO"</span> <span class="attr">class</span>=<span class="string">"com.mkl.autowiring.AutoWiringDAO"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoWiringService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AutoWiringDAO autoWiringDAO;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAutoWiringDAO</span><span class="params">(AutoWiringDAO autoWiringDAO)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.autoWiringDAO = autoWiringDAO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.autoWiringDAO.say(word);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AutoWiringService中存在成员autoWiringDAO，设置了byName的自动装配后，会在IOC容器中寻找ID为autoWiringDAO的bean，把其实例作为setAutoWiringDAO的参数赋值给AutoWiringService的成员</p>
<h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2><p>针对资源文件的统一接口，下面是实现了Resources接口的一些类</p>
<ul>
<li>UrlResource：URL对应的资源，根据一个URL地址可构建</li>
<li>ClassPathResource:：获取类路径下的资源文件</li>
<li>FileSystemResource：获取文件系统里面的资源</li>
<li>ServletContextResource：ServletContext封装的资源，用于访问ServletContext环境下的资源</li>
<li>InputStreamResource：针对输入流封装的资源</li>
<li>ByteArrayResource：针对字节数组封装的资源</li>
</ul>
<h3 id="ResourceLoader"><a href="#ResourceLoader" class="headerlink" title="ResourceLoader"></a>ResourceLoader</h3><p>The ResourceLoader interface is meant to be implemented by objects that can return (i.e. load) Resource instances.</p>
<p><strong>All application contexts implement the ResourceLoader interface, and therefore all application contexts may be used to obtain Resource instances.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourceLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Resource <span class="title">getResource</span><span class="params">(String location)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>When you call getResource() on a specific application context, and the location path specified doesn’t have a specific prefix, you will get back a Resource type that is appropriate to that particular application context.<br>For example, assume the following snippet of code was executed against a ClassPathXmlApplicationContext instance:<br><code>Resource template = ctx.getResource(&quot;some/resource/path/myTemplate.txt&quot;);</code><br>What would be returned would be a ClassPathResource;</p>
<p>不使用前缀的时候，上下文调用getResource，返回的是实现了Resource接口的符合该特定应用程序上下文Resource类型，如对ClassPathXmlApplicationContext的实例调用getResource，返回的是ClassPathResource类型</p>
<p>使用特定前缀，可以返回特定的Resource类型（实现了Resource接口的特定类型），常见前缀如下</p>
<p><img src="https://i.imgur.com/cFwpsFq.png" alt=""></p>
<h3 id="一个Resource的使用例子"><a href="#一个Resource的使用例子" class="headerlink" title="一个Resource的使用例子"></a>一个Resource的使用例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoocResource</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resource</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Resource resource = applicationContext.getResource(<span class="string">"classpath:config.txt"</span>);</span><br><span class="line">        System.out.println(resource.getFilename());</span><br><span class="line">        System.out.println(resource.contentLength());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现ApplicationContextAware接口，实现其setApplicationContext方法，得到上下文，通过该上下文的getResource方法得到Resource，然后调用resource方法输出其文件名和长度</p>
<p>单元测试和配置文件略</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>1.POM加入了依赖却找不到例如ClassPathXmlApplicationContext类<br>解决：右键pom，maven，reimport</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/11/文件管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MakaLoo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MakaL-0-">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/11/文件管理/" itemprop="url">文件管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-11T20:32:01+08:00">
                2019-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/05/11/文件管理/" class="leancloud_visitors" data-flag-title="文件管理">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><h2 id="文件的相关基本概念"><a href="#文件的相关基本概念" class="headerlink" title="文件的相关基本概念"></a>文件的相关基本概念</h2><p>数据项：文件系统中最低级的数据组织形式，分为基本数据项和组合数据项，<strong>基本数据项用于描述一个对象的某种属性的字符集</strong>，是可命名的最小逻辑数据单位，又称为字段，例如，用于描述学生的基本数据项有：学号，姓名等；组合数据项是若干基本数据项的组成；数据项还应有数据类型</p>
<p>记录：<strong>记录是一组相关数据项的集合，用于描述一个对象在某方面的属性</strong>，一个记录应包含哪些数据项取决于需要描述对象的哪个方面。例如，一个学生，当把他作为班上一个学生时，对他的描述为学号，姓名，年龄，所在系班，若把学生当作医疗对象则不同。<strong>唯一标识记录的数据项是关键字</strong></p>
<p>文件：<strong>文件是由创建者所定义的，具有文件名的一组相关元素的集合</strong>，分为有结构文件和无结构文件，<strong>有结构文件中，文件由若干个相关记录组成，而无结构文件被看成是一个字符流</strong>，文件在文件系统是一个最大的数据单位，它描述了一个对象集，例如可以将一个班的学生记录作为一个文件</p>
<p>文件属性可以包括：文件类型，文件长度，文件的物理位置，文件的建立时间（最后一次的修改时间等）</p>
<h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>文件类型按用途分类可分为系统文件，用户文件和库文件<br>按文件中数据的形式分类可分为源文件，目标文件和可执行文件<br>按存取控制属性分类可分为只执行文件，只读文件，读写文件<br>按组织形式和处理方式分类可分为普通文件，目录文件和特殊文件</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>文件系统的模型是指文件和对文件进行操纵和管理的软件集合</p>
<p>分为三层：对象及属性，对文件进行操纵和管理的软件集合，文件系统接口</p>
<p><img src="https://i.imgur.com/T92HXjD.png" alt=""></p>
<h3 id="对象及其属性层"><a href="#对象及其属性层" class="headerlink" title="对象及其属性层"></a>对象及其属性层</h3><p>文件管理系统管理的对象如下：</p>
<ul>
<li>文件</li>
<li>目录</li>
<li>磁盘存储空间</li>
</ul>
<h3 id="对对象操纵和管理的软件集合层"><a href="#对对象操纵和管理的软件集合层" class="headerlink" title="对对象操纵和管理的软件集合层"></a>对对象操纵和管理的软件集合层</h3><p>该层是文件管理系统的核心部分，文件系统的功能大多是这一层实现，其中包括对文件存储空间的管理，对文件目录的管理，用于将文件的逻辑地址转换为物理地址的机制，对文件的读写管理，对文件的共享保护等功能</p>
<p>一般把与文件系统有关的软件分为4个层次：</p>
<ul>
<li>I/O控制层：磁盘驱动程序等组成</li>
<li>基本文件系统层：内存与磁盘之间数据块的交换</li>
<li>基本I/O管理程序：完成与磁盘I/O有关的事务，如文件逻辑块号转换为物理块号等</li>
<li>逻辑文件系统：用于处理与记录和文件相关的操作，如允许用户使用符号文件名访问文件及记录等</li>
</ul>
<h3 id="文件系统接口"><a href="#文件系统接口" class="headerlink" title="文件系统接口"></a>文件系统接口</h3><p>文件系统提供了命令接口和程序接口</p>
<h2 id="文件逻辑结构"><a href="#文件逻辑结构" class="headerlink" title="文件逻辑结构"></a>文件逻辑结构</h2><p>文件的逻辑结构是从用户观点出发所观察到的文件组织形式，即文件是由一系列逻辑记录组成的，是用户可以直接处理的数据及其结构，独立于文件的物理特性，又称为文件组织</p>
<p>文件的物理结构又称为文件的存储结构，是指系统将文件存储在外存上所形成的一种存储组织形式，用户是不能看见的</p>
<p>物理结构和逻辑结构都会影响对文件的检索速度</p>
<p>下图是文件结构类型的概述</p>
<p><img src="https://i.imgur.com/M9LFero.png" alt=""></p>
<h3 id="逻辑结构的类型"><a href="#逻辑结构的类型" class="headerlink" title="逻辑结构的类型"></a>逻辑结构的类型</h3><p>文件按有无结构分为有结构文件和无结构文件</p>
<p>有结构文件根据记录长度分为定长和不定长两类，定长指文件的所有记录长度都是相同的，所有记录的各数据项都处在记录中相同的位置，具有相同的顺序和长度，定长记录有效提高检索记录的速度和效率，方便对文件处理和修改，文件长度用记录数目来表示；变长记录指文件中各记录长度不相同</p>
<p>有结构文件按文件组织方式分为</p>
<ul>
<li>顺序文件：由一系列记录按某种顺序排列形成的文件，记录通常是定长记录（变长记录查询速度慢，不支持随机访问和删除插入记录）</li>
<li>索引文件：可变长记录文件建立一张索引表，为每个记录设置一个表项，加速对记录的检索</li>
<li>索引顺序文件：顺序文件和索引文件的结合，在为每个文件建立一张索引表时，并不是为每个记录建立索引表项，而是为一组记录中的第一个记录建立一个索引表项</li>
</ul>
<p>无结构文件是流式文件，信息管理系统和数据库系统中广泛采用了有结构的文件形式，而源程序，可执行文件，库函数等采用的就是无结构文件，长度是以字节为单位，可以把流式文件看作记录式文件的一个特例：一个记录仅有一个字节</p>
<h4 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h4><p>顺序文件可以按照串结构或顺序结构排列，串结构指按存入时间的先后进行排序，各记录之间的顺序与关键字无关，对串结构文件检索比较费时，顺序结构是由用户指定一个字段作为关键字，文件中所有记录可以按关键字排序，具有更高的检索速度</p>
<h4 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h4><p>为变长记录建立一个索引表，对主文件的每个记录在索引表中设有一个相应表项，用于记录该记录的长度L，以及指向该记录的指针</p>
<p><img src="https://i.imgur.com/UDTyQoQ.png" alt=""></p>
<p>索引文件是可以实现直接存取的，索引文件支持随机访问</p>
<h4 id="索引顺序文件"><a href="#索引顺序文件" class="headerlink" title="索引顺序文件"></a>索引顺序文件</h4><p>索引顺序文件保留了顺序文件的关键字顺序，又增加了文件索引表和溢出文件，溢出文件用来记录新增加的，删除的和修改的记录</p>
<h5 id="一级索引顺序文件"><a href="#一级索引顺序文件" class="headerlink" title="一级索引顺序文件"></a>一级索引顺序文件</h5><p>将变长记录顺序文件的所有记录分为若干组，为顺序文件建立一张索引表，并为每组的第一个记录，在索引表建立一个索引项，其中包含该记录的关键字和指向该记录的指针</p>
<p>对索引顺序文件检索时，先利用提供的关键字以及某种查找算法去检索索引表，找到该记录所在记录组第一个记录的表项，从中得到该记录组第一个记录在主文件的位置，然后再利用顺序查找法去查找主文件，从中找到所要求的记录</p>
<h4 id="直接文件和哈希文件"><a href="#直接文件和哈希文件" class="headerlink" title="直接文件和哈希文件"></a>直接文件和哈希文件</h4><h5 id="直接文件"><a href="#直接文件" class="headerlink" title="直接文件"></a>直接文件</h5><p>直接文件可以根据给定的关键字直接获得记录的物理地址，即关键字本身就决定了记录的物理地址，由关键字到记录物理地址的转换称为键值转换，而上述的索引文件实质是对关键字计算得到对应索引表表项的物理地址，由该物理地址得到指向对应记录的指针</p>
<h5 id="哈希文件"><a href="#哈希文件" class="headerlink" title="哈希文件"></a>哈希文件</h5><p>利用哈希函数将关键字转换为相应记录的地址</p>
<h3 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h3><p>物理结构是从实现的观点出发，文件在外存上的存放组织形式，有如下三种物理结构</p>
<ul>
<li>连续结构</li>
<li>链接结构</li>
<li>索引结构</li>
</ul>
<h2 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h2><p>对目录管理的要求</p>
<ul>
<li><strong>实现”按名存取”</strong>：用户只须向系统提供所需访问的文件的名字，便能快速准确地找到指定文件在外存地存储位置，这是目录管理最基本地功能</li>
<li>提高对目录的检索速度</li>
<li>文件共享：允许多个用户共享一个文件，这样只须在外存中保留一份该文件副本供不同用户使用，节省存储空间，提高利用率</li>
<li>允许文件重名：允许不同用户对不同文件采取相同的名字</li>
</ul>
<h3 id="文件控制块FCB"><a href="#文件控制块FCB" class="headerlink" title="文件控制块FCB"></a>文件控制块FCB</h3><p>文件目录：文件控制块的有序集合，即一个文件控制块就是一个文件目录项，通常一个文件目录被看成是一个文件，称为目录文件</p>
<p>文件控制块：描述和控制文件的数据结构，文件与文件控制块一一对应，一个文件控制块就是一个文件目录项（文件目录是文件控制块的有序集合），包含基本信息，存取控制信息和使用信息，可以分为内存FCB和外存FCB</p>
<p>它们的关系：文件控制块与文件一一对应，而文件目录是有结构文件，其中的每一个记录都是一个文件控制块</p>
<p>检索过程：检索的时候，把文件目录调入内存，查找其目录项，找到与给定的文件名对应的文件名，读出其物理地址</p>
<h4 id="基本信息类"><a href="#基本信息类" class="headerlink" title="基本信息类"></a>基本信息类</h4><ul>
<li>文件名</li>
<li>文件物理位置</li>
<li>文件逻辑结构：流式还是有结构，记录数，定长记录还是变长记录等</li>
<li>文件物理结构：顺序还是链接还是索引</li>
</ul>
<h4 id="存取控制信息类"><a href="#存取控制信息类" class="headerlink" title="存取控制信息类"></a>存取控制信息类</h4><p>文件主，核准用户和一般用户的存取权限</p>
<h4 id="使用信息类"><a href="#使用信息类" class="headerlink" title="使用信息类"></a>使用信息类</h4><ul>
<li>文件建立日期和时间</li>
<li>上一次修改的日期和时间</li>
<li>当前使用信息（已打开文件的进程数，是否被锁等等）</li>
</ul>
<h3 id="索引结点"><a href="#索引结点" class="headerlink" title="索引结点"></a>索引结点</h3><p>OS中每有一个目录，就有一个FCB</p>
<p>引入：文件目录占空间，检索目录文件过程中，要把存放目录文件的第一个盘块中的目录的调入内存，然后将用户所给定的文件名与目录项的文件名一一对应，若没有找到指定文件，还需要将下一盘块的目录项调入内存。检索过程中，只用到了文件名，而没有其他描述文件的信息，仅当找到一个目录项（即其中文件名与指定要查找的文件名相匹配）时，才需从该目录项中读出该文件的物理地址，而其他一些对该文件进行描述的信息在检索目录时一概不用。显然这些信息在检索目录的时候不需要调入内存，为此，采用把文件名与文件描述信息分开的方法，即使<strong>文件描述信息单独形成一个称为索引结点的数据结构</strong></p>
<p>引入后，文件目录项就不是FCB了，而是文件名+索引结点，这样可以使每个盘块可以存更多的文件目录项，减少盘块数，从而减少盘块调入内存的次数</p>
<p><img src="https://i.imgur.com/bUvbRVo.png" alt=""></p>
<p>引入索引结点前的文件目录项（FCB）</p>
<p><img src="https://i.imgur.com/31IywfE.png" alt=""></p>
<p>引入索引结点后的文件目录项（文件名+索引结点）</p>
<p>例如上图，在没有引入索引结点的时候，FCB是上图一所示，每次检索目录的时候都要把FCB调入内存，而FCB又占用比较大的空间，这样系统开销会很多，采用了上图二的文件目录项后，一个目录项只占用很小的开销（UNIX为16个字节，14字节文件名，2字节为i结点指针），可以减少磁盘启动次数，节省系统开销</p>
<h4 id="我对索引结点减少磁盘启动次数的理解"><a href="#我对索引结点减少磁盘启动次数的理解" class="headerlink" title="我对索引结点减少磁盘启动次数的理解"></a>我对索引结点减少磁盘启动次数的理解</h4><p>前提：目录文件所占盘块数为N，则检索该文件目录时平均调入盘块次数为(N+1)/2次，检索一个文件要从第一个文件目录开始检索，直到最后一个文件目录</p>
<p>引入索引结点可以减少磁盘启动次数，节省系统开销，主要原因是调入内存是以盘块为单位和引入索引结点后文件目录项的大小比FCB的大小要小</p>
<p>e.g.在文件系统中，每个盘块为256字节，文件控制块占64个字节，其中文件名占8个字节。如果索引节点编号占2个字节，对一个存放在磁盘上的128个目录项的目录，试比较引入索引节点前后，为找到其中一个文件，平均启动磁盘的次数</p>
<p>在引入索引结点前，每个目录项中存放的是对应文件的FCB，故128个目录项的目录总共需要占用128X64／256=32个盘块。因此，在该目录中检索到一个文件，平均启动磁盘的次数为(1+32)/2=16.5次。<br>引入索引结点后，每个目录项中只需存放文件名和索引结点的编号，因此128个目录项的目录总共需要占用128X(8+2)／256=5个盘块。因此，找到匹配的目录项平均需要启动(1+5)／2，即3次磁盘；而得到索引结点编号后，还需启动磁盘将对应文件的索引结点读入内存，故平均需要启动磁盘4次。可见，引入索引结点后，可大大减少启动磁盘的次数，从而有效地提高检索文件的速度。</p>
<h4 id="引入索引结点后的索引过程"><a href="#引入索引结点后的索引过程" class="headerlink" title="引入索引结点后的索引过程"></a>引入索引结点后的索引过程</h4><ol>
<li>文件目标项只存放文件名和结点号，结点号存放FCB信息</li>
<li>查询只调入文件名部分和结点指针，找到后才调入对应i结点指向的内容</li>
</ol>
<h4 id="磁盘索引结点"><a href="#磁盘索引结点" class="headerlink" title="磁盘索引结点"></a>磁盘索引结点</h4><p>存放在磁盘的索引结点，每个文件有唯一的磁盘索引结点，包括如下内容：</p>
<ul>
<li>文件主标识</li>
<li>文件类型（正规文件，目录文件，特殊文件）</li>
<li>文件存取权限</li>
<li>文件物理地址</li>
<li>文件长度</li>
<li>文件连接计数（本文件系统所有指向该文件名的指针计数，用于共享）</li>
<li>文件存取时间</li>
</ul>
<h4 id="内存索引结点"><a href="#内存索引结点" class="headerlink" title="内存索引结点"></a>内存索引结点</h4><p>存放在内存中的索引结点，当文件被打开时，要将磁盘索引结点拷贝到内存的索引结点中方便以后使用，增加了以下内容</p>
<ul>
<li>索引结点编号</li>
<li>状态</li>
<li>访问计数</li>
<li>文件所属文件系统的逻辑设备号</li>
<li>链接指针</li>
</ul>
<h3 id="单级目录结构"><a href="#单级目录结构" class="headerlink" title="单级目录结构"></a>单级目录结构</h3><p>最简单的文件目录，在整个文件系统中只建立一张目录表，每个文件占一个目录项，目录项含文件名，文件扩展名，文件长度，文件类型，文件物理地址以及其他文件属性，状态位（是否空闲）</p>
<p><img src="https://i.imgur.com/1cziASy.png" alt=""></p>
<p>单级目录结构不允许重名，新建文件时要检查有无同名，删除时回收块并清楚占用目录项</p>
<h3 id="两级目录结构"><a href="#两级目录结构" class="headerlink" title="两级目录结构"></a>两级目录结构</h3><p><img src="https://i.imgur.com/JKxqy9C.png" alt=""></p>
<p>可以为每个用户再建立一个单独的用户文件目录UFD，这些文件目录由用户所有文件的文件控制块组成，在系统中再建立一个主文件目录MFD，MFD的每个目录项为用户的目录文件</p>
<p>两级目录结构允许重名，但不允许用户建立自己的子目录</p>
<h3 id="树形结构目录"><a href="#树形结构目录" class="headerlink" title="树形结构目录"></a>树形结构目录</h3><p>一个目录文件中目录项可以为目录文件和数据文件，允许重名，便于实现文件共享</p>
<p><img src="https://i.imgur.com/8nlH5dR.png" alt=""></p>
<h3 id="目录查询技术"><a href="#目录查询技术" class="headerlink" title="目录查询技术"></a>目录查询技术</h3><p>当用户要访问一个已经存在的文件时，系统首先利用用户提供的文件名对目录进行查询，找出该文件的FCB或对应索引结点，然后根据FCB或索引结点中记录的文件物理地址（盘块号），换算出文件在磁盘上的物理地址，最后再通过磁盘驱动程序将所需文件读入内存</p>
<p>常用的目录查询方式为线性检索法和Hash方法</p>
<h4 id="线性检索法"><a href="#线性检索法" class="headerlink" title="线性检索法"></a>线性检索法</h4><p><img src="https://i.imgur.com/aoT42vI.png" alt=""></p>
<p>查找过程如下：</p>
<ol>
<li>系统先读入第一个文件分量名usr，用它与根目录文件中各目录项的文件名顺序的进行比较，找到匹配者，并得到索引结点号，再从索引结点号得知物理地址号（盘块号），将该盘块132号读入内存</li>
<li>系统再将路径名第二个分量ast读入，与存放在132号盘块的第二级目录文件各目录项的文件名顺序比较，以此类推直到找到mbox的索引结点和物理地址</li>
</ol>
<p><img src="https://i.imgur.com/jr8fDTP.png" alt=""></p>
<h4 id="Hash方法"><a href="#Hash方法" class="headerlink" title="Hash方法"></a>Hash方法</h4><p>建立一张Hash索引文件目录，利用Hash方法查询，系统利用文件名变换为文件目录的索引值，再利用该索引值到目录去查找</p>
<h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><p>两种共享方式：用户直接通过路径名来访问共享文件和对需要共享的文件进行链接</p>
<h2 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h2><ul>
<li>存取控制机制防止人为因素造成文件不安全</li>
<li>磁盘容错技术防止磁盘故障造成文件不安全</li>
<li>后备系统防止自然因素造成的不安全性</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/11/磁盘存储器的管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MakaLoo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MakaL-0-">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/11/磁盘存储器的管理/" itemprop="url">磁盘存储器的管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-11T20:32:01+08:00">
                2019-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/05/11/磁盘存储器的管理/" class="leancloud_visitors" data-flag-title="磁盘存储器的管理">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="磁盘存储器的管理"><a href="#磁盘存储器的管理" class="headerlink" title="磁盘存储器的管理"></a>磁盘存储器的管理</h1><p>磁盘存储器管理的单位是盘块</p>
<h2 id="外存的组织方式"><a href="#外存的组织方式" class="headerlink" title="外存的组织方式"></a>外存的组织方式</h2><p>文件的物理结构直接与外存的组织方式有关，不同的外存组织方式形成不同的文件物理结构</p>
<ul>
<li>连续组织方式：为每个文件分配连续的磁盘空间</li>
<li>链接组织方式：为每个文件分配不连续的磁盘空间，通过链接指针将文件的所有盘块链接在一起</li>
<li>索引组织方式</li>
</ul>
<h3 id="连续组织方式"><a href="#连续组织方式" class="headerlink" title="连续组织方式"></a>连续组织方式</h3><p>特点：</p>
<ul>
<li>顺序访问容易，速度快（磁头移动距离小）</li>
<li>要求连续空间，一段时间后要整理磁盘消除碎片</li>
<li>必须事先知道长度，文件不易动态增长和删除</li>
</ul>
<p>文件对应目录项包含：始址，总块数，最后一块字节数</p>
<h3 id="链接组织方式"><a href="#链接组织方式" class="headerlink" title="链接组织方式"></a>链接组织方式</h3><p>特点：</p>
<ul>
<li>消除磁盘外部碎片，提高外存利用率</li>
<li>对插入，删除和修改记录容易</li>
<li>适应文件的动态增长，无需事先知道文件大小</li>
<li>只能顺序存取</li>
</ul>
<h4 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a>隐式链接</h4><p>文件目录的每个目录项都含有指向链接文件第一个盘块和最后一个盘块的指针，只适用于顺序访问，随机访问效率低</p>
<p>簇：包含多个块的单位，盘块分配时以簇为单位，可以成倍减小查找指定块的时间，增大内部碎片</p>
<h4 id="显示链接"><a href="#显示链接" class="headerlink" title="显示链接"></a>显示链接</h4><p>把用于链接文件各物理块的指针显式地存放在内存的一张链接表中，该表在整个磁盘只设置一张</p>
<p><img src="https://i.imgur.com/r2Cpho8.png" alt=""></p>
<p>表的序号是物理块号，在每个表项中存放链接指针，即下一个盘块号，凡是属于某一文件的第一个盘块号，均作为文件地址被填入相应FCB的物理地址字段，查找是在内存进行的所以速度提升且减少磁盘访问次数，该表称为文件分配表FAT</p>
<h3 id="索引组织方式"><a href="#索引组织方式" class="headerlink" title="索引组织方式"></a>索引组织方式</h3><p>打开某个文件时，只要把该文件占用的索引块号读入内存即可，无需把FAT调入内存，索引的优点是支持直接访问，当要读第i块盘块时，直接从该文件的索引块中找到该盘块号</p>
<p>单级索引：为每个文件分配一个索引块，文件较大时有利，较小时浪费外存空间，文件较大时索引块较多，需要建立多级索引</p>
<p>多级索引如下</p>
<p><img src="https://i.imgur.com/axLLInx.png" alt=""></p>
<h3 id="混合分配方式"><a href="#混合分配方式" class="headerlink" title="混合分配方式"></a>混合分配方式</h3><p>UNIX采用混合分配方式，一，二，多级索引合用</p>
<p><img src="https://i.imgur.com/823nqH9.png" alt=""></p>
<p>i.addr(0)——i.addr(9)存放直接地址，i.addr(10)存放一次间接地址，i.addr(11)存放二次间接地址</p>
<h3 id="文件组织策略"><a href="#文件组织策略" class="headerlink" title="文件组织策略"></a>文件组织策略</h3><ul>
<li>文件访问通常是顺序，文件较小，用连续分配</li>
<li>文件较大顺序访问，链接结构</li>
<li>文件较大随机访问，索引结构</li>
</ul>
<h3 id="分配策略的小习题"><a href="#分配策略的小习题" class="headerlink" title="分配策略的小习题"></a>分配策略的小习题</h3><p><img src="https://i.imgur.com/GJLObbI.png" alt=""></p>
<p><img src="https://i.imgur.com/MvlYqVV.png" alt=""></p>
<h2 id="文件存储空间的管理"><a href="#文件存储空间的管理" class="headerlink" title="文件存储空间的管理"></a>文件存储空间的管理</h2><p>设置一个磁盘分配表，用于记住可供分配的存储空间情况，还应提供对盘块分配和回收的手段，存储空间基本分配单位都是磁盘块而非字节</p>
<h3 id="空闲表法"><a href="#空闲表法" class="headerlink" title="空闲表法"></a>空闲表法</h3><p>空闲表属于连续分配方式，为每个文件分配一块连续的存储空间，即系统为外存上的所有空闲区建立一张空闲表，每个空闲区对应一个空闲表项，包括表项序号，第一个盘块号，空闲盘块数等信息</p>
<p><img src="https://i.imgur.com/hh96knJ.png" alt=""></p>
<h3 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a>空闲链表法</h3><h4 id="空闲盘块链"><a href="#空闲盘块链" class="headerlink" title="空闲盘块链"></a>空闲盘块链</h4><p>将所有空闲空间以盘块为单位拉成一条链，工作效率低</p>
<h4 id="空闲盘区链"><a href="#空闲盘区链" class="headerlink" title="空闲盘区链"></a>空闲盘区链</h4><p>将磁盘所有空闲盘区拉成一条链，每个盘区包含若干个盘块，要有指明本盘块大小的信息</p>
<h3 id="位示图法"><a href="#位示图法" class="headerlink" title="位示图法"></a>位示图法</h3><p>利用二进制的一位来表示磁盘一个盘块的使用情况，0为盘块空闲，1为已分配</p>
<p><img src="https://i.imgur.com/betahpN.png" alt=""></p>
<p><img src="https://i.imgur.com/dU7Bpaj.png" alt=""></p>
<h4 id="位示图法盘块的分配"><a href="#位示图法盘块的分配" class="headerlink" title="位示图法盘块的分配"></a>位示图法盘块的分配</h4><ol>
<li>顺序扫描位示图，找出一个或一组值为0的二进制位</li>
<li>将找到的一个或一组二进制位转换位盘块号，假定找到值为0的二进制位位于位示图第i行j列，则盘块号按下式计算：b=n(i-1)+j</li>
<li>修改位示图，令map[i,j]=1</li>
</ol>
<h4 id="位示图的回收"><a href="#位示图的回收" class="headerlink" title="位示图的回收"></a>位示图的回收</h4><ol>
<li>将回收盘块号转换为位示图的行号列号i=(b-1)DIVn+1,j=(b-1)MODn+1</li>
<li>修改位示图，令map[i,j]=0</li>
</ol>
<h3 id="成组链接法"><a href="#成组链接法" class="headerlink" title="成组链接法"></a>成组链接法</h3><p>UNIX采用的方法</p>
<p>基本思想（汤书P281解释更详细）</p>
<ul>
<li>空闲盘块号栈存放当前可用的一组空闲盘块号及栈中尚有的空闲盘块号数，唯一存在于内存的栈</li>
<li>文件区的所有空闲盘块分为若干组</li>
<li>每一组含有盘块总数和所有的盘块号记入前一组最后一个盘块中</li>
<li>第一组盘块总数和所有盘块号记入空闲盘块号栈</li>
<li>最末一组只有N-1各盘块</li>
</ul>
<p><img src="https://i.imgur.com/ooa2j7G.png" alt=""></p>
<p>S.free(0)是栈底</p>
<h4 id="空闲盘块分配"><a href="#空闲盘块分配" class="headerlink" title="空闲盘块分配"></a>空闲盘块分配</h4><p>首先检查空闲盘块号栈是否上锁，如未上锁，便从<strong>栈顶</strong>取出一空闲盘块号，将与之对应的盘块分配给用户，然后将栈顶指针下移一格<br>若该盘块号已是栈底，即S.free(0)，即最后一个可分配的盘块号。 须调用磁盘读过程，将栈底盘块号所对应盘块的内容读入栈中，作为新的空闲盘块号栈的内容，然后，把原栈底对应的盘块分配出去(其中的有用数据已读入栈中)</p>
<h4 id="空闲盘块的回收"><a href="#空闲盘块的回收" class="headerlink" title="空闲盘块的回收"></a>空闲盘块的回收</h4><p>将回收盘块的盘块号记入空闲盘块号栈的顶部，并执行空闲盘块数加1操作。<br>当栈中空闲盘块号数目已达100时，表示栈已满，便将现有栈中的100个盘块号，记入新回收的盘块中，再将其盘块号作为新栈底</p>
<h2 id="提高磁盘I-O速度的途径"><a href="#提高磁盘I-O速度的途径" class="headerlink" title="提高磁盘I/O速度的途径"></a>提高磁盘I/O速度的途径</h2><ul>
<li>磁盘高速缓存（数据交付，置换算法，周期性写回磁盘）</li>
<li>提前读</li>
<li>延迟写</li>
<li>优化物理块布局</li>
<li>虚拟盘</li>
</ul>
<h2 id="数据一致性控制"><a href="#数据一致性控制" class="headerlink" title="数据一致性控制"></a>数据一致性控制</h2><p>事务：用于访问和修改各种数据项的一个程序单位，可以看作一系列相关的读写操作，被访问的数据可以分散地存放在同一文件的不同记录中，也可放在多个文件中。只有对分布在不同位置的同一数据所进行的读和写(含修改)操作全部完成时，才能再以托付操作(Commit Operation)来终止事务。只要有一个读、写或修改操作失败，便须执行夭折操作(Abort Operation)。读或写操作的失败可能是由于逻辑错误，也可能是系统故障所导致的</p>
<h3 id="事务记录"><a href="#事务记录" class="headerlink" title="事务记录"></a>事务记录</h3><ul>
<li>事务名：用于标识该事务的惟一名字</li>
<li>数据项名：它是被修改数据项的惟一名字</li>
<li>旧值：修改前数据项的值</li>
<li>新值：修改后数据项将具有的值</li>
</ul>
<h3 id="恢复算法"><a href="#恢复算法" class="headerlink" title="恢复算法"></a>恢复算法</h3><p>undo<ti>，把所有被事务Ti修改过的数据恢复修改前的值<br>redo<ti>，把所有被事务Ti修改过的数据设置为新值</ti></ti></p>
<h3 id="检查点"><a href="#检查点" class="headerlink" title="检查点"></a>检查点</h3><p>作用：使对事务记录表中事务记录的清理工作经常化</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/10/设备管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MakaLoo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MakaL-0-">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/10/设备管理/" itemprop="url">设备管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-10T22:38:01+08:00">
                2019-05-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/05/10/设备管理/" class="leancloud_visitors" data-flag-title="设备管理">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h1><p>I/O系统管理的主要对象是I/O设备和相应的设备控制器，其主要任务是，完成用户提出的I/O请求，提高I/O速率，以及提高设备利用率，并为更高层的进程方便地使用这些设备提供手段</p>
<h2 id="I-O系统的层次结构"><a href="#I-O系统的层次结构" class="headerlink" title="I/O系统的层次结构"></a>I/O系统的层次结构</h2><p>I/O软件组织分为4个层次</p>
<ul>
<li>用户层I/O软件：提供库函数对I/O设备操作</li>
<li>设备独立性软件：实现用户程序与设备驱动器的统一接口，设备命名，保护和分配释放等</li>
<li>设备驱动软件：与硬件直接相关，用于具体实现系统对设备发出的操作指令</li>
<li>中断处理程序：用于保存被中断进程的CPU环境，转入相应的中断处理程序处理，处理完恢复现场</li>
</ul>
<h2 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h2><p>设备并不是直接与CPU进行通信，而是与设备控制器通信，I/O设备应提供提供数据信号线，状态信号线和控制信号线给设备控制器</p>
<p>设备控制器主要功能是控制一个或多个I/O设备，实现I/O设备和计算机之间的数据交换，它是CPU与I/O设备之间的接口，接收从CPU发来的命令，去控制I/O设备工作</p>
<h3 id="设备控制器基本功能"><a href="#设备控制器基本功能" class="headerlink" title="设备控制器基本功能"></a>设备控制器基本功能</h3><ul>
<li>接收和识别命令</li>
<li>数据交换：数据总线实现CPU到控制器的交换，数据寄存器实现设备控制器到I/O设备的交换</li>
<li>标识和报告设备的状态</li>
<li>地址识别</li>
<li>数据缓冲区</li>
<li>差错控制</li>
</ul>
<h3 id="设备控制器的组成"><a href="#设备控制器的组成" class="headerlink" title="设备控制器的组成"></a>设备控制器的组成</h3><ul>
<li>设备控制器与处理机的接口：数据线地址线和控制线，实现CPU和设备控制器的通信，数据线通常与数据寄存器或者控制/状态寄存器连接，与数据寄存器连接的话是传输数据，与控制/状态寄存器连接的话是存放控制信息或设备状态信息</li>
<li>设备控制器与设备的接口：控制器由一个或多个设备接口，由数据，控制，状态三种信号组成</li>
<li>I/O逻辑：实现对设备控制，通过一组控制线与处理机交互，处理I/O命令，每当CPU启动一个设备，一方面启动命令发送给控制器，另一方面同时通过地址线把地址发送给控制器，由控制器的I/O逻辑对收到的地址译码，对所选设备控制</li>
</ul>
<p><img src="https://i.imgur.com/Wf5JaZW.png" alt=""></p>
<h2 id="I-O通道"><a href="#I-O通道" class="headerlink" title="I/O通道"></a>I/O通道</h2><p>引入目的：解脱CPU对I/O的组织，管理。虽然设备控制器可以减少CPU对I/O的干预，但当主机所配置的外设很多时，CPU负担仍很重，为此增加了I/O通道</p>
<p>I/O通道是一种特殊的执行I/O指令的处理机，与CPU共享内存，可以有自己的总线，它从CPU接收I/O指令，从内存取出要执行的通道执行程序，然后执行，完成规定I/O任务后，向CPU发中断信号</p>
<h3 id="通道类型"><a href="#通道类型" class="headerlink" title="通道类型"></a>通道类型</h3><ul>
<li>字节多路通道：各通道以时间片轮转方式共享通道，适用于低，中速设备</li>
<li>数组选择通道：无子通道，仅一主通道，某时间由某设备独占，适用高速设备，利用率低</li>
<li>数组多路通道：多子通道按需分配，综合前面两种优点</li>
</ul>
<h2 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I/O控制方式"></a>I/O控制方式</h2><p>四个阶段：程序I/O——中断I/O——DMA控制——通道控制</p>
<p>趋势：减少CPU对I/O操作的干预，提高并行度</p>
<ol>
<li>程序I/O控制方式：采用轮询的方式，CPU需要花代价不断查询I/O状态</li>
<li>中断I/O控制方式：CPU向I/O发命令然后做其他事，设备管理器按照该命令控制指定I/O，当I/O中断产生，CPU转去执行中断处理程序，CPU以字节为单位干预I/O</li>
<li>DMA控制：由DMA控制器直接控制总线传递数据块，DMA控制器完成从I/O到内存，主要用在块设备中</li>
<li>通道控制：DMA控制对多离散块的读取仍需要多次中断，通道方式CPU只要给出通道程序首地址，要访问的I/O设备后，通道程序就会完成一组块操作</li>
</ol>
<p><img src="https://i.imgur.com/dtoV0Yk.png" alt=""></p>
<p><img src="https://i.imgur.com/U2xYU5E.png" alt=""></p>
<h2 id="缓冲管理"><a href="#缓冲管理" class="headerlink" title="缓冲管理"></a>缓冲管理</h2><p>缓冲管理的目的是：组织管理，分配，释放buffer</p>
<p>引入：</p>
<ul>
<li>缓和CPU与I/O设备速度不匹配的矛盾</li>
<li>减少对CPU的中断频率</li>
<li>提高CPU和I/O并行性</li>
<li>解决数据粒度不匹配问题（数据单元大小）</li>
</ul>
<h3 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h3><p><img src="https://i.imgur.com/757qokP.png" alt=""></p>
<h3 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h3><p><img src="https://i.imgur.com/6sjJRcM.png" alt=""></p>
<p>收发可双向同时传送</p>
<h3 id="循环多缓冲"><a href="#循环多缓冲" class="headerlink" title="循环多缓冲"></a>循环多缓冲</h3><p><img src="https://i.imgur.com/l6h6TI6.png" alt=""></p>
<p><img src="https://i.imgur.com/eOKaI4l.png" alt=""></p>
<p><img src="https://i.imgur.com/HeyUobP.png" alt=""></p>
<h3 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h3><p><img src="https://i.imgur.com/CULwxH4.png" alt=""></p>
<p><img src="https://i.imgur.com/YMwks1i.png" alt=""></p>
<p><img src="https://i.imgur.com/zXCNOoe.png" alt=""></p>
<h2 id="设备分配"><a href="#设备分配" class="headerlink" title="设备分配"></a>设备分配</h2><p>包括对设备，设备控制器和通道的分配</p>
<p><img src="https://i.imgur.com/bbGgNk1.png" alt=""></p>
<p><img src="https://i.imgur.com/vS9hByz.png" alt=""></p>
<h3 id="设备分配应考虑的若干因素"><a href="#设备分配应考虑的若干因素" class="headerlink" title="设备分配应考虑的若干因素"></a>设备分配应考虑的若干因素</h3><ul>
<li>设备的固有属性：共享+虚拟，独享</li>
<li>分配算法：FIFO，优先权</li>
<li>安全性</li>
</ul>
<h3 id="设备独立性"><a href="#设备独立性" class="headerlink" title="设备独立性"></a>设备独立性</h3><p>即设备无关性，指<strong>应用程序独立于具体使用的物理设备</strong></p>
<p>设备可以分为逻辑设备和物理设备，逻辑设备名到物理设备名的映射由逻辑设备表LUT实现</p>
<p><img src="https://i.imgur.com/Fg9ojdp.png" alt=""></p>
<p>分配流程：进程给出逻辑名——通过LUT得到物理设备及其driver入口</p>
<p>优点是设备分配更灵活，可以是多对多的映射关系，提供均衡性于容错性，提高共享性，易于实现I/O重定向（改变LUT表即可）</p>
<h4 id="设备独立性软件"><a href="#设备独立性软件" class="headerlink" title="设备独立性软件"></a>设备独立性软件</h4><p>设备独立性软件执行所有设备的公有操作，如分配回收，名字映射，保护，缓冲，差错控制等，并向用户层软件提供统一接口如read，write</p>
<h3 id="SPOOLING技术"><a href="#SPOOLING技术" class="headerlink" title="SPOOLING技术"></a>SPOOLING技术</h3><p>为了缓和CPU高速性和I/O设备低速性的矛盾，引入脱机输入，脱机输出技术，利用专门的外围控制机，将低速I/O设备上的数据，传送到高速磁盘上，或者相反。当系统引入多道程序技术后，完全可以利用其中一道程序来模拟脱机输入时外围控制机的功能，把低速I/O设备上的数据传送到高速磁盘上，再用另一道程序，模拟脱机输出时外围控制器的功能，将数据从磁盘传送到低速输出设备上，这样便可在主机的直接控制下，实现以前的脱机输入，脱机输出的功能，此时外围操作与CPU对数据的处理同时进行，我们把这种联机情况下实现的同时外围操作的技术，称为SPOOLing技术（Simultaneous Periphernal Operating Online）或称为假脱机技术</p>
<p><img src="https://i.imgur.com/gc7ms1O.png" alt=""></p>
<p>SPOOLing提供了I/O速度，将独占设备改造为共享设备，实现了虚拟设备的功能</p>
<h2 id="设备处理"><a href="#设备处理" class="headerlink" title="设备处理"></a>设备处理</h2><p>设备驱动程序的功能：</p>
<ul>
<li>接收I/O进程发来的命令和参数，将命令中的抽象要求转换为具体要求</li>
<li>检查用于I/O请求的合法性</li>
<li>发出I/O命令</li>
<li>及时响应由控制器或通道发来的中断请求，并根据中断类型调用相应的中断处理程序处理</li>
<li>自动构成通道程序</li>
</ul>
<h3 id="设备处理方式"><a href="#设备处理方式" class="headerlink" title="设备处理方式"></a>设备处理方式</h3><ul>
<li>为每一类设备设置一个进程，专门用于执行这类设备的I/O操作</li>
<li>整个系统设置一个I/O进程，用于执行系统中所有各类设备的I/O操作</li>
<li>不设置专门的设备处理进程，而为各类设备设置相应的设备处理程序，供用户或系统进程调用</li>
</ul>
<h2 id="磁盘存储器管理"><a href="#磁盘存储器管理" class="headerlink" title="磁盘存储器管理"></a>磁盘存储器管理</h2><p><img src="https://i.imgur.com/dhsseTC.png" alt=""></p>
<h3 id="磁盘的类型"><a href="#磁盘的类型" class="headerlink" title="磁盘的类型"></a>磁盘的类型</h3><ul>
<li>固定头磁盘：每条磁道上都有一读/写磁头，所有磁头都被装在刚性磁臂中，通过这些磁头可访问所有磁道，并进行并行读/写，有效提高I/O速度</li>
<li>移动头磁盘：每一个盘面仅配一个磁头，也被装入磁臂中，该磁头能移动进行寻道，仅能串行方式读/写，I/O速度慢</li>
</ul>
<h3 id="磁盘访问时间"><a href="#磁盘访问时间" class="headerlink" title="磁盘访问时间"></a>磁盘访问时间</h3><ol>
<li>寻道时间Ts：磁臂（磁头）移动到指定磁道上所经历的时间，是启动磁臂时间s与磁头移动n条磁道所花费时间之和，Ts=m*n+s，m是常数，与磁盘驱动器速度有关</li>
<li>旋转延迟时间Tτ：扇区移动到磁头下面所经历的时间</li>
<li>传输时间Tt：把数据从磁盘读出或向磁盘写入数据所经历的时间Tt=b/rN，b是每次读/写的字节数，r是磁盘每秒转数，N是一条磁道上的字节数</li>
</ol>
<p>当一次读/写的字节数相当于半条磁道上的字节数时，Tt与Tτ相同，可将访问时间Ta表示为Ta=Ts+1/2r+b/rN</p>
<h3 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h3><h4 id="先来先服务FCFS"><a href="#先来先服务FCFS" class="headerlink" title="先来先服务FCFS"></a>先来先服务FCFS</h4><p>根据进程请求访问磁盘的先后次序调度</p>
<p><img src="https://i.imgur.com/SY51mcT.png" alt=""></p>
<h4 id="最短寻道时间优先SSTF"><a href="#最短寻道时间优先SSTF" class="headerlink" title="最短寻道时间优先SSTF"></a>最短寻道时间优先SSTF</h4><p>该算法选择这样的进程，要求访问的磁道与当前磁头所在的磁道距离最近</p>
<p><img src="https://i.imgur.com/is87d8q.png" alt=""></p>
<h4 id="扫描算法SCAN"><a href="#扫描算法SCAN" class="headerlink" title="扫描算法SCAN"></a>扫描算法SCAN</h4><p>SSTF实质是基于优先级的调度算法，可能会导致低优先级进程饥饿现象，因为只要不断有新进程请求到达，且所访问的磁道与磁头距离较近，则较远的进程饥饿，扫描算法不仅考虑访问磁道与当前磁道的距离，更优先考虑磁头当前的移动方向，例如当磁头自里向外移动，SCAN算法考虑的是当前磁道之外的，又是距离最近的，直到再无更外的磁道需要访问，就将磁臂换向改为自外向里，跟电梯运行很像，又称为电梯调度算法</p>
<p><img src="https://i.imgur.com/gdZ27V8.png" alt=""></p>
<h3 id="磁盘高速缓存"><a href="#磁盘高速缓存" class="headerlink" title="磁盘高速缓存"></a>磁盘高速缓存</h3><p>利用内存中的存储空间，来暂存从磁盘中读出的一系列盘块中的信息<br>高速缓存逻辑上属于磁盘，物理上是内存<br>高速缓存在内存中分为两种：第一种是内存中开辟单独的存储空间来作为磁盘高速缓存，大小是固定的，不会受应用程序多少的影响，第二种是把所有未利用的内存空间变为一个缓冲池，供请求分页系统和磁盘I/O（作为磁盘高速缓存）共享</p>
<h4 id="数据交付方式"><a href="#数据交付方式" class="headerlink" title="数据交付方式"></a>数据交付方式</h4><p>系统可以采取两种方式，将数据交付给请求进程</p>
<ul>
<li>数据交付：直接将高速缓存中的数据传送到请求者进程的内存工作区中</li>
<li>指针交付：只将指向高速缓存中某区域的指针交付给请求者进程</li>
</ul>
<h4 id="置换算法"><a href="#置换算法" class="headerlink" title="置换算法"></a>置换算法</h4><p>高速缓存的置换算法和请求分页系统有些区别，除了考虑最近最久未使用这一原则外，还考虑了访问频率，可预见性和数据的一致性</p>
<h4 id="周期性写回磁盘"><a href="#周期性写回磁盘" class="headerlink" title="周期性写回磁盘"></a>周期性写回磁盘</h4><p>UNIX系统专门增设一个修改程序，该程序周期性调用一个系统调用SYNC，主要功能是强制性将所有高速缓存中已修改的盘块数据写回磁盘，一般两次SYNC间隔30s</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="MakaLoo" />
            
              <p class="site-author-name" itemprop="name">MakaLoo</p>
              <p class="site-description motion-element" itemprop="description">Beautifully struggle every day</p>
          </div>

          <nav class="site-state motion-element">
		  
		  

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">69</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">165</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/makloao" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://www.zhihu.com/people/makaloo" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-globe"></i>知乎</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:xiehongjian1997@outlook.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-globe"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MakaLoo</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
      <div id="needsharebutton-float">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("oE3JvjxaL9UMPCdKOwyY8BNP-gzGzoHsz", "0mpd8MSRyvkSyuoF6lMMy84W");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">

  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>

  <script>
    
      pbOptions = {};
      
          pbOptions.iconStyle = "box";
      
          pbOptions.boxForm = "horizontal";
      
          pbOptions.position = "bottomCenter";
      
          pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
      flOptions = {};
      
          flOptions.iconStyle = "box";
      
          flOptions.boxForm = "horizontal";
      
          flOptions.position = "middleRight";
      
          flOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-float', flOptions);
    
  </script>

  

  

  

  

</body>
</html>
