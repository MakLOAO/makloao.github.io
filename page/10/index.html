<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Beautifully struggle every day">
<meta property="og:type" content="website">
<meta property="og:title" content="MakaL-0-">
<meta property="og:url" content="http://yoursite.com/page/10/index.html">
<meta property="og:site_name" content="MakaL-0-">
<meta property="og:description" content="Beautifully struggle every day">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MakaL-0-">
<meta name="twitter:description" content="Beautifully struggle every day">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/10/"/>





  <title>MakaL-0-</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-120154502-1', 'auto');
  ga('send', 'pageview');
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?f15c3fa6d339dfe768bc3d4f2e2f856e";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">MakaL-0-</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">加载图片需要翻出去</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/11/磁盘存储器的管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MakaLoo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MakaL-0-">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/11/磁盘存储器的管理/" itemprop="url">磁盘存储器的管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-11T20:32:01+08:00">
                2019-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/05/11/磁盘存储器的管理/" class="leancloud_visitors" data-flag-title="磁盘存储器的管理">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="磁盘存储器的管理"><a href="#磁盘存储器的管理" class="headerlink" title="磁盘存储器的管理"></a>磁盘存储器的管理</h1><p>磁盘存储器管理的单位是盘块</p>
<h2 id="外存的组织方式"><a href="#外存的组织方式" class="headerlink" title="外存的组织方式"></a>外存的组织方式</h2><p>文件的物理结构直接与外存的组织方式有关，不同的外存组织方式形成不同的文件物理结构</p>
<ul>
<li>连续组织方式：为每个文件分配连续的磁盘空间</li>
<li>链接组织方式：为每个文件分配不连续的磁盘空间，通过链接指针将文件的所有盘块链接在一起</li>
<li>索引组织方式</li>
</ul>
<h3 id="连续组织方式"><a href="#连续组织方式" class="headerlink" title="连续组织方式"></a>连续组织方式</h3><p>特点：</p>
<ul>
<li>顺序访问容易，速度快（磁头移动距离小）</li>
<li>要求连续空间，一段时间后要整理磁盘消除碎片</li>
<li>必须事先知道长度，文件不易动态增长和删除</li>
</ul>
<p>文件对应目录项包含：始址，总块数，最后一块字节数</p>
<h3 id="链接组织方式"><a href="#链接组织方式" class="headerlink" title="链接组织方式"></a>链接组织方式</h3><p>特点：</p>
<ul>
<li>消除磁盘外部碎片，提高外存利用率</li>
<li>对插入，删除和修改记录容易</li>
<li>适应文件的动态增长，无需事先知道文件大小</li>
<li>只能顺序存取</li>
</ul>
<h4 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a>隐式链接</h4><p>文件目录的每个目录项都含有指向链接文件第一个盘块和最后一个盘块的指针，只适用于顺序访问，随机访问效率低</p>
<p>簇：包含多个块的单位，盘块分配时以簇为单位，可以成倍减小查找指定块的时间，增大内部碎片</p>
<h4 id="显示链接"><a href="#显示链接" class="headerlink" title="显示链接"></a>显示链接</h4><p>把用于链接文件各物理块的指针显式地存放在内存的一张链接表中，该表在整个磁盘只设置一张</p>
<p><img src="https://i.imgur.com/r2Cpho8.png" alt=""></p>
<p>表的序号是物理块号，在每个表项中存放链接指针，即下一个盘块号，凡是属于某一文件的第一个盘块号，均作为文件地址被填入相应FCB的物理地址字段，查找是在内存进行的所以速度提升且减少磁盘访问次数，该表称为文件分配表FAT</p>
<h3 id="索引组织方式"><a href="#索引组织方式" class="headerlink" title="索引组织方式"></a>索引组织方式</h3><p>打开某个文件时，只要把该文件占用的索引块号读入内存即可，无需把FAT调入内存，索引的优点是支持直接访问，当要读第i块盘块时，直接从该文件的索引块中找到该盘块号</p>
<p>单级索引：为每个文件分配一个索引块，文件较大时有利，较小时浪费外存空间，文件较大时索引块较多，需要建立多级索引</p>
<p>多级索引如下</p>
<p><img src="https://i.imgur.com/axLLInx.png" alt=""></p>
<h3 id="混合分配方式"><a href="#混合分配方式" class="headerlink" title="混合分配方式"></a>混合分配方式</h3><p>UNIX采用混合分配方式，一，二，多级索引合用</p>
<p><img src="https://i.imgur.com/823nqH9.png" alt=""></p>
<p>i.addr(0)——i.addr(9)存放直接地址，i.addr(10)存放一次间接地址，i.addr(11)存放二次间接地址</p>
<h3 id="文件组织策略"><a href="#文件组织策略" class="headerlink" title="文件组织策略"></a>文件组织策略</h3><ul>
<li>文件访问通常是顺序，文件较小，用连续分配</li>
<li>文件较大顺序访问，链接结构</li>
<li>文件较大随机访问，索引结构</li>
</ul>
<h3 id="分配策略的小习题"><a href="#分配策略的小习题" class="headerlink" title="分配策略的小习题"></a>分配策略的小习题</h3><p><img src="https://i.imgur.com/GJLObbI.png" alt=""></p>
<p><img src="https://i.imgur.com/MvlYqVV.png" alt=""></p>
<h2 id="文件存储空间的管理"><a href="#文件存储空间的管理" class="headerlink" title="文件存储空间的管理"></a>文件存储空间的管理</h2><p>设置一个磁盘分配表，用于记住可供分配的存储空间情况，还应提供对盘块分配和回收的手段，存储空间基本分配单位都是磁盘块而非字节</p>
<h3 id="空闲表法"><a href="#空闲表法" class="headerlink" title="空闲表法"></a>空闲表法</h3><p>空闲表属于连续分配方式，为每个文件分配一块连续的存储空间，即系统为外存上的所有空闲区建立一张空闲表，每个空闲区对应一个空闲表项，包括表项序号，第一个盘块号，空闲盘块数等信息</p>
<p><img src="https://i.imgur.com/hh96knJ.png" alt=""></p>
<h3 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a>空闲链表法</h3><h4 id="空闲盘块链"><a href="#空闲盘块链" class="headerlink" title="空闲盘块链"></a>空闲盘块链</h4><p>将所有空闲空间以盘块为单位拉成一条链，工作效率低</p>
<h4 id="空闲盘区链"><a href="#空闲盘区链" class="headerlink" title="空闲盘区链"></a>空闲盘区链</h4><p>将磁盘所有空闲盘区拉成一条链，每个盘区包含若干个盘块，要有指明本盘块大小的信息</p>
<h3 id="位示图法"><a href="#位示图法" class="headerlink" title="位示图法"></a>位示图法</h3><p>利用二进制的一位来表示磁盘一个盘块的使用情况，0为盘块空闲，1为已分配</p>
<p><img src="https://i.imgur.com/betahpN.png" alt=""></p>
<p><img src="https://i.imgur.com/dU7Bpaj.png" alt=""></p>
<h4 id="位示图法盘块的分配"><a href="#位示图法盘块的分配" class="headerlink" title="位示图法盘块的分配"></a>位示图法盘块的分配</h4><ol>
<li>顺序扫描位示图，找出一个或一组值为0的二进制位</li>
<li>将找到的一个或一组二进制位转换位盘块号，假定找到值为0的二进制位位于位示图第i行j列，则盘块号按下式计算：b=n(i-1)+j</li>
<li>修改位示图，令map[i,j]=1</li>
</ol>
<h4 id="位示图的回收"><a href="#位示图的回收" class="headerlink" title="位示图的回收"></a>位示图的回收</h4><ol>
<li>将回收盘块号转换为位示图的行号列号i=(b-1)DIVn+1,j=(b-1)MODn+1</li>
<li>修改位示图，令map[i,j]=0</li>
</ol>
<h3 id="成组链接法"><a href="#成组链接法" class="headerlink" title="成组链接法"></a>成组链接法</h3><p>UNIX采用的方法</p>
<p>基本思想（汤书P281解释更详细）</p>
<ul>
<li>空闲盘块号栈存放当前可用的一组空闲盘块号及栈中尚有的空闲盘块号数，唯一存在于内存的栈</li>
<li>文件区的所有空闲盘块分为若干组</li>
<li>每一组含有盘块总数和所有的盘块号记入前一组最后一个盘块中</li>
<li>第一组盘块总数和所有盘块号记入空闲盘块号栈</li>
<li>最末一组只有N-1各盘块</li>
</ul>
<p><img src="https://i.imgur.com/ooa2j7G.png" alt=""></p>
<p>S.free(0)是栈底</p>
<h4 id="空闲盘块分配"><a href="#空闲盘块分配" class="headerlink" title="空闲盘块分配"></a>空闲盘块分配</h4><p>首先检查空闲盘块号栈是否上锁，如未上锁，便从<strong>栈顶</strong>取出一空闲盘块号，将与之对应的盘块分配给用户，然后将栈顶指针下移一格<br>若该盘块号已是栈底，即S.free(0)，即最后一个可分配的盘块号。 须调用磁盘读过程，将栈底盘块号所对应盘块的内容读入栈中，作为新的空闲盘块号栈的内容，然后，把原栈底对应的盘块分配出去(其中的有用数据已读入栈中)</p>
<h4 id="空闲盘块的回收"><a href="#空闲盘块的回收" class="headerlink" title="空闲盘块的回收"></a>空闲盘块的回收</h4><p>将回收盘块的盘块号记入空闲盘块号栈的顶部，并执行空闲盘块数加1操作。<br>当栈中空闲盘块号数目已达100时，表示栈已满，便将现有栈中的100个盘块号，记入新回收的盘块中，再将其盘块号作为新栈底</p>
<h2 id="提高磁盘I-O速度的途径"><a href="#提高磁盘I-O速度的途径" class="headerlink" title="提高磁盘I/O速度的途径"></a>提高磁盘I/O速度的途径</h2><ul>
<li>磁盘高速缓存（数据交付，置换算法，周期性写回磁盘）</li>
<li>提前读</li>
<li>延迟写</li>
<li>优化物理块布局</li>
<li>虚拟盘</li>
</ul>
<h2 id="数据一致性控制"><a href="#数据一致性控制" class="headerlink" title="数据一致性控制"></a>数据一致性控制</h2><p>事务：用于访问和修改各种数据项的一个程序单位，可以看作一系列相关的读写操作，被访问的数据可以分散地存放在同一文件的不同记录中，也可放在多个文件中。只有对分布在不同位置的同一数据所进行的读和写(含修改)操作全部完成时，才能再以托付操作(Commit Operation)来终止事务。只要有一个读、写或修改操作失败，便须执行夭折操作(Abort Operation)。读或写操作的失败可能是由于逻辑错误，也可能是系统故障所导致的</p>
<h3 id="事务记录"><a href="#事务记录" class="headerlink" title="事务记录"></a>事务记录</h3><ul>
<li>事务名：用于标识该事务的惟一名字</li>
<li>数据项名：它是被修改数据项的惟一名字</li>
<li>旧值：修改前数据项的值</li>
<li>新值：修改后数据项将具有的值</li>
</ul>
<h3 id="恢复算法"><a href="#恢复算法" class="headerlink" title="恢复算法"></a>恢复算法</h3><p>undo<ti>，把所有被事务Ti修改过的数据恢复修改前的值<br>redo<ti>，把所有被事务Ti修改过的数据设置为新值</ti></ti></p>
<h3 id="检查点"><a href="#检查点" class="headerlink" title="检查点"></a>检查点</h3><p>作用：使对事务记录表中事务记录的清理工作经常化</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/11/文件管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MakaLoo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MakaL-0-">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/11/文件管理/" itemprop="url">文件管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-11T20:32:01+08:00">
                2019-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/05/11/文件管理/" class="leancloud_visitors" data-flag-title="文件管理">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><h2 id="文件的相关基本概念"><a href="#文件的相关基本概念" class="headerlink" title="文件的相关基本概念"></a>文件的相关基本概念</h2><p>数据项：文件系统中最低级的数据组织形式，分为基本数据项和组合数据项，<strong>基本数据项用于描述一个对象的某种属性的字符集</strong>，是可命名的最小逻辑数据单位，又称为字段，例如，用于描述学生的基本数据项有：学号，姓名等；组合数据项是若干基本数据项的组成；数据项还应有数据类型</p>
<p>记录：<strong>记录是一组相关数据项的集合，用于描述一个对象在某方面的属性</strong>，一个记录应包含哪些数据项取决于需要描述对象的哪个方面。例如，一个学生，当把他作为班上一个学生时，对他的描述为学号，姓名，年龄，所在系班，若把学生当作医疗对象则不同。<strong>唯一标识记录的数据项是关键字</strong></p>
<p>文件：<strong>文件是由创建者所定义的，具有文件名的一组相关元素的集合</strong>，分为有结构文件和无结构文件，<strong>有结构文件中，文件由若干个相关记录组成，而无结构文件被看成是一个字符流</strong>，文件在文件系统是一个最大的数据单位，它描述了一个对象集，例如可以将一个班的学生记录作为一个文件</p>
<p>文件属性可以包括：文件类型，文件长度，文件的物理位置，文件的建立时间（最后一次的修改时间等）</p>
<h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>文件类型按用途分类可分为系统文件，用户文件和库文件<br>按文件中数据的形式分类可分为源文件，目标文件和可执行文件<br>按存取控制属性分类可分为只执行文件，只读文件，读写文件<br>按组织形式和处理方式分类可分为普通文件，目录文件和特殊文件</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>文件系统的模型是指文件和对文件进行操纵和管理的软件集合</p>
<p>分为三层：对象及属性，对文件进行操纵和管理的软件集合，文件系统接口</p>
<p><img src="https://i.imgur.com/T92HXjD.png" alt=""></p>
<h3 id="对象及其属性层"><a href="#对象及其属性层" class="headerlink" title="对象及其属性层"></a>对象及其属性层</h3><p>文件管理系统管理的对象如下：</p>
<ul>
<li>文件</li>
<li>目录</li>
<li>磁盘存储空间</li>
</ul>
<h3 id="对对象操纵和管理的软件集合层"><a href="#对对象操纵和管理的软件集合层" class="headerlink" title="对对象操纵和管理的软件集合层"></a>对对象操纵和管理的软件集合层</h3><p>该层是文件管理系统的核心部分，文件系统的功能大多是这一层实现，其中包括对文件存储空间的管理，对文件目录的管理，用于将文件的逻辑地址转换为物理地址的机制，对文件的读写管理，对文件的共享保护等功能</p>
<p>一般把与文件系统有关的软件分为4个层次：</p>
<ul>
<li>I/O控制层：磁盘驱动程序等组成</li>
<li>基本文件系统层：内存与磁盘之间数据块的交换</li>
<li>基本I/O管理程序：完成与磁盘I/O有关的事务，如文件逻辑块号转换为物理块号等</li>
<li>逻辑文件系统：用于处理与记录和文件相关的操作，如允许用户使用符号文件名访问文件及记录等</li>
</ul>
<h3 id="文件系统接口"><a href="#文件系统接口" class="headerlink" title="文件系统接口"></a>文件系统接口</h3><p>文件系统提供了命令接口和程序接口</p>
<h2 id="文件逻辑结构"><a href="#文件逻辑结构" class="headerlink" title="文件逻辑结构"></a>文件逻辑结构</h2><p>文件的逻辑结构是从用户观点出发所观察到的文件组织形式，即文件是由一系列逻辑记录组成的，是用户可以直接处理的数据及其结构，独立于文件的物理特性，又称为文件组织</p>
<p>文件的物理结构又称为文件的存储结构，是指系统将文件存储在外存上所形成的一种存储组织形式，用户是不能看见的</p>
<p>物理结构和逻辑结构都会影响对文件的检索速度</p>
<p>下图是文件结构类型的概述</p>
<p><img src="https://i.imgur.com/M9LFero.png" alt=""></p>
<h3 id="逻辑结构的类型"><a href="#逻辑结构的类型" class="headerlink" title="逻辑结构的类型"></a>逻辑结构的类型</h3><p>文件按有无结构分为有结构文件和无结构文件</p>
<p>有结构文件根据记录长度分为定长和不定长两类，定长指文件的所有记录长度都是相同的，所有记录的各数据项都处在记录中相同的位置，具有相同的顺序和长度，定长记录有效提高检索记录的速度和效率，方便对文件处理和修改，文件长度用记录数目来表示；变长记录指文件中各记录长度不相同</p>
<p>有结构文件按文件组织方式分为</p>
<ul>
<li>顺序文件：由一系列记录按某种顺序排列形成的文件，记录通常是定长记录（变长记录查询速度慢，不支持随机访问和删除插入记录）</li>
<li>索引文件：可变长记录文件建立一张索引表，为每个记录设置一个表项，加速对记录的检索</li>
<li>索引顺序文件：顺序文件和索引文件的结合，在为每个文件建立一张索引表时，并不是为每个记录建立索引表项，而是为一组记录中的第一个记录建立一个索引表项</li>
</ul>
<p>无结构文件是流式文件，信息管理系统和数据库系统中广泛采用了有结构的文件形式，而源程序，可执行文件，库函数等采用的就是无结构文件，长度是以字节为单位，可以把流式文件看作记录式文件的一个特例：一个记录仅有一个字节</p>
<h4 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h4><p>顺序文件可以按照串结构或顺序结构排列，串结构指按存入时间的先后进行排序，各记录之间的顺序与关键字无关，对串结构文件检索比较费时，顺序结构是由用户指定一个字段作为关键字，文件中所有记录可以按关键字排序，具有更高的检索速度</p>
<h4 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h4><p>为变长记录建立一个索引表，对主文件的每个记录在索引表中设有一个相应表项，用于记录该记录的长度L，以及指向该记录的指针</p>
<p><img src="https://i.imgur.com/UDTyQoQ.png" alt=""></p>
<p>索引文件是可以实现直接存取的，索引文件支持随机访问</p>
<h4 id="索引顺序文件"><a href="#索引顺序文件" class="headerlink" title="索引顺序文件"></a>索引顺序文件</h4><p>索引顺序文件保留了顺序文件的关键字顺序，又增加了文件索引表和溢出文件，溢出文件用来记录新增加的，删除的和修改的记录</p>
<h5 id="一级索引顺序文件"><a href="#一级索引顺序文件" class="headerlink" title="一级索引顺序文件"></a>一级索引顺序文件</h5><p>将变长记录顺序文件的所有记录分为若干组，为顺序文件建立一张索引表，并为每组的第一个记录，在索引表建立一个索引项，其中包含该记录的关键字和指向该记录的指针</p>
<p>对索引顺序文件检索时，先利用提供的关键字以及某种查找算法去检索索引表，找到该记录所在记录组第一个记录的表项，从中得到该记录组第一个记录在主文件的位置，然后再利用顺序查找法去查找主文件，从中找到所要求的记录</p>
<h4 id="直接文件和哈希文件"><a href="#直接文件和哈希文件" class="headerlink" title="直接文件和哈希文件"></a>直接文件和哈希文件</h4><h5 id="直接文件"><a href="#直接文件" class="headerlink" title="直接文件"></a>直接文件</h5><p>直接文件可以根据给定的关键字直接获得记录的物理地址，即关键字本身就决定了记录的物理地址，由关键字到记录物理地址的转换称为键值转换，而上述的索引文件实质是对关键字计算得到对应索引表表项的物理地址，由该物理地址得到指向对应记录的指针</p>
<h5 id="哈希文件"><a href="#哈希文件" class="headerlink" title="哈希文件"></a>哈希文件</h5><p>利用哈希函数将关键字转换为相应记录的地址</p>
<h3 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h3><p>物理结构是从实现的观点出发，文件在外存上的存放组织形式，有如下三种物理结构</p>
<ul>
<li>连续结构</li>
<li>链接结构</li>
<li>索引结构</li>
</ul>
<h2 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h2><p>对目录管理的要求</p>
<ul>
<li><strong>实现”按名存取”</strong>：用户只须向系统提供所需访问的文件的名字，便能快速准确地找到指定文件在外存地存储位置，这是目录管理最基本地功能</li>
<li>提高对目录的检索速度</li>
<li>文件共享：允许多个用户共享一个文件，这样只须在外存中保留一份该文件副本供不同用户使用，节省存储空间，提高利用率</li>
<li>允许文件重名：允许不同用户对不同文件采取相同的名字</li>
</ul>
<h3 id="文件控制块FCB"><a href="#文件控制块FCB" class="headerlink" title="文件控制块FCB"></a>文件控制块FCB</h3><p>文件目录：文件控制块的有序集合，即一个文件控制块就是一个文件目录项，通常一个文件目录被看成是一个文件，称为目录文件</p>
<p>文件控制块：描述和控制文件的数据结构，文件与文件控制块一一对应，一个文件控制块就是一个文件目录项（文件目录是文件控制块的有序集合），包含基本信息，存取控制信息和使用信息，可以分为内存FCB和外存FCB</p>
<p>它们的关系：文件控制块与文件一一对应，而文件目录是有结构文件，其中的每一个记录都是一个文件控制块</p>
<p>检索过程：检索的时候，把文件目录调入内存，查找其目录项，找到与给定的文件名对应的文件名，读出其物理地址</p>
<h4 id="基本信息类"><a href="#基本信息类" class="headerlink" title="基本信息类"></a>基本信息类</h4><ul>
<li>文件名</li>
<li>文件物理位置</li>
<li>文件逻辑结构：流式还是有结构，记录数，定长记录还是变长记录等</li>
<li>文件物理结构：顺序还是链接还是索引</li>
</ul>
<h4 id="存取控制信息类"><a href="#存取控制信息类" class="headerlink" title="存取控制信息类"></a>存取控制信息类</h4><p>文件主，核准用户和一般用户的存取权限</p>
<h4 id="使用信息类"><a href="#使用信息类" class="headerlink" title="使用信息类"></a>使用信息类</h4><ul>
<li>文件建立日期和时间</li>
<li>上一次修改的日期和时间</li>
<li>当前使用信息（已打开文件的进程数，是否被锁等等）</li>
</ul>
<h3 id="索引结点"><a href="#索引结点" class="headerlink" title="索引结点"></a>索引结点</h3><p>OS中每有一个目录，就有一个FCB</p>
<p>引入：文件目录占空间，检索目录文件过程中，要把存放目录文件的第一个盘块中的目录的调入内存，然后将用户所给定的文件名与目录项的文件名一一对应，若没有找到指定文件，还需要将下一盘块的目录项调入内存。检索过程中，只用到了文件名，而没有其他描述文件的信息，仅当找到一个目录项（即其中文件名与指定要查找的文件名相匹配）时，才需从该目录项中读出该文件的物理地址，而其他一些对该文件进行描述的信息在检索目录时一概不用。显然这些信息在检索目录的时候不需要调入内存，为此，采用把文件名与文件描述信息分开的方法，即使<strong>文件描述信息单独形成一个称为索引结点的数据结构</strong></p>
<p>引入后，文件目录项就不是FCB了，而是文件名+索引结点，这样可以使每个盘块可以存更多的文件目录项，减少盘块数，从而减少盘块调入内存的次数</p>
<p><img src="https://i.imgur.com/bUvbRVo.png" alt=""></p>
<p>引入索引结点前的文件目录项（FCB）</p>
<p><img src="https://i.imgur.com/31IywfE.png" alt=""></p>
<p>引入索引结点后的文件目录项（文件名+索引结点）</p>
<p>例如上图，在没有引入索引结点的时候，FCB是上图一所示，每次检索目录的时候都要把FCB调入内存，而FCB又占用比较大的空间，这样系统开销会很多，采用了上图二的文件目录项后，一个目录项只占用很小的开销（UNIX为16个字节，14字节文件名，2字节为i结点指针），可以减少磁盘启动次数，节省系统开销</p>
<h4 id="我对索引结点减少磁盘启动次数的理解"><a href="#我对索引结点减少磁盘启动次数的理解" class="headerlink" title="我对索引结点减少磁盘启动次数的理解"></a>我对索引结点减少磁盘启动次数的理解</h4><p>前提：目录文件所占盘块数为N，则检索该文件目录时平均调入盘块次数为(N+1)/2次，检索一个文件要从第一个文件目录开始检索，直到最后一个文件目录</p>
<p>引入索引结点可以减少磁盘启动次数，节省系统开销，主要原因是调入内存是以盘块为单位和引入索引结点后文件目录项的大小比FCB的大小要小</p>
<p>e.g.在文件系统中，每个盘块为256字节，文件控制块占64个字节，其中文件名占8个字节。如果索引节点编号占2个字节，对一个存放在磁盘上的128个目录项的目录，试比较引入索引节点前后，为找到其中一个文件，平均启动磁盘的次数</p>
<p>在引入索引结点前，每个目录项中存放的是对应文件的FCB，故128个目录项的目录总共需要占用128X64／256=32个盘块。因此，在该目录中检索到一个文件，平均启动磁盘的次数为(1+32)/2=16.5次。<br>引入索引结点后，每个目录项中只需存放文件名和索引结点的编号，因此128个目录项的目录总共需要占用128X(8+2)／256=5个盘块。因此，找到匹配的目录项平均需要启动(1+5)／2，即3次磁盘；而得到索引结点编号后，还需启动磁盘将对应文件的索引结点读入内存，故平均需要启动磁盘4次。可见，引入索引结点后，可大大减少启动磁盘的次数，从而有效地提高检索文件的速度。</p>
<h4 id="引入索引结点后的索引过程"><a href="#引入索引结点后的索引过程" class="headerlink" title="引入索引结点后的索引过程"></a>引入索引结点后的索引过程</h4><ol>
<li>文件目标项只存放文件名和结点号，结点号存放FCB信息</li>
<li>查询只调入文件名部分和结点指针，找到后才调入对应i结点指向的内容</li>
</ol>
<h4 id="磁盘索引结点"><a href="#磁盘索引结点" class="headerlink" title="磁盘索引结点"></a>磁盘索引结点</h4><p>存放在磁盘的索引结点，每个文件有唯一的磁盘索引结点，包括如下内容：</p>
<ul>
<li>文件主标识</li>
<li>文件类型（正规文件，目录文件，特殊文件）</li>
<li>文件存取权限</li>
<li>文件物理地址</li>
<li>文件长度</li>
<li>文件连接计数（本文件系统所有指向该文件名的指针计数，用于共享）</li>
<li>文件存取时间</li>
</ul>
<h4 id="内存索引结点"><a href="#内存索引结点" class="headerlink" title="内存索引结点"></a>内存索引结点</h4><p>存放在内存中的索引结点，当文件被打开时，要将磁盘索引结点拷贝到内存的索引结点中方便以后使用，增加了以下内容</p>
<ul>
<li>索引结点编号</li>
<li>状态</li>
<li>访问计数</li>
<li>文件所属文件系统的逻辑设备号</li>
<li>链接指针</li>
</ul>
<h3 id="单级目录结构"><a href="#单级目录结构" class="headerlink" title="单级目录结构"></a>单级目录结构</h3><p>最简单的文件目录，在整个文件系统中只建立一张目录表，每个文件占一个目录项，目录项含文件名，文件扩展名，文件长度，文件类型，文件物理地址以及其他文件属性，状态位（是否空闲）</p>
<p><img src="https://i.imgur.com/1cziASy.png" alt=""></p>
<p>单级目录结构不允许重名，新建文件时要检查有无同名，删除时回收块并清楚占用目录项</p>
<h3 id="两级目录结构"><a href="#两级目录结构" class="headerlink" title="两级目录结构"></a>两级目录结构</h3><p><img src="https://i.imgur.com/JKxqy9C.png" alt=""></p>
<p>可以为每个用户再建立一个单独的用户文件目录UFD，这些文件目录由用户所有文件的文件控制块组成，在系统中再建立一个主文件目录MFD，MFD的每个目录项为用户的目录文件</p>
<p>两级目录结构允许重名，但不允许用户建立自己的子目录</p>
<h3 id="树形结构目录"><a href="#树形结构目录" class="headerlink" title="树形结构目录"></a>树形结构目录</h3><p>一个目录文件中目录项可以为目录文件和数据文件，允许重名，便于实现文件共享</p>
<p><img src="https://i.imgur.com/8nlH5dR.png" alt=""></p>
<h3 id="目录查询技术"><a href="#目录查询技术" class="headerlink" title="目录查询技术"></a>目录查询技术</h3><p>当用户要访问一个已经存在的文件时，系统首先利用用户提供的文件名对目录进行查询，找出该文件的FCB或对应索引结点，然后根据FCB或索引结点中记录的文件物理地址（盘块号），换算出文件在磁盘上的物理地址，最后再通过磁盘驱动程序将所需文件读入内存</p>
<p>常用的目录查询方式为线性检索法和Hash方法</p>
<h4 id="线性检索法"><a href="#线性检索法" class="headerlink" title="线性检索法"></a>线性检索法</h4><p><img src="https://i.imgur.com/aoT42vI.png" alt=""></p>
<p>查找过程如下：</p>
<ol>
<li>系统先读入第一个文件分量名usr，用它与根目录文件中各目录项的文件名顺序的进行比较，找到匹配者，并得到索引结点号，再从索引结点号得知物理地址号（盘块号），将该盘块132号读入内存</li>
<li>系统再将路径名第二个分量ast读入，与存放在132号盘块的第二级目录文件各目录项的文件名顺序比较，以此类推直到找到mbox的索引结点和物理地址</li>
</ol>
<p><img src="https://i.imgur.com/jr8fDTP.png" alt=""></p>
<h4 id="Hash方法"><a href="#Hash方法" class="headerlink" title="Hash方法"></a>Hash方法</h4><p>建立一张Hash索引文件目录，利用Hash方法查询，系统利用文件名变换为文件目录的索引值，再利用该索引值到目录去查找</p>
<h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><p>两种共享方式：用户直接通过路径名来访问共享文件和对需要共享的文件进行链接</p>
<h2 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h2><ul>
<li>存取控制机制防止人为因素造成文件不安全</li>
<li>磁盘容错技术防止磁盘故障造成文件不安全</li>
<li>后备系统防止自然因素造成的不安全性</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/10/设备管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MakaLoo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MakaL-0-">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/10/设备管理/" itemprop="url">设备管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-10T22:38:01+08:00">
                2019-05-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/05/10/设备管理/" class="leancloud_visitors" data-flag-title="设备管理">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h1><p>I/O系统管理的主要对象是I/O设备和相应的设备控制器，其主要任务是，完成用户提出的I/O请求，提高I/O速率，以及提高设备利用率，并为更高层的进程方便地使用这些设备提供手段</p>
<h2 id="I-O系统的层次结构"><a href="#I-O系统的层次结构" class="headerlink" title="I/O系统的层次结构"></a>I/O系统的层次结构</h2><p>I/O软件组织分为4个层次</p>
<ul>
<li>用户层I/O软件：提供库函数对I/O设备操作</li>
<li>设备独立性软件：实现用户程序与设备驱动器的统一接口，设备命名，保护和分配释放等</li>
<li>设备驱动软件：与硬件直接相关，用于具体实现系统对设备发出的操作指令</li>
<li>中断处理程序：用于保存被中断进程的CPU环境，转入相应的中断处理程序处理，处理完恢复现场</li>
</ul>
<h2 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h2><p>设备并不是直接与CPU进行通信，而是与设备控制器通信，I/O设备应提供提供数据信号线，状态信号线和控制信号线给设备控制器</p>
<p>设备控制器主要功能是控制一个或多个I/O设备，实现I/O设备和计算机之间的数据交换，它是CPU与I/O设备之间的接口，接收从CPU发来的命令，去控制I/O设备工作</p>
<h3 id="设备控制器基本功能"><a href="#设备控制器基本功能" class="headerlink" title="设备控制器基本功能"></a>设备控制器基本功能</h3><ul>
<li>接收和识别命令</li>
<li>数据交换：数据总线实现CPU到控制器的交换，数据寄存器实现设备控制器到I/O设备的交换</li>
<li>标识和报告设备的状态</li>
<li>地址识别</li>
<li>数据缓冲区</li>
<li>差错控制</li>
</ul>
<h3 id="设备控制器的组成"><a href="#设备控制器的组成" class="headerlink" title="设备控制器的组成"></a>设备控制器的组成</h3><ul>
<li>设备控制器与处理机的接口：数据线地址线和控制线，实现CPU和设备控制器的通信，数据线通常与数据寄存器或者控制/状态寄存器连接，与数据寄存器连接的话是传输数据，与控制/状态寄存器连接的话是存放控制信息或设备状态信息</li>
<li>设备控制器与设备的接口：控制器由一个或多个设备接口，由数据，控制，状态三种信号组成</li>
<li>I/O逻辑：实现对设备控制，通过一组控制线与处理机交互，处理I/O命令，每当CPU启动一个设备，一方面启动命令发送给控制器，另一方面同时通过地址线把地址发送给控制器，由控制器的I/O逻辑对收到的地址译码，对所选设备控制</li>
</ul>
<p><img src="https://i.imgur.com/Wf5JaZW.png" alt=""></p>
<h2 id="I-O通道"><a href="#I-O通道" class="headerlink" title="I/O通道"></a>I/O通道</h2><p>引入目的：解脱CPU对I/O的组织，管理。虽然设备控制器可以减少CPU对I/O的干预，但当主机所配置的外设很多时，CPU负担仍很重，为此增加了I/O通道</p>
<p>I/O通道是一种特殊的执行I/O指令的处理机，与CPU共享内存，可以有自己的总线，它从CPU接收I/O指令，从内存取出要执行的通道执行程序，然后执行，完成规定I/O任务后，向CPU发中断信号</p>
<h3 id="通道类型"><a href="#通道类型" class="headerlink" title="通道类型"></a>通道类型</h3><ul>
<li>字节多路通道：各通道以时间片轮转方式共享通道，适用于低，中速设备</li>
<li>数组选择通道：无子通道，仅一主通道，某时间由某设备独占，适用高速设备，利用率低</li>
<li>数组多路通道：多子通道按需分配，综合前面两种优点</li>
</ul>
<h2 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I/O控制方式"></a>I/O控制方式</h2><p>四个阶段：程序I/O——中断I/O——DMA控制——通道控制</p>
<p>趋势：减少CPU对I/O操作的干预，提高并行度</p>
<ol>
<li>程序I/O控制方式：采用轮询的方式，CPU需要花代价不断查询I/O状态</li>
<li>中断I/O控制方式：CPU向I/O发命令然后做其他事，设备管理器按照该命令控制指定I/O，当I/O中断产生，CPU转去执行中断处理程序，CPU以字节为单位干预I/O</li>
<li>DMA控制：由DMA控制器直接控制总线传递数据块，DMA控制器完成从I/O到内存，主要用在块设备中</li>
<li>通道控制：DMA控制对多离散块的读取仍需要多次中断，通道方式CPU只要给出通道程序首地址，要访问的I/O设备后，通道程序就会完成一组块操作</li>
</ol>
<p><img src="https://i.imgur.com/dtoV0Yk.png" alt=""></p>
<p><img src="https://i.imgur.com/U2xYU5E.png" alt=""></p>
<h2 id="缓冲管理"><a href="#缓冲管理" class="headerlink" title="缓冲管理"></a>缓冲管理</h2><p>缓冲管理的目的是：组织管理，分配，释放buffer</p>
<p>引入：</p>
<ul>
<li>缓和CPU与I/O设备速度不匹配的矛盾</li>
<li>减少对CPU的中断频率</li>
<li>提高CPU和I/O并行性</li>
<li>解决数据粒度不匹配问题（数据单元大小）</li>
</ul>
<h3 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h3><p><img src="https://i.imgur.com/757qokP.png" alt=""></p>
<h3 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h3><p><img src="https://i.imgur.com/6sjJRcM.png" alt=""></p>
<p>收发可双向同时传送</p>
<h3 id="循环多缓冲"><a href="#循环多缓冲" class="headerlink" title="循环多缓冲"></a>循环多缓冲</h3><p><img src="https://i.imgur.com/l6h6TI6.png" alt=""></p>
<p><img src="https://i.imgur.com/eOKaI4l.png" alt=""></p>
<p><img src="https://i.imgur.com/HeyUobP.png" alt=""></p>
<h3 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h3><p><img src="https://i.imgur.com/CULwxH4.png" alt=""></p>
<p><img src="https://i.imgur.com/YMwks1i.png" alt=""></p>
<p><img src="https://i.imgur.com/zXCNOoe.png" alt=""></p>
<h2 id="设备分配"><a href="#设备分配" class="headerlink" title="设备分配"></a>设备分配</h2><p>包括对设备，设备控制器和通道的分配</p>
<p><img src="https://i.imgur.com/bbGgNk1.png" alt=""></p>
<p><img src="https://i.imgur.com/vS9hByz.png" alt=""></p>
<h3 id="设备分配应考虑的若干因素"><a href="#设备分配应考虑的若干因素" class="headerlink" title="设备分配应考虑的若干因素"></a>设备分配应考虑的若干因素</h3><ul>
<li>设备的固有属性：共享+虚拟，独享</li>
<li>分配算法：FIFO，优先权</li>
<li>安全性</li>
</ul>
<h3 id="设备独立性"><a href="#设备独立性" class="headerlink" title="设备独立性"></a>设备独立性</h3><p>即设备无关性，指<strong>应用程序独立于具体使用的物理设备</strong></p>
<p>设备可以分为逻辑设备和物理设备，逻辑设备名到物理设备名的映射由逻辑设备表LUT实现</p>
<p><img src="https://i.imgur.com/Fg9ojdp.png" alt=""></p>
<p>分配流程：进程给出逻辑名——通过LUT得到物理设备及其driver入口</p>
<p>优点是设备分配更灵活，可以是多对多的映射关系，提供均衡性于容错性，提高共享性，易于实现I/O重定向（改变LUT表即可）</p>
<h4 id="设备独立性软件"><a href="#设备独立性软件" class="headerlink" title="设备独立性软件"></a>设备独立性软件</h4><p>设备独立性软件执行所有设备的公有操作，如分配回收，名字映射，保护，缓冲，差错控制等，并向用户层软件提供统一接口如read，write</p>
<h3 id="SPOOLING技术"><a href="#SPOOLING技术" class="headerlink" title="SPOOLING技术"></a>SPOOLING技术</h3><p>为了缓和CPU高速性和I/O设备低速性的矛盾，引入脱机输入，脱机输出技术，利用专门的外围控制机，将低速I/O设备上的数据，传送到高速磁盘上，或者相反。当系统引入多道程序技术后，完全可以利用其中一道程序来模拟脱机输入时外围控制机的功能，把低速I/O设备上的数据传送到高速磁盘上，再用另一道程序，模拟脱机输出时外围控制器的功能，将数据从磁盘传送到低速输出设备上，这样便可在主机的直接控制下，实现以前的脱机输入，脱机输出的功能，此时外围操作与CPU对数据的处理同时进行，我们把这种联机情况下实现的同时外围操作的技术，称为SPOOLing技术（Simultaneous Periphernal Operating Online）或称为假脱机技术</p>
<p><img src="https://i.imgur.com/gc7ms1O.png" alt=""></p>
<p>SPOOLing提供了I/O速度，将独占设备改造为共享设备，实现了虚拟设备的功能</p>
<h2 id="设备处理"><a href="#设备处理" class="headerlink" title="设备处理"></a>设备处理</h2><p>设备驱动程序的功能：</p>
<ul>
<li>接收I/O进程发来的命令和参数，将命令中的抽象要求转换为具体要求</li>
<li>检查用于I/O请求的合法性</li>
<li>发出I/O命令</li>
<li>及时响应由控制器或通道发来的中断请求，并根据中断类型调用相应的中断处理程序处理</li>
<li>自动构成通道程序</li>
</ul>
<h3 id="设备处理方式"><a href="#设备处理方式" class="headerlink" title="设备处理方式"></a>设备处理方式</h3><ul>
<li>为每一类设备设置一个进程，专门用于执行这类设备的I/O操作</li>
<li>整个系统设置一个I/O进程，用于执行系统中所有各类设备的I/O操作</li>
<li>不设置专门的设备处理进程，而为各类设备设置相应的设备处理程序，供用户或系统进程调用</li>
</ul>
<h2 id="磁盘存储器管理"><a href="#磁盘存储器管理" class="headerlink" title="磁盘存储器管理"></a>磁盘存储器管理</h2><p><img src="https://i.imgur.com/dhsseTC.png" alt=""></p>
<h3 id="磁盘的类型"><a href="#磁盘的类型" class="headerlink" title="磁盘的类型"></a>磁盘的类型</h3><ul>
<li>固定头磁盘：每条磁道上都有一读/写磁头，所有磁头都被装在刚性磁臂中，通过这些磁头可访问所有磁道，并进行并行读/写，有效提高I/O速度</li>
<li>移动头磁盘：每一个盘面仅配一个磁头，也被装入磁臂中，该磁头能移动进行寻道，仅能串行方式读/写，I/O速度慢</li>
</ul>
<h3 id="磁盘访问时间"><a href="#磁盘访问时间" class="headerlink" title="磁盘访问时间"></a>磁盘访问时间</h3><ol>
<li>寻道时间Ts：磁臂（磁头）移动到指定磁道上所经历的时间，是启动磁臂时间s与磁头移动n条磁道所花费时间之和，Ts=m*n+s，m是常数，与磁盘驱动器速度有关</li>
<li>旋转延迟时间Tτ：扇区移动到磁头下面所经历的时间</li>
<li>传输时间Tt：把数据从磁盘读出或向磁盘写入数据所经历的时间Tt=b/rN，b是每次读/写的字节数，r是磁盘每秒转数，N是一条磁道上的字节数</li>
</ol>
<p>当一次读/写的字节数相当于半条磁道上的字节数时，Tt与Tτ相同，可将访问时间Ta表示为Ta=Ts+1/2r+b/rN</p>
<h3 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h3><h4 id="先来先服务FCFS"><a href="#先来先服务FCFS" class="headerlink" title="先来先服务FCFS"></a>先来先服务FCFS</h4><p>根据进程请求访问磁盘的先后次序调度</p>
<p><img src="https://i.imgur.com/SY51mcT.png" alt=""></p>
<h4 id="最短寻道时间优先SSTF"><a href="#最短寻道时间优先SSTF" class="headerlink" title="最短寻道时间优先SSTF"></a>最短寻道时间优先SSTF</h4><p>该算法选择这样的进程，要求访问的磁道与当前磁头所在的磁道距离最近</p>
<p><img src="https://i.imgur.com/is87d8q.png" alt=""></p>
<h4 id="扫描算法SCAN"><a href="#扫描算法SCAN" class="headerlink" title="扫描算法SCAN"></a>扫描算法SCAN</h4><p>SSTF实质是基于优先级的调度算法，可能会导致低优先级进程饥饿现象，因为只要不断有新进程请求到达，且所访问的磁道与磁头距离较近，则较远的进程饥饿，扫描算法不仅考虑访问磁道与当前磁道的距离，更优先考虑磁头当前的移动方向，例如当磁头自里向外移动，SCAN算法考虑的是当前磁道之外的，又是距离最近的，直到再无更外的磁道需要访问，就将磁臂换向改为自外向里，跟电梯运行很像，又称为电梯调度算法</p>
<p><img src="https://i.imgur.com/gdZ27V8.png" alt=""></p>
<h3 id="磁盘高速缓存"><a href="#磁盘高速缓存" class="headerlink" title="磁盘高速缓存"></a>磁盘高速缓存</h3><p>利用内存中的存储空间，来暂存从磁盘中读出的一系列盘块中的信息<br>高速缓存逻辑上属于磁盘，物理上是内存<br>高速缓存在内存中分为两种：第一种是内存中开辟单独的存储空间来作为磁盘高速缓存，大小是固定的，不会受应用程序多少的影响，第二种是把所有未利用的内存空间变为一个缓冲池，供请求分页系统和磁盘I/O（作为磁盘高速缓存）共享</p>
<h4 id="数据交付方式"><a href="#数据交付方式" class="headerlink" title="数据交付方式"></a>数据交付方式</h4><p>系统可以采取两种方式，将数据交付给请求进程</p>
<ul>
<li>数据交付：直接将高速缓存中的数据传送到请求者进程的内存工作区中</li>
<li>指针交付：只将指向高速缓存中某区域的指针交付给请求者进程</li>
</ul>
<h4 id="置换算法"><a href="#置换算法" class="headerlink" title="置换算法"></a>置换算法</h4><p>高速缓存的置换算法和请求分页系统有些区别，除了考虑最近最久未使用这一原则外，还考虑了访问频率，可预见性和数据的一致性</p>
<h4 id="周期性写回磁盘"><a href="#周期性写回磁盘" class="headerlink" title="周期性写回磁盘"></a>周期性写回磁盘</h4><p>UNIX系统专门增设一个修改程序，该程序周期性调用一个系统调用SYNC，主要功能是强制性将所有高速缓存中已修改的盘块数据写回磁盘，一般两次SYNC间隔30s</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/10/虚拟存储器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MakaLoo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MakaL-0-">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/10/虚拟存储器/" itemprop="url">虚拟存储器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-10T20:13:18+08:00">
                2019-05-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/05/10/虚拟存储器/" class="leancloud_visitors" data-flag-title="虚拟存储器">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>虚拟存储器的引入：常规存储器管理方式特征：一次性（全部装入），驻留性（驻留在内存不换出）</p>
<p><strong>局部性原理</strong>：</p>
<ul>
<li>时间局部性：如循环执行，某条指令被执行，不久以后可能会再次执行，数据被访问，不久后可能会再次被访问，原因是程序中存在大量循环操作</li>
<li>空间局部性：如顺序执行，一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址可能集中在一定范围之内</li>
</ul>
<p>虚拟存储器的定义：<strong>具有请求调入功能和置换功能，能从逻辑上对内存容量进行扩充的一种存储系统</strong><br>实质：时间换空间，但时间牺牲不大</p>
<p>虚拟存储器特征：离散性（部分装入），多次性（局部装入，多次装入），对换性，虚拟性</p>
<h2 id="虚拟存储器的实现方式"><a href="#虚拟存储器的实现方式" class="headerlink" title="虚拟存储器的实现方式"></a>虚拟存储器的实现方式</h2><p>虚拟存储器的实现，全都建立在离散分配存储管理方式的基础上</p>
<p>需要动态重定位</p>
<p>目前的虚拟存储器都是采用分页请求系统和分段请求系统的方式实现的，分页请求系统就是在分页系统的基础上增加了请求调页功能和页面置换功能，分段请求系统在分段系统的基础上加入了请求调段功能和分段置换功能</p>
<ul>
<li>分页请求系统<ul>
<li>以页为单位转换</li>
<li>需硬件：<ul>
<li>请求分页的页表机制</li>
<li>缺页中断</li>
<li>地址变换机构</li>
</ul>
</li>
<li>需实现请求分页机制的软件</li>
</ul>
</li>
<li>请求分段系统<ul>
<li>以段为单位转换<ul>
<li>请求分段的段表结构</li>
<li>缺段中断</li>
<li>地址变换机构</li>
</ul>
</li>
<li>需实现请求分段机制的软件</li>
</ul>
</li>
</ul>
<h2 id="请求分页存储管理方式"><a href="#请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h2><h3 id="请求分页的页表机制"><a href="#请求分页的页表机制" class="headerlink" title="请求分页的页表机制"></a>请求分页的页表机制</h3><p>在纯页表机制上增加若干项形成，主要作用还是将用户地址空间中的逻辑地址映射为内存空间中的物理地址，为了满足页面换出换进换出的需要，它增加了一些字段</p>
<p><img src="https://i.imgur.com/EskQP0h.png" alt=""></p>
<ul>
<li>状态位P：仅有一位，指示该页是否已经调入内存</li>
<li>访问字段A：记录本页在一段时间内被访问的次数或记录本页最近已有多长时间未被访问，作为置换算法换出页面时的参考</li>
<li>修改位M：标识该页在调入内存后是否被修改过，由于内存每一页在外存上都有一份副本，因此置换该页时，如果未被修改，就不需要将该页写回到外存</li>
</ul>
<h3 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h3><p>请求分页系统中，每当所要访问的页面不在内存时，便产生一缺页中断，请求OS将所缺之页调入内存，它与一般中断相比有明显区别，主要表现如下：</p>
<ul>
<li>在指令执行期间产生和处理信号。通常CPU都是在一条指令执行完后才检查是否有中断请求到达。然而缺页中断在指令执行期间，若发现所要访问的指令或数据不在内存时，便立即产生和处理缺页中断信号，以便及时将所缺的页面调入内存</li>
<li>一条指令在执行期间可能产生多次缺页中断。例如下图中，执行一条指令copy A to B，可能要产生6次缺页中断，因为指令本身跨了两个页面，A和B各自为一个数据块，它们也都跨了两个页面</li>
</ul>
<p><img src="https://i.imgur.com/aW7AfPZ.png" alt=""></p>
<h3 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><p>在分页系统地址变换机构的基础上，为实现虚拟存储器，再增加了某些功能，比如产生和处理缺页中断，以及从内存中换出一页的功能等等</p>
<p><img src="https://i.imgur.com/fGAbVRm.jpg" alt=""></p>
<h3 id="请求分页的内存分配"><a href="#请求分页的内存分配" class="headerlink" title="请求分页的内存分配"></a>请求分页的内存分配</h3><p>为进程分配内存时涉及三个问题：第一，为保证进程能正常运行，所需要的最小物理块数的确定；第二，在为每个进程分配物理块时，应采取什么样的分配策略，即所分配的物理块是固定的，还是可变的；第三，为不同进程分配物理块数，是平均分配算法还是根据进程大小按比例分配</p>
<h4 id="最小物理块数的确定"><a href="#最小物理块数的确定" class="headerlink" title="最小物理块数的确定"></a>最小物理块数的确定</h4><p>最小物理块数指保证进程正常运行所需的最小物理块数，取决于计算机硬件结构和指令格式，比如单地址指令且直接寻址的机器，最小物理块数为2，一块存放指令的页面，一块存放数据的页面，而对于单地址指令间接寻址，至少需要3个物理块，如果指令长度两个或多个字节，且指令本身可跨两个页面，源地址目标地址所涉及区域也跨两个页面，则要为每个进程分配6个物理块以装入6个页面</p>
<h4 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h4><p>可采用固定和可变分配策略，置换时也可采取全局置换和局部置换，组合出下面三种适用的策略，全局置换指产生缺页都获得新物理块，如果没有空闲物理块，就从内存中选择一页调出，该页可能是系统中任何一个进程的，局部置换指换出的页面只能是该进程的页面，而不能是其他进程的</p>
<ul>
<li>固定分配局部置换：固定分配指为每个进程分配一组固定数目的物理块，在进程运行时间不再改变，局部置换指如果进程在运行中发现缺页，则只能从分配给该进程的n个页面中选一页换出，再调入一页，以保证分配给该进程内存空间不变，缺点是难以确定固定分配的页数，如果少，置换率高，如果多就浪费</li>
<li>可变分配全局置换：可变分配指先为每个进程分配一定数目的物理块，在进程运行器件可根据情况适当增加或减少。可变分配全局置换这可能是最易于实现的一种物理块分配和置换策略，已用于若干个OS中。在采用这种策略时，凡产生缺页（中断）的进程，都将获得新的物理块，仅当空闲物理块队列中的物理块用完时，OS才能从内存中选择一页调出。被选择调出的页可能是系统中任何一个进程中的页，因此这个被选中的进程拥有的物理块会减少，这将导致其缺页率增加</li>
<li>可变分配局部置换：当某进程发现缺页时，只允许从该进程在内存的页面中选择一页换出，这样不会影响到其它进程的运行，如果进程运行中频繁缺页中断，系统就为该进程分配若干附加的物理块，直到进程缺页率降到适当程度为止，反之如果缺页率比较低，就适当减少该进程物理块数</li>
</ul>
<h5 id="物理块分配算法"><a href="#物理块分配算法" class="headerlink" title="物理块分配算法"></a>物理块分配算法</h5><ul>
<li>平均分配算法</li>
<li>考虑优先权分配算法</li>
</ul>
<h3 id="页面调入策略"><a href="#页面调入策略" class="headerlink" title="页面调入策略"></a>页面调入策略</h3><p>问题：</p>
<ul>
<li>何时调入页面<ul>
<li>预调页策略：将那些预计在不久后会被访问的页面预先调入内存</li>
<li>请求调页策略：在进程需要访问页面不在内存的数据和程序时才提出请求，费系统开销</li>
</ul>
</li>
<li>从何处调入页面<ul>
<li>对换区，快</li>
<li>文件区，慢，在缺少对换区空间时</li>
<li>UNIX方式：未运行过的页面都从文件区调入，运行过但被换出的页面从对换区调入</li>
</ul>
</li>
<li>页面调入过程：在上面地址变换机构的图的左半部分就是页面调入过程</li>
</ul>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h4 id="最佳置换算法OPT"><a href="#最佳置换算法OPT" class="headerlink" title="最佳置换算法OPT"></a>最佳置换算法OPT</h4><p>其所选择的被淘汰页面，将是以后永不使用的，或许是在<strong>最长时间内不再被访问的页面</strong>，因为人们目前无法预知，一个进程在内存的若干页面中哪一个是未来最长时间不再被访问的，因而该算法是无法实现的，用于评价其他算法</p>
<p><img src="https://i.imgur.com/N2jBRuD.png" alt=""></p>
<p>考虑先将7，0，1三个页面装入内存，当进程要访问页面2，就会产生缺页中断，这个时候就会把页面7淘汰，因为页面0是第5个被访问的页面，页面1是第14个被访问的页面，页面7是第18个被访问的页面，访问到页面3的时候，同理页面1被淘汰，以此类推</p>
<h4 id="先进先出页面置换算法FIFO"><a href="#先进先出页面置换算法FIFO" class="headerlink" title="先进先出页面置换算法FIFO"></a>先进先出页面置换算法FIFO</h4><p>该算法总是淘汰最先进入内存的页面，即选择内存中驻留时间最久的页面淘汰，该算法实现只需要把 进程已调入内存的页面按先后次序链接成一个队列，并设置一个指针，称为替换指针，它总是指向最老的页面</p>
<h4 id="最近最久未使用置换算法LRU"><a href="#最近最久未使用置换算法LRU" class="headerlink" title="最近最久未使用置换算法LRU"></a>最近最久未使用置换算法LRU</h4><p>根据页面调入内存后的使用情况做出决策，选择<strong>最近最久未使用的页面</strong>淘汰，每个页面一个访问字段，用来记录一个页面自上次被访问以来经历了多少时间t，当需要淘汰一个页面时，选择现有页面中t值最大的淘汰</p>
<p>需要移位寄存器R=Rn-1Rn-2…R2R1R0的支持，当访问某物理块时，就将移位寄存器Rn-1置1，定时器每隔一段时间将寄存器右移一位，<strong>具有最小数值的寄存器所对应的页面就是最近最久未使用的页面</strong><br>或者需要栈的支持，当进程访问某页面，将该页面号从栈移出，压入栈顶，栈底就是最近最久未使用的页面号</p>
<h4 id="Clock置换算法，页面缓冲算法等"><a href="#Clock置换算法，页面缓冲算法等" class="headerlink" title="Clock置换算法，页面缓冲算法等"></a>Clock置换算法，页面缓冲算法等</h4><p>考纲没说要考，再看下去我要挂科了</p>
<h3 id="请求分页访问内存有效时间"><a href="#请求分页访问内存有效时间" class="headerlink" title="请求分页访问内存有效时间"></a>请求分页访问内存有效时间</h3><p>EAT=(1-p)<em>t+p</em>f<br>其中p为缺页率，t为内存访问时间，f为缺页中断时间</p>
<h2 id="请求分段存储管理方式"><a href="#请求分段存储管理方式" class="headerlink" title="请求分段存储管理方式"></a>请求分段存储管理方式</h2><h3 id="请求分段的段表机制"><a href="#请求分段的段表机制" class="headerlink" title="请求分段的段表机制"></a>请求分段的段表机制</h3><p><img src="https://i.imgur.com/hp6kwQQ.png" alt=""></p>
<ul>
<li>存取方式：执行，只读，读/写</li>
<li>存在位P：是否已调入内存</li>
<li>增补位：本段在运行过程中是否做过动态增长</li>
</ul>
<h3 id="缺段中断机构"><a href="#缺段中断机构" class="headerlink" title="缺段中断机构"></a>缺段中断机构</h3><p><img src="https://i.imgur.com/DbhfGOj.png" alt=""></p>
<p>与缺页中断的区别主要是有空区拼接，形成一个合适的空区</p>
<h3 id="地址变换机构-1"><a href="#地址变换机构-1" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><p><img src="https://i.imgur.com/6xN5oK5.png" alt=""></p>
<h3 id="分段的共享与保护"><a href="#分段的共享与保护" class="headerlink" title="分段的共享与保护"></a>分段的共享与保护</h3><p>分段的优点是便于实现分段的共享与保护</p>
<h4 id="共享段表"><a href="#共享段表" class="headerlink" title="共享段表"></a>共享段表</h4><p><img src="https://i.imgur.com/MHkyUus.png" alt=""></p>
<h4 id="分段保护"><a href="#分段保护" class="headerlink" title="分段保护"></a>分段保护</h4><p>提供如下分段保护</p>
<ul>
<li>越界检查</li>
<li>存取控制检查</li>
<li>环保护机构</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/09/存储器管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MakaLoo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MakaL-0-">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/09/存储器管理/" itemprop="url">存储器管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-09T23:05:18+08:00">
                2019-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/05/09/存储器管理/" class="leancloud_visitors" data-flag-title="存储器管理">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h1><h2 id="存储器管理概述"><a href="#存储器管理概述" class="headerlink" title="存储器管理概述"></a>存储器管理概述</h2><h3 id="存储器的多层结构"><a href="#存储器的多层结构" class="headerlink" title="存储器的多层结构"></a>存储器的多层结构</h3><p>由于CPU与存储器的速度不匹配，需要对存储器进行分层，经典是三层结构：CPU寄存器，主存和辅存，目前比较高级的分层是六层：寄存器，高速缓存，主存储器，磁盘缓存，固定磁盘和可移动存储介质，层次越高，速度越快，但价格越高，存储容量越小</p>
<p>高速缓存常用SRAM，内存DRAM，SDRAM等，外存是软盘，硬盘，光盘等</p>
<p><img src="https://i.imgur.com/j0Z0S0T.png" alt=""></p>
<h4 id="各层次作用"><a href="#各层次作用" class="headerlink" title="各层次作用"></a>各层次作用</h4><p>主存又称内存，用于保存进程运行的程序和数据，处理机都是从主存储器取指令和数据的，并把指令放入指令寄存器，数据放入数据寄存器，或者反过来把寄存器中的数据存入主存储器。</p>
<p>寄存器有与处理机相同的速度</p>
<p>高速缓存是介于寄存器和存储器之间的存储器，主要用于备份主存常用的数据，减少处理机对主存的访问次数，可以大幅度提高程序执行速度</p>
<p>磁盘缓存是为了缓和磁盘I/O速度和主存访问速度的不匹配，主要用于暂时存放频繁使用的一部分磁盘数据和信息，以减少访问磁盘的次数，它本身不是一种实际存在的存储器，而是利用主存中部分存储空间暂时存放从磁盘中读出或写入的信息</p>
<h3 id="存储器管理功能"><a href="#存储器管理功能" class="headerlink" title="存储器管理功能"></a>存储器管理功能</h3><p>存储器管理主要有如下功能</p>
<ul>
<li>存储分配和回收：分配和和回收算法及相应的数据结构</li>
<li>地址变换<ul>
<li>可执行文件生成中的链接技术</li>
<li>程序加载（装入）时的重定位技术</li>
<li>进程运行时硬件和软件的地址变换技术和机构</li>
</ul>
</li>
<li>存储共享和保护<ul>
<li>代码和数据共享</li>
<li>地址空间访问权限（读，写，执行）</li>
</ul>
</li>
<li>存储器扩充</li>
</ul>
<h3 id="重定位概念"><a href="#重定位概念" class="headerlink" title="重定位概念"></a>重定位概念</h3><p>重定位是实现逻辑地址（相对地址）到物理地址（绝对地址）的映射<br>逻辑地址：应用程序的地址都是从0开始的<br>物理地址：主存中一系列存储信息的物理单元的地址</p>
<h3 id="程序的装入"><a href="#程序的装入" class="headerlink" title="程序的装入"></a>程序的装入</h3><p>一个程序一般有5个过程，编辑，编译，链接，装入和运行</p>
<p>程序装入分为绝对装入和可重定位装入和动态运行时装入<br>绝对装入指编译后，装入前已产生绝对地址，装入时不需要再作地址重定位，绝对地址由编译器或程序员编程完成<br>可重定位装入指静态重定位，静态重定位指地址转换在装入时一次完成，缺点是不允许程序在运行中在内存中移动位置<br>动态运行时装入在把装入模块装入内存后，并不立即把装入模块中的逻辑地址转换成物理地址，而是把这种地址转换推迟到程序真正要执行的时候才进行，因此，装入内存后的地址都是逻辑地址，需要一个重定位寄存器的支持</p>
<h3 id="程序的链接"><a href="#程序的链接" class="headerlink" title="程序的链接"></a>程序的链接</h3><p>源程序编译后得到一组目标模块，链接程序的功能是将这组目标模块以及它们所需要的库函数装配成一个完整的装入模块</p>
<p>静态链接：对相对地址进行修改，变换外部调用符号<br>动态链接：便于修改和更新，便于实现对目标模块的共享<br>运行时动态链接</p>
<h2 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h2><p>为了能将用户程序装入内存，必须为它分配一定大小的内存空间，连续分配方式是最早出现的一种存储器分配方式</p>
<h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><p>用于单用户单任务中，把内存分为系统区和用户区，应用程序装入到用户区，可使用用户区全部空间，优点是易于管理，缺点是对要求内存空间少的程序造成内存浪费，程序全部装入，很少使用的程序部分也会占用内存</p>
<h3 id="固定分区"><a href="#固定分区" class="headerlink" title="固定分区"></a>固定分区</h3><p>特点：有n个分区，可同时装入n个作业/任务<br>固定分区可以把分区划分为相等的跟不相等的，不相等的利用率更高</p>
<p>数据结构：分区使用表，将分区按大小排序，并将地址，分配标识符（是否已分配），大小作记录，由于每个分区的大小固定，必然会造成存储空间的浪费</p>
<h3 id="可变式分区"><a href="#可变式分区" class="headerlink" title="可变式分区"></a>可变式分区</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul>
<li>空闲分区表：记录每个空闲分区的情况，每个空闲分区占一个表目，表目中包括分区号，分区大小和分区始址等。</li>
<li>空闲分区链：实现对空闲分区表的分配和链接，在每个分区的起始部分设置一些用于控制分区分配的信息，以及用于链接各分区所用的前向指针，在分区尾部设置一后向指针，通过前后向链接指针，可将所有空闲分区链接成一个双向链，分区尾部重复设置状态位和分区大小表目，当分区被分配出去后，状态位由”0”改为”1”，此时前后指针无意义</li>
</ul>
<p><img src="https://i.imgur.com/JiCVrro.png" alt=""></p>
<h4 id="分配算法"><a href="#分配算法" class="headerlink" title="分配算法"></a>分配算法</h4><p>为把一个新作业装入内存，须按照一定的分配算法，从空闲分区表或空闲分区链中选一分区分配给该作业</p>
<h4 id="分区分配操作"><a href="#分区分配操作" class="headerlink" title="分区分配操作"></a>分区分配操作</h4><h5 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h5><p>利用某种分配算法，从空闲分区链（表）中找到所需大小的分区，设请求的分区大小是u.size，表中每个空闲分区的大小可表示为m.size，若m.size-u.size&lt;=size（size是事先规定的不再切割的剩余分区的大小）说明多余部分太小，可不再切割，将整个分区分配给请求者，并从分区链移除，否则从该分区中按请求的大小划分找出一块内存空间分配出去，余下的部分仍留在空闲分区链（表）中，然后将分配区的首地址返回给调用者</p>
<p><img src="https://i.imgur.com/waRwwTm.png" alt=""></p>
<h5 id="回收内存"><a href="#回收内存" class="headerlink" title="回收内存"></a>回收内存</h5><p>当进程运行完毕释放内存后，系统根据<strong>回收区的首地址</strong>，从空闲区链（表）中找到相应的插入点，此时可能出现下面四种情况</p>
<ul>
<li>回收区与插入点前一个空闲分区F1相邻接，此时应将回收区与插入点前一分区合并，不必为回收区分配新表项，而只需修改前一分区F1的大小</li>
<li>回收区与插入点后一个空闲分区F2相邻接，此时将两分区合并，形成新的空闲分区，但用回收区的首地址作为新空闲区的首地址，大小为两者之和</li>
<li>回收区同时与插入点的前，后两个分区邻接，此时将三个分区合并，使用F1的表项和F1的首地址，取消F2的表项，大小为三者之和</li>
<li>回收区既不与F1邻接也不与F2邻接：新建表项，填入回收区首地址和大小，插入到空闲链适当位置</li>
</ul>
<p><img src="https://i.imgur.com/M2f7lE3.png" alt=""></p>
<h3 id="分配算法-1"><a href="#分配算法-1" class="headerlink" title="分配算法"></a>分配算法</h3><h4 id="基于顺序搜索的动态分区分配算法"><a href="#基于顺序搜索的动态分区分配算法" class="headerlink" title="基于顺序搜索的动态分区分配算法"></a>基于顺序搜索的动态分区分配算法</h4><ul>
<li>首次适应(first fit, FF)算法：空闲分区链以地址递增的次序链接，从链首开始顺序查找直到找到一个大小能满足要求的空闲分区为止，然后从该分区划出一块内存空间分配给请求者</li>
<li>循环首次适应(next fit, NF)算法：不再是每次都从链首开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找</li>
<li>最佳适应(best fit, BF)算法：每次为作业分配内存时，总是把能满足要求又是最小的空闲分区分配给作业，要求所有空闲分区按容量从大到小顺序形成一空闲分区链</li>
<li>最坏适应(worst fit, WF)算法：总是挑选最大的空闲区从中分割一部分存储空间给作业使用，要求将所有空闲分区按容量从大到小形成一空闲分区链，查找时只需看第一个分区是否满足作业要求</li>
</ul>
<h4 id="基于索引搜索的动态分区分配算法"><a href="#基于索引搜索的动态分区分配算法" class="headerlink" title="基于索引搜索的动态分区分配算法"></a>基于索引搜索的动态分区分配算法</h4><ul>
<li>快速适应(quick fit)算法：将空闲分区根据容量大小分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链，内存设立一张管理索引表，索引表项对应空闲分区类型，并记录该类型空闲分区链表表头的指针，根据进程常用空间大小划分，比如2KB，4KB，8KB等，7KB可以放在8KB也可以放在特殊的空闲分区链表中</li>
<li>伙伴系统：无论已分配分区或空闲分区，其大小均为2的k次幂，对于相同大小空闲分区单独设立一个空闲分区双向链表，不同大小的空闲分区形成了k个空闲分区链表，对于进程分配一个长度为n的存储空间时，计算i值，使2^(i-1) &lt; n &lt;= 2^i，先从2^i的空闲分区查找，若找到就分配，没有则从2^(i+1)的空闲分区查找，找到就分为相等的两个分区，称为一对伙伴，其中一个分区用于分配，另一个分区加入到2^i的空闲分区链表中</li>
<li>哈希算法，构造空闲分区大小为关键字的哈希表，每一个表项记录一个对应的空闲分区链表表头指针</li>
</ul>
<h4 id="动态可重定位分区分配"><a href="#动态可重定位分区分配" class="headerlink" title="动态可重定位分区分配"></a>动态可重定位分区分配</h4><ul>
<li>紧凑：连续分配方式的一个重要特点是：一个系统或用户程序必须被装入一片连续的内存空间中，当计算机运行一段时间后，它的内存空间会被划分为许多小的分区，而缺乏大的空闲空间，当有大作业要加入，因为小分区不邻接，无法分配内存给大作业，紧凑就是将内存中的所有<strong>作业</strong>进行移动，使它们全都相邻接，这样，原来分散的多个空闲小分区拼接成一个大分区，每次紧凑后，必须对移动了的程序或数据进行重定位</li>
<li>动态重定位：动态运行时装入的方式，作业装入内存后所有地址仍然是相对地址，而将相对地址转换成绝对地址的工作被推迟到程序指令要真正执行的时候进行，设一个重定位寄存器，用它存放程序（数据）在内存中的起始地址，程序执行时真正访问的地址是相对地址与重定位寄存器的地址相加而形成的</li>
</ul>
<p><img src="https://i.imgur.com/UkxuVZ5.png" alt=""></p>
<p><img src="https://i.imgur.com/ayDa85o.png" alt=""></p>
<h2 id="对换"><a href="#对换" class="headerlink" title="对换"></a>对换</h2><p>对换的引入：将阻塞进程，暂时不用的程序，数据换出，将具备运行条件的进程换入<br>类型：</p>
<ul>
<li>整体对换：进程对换，解决内存紧张</li>
<li>部分对换：页面对换/分段对换：提供虚存支持</li>
</ul>
<h3 id="对换空间的管理"><a href="#对换空间的管理" class="headerlink" title="对换空间的管理"></a>对换空间的管理</h3><p>具有对换功能的OS中，常把磁盘空间分为文件区和对换区，对换区比文件区侧重于对换速度，因此对换区一般采用连续分配，采用数据结构和分配回收类似于可变化分区分配</p>
<h3 id="进程的换出与换入"><a href="#进程的换出与换入" class="headerlink" title="进程的换出与换入"></a>进程的换出与换入</h3><p>当内存不足时，便调用对换进程，实现进程的换出和换入</p>
<h4 id="进程的换出"><a href="#进程的换出" class="headerlink" title="进程的换出"></a>进程的换出</h4><ol>
<li>选择被换出的进程：选择因素：优先级，驻留时间，进程状态</li>
<li>进程换出过程：共享段计数减一，如果是0就换出，修改PCB和MCB</li>
</ol>
<h4 id="进程的换入"><a href="#进程的换入" class="headerlink" title="进程的换入"></a>进程的换入</h4><ol>
<li>选择换入进程：优先级，换出时间等</li>
<li>申请内存</li>
<li>换入</li>
</ol>
<h2 id="分页存储管理方式"><a href="#分页存储管理方式" class="headerlink" title="分页存储管理方式"></a>分页存储管理方式</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>分页主要是将用户程序的地址空间划分为若干个固定大小的区域，称为”页”或”页面”，典型的页面大小为1kb，相应地，也将内存空间分为若干个物理块或页框，页和块的大小相同，这样可以将用户程序的任一页放入任一物理块中，实现离散分配（页是相对用户程序的地址而言，页框或者块是相对内存空间而言）</p>
<p>离散分配的引入：连续分配引起碎片，紧凑方式消耗系统开销</p>
<h3 id="分页存储管理的基本方法"><a href="#分页存储管理的基本方法" class="headerlink" title="分页存储管理的基本方法"></a>分页存储管理的基本方法</h3><h4 id="地址结构"><a href="#地址结构" class="headerlink" title="地址结构"></a>地址结构</h4><p><img src="https://i.imgur.com/UpDwi5n.png" alt=""></p>
<p>A：逻辑地址空间的地址 L：页面的大小</p>
<p>包含两部分内容：前一部分为页号P，后一部分为位（偏）移量W，即页内地址，图中的地址长度为32位，其中0——11位为页内地址，即每页大小4KB（页面大小），12——31位为页号，地址空间最多允许有1M页</p>
<h4 id="页的计算例子"><a href="#页的计算例子" class="headerlink" title="页的计算例子"></a>页的计算例子</h4><p><img src="https://i.imgur.com/df5F6fB.png" alt=""></p>
<h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>为了能在内存中找到每个页面对应的物理块，系统为每个进程建立一张页面映射表，为页表，在进程地址空间内的所有页(0——n)，依次在页表中有一页表项，其中记录了相应页在内存中对应的物理块号，实现从页号到物理块号的地址映射</p>
<p><img src="https://i.imgur.com/ElwJb15.png" alt=""></p>
<h3 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><p>为了能将用户地址空间中的逻辑地址转换成内存空间中的物理地址，系统中设立了地址变换机构，地址变换机构任务实际只是将逻辑地址中的页号转换为内存中的物理块号（页内地址与物理块内的地址是一样的，所以不需要变换），地址变换任务就是<strong>借助页表实现的</strong></p>
<h4 id="基本地址变换机构"><a href="#基本地址变换机构" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h4><ul>
<li>越界保护</li>
<li>每个进程对应一页表，其信息（如长度，始址）放在PCB中，执行时将其首地址装入页表寄存器</li>
</ul>
<p>页表是驻留在内存中的，当调度程序调度某程序的时候，才将PCB中的页表始址和页表长度装入页表寄存器（一个进程对应一个页表，所以对不同页表，需要有页表始址来区分）</p>
<p><img src="https://i.imgur.com/eL5lZKb.png" alt=""></p>
<h5 id="地址变换过程"><a href="#地址变换过程" class="headerlink" title="地址变换过程"></a>地址变换过程</h5><p>当进程要访问某个逻辑地址的数据时，分页地址变换机构会自动地将有效地址（相对地址）分为页号和页内地址两部分，再以页号为索引区检索页表，查找操作由硬件执行。在检索之前，先将页号与页表长度比较，若大于或等于页表长度，则表示本次所访问的地址已超越进程的地址空间，产生一地址越界中断。若未出现越界错误，则将页表始址与页号和页表项长度的乘积相加，便得到该表项在页表中的位置，于是可从中得到该页的物理块号，将它装入物理地址寄存器，然后把页内地址送入物理地址寄存器的块内地址字段中，这样便完成了逻辑地址到物理地址的变换</p>
<h5 id="我对将页表始址与页号和页表项长度的乘积相加地理解"><a href="#我对将页表始址与页号和页表项长度的乘积相加地理解" class="headerlink" title="我对将页表始址与页号和页表项长度的乘积相加地理解"></a>我对将页表始址与页号和页表项长度的乘积相加地理解</h5><p>页表项长度应该就是页表项（即物理块）的地址的长度<br>通过上述式子的计算，得到的是一个地址值（页表始址+页号*页表项长度（地址长度）），这个地址值应该是页表中该页表项的物理内存地址，访问这个物理内存地址，就得到这个物理块号了</p>
<h5 id="需要考虑的问题"><a href="#需要考虑的问题" class="headerlink" title="需要考虑的问题"></a>需要考虑的问题</h5><p>直接映射的分页系统对系统效能不利，因为CPU需要访问两次主存才能得到所需要的数据，第一次访问是访问主存中的页表，从中找到指定页的物理块号再将块号与页内偏移量W拼接形成物理地址，第二次访问是从第一次所得地址中获得实际数据，为了解决这个问题，引入快表</p>
<h4 id="具有快表的地址变换机构"><a href="#具有快表的地址变换机构" class="headerlink" title="具有快表的地址变换机构"></a>具有快表的地址变换机构</h4><p>为了提高地址变换速度，在地址变换机构中增设一个具有并行查寻能力的特殊高速缓冲寄存器，又称为”联想寄存器”，或称为”快表”，或者TLB，用以存放当前访问的那些页表项，此时地址变换过程是这样的：</p>
<p>在CPU给出有效地址后，由地址变换机构自动地将页号P送入高速缓冲寄存器，并将此页号与高速缓存中地所有页号进行比较，若其中有与此相匹配的页号，便表示所要访问的页表项在快表中，于是，可直接从快表中读出该页所对应的物理块号，并送到物理地址寄存器，如在快表中没有找到对应的页表项，则还须再访问内存中的页表，找到后把从页表中读出的物理块号送往地址寄存器，同时，再将此页表项存入快表的一个寄存器单元中，如果快表满了，则OS找到一个老的且被认为不需要的页表项换出</p>
<p><img src="https://i.imgur.com/IxGYPDQ.png" alt=""></p>
<h3 id="访问内存的有效时间"><a href="#访问内存的有效时间" class="headerlink" title="访问内存的有效时间"></a>访问内存的有效时间</h3><p>从进程发出指定逻辑地址的访问请求，经过地址变换，到在内存中找到对应的实际物理地址单元并取出数据，所需要花费的总时间，称为内存的有效访问时间（Effective Access Time, EAT)，有效访问时间分为第一次访问内存时间（即查找页表对应的页表项所耗费的时间t）与第二次访问内存时间（即将页表项的物理块与页内地址拼接成实际物理地址所耗费的时间t）之和</p>
<p>t：访问一次内存所需要的时间<br>EAT=t+t=2*t</p>
<p>引入快表后，快表命中率a，查找快表需要的时间λ</p>
<p>EAT=a<em>(t+λ)+(1-a)(2t+λ)=2</em>t+λ-t*a</p>
<h3 id="两级和多级页表"><a href="#两级和多级页表" class="headerlink" title="两级和多级页表"></a>两级和多级页表</h3><p><img src="https://i.imgur.com/a87JQe4.jpg" alt=""></p>
<p>两级页表的逻辑地址结构</p>
<p><img src="https://i.imgur.com/vAODx2G.png" alt=""></p>
<p><img src="https://i.imgur.com/dmvJmwv.png" alt=""></p>
<p>以前面的32位逻辑地址空间为例，当页面大小为4KB的时候(12位)，采用两级页表结构时，再对页表进行分页，使每页包含2^10个页表项，或者说，外层页表中的外层页内地址P2为10位，外层页号P1也为10位</p>
<p>（通过外部页号得到P2的始址，然后P2和d就可以通过上面说过的地址变换过程获得物理地址了）<br>外层页表的每个页表项中存放的是某页表分页的首地址，地址变换机构中同样要增加外层页表寄存器，用于存放外层页表的始址，并利用逻辑地址中的外层页号作为外层页表的索引，从中找到指定页表的始址（同上页表始址与页号和页表项长度乘积相加那个原理），再利用P2作为指定页表分页的索引，找到指定页表项，即含有该页在内存中的物理块号，用该块号P和页内地址d即可构成访问的内存物理地址</p>
<h4 id="一个练习小例子"><a href="#一个练习小例子" class="headerlink" title="一个练习小例子"></a>一个练习小例子</h4><p><img src="https://i.imgur.com/NzHTbzz.png" alt=""></p>
<p>对题目的理解：页号是用户程序而言的，该用户程序有32页，每页2K，而物理块是针对内存空间而言的，内存有1M，第1题第2问中，因为物理空间有1M，每页2K，即每个物理块2K，所以内存中有512个物理块，这32页必须可以对应到这512个物理块中的每一块，物理块号为0#——511#，页表项是物理块的块号，所以页表项位数应该是511的二进制位数，即9位</p>
<p><img src="https://i.imgur.com/nzZDyXX.png" alt=""></p>
<p>对第二题，由逻辑地址算出页号和页内地址，通过页号找到物理块号，物理地址=物理块号*页面大小+业内地址</p>
<p><img src="https://i.imgur.com/Pypgxvw.png" alt=""></p>
<h2 id="分段存储管理系统"><a href="#分段存储管理系统" class="headerlink" title="分段存储管理系统"></a>分段存储管理系统</h2><p>基本思想：按程序的逻辑结构，将程序的地址空间划分为若干段，各段大小可不相同，在进行存储分配时，以段为单位，这些段在内存中可以不相邻接<br>为什么引入：一方面程序可分为若干个段，主程序段，子程序段A，子程序段B，数据段，栈段等，另一方面实现和满足信息共享，信息保护，动态链接以及信息的动态增长等需要</p>
<h3 id="分段系统基本原理"><a href="#分段系统基本原理" class="headerlink" title="分段系统基本原理"></a>分段系统基本原理</h3><h4 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h4><p>每个段定义了一组逻辑信息，分段地址的地址具有如下结构</p>
<p><img src="https://i.imgur.com/lIzzMcm.png" alt=""></p>
<h4 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h4><p><img src="https://i.imgur.com/0jaI7D8.png" alt=""></p>
<h4 id="地址变换过程-1"><a href="#地址变换过程-1" class="headerlink" title="地址变换过程"></a>地址变换过程</h4><p><img src="https://i.imgur.com/NI7gUs6.png" alt=""></p>
<p>设置了段表寄存器，用于存放段表始址和段表长度TL，在进行地址变换时，系统将逻辑地址中的段号和段表长度TL进行比较，若S&gt;TL，表示段号太大，访问越界，若未越界，则根据段表始址和段号，计算出该段对应段表项的位置（物理地址），从中读出该段在内存的起始地址，然后检查段内地址d是否超过该段段长SL，若超过，即d&gt;SL，同样发出越界中断，若未越界，则该段基址d与段内地址相加，即可得到要访问的内存物理地址</p>
<p>分段同样需要访问两次内存，同样由联想存储器用于保存最近常用的段表项</p>
<h2 id="分页和分段主要区别"><a href="#分页和分段主要区别" class="headerlink" title="分页和分段主要区别"></a>分页和分段主要区别</h2><ul>
<li>页是信息的物理单位，段是逻辑单位</li>
<li>页长度固定由系统决定，段长度不固定</li>
<li>分页用户程序地址空间是一维的，分段是二维的，既要给出段名又要给出段内地址</li>
</ul>
<h2 id="段页式存储管理方式"><a href="#段页式存储管理方式" class="headerlink" title="段页式存储管理方式"></a>段页式存储管理方式</h2><p><img src="https://i.imgur.com/Epa98nQ.png" alt=""></p>
<p><img src="https://i.imgur.com/VyaIZ0X.png" alt=""></p>
<p><img src="https://i.imgur.com/kQnRsbQ.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/09/处理机调度与死锁/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MakaLoo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MakaL-0-">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/09/处理机调度与死锁/" itemprop="url">处理机调度与死锁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-09T16:56:18+08:00">
                2019-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/05/09/处理机调度与死锁/" class="leancloud_visitors" data-flag-title="处理机调度与死锁">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="处理机调度与死锁"><a href="#处理机调度与死锁" class="headerlink" title="处理机调度与死锁"></a>处理机调度与死锁</h1><h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>处理机调度分为三个层次</p>
<ul>
<li>高级调度：作业调度，调度对象是作业，根据某种算法，决定将外存上处于后备队列的哪几个作业调入内存，为它们创建进程，分配资源，并放入就绪队列，主要用在多道批处理系统，在分时和实时系统中不设置高级调度</li>
<li>低级调度：进程调度，根据某种算法，决定就绪队列中哪几个进程应获得处理机，并由分派程序将处理机分配给被选中的进程，最基本的调度</li>
<li>中级调度：内存调度，主要目的是提高内存利用率和系统吞吐量，把暂时不能运行的进程调至外存等待，此时进程状态称为就绪驻外存状态（或挂起状态），当进程具备运行条件且内存又有空闲时，由中级调度决定，把外存上已具备运行条件的就绪进程重新调入内存，并挂在就绪队列上等待，实际上中级调度是存储器管理的对换功能</li>
</ul>
<p>调度的运行频率是低&gt;中&gt;高</p>
<h4 id="调度队列模型"><a href="#调度队列模型" class="headerlink" title="调度队列模型"></a>调度队列模型</h4><p>仅有进程调度的调度队列模型</p>
<p><img src="https://i.imgur.com/yC8IKjo.png" alt=""></p>
<p>同时具有三级调度的调度队列模型</p>
<p><img src="https://i.imgur.com/NZoTVUp.png" alt=""></p>
<h3 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h3><p>多道批处理系统中，用户提交的作业先存放到外存，排成一个后备队列，作业调度程序按一定算法从后备队列中选择若干作业调入内存，使他们共享CPU和系统资源，当程序A因I/O而暂停执行时，再调度另一道程序B运行，这样可以保持CPU处于忙碌状态</p>
<p>周转时间常用于批处理系统，指从作业被提交给系统开始，到作业完成的时间，分为</p>
<ul>
<li>驻外等待调度时间</li>
<li>驻内等待调度时间</li>
<li>执行时间</li>
<li>阻塞时间</li>
</ul>
<p>平均周转时间可以表示为</p>
<p><img src="https://i.imgur.com/oHUPcXu.png" alt=""></p>
<p>带权周转时间描述进程在其周转时间中，等待和执行时间的具体分配情况，W=T/Ts，T是周转时间，Ts是系统为它提供服务的时间<br>平均带权周转时间表示为</p>
<p><img src="https://i.imgur.com/5R2w6fF.png" alt=""></p>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><h4 id="先来先服务-FCFS-和短作业优先-SJF-调度算法"><a href="#先来先服务-FCFS-和短作业优先-SJF-调度算法" class="headerlink" title="先来先服务(FCFS)和短作业优先(SJF)调度算法"></a>先来先服务(FCFS)和短作业优先(SJF)调度算法</h4><p>它们都可以用于作业调度和进程调度</p>
<p>FCFS(first-come first-served)就不解释了，SJF（short job first)以作业长短计算优先级，作业越短优先级越高，作业长度以作业所要求的运行时间来衡量，SJF缺点是必须预知作业的运行时间，对长作业非常不利，人机无法交互，未考虑作业紧迫程度。</p>
<h5 id="FCFS和SJF的比较"><a href="#FCFS和SJF的比较" class="headerlink" title="FCFS和SJF的比较"></a>FCFS和SJF的比较</h5><p><img src="https://i.imgur.com/cmZuzFf.png" alt=""></p>
<p>在SJF中，当A完成后，此时时间为4，B,C,D,E均已到达，因为D的作业最短，所以处理机先为D服务，然后为B，E，C服务</p>
<h4 id="高优先权优先调度算法"><a href="#高优先权优先调度算法" class="headerlink" title="高优先权优先调度算法"></a>高优先权优先调度算法</h4><p>可以作为作业调度和进程调度</p>
<p>优先级调度算法（PSA，priority-scheduling algorithm）分为非抢占式优先权算法和抢占式优先权算法，抢占式实时性更好</p>
<p>优先权的类型分为</p>
<ul>
<li>静态优先权：整个运行期不变</li>
<li>动态优先权：优先权随执行时间而下降，随等待时间而上升，响应比Pp=(等待时间+服务时间)/服务时间作为优先权，优点是长短兼顾，缺点是需要计算Rp</li>
</ul>
<h5 id="高响应比优先算法-HRRN-Highest-Response-Ratio-Next"><a href="#高响应比优先算法-HRRN-Highest-Response-Ratio-Next" class="headerlink" title="高响应比优先算法(HRRN,Highest Response Ratio Next)"></a>高响应比优先算法(HRRN,Highest Response Ratio Next)</h5><p>响应比Rp=(tw+ts)/ts，tw为等待时间，ts为服务时间</p>
<h4 id="基于时间片的轮转调度算法-RR"><a href="#基于时间片的轮转调度算法-RR" class="headerlink" title="基于时间片的轮转调度算法(RR)"></a>基于时间片的轮转调度算法(RR)</h4><p>进程调度算法，基于时间片的轮转(RR,round robin)让就绪队列上的每个进程每次仅运行一个时间片，每个进程每次大约都可获得1/n的处理机时间</p>
<h5 id="进程切换时间"><a href="#进程切换时间" class="headerlink" title="进程切换时间"></a>进程切换时间</h5><ul>
<li>若一个时间片尚未用完，正在运行的进程已经完成，则激活调度程序，将它从就绪队列中删除，再调度就绪队列中队首的进程运行，并启动一个新的时间片</li>
<li>若时间片用完，计时器中断处理程序激活，调度程序把它送往就绪队列的队尾</li>
</ul>
<h5 id="时间片大小的确定"><a href="#时间片大小的确定" class="headerlink" title="时间片大小的确定"></a>时间片大小的确定</h5><p>若时间片太大，则退化为FCFS，若太小，则系统开销过大，时间片大小确定应考虑系统对响应时间的要求，就绪队列中进程的数目和系统的处理能力（应保证一个时间片处理完常用命令）</p>
<h4 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h4><p>实时调度必须提供：</p>
<ul>
<li>就需时间：某任务成为就绪的起始时间</li>
<li>开始/完成截止时间</li>
<li>处理时间</li>
<li>资源要求</li>
<li>优先级</li>
</ul>
<p>非抢占式用时间片轮转，抢占式可以时钟中断或立即抢占（只要不在临界区就抢占）</p>
<h4 id="常见的实时调度算法"><a href="#常见的实时调度算法" class="headerlink" title="常见的实时调度算法"></a>常见的实时调度算法</h4><h5 id="最早截止时间优先EDF"><a href="#最早截止时间优先EDF" class="headerlink" title="最早截止时间优先EDF"></a>最早截止时间优先EDF</h5><p>根据任务的开始截止时间来确定任务优先级</p>
<h5 id="最低松弛度优先LLF"><a href="#最低松弛度优先LLF" class="headerlink" title="最低松弛度优先LLF"></a>最低松弛度优先LLF</h5><p>松弛（紧急）程度=完成截止时间-处理时间-当前时间</p>
<p>主要用于可抢占的调度方式</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁定义：如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件，那么该组进程是死锁的。</p>
<p>产生死锁的原因</p>
<ul>
<li>竞争资源引起死锁：竞争不可抢占的资源或可消耗资源引起死锁</li>
<li>进程推进顺序不当</li>
</ul>
<p>产生死锁必要条件</p>
<ul>
<li>互斥条件：资源必须互斥</li>
<li>请求和保持条件：进程已经保持至少一个资源但又提出新的资源请求</li>
<li>不可抢占条件：资源不可抢占</li>
<li>循环等待条件：发生死锁时，必然存在一个进程——资源的循环链，即P0等待P1占用的资源，P1等待P2占用的资源，Pn等待P0占用的资源</li>
</ul>
<p>解决死锁的方法</p>
<ul>
<li>预防死锁</li>
<li>避免死锁</li>
<li>检测死锁</li>
<li>解除死锁</li>
</ul>
<h3 id="解决死锁的方法"><a href="#解决死锁的方法" class="headerlink" title="解决死锁的方法"></a>解决死锁的方法</h3><h4 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h4><p>预防死锁：破坏产生死锁的4个必要条件之一，互斥条件一般是不能破坏的，所以主要是破坏产生死锁的后三个条件，预防死锁有效，但资源利用率低</p>
<p>摒弃请求和保持条件：资源一次性分配<br>摒弃不剥夺条件：新申请不能满足就释放已获得资源<br>摒弃环路条件：资源有序分配，为资源编号，申请时按编号进行</p>
<h4 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h4><p>避免死锁是在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁，最经典的避免死锁的算法是银行家算法</p>
<h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><ul>
<li>可利用资源向量Available：含有m个元素的数组，每个元素代表一类可利用的资源数目，初始值是系统配置的该类全部可用资源的数目，Available[j]=K表示系统中现有Rj类资源的最大数目K个</li>
<li>最大需求矩阵Max：是一个n*m的矩阵，定义了系统中n个进程中每一个进程对m类资源的最大需求，如果Max[i, j]=K，则表示进程i需要Rj类资源的最大数目为K</li>
<li>分配矩阵Allocation：n*m矩阵，定义了系统中每一类资源当前已分配给每一进程的资源数，如果Allocation[i, j]=K，则表示进程i当前已分得Rj类资源的数目为K</li>
<li>需求矩阵Need：n*m矩阵，用来表示每一个进程尚需的各类资源数，如果Need[i, j]=K，表示进程i还需要Rj类资源K个</li>
</ul>
<p>Need[i, j] = Max[i, j] - Allocation[i, j]</p>
<h5 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h5><p>设Requesti是进程Pi的请求向量，如果Requesti[j]=K，则表示进程Pi需要K个Rj类的资源，当Pi发出资源请求后，系统按下述步骤进行检查</p>
<ol>
<li>如果Requesti[j] &lt;= Need[i, j]，则转向步骤2，否则认为出错，因为它申请的资源大于它宣布的最大值</li>
<li>如果Requesti[j] &lt;= Available[j]，则转向步骤3，否则尚无足够资源，Pi需等待</li>
<li>系统试探把资源分配给进程Pi，并修改下面数据结构的数值<br> Available[j] = Available[j] - Requesti[j];<br> Allocation[i, j] = Allocation[i, j] + Requesti[j];<br> Need[i, j] = Need[i, j] - Requesti[j];</li>
<li>系统执行安全性算法，检查此次资源分配后系统是否处于安全状态，若安全，才正式分配资源给Pi，否则本次试探分配作废，恢复原来的资源分配状态，让进程Pi等待</li>
</ol>
<h5 id="安全性算法"><a href="#安全性算法" class="headerlink" title="安全性算法"></a>安全性算法</h5><p>如上面所述，<strong>安全性算法是试探性分配后（即修改了Available，Allocation，Need但未正式分配资源）进行的，若安全才正式分配，否则试探分配作废</strong>，算法如下</p>
<ol>
<li>设置两个向量：工作向量Work，表示系统可提供给进程继续运行所需的各类资源数目，含有m个元素，执行安全算法开始时，Work=Available；Finish，它表示系统是否有足够资源分配给进程，使之运行完成。开始时Finish[i]=false，当有足够资源分配给进程时，再令Finish[i]=true</li>
<li>从进程集合中找到一个满足下述条件的进程：<br>Finish[i]=false;<br>Need[i, j] &lt;= Work[j];<br>若找到，则转向步骤3，否则转向步骤4</li>
<li><strong>假如</strong>进程Pi获得资源，则进程Pi可顺利执行，直到完成，并释放分配给它的资源，故应执行<br>Work[j] = Work[j] + Allocation[i, j];<br>Finish[i] = true;<br>go to step 2;</li>
<li>如果所有进程的Finish[i]=true都满足，则表示系统处于安全状态，否则，系统处于不安全状态</li>
</ol>
<h5 id="银行家算法安全性检查的例子"><a href="#银行家算法安全性检查的例子" class="headerlink" title="银行家算法安全性检查的例子"></a>银行家算法安全性检查的例子</h5><p><img src="https://i.imgur.com/vd5ekYs.png" alt=""></p>
<p><img src="https://i.imgur.com/5XOTJlu.png" alt=""></p>
<p>一开始检查，发现p0不满足第2步的条件，p1满足，就把p1的资源释放，加到Work，然后继续检查，p2不满足，p3满足，则释放掉p3的资源，然后释放，最后所有的进程都释放了</p>
<p>P.S.解题的时候，画表，行是每个进程，列依次是Work,Need,Allocation,Work+Allocation,Finish</p>
<h4 id="检测死锁"><a href="#检测死锁" class="headerlink" title="检测死锁"></a>检测死锁</h4><h5 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h5><p><img src="https://i.imgur.com/itV3elJ.png" alt=""></p>
<p>资源分配图圆圈表示进程，方框表示资源，方框内点表示资源数，箭头由资源指向进程表示一个单位的资源分配给进程，进程指向资源表示进程请求一个单位的资源</p>
<h5 id="死锁定理"><a href="#死锁定理" class="headerlink" title="死锁定理"></a>死锁定理</h5><p>S为死锁状态的充分条件是当且仅当S状态的资源分配图是不可完全简化</p>
<h5 id="资源分配图的简化"><a href="#资源分配图的简化" class="headerlink" title="资源分配图的简化"></a>资源分配图的简化</h5><p>找出既不阻塞又非独立的进程结点Pi，去掉所有分配边和请求边，若能去掉所有结点的所有分配边和请求边，则不会发生死锁，否则发生死锁</p>
<h4 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁"></a>解除死锁</h4><p>主要方法</p>
<ul>
<li>抢占资源：从一个或多个进程抢占足够资源分配给死锁进程</li>
<li>终止进程</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/08/进程管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MakaLoo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MakaL-0-">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/08/进程管理/" itemprop="url">进程管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-08T22:06:18+08:00">
                2019-05-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/05/08/进程管理/" class="leancloud_visitors" data-flag-title="进程管理">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程的定义，与程序的区别"><a href="#进程的定义，与程序的区别" class="headerlink" title="进程的定义，与程序的区别"></a>进程的定义，与程序的区别</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位，是程序的一次执行。</p>
<h3 id="与程序的区别"><a href="#与程序的区别" class="headerlink" title="与程序的区别"></a>与程序的区别</h3><table>
<thead>
<tr>
<th style="text-align:left">进程</th>
<th style="text-align:left">程序</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">程序是指令的集合，是静态的概念</td>
<td style="text-align:left">进程是处理机上的一次执行过程，动态的概念</td>
</tr>
<tr>
<td style="text-align:left">程序是长期存在的</td>
<td style="text-align:left">进程有生命周期，有创建，活动和消亡</td>
</tr>
<tr>
<td style="text-align:left">程序是指令的有序集合</td>
<td style="text-align:left">进程由程序，PCB和数据组成</td>
</tr>
<tr>
<td style="text-align:left">程序和进程并非一一对应，同一程序同时运行在若干不同数据集上，它将属于若干个不同进程</td>
<td style="text-align:left">一个进程可以执行多个程序</td>
</tr>
</tbody>
</table>
<h2 id="进程的状态及其转换"><a href="#进程的状态及其转换" class="headerlink" title="进程的状态及其转换"></a>进程的状态及其转换</h2><p>进程三种基本状态分别是</p>
<ul>
<li>就绪状态</li>
<li>执行状态</li>
<li>阻塞状态</li>
</ul>
<p>它们的转换关系如下</p>
<p><img src="https://i.imgur.com/NKJai9R.png" alt=""></p>
<p>引入挂起状态（被换出内存的状态）后，进程的转换如下</p>
<p><img src="https://i.imgur.com/I6mlock.png" alt=""></p>
<h3 id="挂起状态"><a href="#挂起状态" class="headerlink" title="挂起状态"></a>挂起状态</h3><p>挂起状态是把进程从内存移出外存，不释放CPU</p>
<p>而阻塞状态是释放CPU，但不释放内存</p>
<p>引入挂起状态的原因是</p>
<ul>
<li>终端用户请求</li>
<li>父进程请求</li>
<li>负荷调节需要</li>
<li>操作系统需要</li>
</ul>
<h2 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a>进程控制块PCB</h2><h3 id="PCB的作用"><a href="#PCB的作用" class="headerlink" title="PCB的作用"></a>PCB的作用</h3><p>PCB是进程的唯一标识，它常驻内存</p>
<ul>
<li>它作为独立运行基本单位的标志</li>
<li>能实现间断性运行方式</li>
<li>提供进程管理所需要的信息</li>
<li>提供进程调度所需要的信息</li>
<li>实现与其他进程的同步和通信</li>
</ul>
<h3 id="PCB的信息"><a href="#PCB的信息" class="headerlink" title="PCB的信息"></a>PCB的信息</h3><p>PCB主要包括以下四个方面的信息</p>
<ul>
<li>进程标识符：外部标识符（针对用户即进程），内部标识符（针对系统）</li>
<li>处理机状态：通用寄存器，指令计数器，用户栈指针，程序状态字等</li>
<li>进程调度信息：进程状态，进程优先级，进程调度其他信息（已等待CPU时间等），事件（阻塞原因）</li>
<li>进程控制信息：程序和数据地址，进程同步和通信机制，资源清单，链接指针（所在队列下一个进程PCB的首地址）</li>
</ul>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>任务：对系统中所有进程从产生，存在到消亡的全过程实施有效的管理和控制</p>
<p>进程控制由内核中原语实现。</p>
<p>原语（Primitive）：由若干条指令组成，用于完成一定功能的一个过程，它们是原子操作，即所有动作要么全不做，要么全做，是不可分割的，不允许被中断的。原语由内核系统态执行，常驻内存。</p>
<p>常见的进程控制原语如下</p>
<ul>
<li>创建</li>
<li>撤销</li>
<li>阻塞：执行-&gt;阻塞</li>
<li>唤醒：阻塞-&gt;就绪</li>
<li>挂起：活动-&gt;静止</li>
<li>激活：静止-&gt;活动</li>
</ul>
<h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><p>进程创建的过程如下</p>
<ol>
<li>申请空白PCB</li>
<li>为新进程分配资源</li>
<li>初始化PCB</li>
<li>新进程插入到就绪队列</li>
</ol>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>同步指并发进程在执行次序上的协调，以达到有效资源共享和相互合作，是程序执行有可再现性。</p>
<p>进程有两种形式的制约关系，分别是</p>
<ul>
<li>资源共享关系：进程间接制约，需互斥地访问临界资源</li>
<li>相互合作关系：进程直接制约</li>
</ul>
<p>临界资源：一次仅允许一个进程访问的资源</p>
<p>临界区：进程访问临界资源的那段代码</p>
<p>同步机制应遵循：</p>
<ul>
<li>空闲让进</li>
<li>忙则等待</li>
<li>有限等待</li>
<li>让权等待：不能进入临界区的进程应放弃CPU执行权</li>
</ul>
<h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><p>实现进程同步有许多方法，其中比较经典的是信号量机制</p>
<h4 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h4><p>整型信号量定义为用于表示资源数目的整型量S，它除初始化外，仅能通过两个原子操作wait(S)和signal(S)来访问，这两个操作一直被称为P，V操作，wait，signal操作描述如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wait(S) &#123;</span><br><span class="line">	<span class="keyword">while</span> (S &lt;= <span class="number">0</span>);</span><br><span class="line">	S--;</span><br><span class="line">&#125;</span><br><span class="line">signal(S) &#123;</span><br><span class="line">	S++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个操作是原子操作，它们在执行的时候是不可中断的</p>
<h4 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h4><p>整型信号量并没有实现让权等待，而是让进程处于忙等状态，这个时候就需要引入记录型信号量来实现</p>
<p>记录型信号量有一个整型变量value表示资源数目，还有一个进程链表指针list，用于链接上述所有等待进程，定义和PV操作描述如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">process_control_block</span> *<span class="title">list</span>;</span></span><br><span class="line">&#125; semaphore;</span><br><span class="line"></span><br><span class="line">wait(semaphore *S) &#123;</span><br><span class="line">	S-&gt;value--;</span><br><span class="line">	<span class="keyword">if</span> (S-&gt;value &lt; <span class="number">0</span>) block(S-&gt;<span class="built_in">list</span>); <span class="comment">// block是阻塞原语，它的意思是把当前进程自我阻塞并插入到S-&gt;list中</span></span><br><span class="line">&#125;</span><br><span class="line">signal(semaphore *S) &#123;</span><br><span class="line">	S-&gt;value++;</span><br><span class="line">	<span class="keyword">if</span> (S-&gt;value &lt;= <span class="number">0</span>) wakeup(S-&gt;<span class="built_in">list</span>); <span class="comment">// wakeup是唤醒原语</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>S-&gt;value是系统中某类资源数目，对它每次wait，意味进程请求一个单位的该类资源，当S-&gt;value &lt; 0，表示该资源已分配完成，进程应调用block原语自我阻塞，并插入到信号量链表S-&gt;list中。当S-&gt;value &lt; 0，它的绝对值是链表中已阻塞进程的数目。对信号量每次signal操作表示执行进程释放一个单位资源，S-&gt;value++，若+1后S-&gt;value仍然&lt;=0，表示该信号量链表中仍有等待该资源的进程被阻塞，调用wakeup原语唤醒该进程.如果S-&gt;value初值为1，则只允许一个进程访问临界资源，此时信号量为互斥信号量。</p>
<h4 id="AND型信号量"><a href="#AND型信号量" class="headerlink" title="AND型信号量"></a>AND型信号量</h4><p>AND同步机制基本思想是：将进程整个运行过程中需要的所有资源，一次性全部分配给进程，使用后一次性释放，原语为Swait(Simultaneous wait)和Swakeup</p>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>引入原因：为了避免凡要使用临界资源的进程都自备同步操作wait(s)和signal(s)，将同步操作的机制和临界资源结合到一起，形成管程</p>
<p>定义：一个数据结构和能为并发进程所执行的一组操作，包括局部于管程的共享变量，对该数据结构进程操作的一组过程，对局部管程数据设置初值</p>
<p>管程语法描述如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Monitor monitor_name &#123; 		 <span class="comment">// 管程名</span></span><br><span class="line">	share variable declarations; <span class="comment">// 共享变量</span></span><br><span class="line">	cond declarations; 			 <span class="comment">// 条件变量</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">P1</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">	</span>&#123;...&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">	</span>&#123;...&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">void</span>(....)</span><br><span class="line">	&#123;...&#125;</span><br><span class="line">	&#123;							 <span class="comment">// 管程主体</span></span><br><span class="line">		initialization code;	 <span class="comment">// 初始化代码</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>用于进程的阻塞和挂起，形式为condition x, y，对条件变量的操作仅仅是wait和signal，每个条件变量保存一个链表，用于记录因该条件变量而阻塞的所有进程，同时提供两个操作x.wait和x.signal</p>
<p>x.wait：正在调用管程的进程因x条件需要被阻塞或挂起，调用x.wait将自己插入到x条件的等待队列上，并释放管程<br>x.signal：正在调用管程的进程发现x条件发生了变化，则调用它，重新启动一个因x条件而阻塞或挂起的进程</p>
<h2 id="进程同步的经典问题"><a href="#进程同步的经典问题" class="headerlink" title="进程同步的经典问题"></a>进程同步的经典问题</h2><h3 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h3><p>问题描述：一组生产者向一组消费者提供消息，它们共享一个包含n个缓冲区的有界缓冲池，生产者向其中投放消息，消费者从中取得消息</p>
<p>问题求解：<strong>互斥信号量mutex实现诸进程对缓冲池的互斥使用，信号量empty和full分别表示缓冲池中空缓冲区和满缓冲区的数量</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> in = <span class="number">0</span>, out = <span class="number">0</span>;</span><br><span class="line">item buffer[n];</span><br><span class="line">semaphore mutex = <span class="number">1</span>, empty = n, full = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		produce an item nextp;</span><br><span class="line">		...</span><br><span class="line">		wait(empty); <span class="comment">// 当空缓冲池数量为0，即缓冲池已满</span></span><br><span class="line">		wait(mutex);</span><br><span class="line">		buffer[in] = nextp;</span><br><span class="line">		in = (in + <span class="number">1</span>) % n;</span><br><span class="line">		signal(mutex);</span><br><span class="line">		signal(full);</span><br><span class="line">	&#125; <span class="keyword">while</span> (TRUE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		wait(full); <span class="comment">// 当满缓冲池为0，即缓冲池已空</span></span><br><span class="line">		wait(mutex);</span><br><span class="line">		nextc = buffer[out];</span><br><span class="line">		out = (out + <span class="number">1</span>) % n;</span><br><span class="line">		signal(mutex);</span><br><span class="line">		signal(empty);</span><br><span class="line">	consume the item in nextc;</span><br><span class="line">	...</span><br><span class="line">	&#125; <span class="keyword">while</span> (TRUE);	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cobegin</span><br><span class="line">		producer(); consumer();</span><br><span class="line">	coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>P操作很重要，假如颠倒了生产者的P操作，先拥有了缓冲池的使用权，但此时无空缓冲池，则会进入死锁</strong>，V操作顺序则无关紧要，<strong>当缓冲区只有一个时，mutex可以省略</strong></p>
<h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><p><img src="https://i.imgur.com/PST5Kvw.png" alt=""></p>
<p>哲学家进餐应定义5个信号量表示5只筷子，且初值均为1，而不能定义1个信号量，因为5个筷子位置不同，哲学家并不是随意拿5个筷子的，他们只能拿他们左右最靠近他们的筷子，描述如下<br><code>semaphore chopstick[5] = {1, 1, 1, 1, 1};</code></p>
<p>第i个哲学家的活动可描述为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	wait(chopstick[i]);</span><br><span class="line">	wait(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// eat</span></span><br><span class="line">	...</span><br><span class="line">	signal(chopstick[i]);</span><br><span class="line">	signal(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// think</span></span><br><span class="line">	...</span><br><span class="line">&#125; <span class="keyword">while</span>(TRUE)</span><br></pre></td></tr></table></figure>
<p>哲学家问题出现死锁的可能是：五个哲学家同时饥饿而各自拿起左边的筷子，就会使5个信号量chopstick均为0，当他们再试图去拿右边的筷子时，会因没有筷子可拿而无限等待</p>
<p>解决方法有如下几个：</p>
<p>1.至多允许有4位哲学家同时拿左边筷子，方法：设置信号量sm初值为4</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">philopher(i) &#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		wait(sm);</span><br><span class="line">		wait(chopstick[i]);</span><br><span class="line">		wait(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">		eat;</span><br><span class="line">		signal(sm);</span><br><span class="line">		signal(chopstick[i]);</span><br><span class="line">		signal(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">		signal(sm);</span><br><span class="line">		think;</span><br><span class="line">	&#125; <span class="keyword">while</span> (TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.规定奇数号哲学家先拿他左手边的筷子，再拿右手边的筷子，偶数号哲学家相反</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">philopher(i) &#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">			wait(chopstick[i]);</span><br><span class="line">			wait(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">			eat;</span><br><span class="line">			signal(chopstick[i]);</span><br><span class="line">			signal(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			wait(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">			wait(chopstick[i]);</span><br><span class="line">			eat;</span><br><span class="line">			signal(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">			signal(chopstick[i]);</span><br><span class="line">		&#125;	</span><br><span class="line">		think;</span><br><span class="line">	&#125; <span class="keyword">while</span> (TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.仅当左右手两只筷子均可用的时候，才拿起筷子进餐，利用AND信号量解决</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">philopher(i) &#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		Sswait(chopstick[i], chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>])</span><br><span class="line">		eat;</span><br><span class="line">		Ssignal(chopstick[i], chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">		think;</span><br><span class="line">	&#125; <span class="keyword">while</span> (TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h3><p>问题描述：读进程可共享同一对象，写进程不可共享同一对象</p>
<p>分析：整型变量readcount表示读者数，信号量rmutex互斥访问readcount，wmutex读写互斥，只要有一个进程在读，就不允许写进程去写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">semaphore rmutex = <span class="number">1</span>, wmutex = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> readcount = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		wait(rmutex); <span class="comment">// readcount的互斥访问</span></span><br><span class="line">		<span class="keyword">if</span> (readcount == <span class="number">0</span>) wait(wmutex); <span class="comment">// 读写互斥，当该进程为第一个读进程，判断是否有写进程在写，有则阻塞，无则加锁</span></span><br><span class="line">		readcount++;</span><br><span class="line">		signal(rmutex);</span><br><span class="line">		...</span><br><span class="line">		perform read operation;</span><br><span class="line">		...</span><br><span class="line">		wait(rmutex);</span><br><span class="line">		readcount--;</span><br><span class="line">		<span class="keyword">if</span> (readcount == <span class="number">0</span>) signal(wmutex);</span><br><span class="line">		signal(rmutex);</span><br><span class="line">	&#125; <span class="keyword">while</span> (TRUE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		wait(wmutex);</span><br><span class="line">		perform write operation;</span><br><span class="line">		signal(wmutex);</span><br><span class="line">	&#125; <span class="keyword">while</span> (TRUE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cobegin</span><br><span class="line">		reader(); writer();</span><br><span class="line">	coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="读-写问题的扩散——写者优先"><a href="#读-写问题的扩散——写者优先" class="headerlink" title="读-写问题的扩散——写者优先"></a>读-写问题的扩散——写者优先</h4><p>即当写进程到达后，后续的读进程必须等待</p>
<p>方法：增加信号量S（初值1），当写进程运行时上锁，封锁后续读者。增加信号量s后，当读进程读，先wait(s)，若后续读进程运行，都会进入s的阻塞队列，而不会在其他进程读的期间（上锁了s，没有上锁rmutex）进入wmutex的阻塞队列，当有写进程运行并进入s的阻塞队列，后续再有读进程进入s的阻塞队列，都排在写进程之后，当前面读进程释放s后，写进程就可以对s上锁，阻止后续读进程了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">semaphore rmutex = <span class="number">1</span>, wmutex = <span class="number">1</span>, s = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> readcount = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		wait(s);</span><br><span class="line">		wait(rmutex); <span class="comment">// readcount的互斥访问</span></span><br><span class="line">		<span class="keyword">if</span> (readcount == <span class="number">0</span>) wait(wmutex); <span class="comment">// 读写互斥，当该进程为第一个读进程，判断是否有写进程在写，有则阻塞，无则加锁</span></span><br><span class="line">		readcount++;</span><br><span class="line">		signal(rmutex);</span><br><span class="line">		signal(s);</span><br><span class="line">		...</span><br><span class="line">		perform read operation;</span><br><span class="line">		...</span><br><span class="line">		wait(rmutex);</span><br><span class="line">		readcount--;</span><br><span class="line">		<span class="keyword">if</span> (readcount == <span class="number">0</span>) signal(wmutex);</span><br><span class="line">		signal(rmutex);</span><br><span class="line">	&#125; <span class="keyword">while</span> (TRUE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		wait(s);</span><br><span class="line">		wait(wmutex);</span><br><span class="line">		perform write operation;</span><br><span class="line">		signal(wmutex);</span><br><span class="line">		signal(s);</span><br><span class="line">	&#125; <span class="keyword">while</span> (TRUE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cobegin</span><br><span class="line">		reader(); writer();</span><br><span class="line">	coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程通信实质是进程间的信息交换，有如下几种通信方式</p>
<ul>
<li>信号量机制：低级，效率低，对用户不透明</li>
<li>共享存贮器：共享存储区等</li>
<li>消息传递系统：交换报文，由一组通信原语实现</li>
<li>管道通信：管道是连接一个读进程和一个写进程之间通信的共享文件</li>
<li>客户机-服务器系统：套接字等</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/10/JavaScript09-事件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MakaLoo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MakaL-0-">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/10/JavaScript09-事件/" itemprop="url">JavaScript09-事件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-10T11:08:34+08:00">
                2019-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/04/10/JavaScript09-事件/" class="leancloud_visitors" data-flag-title="JavaScript09-事件">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JavaScript09-事件"><a href="#JavaScript09-事件" class="headerlink" title="JavaScript09-事件"></a>JavaScript09-事件</h1><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>事件流描述的是从页面中接收事件的顺序。如果单击某个按钮，那么单击事件不仅仅发生在按钮上，同样发生在按钮的容器元素，甚至整个页面上。<strong>事件冒泡就是最具体的元素最先接收这个事件，然后逐级向上，事件捕获则相反。</strong></p>
<h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>事件冒泡是IE提出的，即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>aha<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>点击&lt;div&gt;元素，那么这个click事件就按照如下顺序传播：</p>
<ol>
<li>&lt;div&gt;</li>
<li>&lt;body&gt;</li>
<li>&lt;html&gt;</li>
<li>document</li>
</ol>
<h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>Netscape Communicator团队提出的另一种事件流。事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。仍以上面html代码为例，单击&lt;div&gt;元素就会以下列顺序触发click事件</p>
<ol>
<li>document</li>
<li>&lt;html&gt;</li>
<li>&lt;body&gt;</li>
<li>&lt;div&gt;</li>
</ol>
<p>一般考虑到老版本，使用事件冒泡更多。</p>
<h3 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h3><p>DOM2级事件规定的事件流包括三个阶段：事件捕获阶段，处于目标阶段和事件冒泡阶段。</p>
<h2 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h2><p>事件处理程序名字以”on”开头，因此click事件的事件处理程序就是onclick，load事件的事件处理程序就是onload。</p>
<h3 id="HTML事件处理程序"><a href="#HTML事件处理程序" class="headerlink" title="HTML事件处理程序"></a>HTML事件处理程序</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">showMessage</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">"Hello World!"</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"showMessage()"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样指定事件处理程序会创建一个封装着元素属性值的函数，这个函数中有一个局部变量event，也就是事件对象</p>
<p><code>&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(event.type)&quot; /&gt; // &quot;click&quot;</code></p>
<p>通过event对象，可以直接访问事件对象，在这个函数内部，this值等于事件的目标元素</p>
<p><code>&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(this.value)&quot; /&gt; // 返回元素的value属性，这里为&quot;Click Me&quot;</code></p>
<p>关于这个动态创建的函数，可以像访问局部变量一样访问document及该元素本身的成员，使用with像下面这样扩展：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">with</span>(<span class="built_in">document</span>)  &#123;</span><br><span class="line">		<span class="keyword">with</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">			<span class="comment">// 元素属性值</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前元素是一个表单输入元素，则作用域还会包含访问表单元素的入口，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">with</span>(<span class="built_in">document</span>)  &#123;</span><br><span class="line">		<span class="keyword">with</span>(<span class="keyword">this</span>.form) &#123;</span><br><span class="line">			<span class="keyword">with</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">				<span class="comment">// 元素属性值</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>扩展这个作用域的方式，主要是想让事件处理程序无需引用表单元素就能访问其他表单字段，例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Echo Username"</span> <span class="attr">onclick</span>=<span class="string">"alert(username.value)"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="DOM0级事件处理程序"><a href="#DOM0级事件处理程序" class="headerlink" title="DOM0级事件处理程序"></a>DOM0级事件处理程序</h3><p>通过JavaScript指定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性。如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var btn = document.getElementById(&quot;myBtn&quot;);</span><br><span class="line">btn.onclick = function() &#123;</span><br><span class="line">    alert(&quot;Clicked&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用DOM0级方法执行的事件处理程序被认为是元素的方法，程序中的this引用的是当前元素。<br>只需把属性值设置为null就可以删除事件处理程序</p>
<h3 id="DOM2级事件处理程序"><a href="#DOM2级事件处理程序" class="headerlink" title="DOM2级事件处理程序"></a>DOM2级事件处理程序</h3><p>DOM2级事件定义了两个方法，用于处理指定和删除事件处理程序的操作：addEventListener()和removeEventListener()。所有DOM节点都包含这两个方法，它们接收3个参数：要处理的事件名，作为事件处理程序的函数和一个布尔值。这个布尔值若为true，表示捕获阶段调用事件处理程序；如果是false，表示冒泡阶段调用事件处理程序。</p>
<p>DOM2级方法主要好处是可以添加多个事件处理程序，如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"Hello World!"</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>通过addEventListener()添加的事件处理程序只能使用removeEventListener()来移除；移除时传入的参数要与添加处理程序时使用的参数相同，即添加的匿名参数无法移除。</p>
<p>大多数情况下，都是把事件处理程序添加到事件流的冒泡阶段，这样可以最大限度地兼容各种浏览器。最好只在需要在事件到达目标之前截获它的时候将事件处理程序添加到捕获阶段。如果不是特别需要，不建议在事件捕获阶段注册事件处理程序。</p>
<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>在触发DOM上某个事件时，会产生一个事件对象event，这个对象中包含所有与事件有关的信息，包括导致事件的元素，事件的类型以及其他与特定事件相关的信息。例如鼠标操作导致的鼠标位置的信息等。</p>
<h3 id="DOM中的事件对象"><a href="#DOM中的事件对象" class="headerlink" title="DOM中的事件对象"></a>DOM中的事件对象</h3><p>兼容DOM的浏览器会将一个event对象传入到事件处理程序中。</p>
<p>关于event的更多（比如其成员),可以看<a href="https://developer.mozilla.org/en-US/docs/Web/API/Event" target="_blank" rel="noopener">MDN的DOM Event接口</a></p>
<p>如果事件处理程序指定给目标元素，则this，currentTarget和target是相同的，事件处理程序内部，对象this始终等于currentTarget的值，如果事件处理程序存在于父节点中，则这些值是不同的，如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(event.currentTarget == <span class="built_in">document</span>.body);</span><br><span class="line">    alert(<span class="built_in">document</span>.body == <span class="keyword">this</span>);</span><br><span class="line">    alert(event.target == btn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要处理一个函数处理多个事件的时候，可以使用type属性，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(event.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"click"</span> :</span><br><span class="line">            alert(<span class="string">"clicked"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"mouseover"</span> :</span><br><span class="line">            event.target.style.backgroundColor = <span class="string">"red"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"mouseout"</span> :</span><br><span class="line">            event.target.style.backgroundColor = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">btn.onclick = handler;</span><br><span class="line">btn.onmouseover = handler;</span><br><span class="line">btn.onmouseout = handler;</span><br></pre></td></tr></table></figure>
<p>要阻止特定事件的默认行为，可以使用preventDefault()方法。例如，链接的默认行为就是在被单击的时候会导航到其href特性指定的URL。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.getElementById(<span class="string">"myLink"</span>);</span><br><span class="line">link.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有cancelable属性设置为true的事件，才可以使用preventDefault()方法来取消默认行为。</p>
<p>stopPropagation()方法用于立即停止事件在DOM层次中的传播，即取消进一步事件捕获或冒泡。例如，直接添加到一个按钮的事件处理程序可以调用stopPropagation()，从而避免触发注册在document.body上面的事件处理程序。</p>
<p>eventPhase属性可以用来确定事件当前位于事件流的哪个阶段。如果是在捕获阶段调用事件处理程序，那么eventPhase的值为1，如果事件处理程序在目标对象上，则eventPhase值为2，如果是在冒泡阶段调用的事件处理程序，eventPhase等于3。</p>
<h3 id="跨浏览器的事件对象"><a href="#跨浏览器的事件对象" class="headerlink" title="跨浏览器的事件对象"></a>跨浏览器的事件对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line"></span><br><span class="line">    addHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">            element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">            <span class="comment">// IE事件处理程序</span></span><br><span class="line">            element.attachEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            element[<span class="string">"on"</span> + type] = handler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    getEvent: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> event ? event : <span class="built_in">window</span>.event;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    getTarget: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> event.target || event.srcElement;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    preventDefault: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event.preventDefault) &#123;</span><br><span class="line">            event.preventDefault();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            event.returnValue = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    removeHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (element.removeEventListener) &#123;</span><br><span class="line">            element.removeEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</span><br><span class="line">            element.detachEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            element[<span class="string">"on"</span> + type] = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    stopPropagation: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event.stopPropagation) &#123;</span><br><span class="line">            event.stopPropagation();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与mouseout，mouseover事件相关的属性，见下面</span></span><br><span class="line">    getRelatedTarget: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event.relatedTarget) &#123;</span><br><span class="line">            <span class="keyword">return</span> event.relatedTarget;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.toElement) &#123;</span><br><span class="line">            <span class="comment">// 兼容IE8</span></span><br><span class="line">            <span class="keyword">return</span> event.toElement;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.fromElement) &#123;</span><br><span class="line">            <span class="keyword">return</span> event.fromElement;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 与mousedown，mouseout事件相关的鼠标属性</span></span><br><span class="line">	getButton: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">document</span>.implementation.hasFeature(<span class="string">"MouseEvents"</span>, <span class="string">"2.0"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> event.button;    </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span>(event.button) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><p>DOM3级事件规定了以下几类事件</p>
<ul>
<li>UI事件：当用户与页面上的元素交互时触发；</li>
<li>焦点事件：当元素获得或失去焦点时触发；</li>
<li>鼠标事件：当用户通过鼠标在页面上执行操作时触发；</li>
<li>滚轮事件：当使用鼠标滚轮时触发；</li>
<li>文本事件：当在文档中输入文本时触发；</li>
<li>键盘事件：当用户通过键盘在页面上执行操作时触发；</li>
<li>合成事件：当为IME（输入法编辑器）输入字符时触发；</li>
<li>变动事件：当底层DOM结构发生变化时触发。</li>
</ul>
<h3 id="UI事件"><a href="#UI事件" class="headerlink" title="UI事件"></a>UI事件</h3><p>UI事件指的是那些不一定与用户操作有关的事件，有如下UI事件。</p>
<ul>
<li>load：当页面完全加载后在window上触发，当所有框架都加载完毕时在框架集上触发，当图像加载完毕在&lt;img&gt;元素上触发，或者当嵌入的内容加载完毕时在&lt;object&gt;元素上触发。</li>
<li>unload：当页面完全卸载后在window上触发，当所有框架都卸载后在框架集上触发，或当嵌入的内容卸载后在&lt;object&gt;元素上触发。</li>
<li>abort：在用户停止下载过程时，如果浅入的内容没有加载完，则在&lt;object&gt;元素上触发。</li>
<li>error：当发生在JavaScript错误时在window上触发，当无法加载图像时在&lt;img&gt;上触发，当无法加载嵌入内容时在&lt;object&gt;上触发，或者当有一或多个框架无法加载时在框架集上触发。</li>
<li>select：当用户选择文本框（&lt;input&gt;或&lt;texterea&gt;）中的一或多个字符时触发。</li>
<li>resize：当窗口或框架大小变化时在window或框架上触发。</li>
<li>scroll：当用户滚动带滚动条的元素中的内容时，在该元素上触发。&lt;body&gt;元素中包含所加载页面的滚动条。</li>
</ul>
<p>确定浏览器是否支持DOM2级事件规定的HTML事件，可以用如下代码</p>
<p><code>var isSupported = document.implementation.hasFeature(&quot;HTMLEvents&quot;, &quot;2.0&quot;);</code></p>
<p>确定浏览器是否支持DOM3级事件定义的事件，可以用如下代码</p>
<p><code>var isSupported = document.implementation.hasFeature(&quot;UIEvent&quot;, &quot;3.0&quot;);</code></p>
<h4 id="load事件"><a href="#load事件" class="headerlink" title="load事件"></a>load事件</h4><p>当页面完全加载后（包括所有图像，JS文件，CSS等外部资源），就会触发window上的load事件。</p>
<p>有两种添加onload事件处理程序的方式，一个是使用上面的EventUtil，另一个就是给&lt;body&gt;元素添加onload特性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"loaded!"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>&lt;body onload=&quot;alert(&#39;Loaded!&#39;)&quot;&gt;&lt;/body&gt;</code></p>
<p>一般来说，在window上面发生的任何事件都可以在&lt;body&gt;元素中通过相应的特性来指定。</p>
<p>对于&lt;img&gt;元素，可以为其指定一个事件处理程序，以便图像加载完毕后给出提示。此时，<strong>最重要的是要在指定的属性之前先加载指定事件。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> image = <span class="built_in">document</span>.createElement(<span class="string">"img"</span>);</span><br><span class="line">    EventUtil.addHandler(image, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        event = EventUtil.getEvent(event);</span><br><span class="line">        alert(EventUtil.getTarget(event).src);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line">    image.src = <span class="string">"./a.jpg"</span>;    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>还有一些元素也以非标准方式支持load事件，&lt;script&gt;元素也会触发load事件，以便开发人员确定动态加载的JS文件是否加载完毕。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">    EventUtil.addHandler(script, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">"Loaded!"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    script.src = <span class="string">"example.js"</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="unload事件"><a href="#unload事件" class="headerlink" title="unload事件"></a>unload事件</h4><p>在文档被完全卸载后触发。只要用户从一个页面切换到另一个页面，就会发生unload事件。利用这个事件最多的情况就是清除引用，以避免内存泄漏。unload事件的对象同样是window。</p>
<h4 id="resize事件"><a href="#resize事件" class="headerlink" title="resize事件"></a>resize事件</h4><p>当浏览器窗口被调整到一个新的高度或宽度的时候，就会触发resize事件。这个事件在window上触发。不同浏览器resize事件处理不同，有可能是变化了1像素就触发，然后随着变化不断重复触发，也有可能用户停止调整窗口大小的时候才触发。</p>
<h4 id="scroll事件"><a href="#scroll事件" class="headerlink" title="scroll事件"></a>scroll事件</h4><p>scroll事件同样是在window上发生的，尽管它实际表示的是页面中相应元素的变化。scroll事件在滚动期间重复被触发。</p>
<h3 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h3><p>焦点事件会在页面元素获得或失去焦点时触发。利用这些元素并与document.hasFocus()方法及document.activeElement属性配合，可以知晓用户在页面上的行踪。有以下6个焦点事件。</p>
<ul>
<li>blur：在元素失去焦点时触发。这个事件不会冒泡。</li>
<li>focus：元素获得焦点的时候触发。不会冒泡。</li>
<li>focusin：元素获得焦点时触发，与HTML事件focus等价。</li>
<li>focusout：元素失去焦点时触发。</li>
</ul>
<p>当焦点从页面中一个元素移动到另一个元素，会依次触发下列事件：</p>
<ol>
<li>focusout在失去焦点元素上触发。</li>
<li>focusin在获得焦点元素上触发。</li>
<li>blur</li>
<li>focus</li>
</ol>
<p>确定浏览器是否支持这些事件：</p>
<p><code>var isSupported = document.implementation.hasFeature(&quot;FocusEvent&quot;, &quot;3.0&quot;);</code></p>
<h3 id="鼠标与滚轮事件"><a href="#鼠标与滚轮事件" class="headerlink" title="鼠标与滚轮事件"></a>鼠标与滚轮事件</h3><ul>
<li>click：用户单击主鼠标按钮或按下回车触发。</li>
<li>dblclick：用户双击主鼠标按钮触发。</li>
<li>mousedown：用户按下任意鼠标按钮触发。</li>
<li>mouseenter：鼠标光标从元素外部首次移动到元素范围之内时触发。这个事件不冒泡，在光标移动到后代元素上不会触发。</li>
<li>mouseleave：在位于元素上方的鼠标光标移动到元素范围之外时触发。这个事件不冒泡，光标移到后代元素上不会触发。</li>
<li>mousemove：鼠标指针在元素内部移动时重复触发。</li>
<li>mouseout：鼠标指针位于一个元素上方，然后用户将其移入到另一个元素时触发。另一个元素可以是该元素的外部元素或子元素。</li>
<li>mouseover：鼠标指针位于一个元素外部，首次移入另一个元素边界之内触发。</li>
<li>mouseup：用户释放鼠标按钮时触发。</li>
</ul>
<p>检查是否支持上面事件可以使用如下代码</p>
<p><code>var isSupported = document.implementation.hasFeature(&quot;MouseEvent&quot;, &quot;3.0&quot;);
alert(isSupported);</code></p>
<h4 id="客户区坐标位置"><a href="#客户区坐标位置" class="headerlink" title="客户区坐标位置"></a>客户区坐标位置</h4><p>鼠标事件都是在浏览器视口中的特定位置上发生的，这个位置信息保存在事件对象的clientX和clientY属性中。<br><a href="https://blog.csdn.net/zshsats/article/details/79942126" target="_blank" rel="noopener">视口坐标，页面坐标，屏幕坐标的区别可以看这个</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line">EventUtil.addHandler(div, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    alert(<span class="string">"Client coordinates: "</span> + event.clientX + <span class="string">","</span> + event.clientY);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="页面坐标位置"><a href="#页面坐标位置" class="headerlink" title="页面坐标位置"></a>页面坐标位置</h4><p>通过客户区坐标位置能够知道鼠标是在视口中什么位置发生的，而页面坐标通过事件对象的pageX和pageY属性，告诉你事件是在页面中什么位置发生的。这两个属性表示鼠标光标在页面中的位置。坐标是从页面本身而非视口左边和顶边计算。</p>
<p><strong>当页面没有滚动的的时候，页面坐标等于视口坐标，如果有滚动，页面坐标为滚动高度加上视口坐标。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line">EventUtil.addHandler(div, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    alert(<span class="string">"Page coordinates: "</span> + event.pageX + <span class="string">","</span> + event.pageY);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="屏幕坐标位置"><a href="#屏幕坐标位置" class="headerlink" title="屏幕坐标位置"></a>屏幕坐标位置</h4><p>屏幕坐标位置是相对于整个电脑屏幕的位置。属性为screenX和screenY。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line">EventUtil.addHandler(div, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    alert(<span class="string">"Screen coordinates: "</span> + event.screenX + <span class="string">","</span> + event.screenY);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="修改键"><a href="#修改键" class="headerlink" title="修改键"></a>修改键</h4><p>按下鼠标时键盘上的某些键的状态也可以影响到所要采取的操作。这些修改键是Shift，Ctrl，Alt和Meta（Windows的win键）。<strong>DOM为此规定了4个属性，表示这4个修改键的状态：shiftKey，ctrlKey，altKey和metaKey。这些属性中包含的都是布尔值</strong>，如果相应键按下，值为true，否则为false。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line">EventUtil.addHandler(div, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    <span class="keyword">var</span> keys = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event.shiftKey) &#123;</span><br><span class="line">        keys.push(<span class="string">"shift"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event.ctrlKey) &#123;</span><br><span class="line">        keys.push(<span class="string">"ctrl"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event.altKey) &#123;</span><br><span class="line">        keys.push(<span class="string">"alt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event.metaKey) &#123;</span><br><span class="line">        keys.push(<span class="string">"meta"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    alert(<span class="string">"Keys: "</span> + keys.join(<span class="string">","</span>));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="相关元素"><a href="#相关元素" class="headerlink" title="相关元素"></a>相关元素</h4><p>发生mouseover和mouseout事件时，还会涉及更多的元素。这两个事件都会涉及把鼠标指针从一个元素的边界之内移动到另一个元素的边界之内。<strong>对mouseover事件而言，事件的主目标是获得光标的元素，而相关元素是那个失去光标的元素。</strong>类似地，对mouseout事件而言，事件的主目标是失去光标的元素，而相关元素则是获得光标的元素。</p>
<p>DOM通过event对象的relatedTarget属性提供了相关元素的信息。这个属性只对mouseover和mouseout事件才包含值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line">EventUtil.addHandler(div, <span class="string">"mouseout"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    <span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line">    <span class="keyword">var</span> relatedTarget = EventUtil.getRelatedTarget(event);</span><br><span class="line">    alert(<span class="string">"Mouse out of "</span> + target.tagName + <span class="string">" to "</span> + relatedTarget.tagName);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="鼠标按钮"><a href="#鼠标按钮" class="headerlink" title="鼠标按钮"></a>鼠标按钮</h4><p>只有在主鼠标按钮被单击（或键盘回车被按下）的时候才会触发click事件，因此检测按钮的信息并不是必要的。但<strong>对于mousedown和mouseup事件来说，在其event对象内存在一个button属性，表示按下或释放的按钮。DOM的button属性可能有如下3个值：0表示主鼠标按钮，1表示中间鼠标按钮（滚轮按钮），2表示次鼠标按钮。</strong>IE8之前的button属性与DOM有很大差异，不做表述。具体的兼容鼠标检测见上面EventUtil</p>
<h4 id="更多的事件信息"><a href="#更多的事件信息" class="headerlink" title="更多的事件信息"></a>更多的事件信息</h4><p>DOM2级事件规范在event事件中还提供了detail属性，用于给出有关事件的更多信息。对于鼠标事件来说，detail中包含一个数值，表示在给定位置上发生了多少次单击。同一元素上相继发生一次mousedown和一次mouseup事件算一次单击。detail属性从1开始计数，每次单击后递增。如果鼠标在mouseup和mousedown之间移动了位置，detail会被重置为0.</p>
<h4 id="鼠标滚轮事件"><a href="#鼠标滚轮事件" class="headerlink" title="鼠标滚轮事件"></a>鼠标滚轮事件</h4><p>mousewheel事件，当用户通过鼠标滚轮与页面发生交互，在垂直方向上滚动页面时（无论向上向下），就会触发mousewheel事件。这个事件可以在任何元素上触发，最终冒泡到window对象。mousewheel事件包含一个特殊的wheelDelta属性。当用户向前滚动鼠标滚轮，wheelDelta是120的倍数，当用户向后滚动滚轮，wheelDelta是-120的倍数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">"mousewheel"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    alert(event.wheelDelta);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>跨浏览器的解决方案</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getWheelDelta: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.wheelDelta) &#123;</span><br><span class="line">        <span class="keyword">return</span> (client.engine.opera &amp;&amp; client.engine.opera &lt; <span class="number">9.5</span> ? -event.wheelDelta : event.wheelDelta);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -event.detail * <span class="number">40</span>; <span class="comment">//兼容Firefox</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="键盘与文本事件"><a href="#键盘与文本事件" class="headerlink" title="键盘与文本事件"></a>键盘与文本事件</h3><p>有三个键盘事件，如下：</p>
<ul>
<li>keydown：当用户按下键盘上的任意键时触发，如果按住不放，则重复触发。</li>
<li>keypress：当用户按下键盘上的字符键时触发，如果按住不放会重复触发。</li>
<li>keyup：当用户释放键盘上的键时触发。</li>
</ul>
<p>用户按下一个字符键时，首先触发keydown，其次是keypress，最后是keyup。键盘事件同样也有shiftKey，ctrlKey，altKey和metaKey。</p>
<h4 id="键码"><a href="#键码" class="headerlink" title="键码"></a>键码</h4><p>在发生keydown和keyup事件时，event对象的keyCode属性会包含一个代码。对数字字母字符键，keyCode属性的值与ASCII中对应小写字母或数字的编码相同。<a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode" target="_blank" rel="noopener">其他keyCode值在这里！</a></p>
<h4 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h4><p>charCode属性<strong>只有在发生keypress事件时</strong>才包含值，而且<strong>这个值是按下的那个键所代表的字符的ASCII编码</strong>。此时keyCode通常等于0或者也可能等于所按键的键码。对于IE8及其之前版本和Opera，则用keyCode来保存字符的ASCII编码，跨浏览器获取字符编码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getCharCode: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> event.charCode == <span class="string">"number"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> event.charCode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> event.keyCode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在DOM3级事件中，不再有charCode属性，而是key和char属性。<br>key属性是一个字符串，当按下字符键，他的值是字符键的值（如”A”，”k”），当按下非字符键，他的值是相应键的名（如”Shift”，”Down”）。<br>char属性按下字符键时显示字符键的值，按下非字符键，显示null。<br>（存在跨浏览器的问题，所以不推荐使用上面两个值，以及Chorme和Safari 5的KeyIdentifier）</p>
<h4 id="textInput事件"><a href="#textInput事件" class="headerlink" title="textInput事件"></a>textInput事件</h4><p>DOM3级事件规范引入的一个新事件，当用户在可编辑区域输入字符时，就会触发这个事件。任何可以获得焦点的元素都可以触发keypress事件，但只有可编辑区域才会触发textInput事件。textInput只会在用户按下能够输入实际字符的键时才会被触发，而keypress事件则在按下那些能够影响文本显示的键时也会触发（比如退格）。</p>
<p>textInput事件有一个data属性，表示用户输入的字符。</p>
<h3 id="变动事件"><a href="#变动事件" class="headerlink" title="变动事件"></a>变动事件</h3><p>DOM2级的变动事件能在DOM中某一部分发生变化时给出提示。为XML或HTML DOM设计。DOM2级定义了如下变动事件。</p>
<ul>
<li>DOMSubtreeModified：在DOM结构中发生任何变化时触发。这个事件在其他任何事件触发后都会触发。</li>
<li>DOMNodeInserted：在一个结点作为子节点被插入到另一个节点中触发。</li>
<li>DOMNodeRemoved：在结点从其父节点中被移除时触发。</li>
</ul>
<p><code>var isSupported = document.implementation.hasFeature(&quot;MutationEvents&quot;, &quot;2.0&quot;);</code>检查是否支持变动事件。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Mutation_events" target="_blank" rel="noopener">MDN的mutation事件</a></p>
<h3 id="设备事件与触摸手势事件"><a href="#设备事件与触摸手势事件" class="headerlink" title="设备事件与触摸手势事件"></a>设备事件与触摸手势事件</h3><p>主要用于智能手机和平板电脑</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/10/DNS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MakaLoo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MakaL-0-">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/10/DNS/" itemprop="url">计算机网络之DNS服务</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-10T11:08:34+08:00">
                2019-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/04/10/DNS/" class="leancloud_visitors" data-flag-title="计算机网络之DNS服务">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>DNS是计算机网络应用层一个很重要的服务，了解它基本就了解了整个网络中域名到IP转换的过程。</p>
<h2 id="DNS是什么"><a href="#DNS是什么" class="headerlink" title="DNS是什么"></a>DNS是什么</h2><p>在《计算机网络-自顶向下方法》中有这么一句话</p>
<blockquote>
<p>DNS：因特网的目录服务</p>
</blockquote>
<p>DNS（Domain Name System）其实就是一个目录，他的作用是通过用户给定域名，查出对应的IP地址。</p>
<p>而更为严格的定义就是：<br>DNS是：</p>
<ul>
<li>一个由分层的DNS服务器实现的分布式数据库</li>
<li>一个使得主机能够查询分布式数据库的应用层协议</li>
</ul>
<p>或者说DNS是一个黑盒子，它提供了主机名到IP地址的转换，一个简便的DNS黑盒子过程如下：</p>
<ol>
<li>同一台用户主机上运行着DNS应用的客户端</li>
<li>浏览器从URL中抽取出主机名，传给DNS应用的客户端</li>
<li>DNS客户向DNS服务器发送一个包含主机名的请求</li>
<li>DNS客户最终收到一份回答报文，其中含有对应该主机名的IP地址</li>
<li>一旦浏览器获得该地址，就可以向位于该IP地址的80端口的HTTP服务器进程发起一个TCP连接</li>
</ol>
<p>DNS主要任务是主机名到IP地址转换的目录服务<br>DNS除了有主机名到IP地址的转换服务外，还有如下服务：</p>
<ul>
<li>主机别名</li>
<li>邮件服务器别名</li>
<li>负载分配</li>
</ul>
<p>值得一提的是，DNS协议运行在UDP之上，使用53端口。</p>
<h2 id="DNS分布式，层次数据库"><a href="#DNS分布式，层次数据库" class="headerlink" title="DNS分布式，层次数据库"></a>DNS分布式，层次数据库</h2><p>DNS是一个分布式，层次数据库，大致有三类：根DNS服务器，顶级域(TLD)DNS服务器和权威DNS服务器。<br>还有一类是本地DNS服务器，每个ISP都有一台本地DNS服务器，本地DNS服务器起着代理的作用，将请求转发到DNS服务器的层次结构中。</p>
<p><img src="https://i.imgur.com/jsC0CRt.png" alt=""></p>
<p>在说服务器分层作用之前，先要说一下域名，常见的域名是例如<code>www.example.com</code>，但是它真正的域名是<code>www.example.com.root</code>，只是省略了后面的<code>.root</code>。<code>.root</code>称为根域名，<code>.com</code>，<code>.net</code>等等称为顶级域名(TLD)，<code>.example</code>称为次级域名，这个域名是用户可以注册的，再下一级是主机名(host)，比如<code>www</code>，又称为三级域名。</p>
<p>总结一下，域名的层级结构如下：</p>
<p><code>主机名(三级域名).次级域名.顶级域名.根域名</code></p>
<p>即<code>host.sld.tld.root</code></p>
<h3 id="根DNS服务器"><a href="#根DNS服务器" class="headerlink" title="根DNS服务器"></a>根DNS服务器</h3><p>它将返回顶级域名的TLD服务器的IP地址，根域名服务器的NS记录和IP地址一般是不会变化的</p>
<h3 id="顶级域DNS服务器"><a href="#顶级域DNS服务器" class="headerlink" title="顶级域DNS服务器"></a>顶级域DNS服务器</h3><p>它返回权威服务器的IP地址</p>
<h3 id="权威DNS服务器"><a href="#权威DNS服务器" class="headerlink" title="权威DNS服务器"></a>权威DNS服务器</h3><p>它返回主机名(如<a href="http://www.amazon.com)的IP地址" target="_blank" rel="noopener">www.amazon.com)的IP地址</a></p>
<h3 id="本地DNS服务器"><a href="#本地DNS服务器" class="headerlink" title="本地DNS服务器"></a>本地DNS服务器</h3><p>严格上来说它不属于DNS层次结构，但它也很重要。本地DNS服务器由ISP提供，当主机发出DNS请求时，通常被发往到本地DNS服务器，由本地DNS服务器代理转发到DNS服务器层次结构</p>
<h2 id="工作机理"><a href="#工作机理" class="headerlink" title="工作机理"></a>工作机理</h2><p><img src="https://i.imgur.com/4klvXoE.png" alt=""></p>
<p>以主机<code>cis.poly.edu</code>请求<code>gaia.cs.umass.ude</code>的IP地址为例，假设<code>cis.poly.edu</code>的本地DNS为<code>dns.poly.edu</code>，并且<code>gaia.cs.umass.edu</code>的权威DNS服务器为<code>dns.umass.edu</code></p>
<ol>
<li>主机<code>cis.poly.edu</code>首先向它的本地DNS服务器<code>dns.poly.edu</code>发送一个DNS查询报文</li>
<li>本地DNS服务器<code>dns.poly.edu</code>将报文转发到根DNS服务器，根DNS服务器注意到edu前缀并向本地DNS服务器返回负责edu的TLD的IP地址列表</li>
<li>该本地DNS服务器则再次向这些TLD服务器之一发送查询报文</li>
<li>该TLD服务器注意到<code>umass.edu</code>前缀，并用权威DNS服务器的IP地址进行响应</li>
<li>最后，本地DNS服务器直接向<code>dns.umass.edu</code>重发查询报文，<code>dns.umass.edu</code>将<code>gaia.cs.umass.edu</code>的IP地址进行响应</li>
</ol>
<p>从请求主机到本地DNS服务器的查询是递归的，其余的查询是迭代的</p>
<h2 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h2><p>为了改善时延性能并减少在因特网上到处传输的DNS报文数量，DNS广泛采用了缓存技术</p>
<p>它能够把回答中的信息缓存在本地存储器中，但该缓存不是永久的，由于主机和主机名与IP地址间的映射并不是永久的，所以DNS服务器一般在一段时间后（通常为2天）将丢弃缓存的信息。</p>
<h2 id="DNS报文和记录"><a href="#DNS报文和记录" class="headerlink" title="DNS报文和记录"></a>DNS报文和记录</h2><h3 id="DNS记录"><a href="#DNS记录" class="headerlink" title="DNS记录"></a>DNS记录</h3><p>共同实现DNS分布式数据库的所有DNS服务器存储了资源记录（Resource Record，RR），RR提供了主机名到IP地址的映射。</p>
<p>RR是一个包含了下列字段的4元组：<br>(Name, Value, Type, TTL)</p>
<p>TTL是该记录的生存时间，它决定了资源记录应当从缓存中删除的时间</p>
<ul>
<li>如果Type=A，则Name是主机名，Value是该主机名对应的IP地址</li>
<li>如果Type=NS，则Name是个域（如foo.com），Value是个知道如何获得该域中主机IP地址的权威DNS服务器的主机名。这个记录用于沿着查询链来路由DNS查询。（如(foo.com, dns.foo.com, NS)就是一个NS记录）</li>
<li>如果Type=CNAME，则Value是别名为Name的主机对应的规范主机名</li>
<li>如果Type=MX，则Value是个别名为Name的邮件服务器的规范主机名</li>
</ul>
<p>如果一台DNS服务器是用于某特定主机名的权威DNS服务器，那么该DNS服务器会有一条包含该主机名的类型A记录<br>如果服务器不是用于某主机名的权威服务器，那么该服务器将包含一条类型NS记录，该记录对应包含主机名的域；它还包括一条类型A记录，提供在NS记录的Value字段中的DNS的IP地址<br>（比如<strong>edu TLD服务器</strong>不是主机gaia.cs.umass.edu的权威DNS服务器，则该服务器将包含一条包括主机cs.umass.edu的域记录，如(umass.edu, dns.umass.edu, NS)，该TLD服务器还将包含一条类型A记录，如(dns.umass.edu, 128.199.40.111, A)，该记录将名字dns.umass.edu映射为一个IP地址）</p>
<h3 id="DNS报文"><a href="#DNS报文" class="headerlink" title="DNS报文"></a>DNS报文</h3><p><img src="https://i.imgur.com/Q7F2t9H.png" alt=""></p>
<h3 id="对分级查询的进一步解释"><a href="#对分级查询的进一步解释" class="headerlink" title="对分级查询的进一步解释"></a>对分级查询的进一步解释</h3><p>所谓”分级查询”，就是从根域名开始，依次查询每一级域名的NS记录，直到查到最终的IP地址，见下面的DNS记录可知</p>
<ol>
<li>从”根域名服务器”查到”顶级域名服务器”的NS记录和A记录（IP地址）</li>
<li>从”顶级域名服务器”查到”次级域名服务器”的NS记录和A记录（IP地址）</li>
<li>从”次级域名服务器”查出”主机名”的IP地址</li>
</ol>
<p>（根域名服务器的NS记录和IP地址一般是不会变化的，所以内置在DNS服务器中）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/25/对String,StringBuilder,StringBuffer的区分(源码剖析)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MakaLoo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MakaL-0-">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/25/对String,StringBuilder,StringBuffer的区分(源码剖析)/" itemprop="url">源码剖析-对String,StringBuilder,StringBuffer的区分</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-25T10:41:18+08:00">
                2019-03-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/03/25/对String,StringBuilder,StringBuffer的区分(源码剖析)/" class="leancloud_visitors" data-flag-title="源码剖析-对String,StringBuilder,StringBuffer的区分">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="源码剖析-对String-StringBuilder-StringBuffer的区分"><a href="#源码剖析-对String-StringBuilder-StringBuffer的区分" class="headerlink" title="源码剖析-对String,StringBuilder,StringBuffer的区分"></a>源码剖析-对String,StringBuilder,StringBuffer的区分</h1><p>首先观察他们继承的类和接口</p>
<p>String：<code>public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {}</code><br>StringBuilder：<code>public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, CharSequence {}</code><br>StringBuffer：<code>public final class StringBuffer extends AbstractStringBuilder implements java.io.Serializable, CharSequence {}</code></p>
<p>可以观察到，String对象继承了Serializable，Comparable，CharSequence接口<br>StringBuilder与StringBuffer均继承自AbstractStringBuilder父类，Serializable，CharSequence接口</p>
<p>Serializable是序列化接口，它的作用是：</p>
<blockquote>
<p>Serializability of a class is enabled by the class implementing the java.io.Serializable interface.</p>
</blockquote>
<h2 id="String-源码剖析"><a href="#String-源码剖析" class="headerlink" title="String 源码剖析"></a>String 源码剖析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private final char[] value;</span><br><span class="line">private int hash; // 默认为0，哈希缓存</span><br></pre></td></tr></table></figure>
<p>String由value，hash组成，value就是它的值了，hash是哈希缓存，注意value是final char[]类型的，即String对象是不可变的</p>
<p>String的equals方法重写了，实现的是依次判断value数组的每个值是否相等，都相等就返回true，否则返回false</p>
<h3 id="Comparable接口"><a href="#Comparable接口" class="headerlink" title="Comparable接口"></a>Comparable接口</h3><p>String实现了Comparable接口，即String对象可以通过调用<code>compareTo()</code>方法进行比较，这是String与StringBuilder和StringBuffer的第一个区别</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> v1[] = value;</span><br><span class="line">    <span class="keyword">byte</span> v2[] = anotherString.value;</span><br><span class="line">    <span class="keyword">if</span> (coder() == anotherString.coder()) &#123;</span><br><span class="line">        <span class="keyword">return</span> isLatin1() ? StringLatin1.compareTo(v1, v2)</span><br><span class="line">                          : StringUTF16.compareTo(v1, v2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isLatin1() ? StringLatin1.compareToUTF16(v1, v2)</span><br><span class="line">                      : StringUTF16.compareToLatin1(v1, v2);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>他主要实现了在当前字符编码上对字符串的比较，判断字符串是否相等</p>
<h2 id="StringBuilder与StringBuffer"><a href="#StringBuilder与StringBuffer" class="headerlink" title="StringBuilder与StringBuffer"></a>StringBuilder与StringBuffer</h2><h3 id="AbstractStringBuilder"><a href="#AbstractStringBuilder" class="headerlink" title="AbstractStringBuilder"></a>AbstractStringBuilder</h3><p>注意到在这个抽象类中定义了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] value;</span><br><span class="line"><span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure>
<p>但注意到value不是final类型，即他是可变的，这个是与String的第二个区别</p>
<h3 id="CharSequence"><a href="#CharSequence" class="headerlink" title="CharSequence"></a>CharSequence</h3><p><img src="https://i.imgur.com/PMITMBm.png" alt=""><br><!-- TODO: 这个是CharSequence.png --></p>
<h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>StringBuilder继承自AbstractStringBuilder，大部分代码都已经由其实现，StringBuilder只需要在构造器中调用super()方法即可，包括append()方法，delete()方法，replace()方法，insert()方法，indexOf()方法，lastIndexOf()方法，reverse()方法也都是调用super()方法即可。</p>
<h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><p>而StringBuffer则是在AbstractStringBuilder的方法上添加了synchronized的关键字，即它是线程安全的</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>String是可以比较的，通过compareTo()方法，而StringBuilder和StringBuffer只能通过toString()方法后再调用compareTo()方法来比较。</li>
<li>String对象是不可变的，其值是final类型，而StringBuilder和StringBuffer对象可变，并没有final修饰。</li>
<li>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。 </li>
</ol>
<p>对他们的使用，应该遵循下面原则：</p>
<ul>
<li>操作少量的数据 = String</li>
<li>单线程操作字符串缓冲区下操作大量数据 = StringBuilder</li>
<li>多线程操作字符串缓冲区下操作大量数据 = StringBuffer</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="MakaLoo" />
            
              <p class="site-author-name" itemprop="name">MakaLoo</p>
              <p class="site-description motion-element" itemprop="description">Beautifully struggle every day</p>
          </div>

          <nav class="site-state motion-element">
		  
		  

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">124</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">243</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/makloao" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://www.zhihu.com/people/makaloo" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-globe"></i>知乎</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:xiehj1997@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-globe"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MakaLoo</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
      <div id="needsharebutton-float">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("oE3JvjxaL9UMPCdKOwyY8BNP-gzGzoHsz", "0mpd8MSRyvkSyuoF6lMMy84W");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">

  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>

  <script>
    
      pbOptions = {};
      
          pbOptions.iconStyle = "box";
      
          pbOptions.boxForm = "horizontal";
      
          pbOptions.position = "bottomCenter";
      
          pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
      flOptions = {};
      
          flOptions.iconStyle = "box";
      
          flOptions.boxForm = "horizontal";
      
          flOptions.position = "middleRight";
      
          flOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-float', flOptions);
    
  </script>

  

  

  

  

</body>
</html>
