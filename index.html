<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Beautifully struggle every day">
<meta property="og:type" content="website">
<meta property="og:title" content="MakaL-0-">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="MakaL-0-">
<meta property="og:description" content="Beautifully struggle every day">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MakaL-0-">
<meta name="twitter:description" content="Beautifully struggle every day">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>MakaL-0-</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-120154502-1', 'auto');
  ga('send', 'pageview');
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?f15c3fa6d339dfe768bc3d4f2e2f856e";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">MakaL-0-</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">aha~~~</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/09/存储器管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MakaLoo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MakaL-0-">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/09/存储器管理/" itemprop="url">存储器管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-09T23:05:18+08:00">
                2019-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/05/09/存储器管理/" class="leancloud_visitors" data-flag-title="存储器管理">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h1><h2 id="存储器管理概述"><a href="#存储器管理概述" class="headerlink" title="存储器管理概述"></a>存储器管理概述</h2><h3 id="存储器的多层结构"><a href="#存储器的多层结构" class="headerlink" title="存储器的多层结构"></a>存储器的多层结构</h3><p>由于CPU与存储器的速度不匹配，需要对存储器进行分层，经典是三层结构：CPU寄存器，主存和辅存，目前比较高级的分层是六层：寄存器，高速缓存，主存储器，磁盘缓存，固定磁盘和可移动存储介质，层次越高，速度越快，但价格越高，存储容量越小</p>
<p>高速缓存常用SRAM，内存DRAM，SDRAM等，外存是软盘，硬盘，光盘等</p>
<p><img src="https://i.imgur.com/j0Z0S0T.png" alt=""></p>
<h4 id="各层次作用"><a href="#各层次作用" class="headerlink" title="各层次作用"></a>各层次作用</h4><p>主存又称内存，用于保存进程运行的程序和数据，处理机都是从主存储器取指令和数据的，并把指令放入指令寄存器，数据放入数据寄存器，或者反过来把寄存器中的数据存入主存储器。</p>
<p>寄存器有与处理机相同的速度</p>
<p>高速缓存是介于寄存器和存储器之间的存储器，主要用于备份主存常用的数据，减少处理机对主存的访问次数，可以大幅度提高程序执行速度</p>
<p>磁盘缓存是为了缓和磁盘I/O速度和主存访问速度的不匹配，主要用于暂时存放频繁使用的一部分磁盘数据和信息，以减少访问磁盘的次数，它本身不是一种实际存在的存储器，而是利用主存中部分存储空间暂时存放从磁盘中读出或写入的信息</p>
<h3 id="存储器管理功能"><a href="#存储器管理功能" class="headerlink" title="存储器管理功能"></a>存储器管理功能</h3><p>存储器管理主要有如下功能</p>
<ul>
<li>存储分配和回收：分配和和回收算法及相应的数据结构</li>
<li>地址变换<ul>
<li>可执行文件生成中的链接技术</li>
<li>程序加载（装入）时的重定位技术</li>
<li>进程运行时硬件和软件的地址变换技术和机构</li>
</ul>
</li>
<li>存储共享和保护<ul>
<li>代码和数据共享</li>
<li>地址空间访问权限（读，写，执行）</li>
</ul>
</li>
<li>存储器扩充</li>
</ul>
<h3 id="重定位概念"><a href="#重定位概念" class="headerlink" title="重定位概念"></a>重定位概念</h3><p>重定位是实现逻辑地址（相对地址）到物理地址（绝对地址）的映射<br>逻辑地址：应用程序的地址都是从0开始的<br>物理地址：主存中一系列存储信息的物理单元的地址</p>
<h3 id="程序的装入"><a href="#程序的装入" class="headerlink" title="程序的装入"></a>程序的装入</h3><p>一个程序一般有5个过程，编辑，编译，链接，装入和运行</p>
<p>程序装入分为绝对装入和可重定位装入和动态运行时装入<br>绝对装入指编译后，装入前已产生绝对地址，装入时不需要再作地址重定位，绝对地址由编译器或程序员编程完成<br>可重定位装入指静态重定位，静态重定位指地址转换在装入时一次完成，缺点是不允许程序在运行中在内存中移动位置<br>动态运行时装入在把装入模块装入内存后，并不立即把装入模块中的逻辑地址转换成物理地址，而是把这种地址转换推迟到程序真正要执行的时候才进行，因此，装入内存后的地址都是逻辑地址，需要一个重定位寄存器的支持</p>
<h3 id="程序的链接"><a href="#程序的链接" class="headerlink" title="程序的链接"></a>程序的链接</h3><p>源程序编译后得到一组目标模块，链接程序的功能是将这组目标模块以及它们所需要的库函数装配成一个完整的装入模块</p>
<p>静态链接：对相对地址进行修改，变换外部调用符号<br>动态链接：便于修改和更新，便于实现对目标模块的共享<br>运行时动态链接</p>
<h2 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h2><p>为了能将用户程序装入内存，必须为它分配一定大小的内存空间，连续分配方式是最早出现的一种存储器分配方式</p>
<h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><p>用于单用户单任务中，把内存分为系统区和用户区，应用程序装入到用户区，可使用用户区全部空间，优点是易于管理，缺点是对要求内存空间少的程序造成内存浪费，程序全部装入，很少使用的程序部分也会占用内存</p>
<h3 id="固定分区"><a href="#固定分区" class="headerlink" title="固定分区"></a>固定分区</h3><p>特点：有n个分区，可同时装入n个作业/任务<br>固定分区可以把分区划分为相等的跟不相等的，不相等的利用率更高</p>
<p>数据结构：分区使用表，将分区按大小排序，并将地址，分配标识符（是否已分配），大小作记录，由于每个分区的大小固定，必然会造成存储空间的浪费</p>
<h3 id="可变式分区"><a href="#可变式分区" class="headerlink" title="可变式分区"></a>可变式分区</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul>
<li>空闲分区表：记录每个空闲分区的情况，每个空闲分区占一个表目，表目中包括分区号，分区大小和分区始址等。</li>
<li>空闲分区链：实现对空闲分区表的分配和链接，在每个分区的起始部分设置一些用于控制分区分配的信息，以及用于链接各分区所用的前向指针，在分区尾部设置一后向指针，通过前后向链接指针，可将所有空闲分区链接成一个双向链，分区尾部重复设置状态位和分区大小表目，当分区被分配出去后，状态位由”0”改为”1”，此时前后指针无意义</li>
</ul>
<p><img src="https://i.imgur.com/JiCVrro.png" alt=""></p>
<h4 id="分配算法"><a href="#分配算法" class="headerlink" title="分配算法"></a>分配算法</h4><p>为把一个新作业装入内存，须按照一定的分配算法，从空闲分区表或空闲分区链中选一分区分配给该作业</p>
<h4 id="分区分配操作"><a href="#分区分配操作" class="headerlink" title="分区分配操作"></a>分区分配操作</h4><h5 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h5><p>利用某种分配算法，从空闲分区链（表）中找到所需大小的分区，设请求的分区大小是u.size，表中每个空闲分区的大小可表示为m.size，若m.size-u.size&lt;=size（size是事先规定的不再切割的剩余分区的大小）说明多余部分太小，可不再切割，将整个分区分配给请求者，并从分区链移除，否则从该分区中按请求的大小划分找出一块内存空间分配出去，余下的部分仍留在空闲分区链（表）中，然后将分配区的首地址返回给调用者</p>
<p><img src="https://i.imgur.com/waRwwTm.png" alt=""></p>
<h5 id="回收内存"><a href="#回收内存" class="headerlink" title="回收内存"></a>回收内存</h5><p>当进程运行完毕释放内存后，系统根据<strong>回收区的首地址</strong>，从空闲区链（表）中找到相应的插入点，此时可能出现下面四种情况</p>
<ul>
<li>回收区与插入点前一个空闲分区F1相邻接，此时应将回收区与插入点前一分区合并，不必为回收区分配新表项，而只需修改前一分区F1的大小</li>
<li>回收区与插入点后一个空闲分区F2相邻接，此时将两分区合并，形成新的空闲分区，但用回收区的首地址作为新空闲区的首地址，大小为两者之和</li>
<li>回收区同时与插入点的前，后两个分区邻接，此时将三个分区合并，使用F1的表项和F1的首地址，取消F2的表项，大小为三者之和</li>
<li>回收区既不与F1邻接也不与F2邻接：新建表项，填入回收区首地址和大小，插入到空闲链适当位置</li>
</ul>
<p><img src="https://i.imgur.com/M2f7lE3.png" alt=""></p>
<h3 id="分配算法-1"><a href="#分配算法-1" class="headerlink" title="分配算法"></a>分配算法</h3><h4 id="基于顺序搜索的动态分区分配算法"><a href="#基于顺序搜索的动态分区分配算法" class="headerlink" title="基于顺序搜索的动态分区分配算法"></a>基于顺序搜索的动态分区分配算法</h4><ul>
<li>首次适应(first fit, FF)算法：空闲分区链以地址递增的次序链接，从链首开始顺序查找直到找到一个大小能满足要求的空闲分区为止，然后从该分区划出一块内存空间分配给请求者</li>
<li>循环首次适应(next fit, NF)算法：不再是每次都从链首开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找</li>
<li>最佳适应(best fit, BF)算法：每次为作业分配内存时，总是把能满足要求又是最小的空闲分区分配给作业，要求所有空闲分区按容量从大到小顺序形成一空闲分区链</li>
<li>最坏适应(worst fit, WF)算法：总是挑选最大的空闲区从中分割一部分存储空间给作业使用，要求将所有空闲分区按容量从大到小形成一空闲分区链，查找时只需看抵押给分区是否满足作业要求</li>
</ul>
<h4 id="基于索引搜索的动态分区分配算法"><a href="#基于索引搜索的动态分区分配算法" class="headerlink" title="基于索引搜索的动态分区分配算法"></a>基于索引搜索的动态分区分配算法</h4><ul>
<li>快速适应(quick fit)算法：将空闲分区根据容量大小分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链，内存设立一张管理索引表，索引表项对应空闲分区类型，并记录该类型空闲分区链表表头的指针，根据进程常用空间大小划分，比如2KB，4KB，8KB等，7KB可以放在8KB也可以放在特殊的空闲分区链表中</li>
<li>伙伴系统：无论已分配分区或空闲分区，其大小均为2的k次幂，对于相同大小空闲分区单独设立一个空闲分区双向链表，不同大小的空闲分区形成了k个空闲分区链表，对于进程分配一个长度为n的存储空间时，计算i值，使2^(i-1) &lt; n &lt;= 2^i，先从2^i的空闲分区查找，若找到就分配，没有则从2^(i+1)的空闲分区查找，找到就分为相等的两个分区，称为一对伙伴，其中一个分区用于分配，另一个分区加入到2^i的空闲分区链表中</li>
<li>哈希算法，构造空闲分区大小为关键字的哈希表，每一个表项记录一个对应的空闲分区链表表头指针</li>
</ul>
<h4 id="动态可重定位分区分配"><a href="#动态可重定位分区分配" class="headerlink" title="动态可重定位分区分配"></a>动态可重定位分区分配</h4><ul>
<li>紧凑：连续分配方式的一个重要特点是：一个系统或用户程序必须被装入一片连续的内存空间中，当计算机运行一段时间后，它的内存空间会被划分为许多小的分区，而缺乏大的空闲空间，当有大作业要加入，因为小分区不邻接，无法分配内存给大作业，紧凑就是将内存中的所有<strong>作业</strong>进行移动，使它们全都相邻接，这样，原来分散的多个空闲小分区拼接成一个大分区，每次紧凑后，必须对移动了的程序或数据进行重定位</li>
<li>动态重定位：动态运行时装入的方式，作业装入内存后所有地址仍然是相对地址，而将相对地址转换成绝对地址的工作被推迟到程序指令要真正执行的时候进行，设一个重定位寄存器，用它存放程序（数据）在内存中的起始地址，程序执行时真正访问的地址是相对地址与重定位寄存器的地址相加而形成的</li>
</ul>
<p><img src="https://i.imgur.com/UkxuVZ5.png" alt=""></p>
<p><img src="https://i.imgur.com/ayDa85o.png" alt=""></p>
<h2 id="对换"><a href="#对换" class="headerlink" title="对换"></a>对换</h2><p>对换的引入：将阻塞进程，暂时不用的程序，数据换出，将具备运行条件的进程换入<br>类型：</p>
<ul>
<li>整体对换：进程对换，解决内存紧张</li>
<li>部分对换：页面对换/分段对换：提供虚存支持</li>
</ul>
<h3 id="对换空间的管理"><a href="#对换空间的管理" class="headerlink" title="对换空间的管理"></a>对换空间的管理</h3><p>具有对换功能的OS中，常把磁盘空间分为文件区和对换区，对换区比文件区侧重于对换速度，因此对换区一般采用连续分配，采用数据结构和分配回收类似于可变化分区分配</p>
<h3 id="进程的换出与换入"><a href="#进程的换出与换入" class="headerlink" title="进程的换出与换入"></a>进程的换出与换入</h3><p>当内存不足时，便调用对换进程，实现进程的换出和换入</p>
<h4 id="进程的换出"><a href="#进程的换出" class="headerlink" title="进程的换出"></a>进程的换出</h4><ol>
<li>选择被换出的进程：选择因素：优先级，驻留时间，进程状态</li>
<li>进程换出过程：共享段计数减一，如果是0就换出，修改PCB和MCB</li>
</ol>
<h4 id="进程的换入"><a href="#进程的换入" class="headerlink" title="进程的换入"></a>进程的换入</h4><ol>
<li>选择换入进程：优先级，换出时间等</li>
<li>申请内存</li>
<li>换入</li>
</ol>
<h2 id="分页存储管理方式"><a href="#分页存储管理方式" class="headerlink" title="分页存储管理方式"></a>分页存储管理方式</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>分页主要是将用户程序的地址空间划分为若干个固定大小的区域，称为”页”或”页面”，典型的页面大小为1kb，相应地，也将内存空间分为若干个物理块或页框，页和块的大小相同，这样可以将用户程序的任一页放入任一物理块中，实现离散分配（页是相对用户程序的地址而言，页框或者块是相对内存空间而言）</p>
<p>离散分配的引入：连续分配引起碎片，紧凑方式消耗系统开销</p>
<h3 id="分页存储管理的基本方法"><a href="#分页存储管理的基本方法" class="headerlink" title="分页存储管理的基本方法"></a>分页存储管理的基本方法</h3><h4 id="地址结构"><a href="#地址结构" class="headerlink" title="地址结构"></a>地址结构</h4><p><img src="https://i.imgur.com/UpDwi5n.png" alt=""></p>
<p>A：逻辑地址空间的地址 L：页面的大小</p>
<p>包含两部分内容：前一部分为页号P，后一部分为位（偏）移量W，即页内地址，图中的地址长度为32位，其中0——11位为页内地址，即每页大小4KB（页面大小），12——31位为页号，地址空间最多允许有1M页</p>
<h4 id="页的计算例子"><a href="#页的计算例子" class="headerlink" title="页的计算例子"></a>页的计算例子</h4><p><img src="https://i.imgur.com/df5F6fB.png" alt=""></p>
<h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>为了能在内存中找到每个页面对应的物理块，系统为每个进程建立一张页面映射表，为页表，在进程地址空间内的所有页(0——n)，依次在页表中有一页表项，其中记录了相应页在内存中对应的物理块号，实现从页号到物理块号的地址映射</p>
<p><img src="https://i.imgur.com/ElwJb15.png" alt=""></p>
<h3 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><p>为了能将用户地址空间中的逻辑地址转换成内存空间中的物理地址，系统中设立了地址变换机构，地址变换机构任务实际只是将逻辑地址中的页号转换为内存中的物理块号（页内地址与物理块内的地址是一样的，所以不需要变换），地址变换任务就是<strong>借助页表实现的</strong></p>
<h4 id="基本地址变换机构"><a href="#基本地址变换机构" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h4><ul>
<li>越界保护</li>
<li>每个进程对应一页表，其信息（如长度，始址）放在PCB中，执行时将其首地址装入页表寄存器</li>
</ul>
<p>页表是驻留在内存中的，当调度程序调度某程序的时候，才将PCB中的页表始址和页表长度装入页表寄存器（一个进程对应一个页表，所以对不同页表，需要有页表始址来区分）</p>
<p><img src="https://i.imgur.com/eL5lZKb.png" alt=""></p>
<h5 id="地址变换过程"><a href="#地址变换过程" class="headerlink" title="地址变换过程"></a>地址变换过程</h5><p>当进程要访问某个逻辑地址的数据时，分页地址变换机构会自动地将有效地址（相对地址）分为页号和页内地址两部分，再以页号为索引区检索页表，查找操作由硬件执行。在检索之前，先将页号与页表长度比较，若大于或等于页表长度，则表示本次所访问的地址已超越进程的地址空间，产生一地址越界中断。若未出现越界错误，则将页表始址与页号和页表项长度的乘积相加，便得到该表项在页表中的位置，于是可从中得到该页的物理块号，将它装入物理地址寄存器，然后把页内地址送入物理地址寄存器的块内地址字段中，这样便完成了逻辑地址到物理地址的变换</p>
<h5 id="我对将页表始址与页号和页表项长度的乘积相加地理解"><a href="#我对将页表始址与页号和页表项长度的乘积相加地理解" class="headerlink" title="我对将页表始址与页号和页表项长度的乘积相加地理解"></a>我对将页表始址与页号和页表项长度的乘积相加地理解</h5><p>页表项长度应该就是页表项（即物理块）的地址的长度<br>通过上述式子的计算，得到的是一个地址值（页表始址+页号*页表项长度（地址长度）），这个地址值应该是页表中该页表项的物理内存地址，访问这个物理内存地址，就得到这个物理块号了</p>
<h5 id="需要考虑的问题"><a href="#需要考虑的问题" class="headerlink" title="需要考虑的问题"></a>需要考虑的问题</h5><p>直接映射的分页系统对系统效能不利，因为CPU需要访问两次主存才能得到所需要的数据，第一次访问是访问主存中的页表，从中找到指定页的物理块号再将块号与页内偏移量W拼接形成物理地址，第二次访问是从第一次所得地址中获得实际数据，为了解决这个问题，引入快表</p>
<h4 id="具有快表的地址变换机构"><a href="#具有快表的地址变换机构" class="headerlink" title="具有快表的地址变换机构"></a>具有快表的地址变换机构</h4><p>为了提高地址变换速度，在地址变换机构中增设一个具有并行查寻能力的特殊高速缓冲寄存器，又称为”联想寄存器”，或称为”快表”，或者TLB，用以存放当前访问的那些页表项，此时地址变换过程是这样的：</p>
<p>在CPU给出有效地址后，由地址变换机构自动地将页号P送入高速缓冲寄存器，并将此页号与高速缓存中地所有页号进行比较，若其中有与此相匹配的页号，便表示所要访问的页表项在快表中，于是，可直接从快表中读出该页所对应的物理块号，并送到物理地址寄存器，如在快表中没有找到对应的页表项，则还须再访问内存中的页表，找到后把从页表中读出的物理块号送往地址寄存器，同时，再将此页表项存入快表的一个寄存器单元中，如果快表满了，则OS找到一个老的且被认为不需要的页表项换出</p>
<p><img src="https://i.imgur.com/IxGYPDQ.png" alt=""></p>
<h3 id="访问内存的有效时间"><a href="#访问内存的有效时间" class="headerlink" title="访问内存的有效时间"></a>访问内存的有效时间</h3><p>从进程发出指定逻辑地址的访问请求，经过地址变换，到在内存中找到对应的实际物理地址单元并取出数据，所需要花费的总时间，称为内存的有效访问时间（Effective Access Time, EAT)，有效访问时间分为第一次访问内存时间（即查找页表对应的页表项所耗费的时间t）与第二次访问内存时间（即将页表项的物理块与页内地址拼接成实际物理地址所耗费的时间t）之和</p>
<p>t：访问一次内存所需要的时间<br>EAT=t+t=2*t</p>
<p>引入快表后，快表命中率a，查找快表需要的时间λ</p>
<p>EAT=a<em>(t+λ)+(1-a)(2t+λ)=2</em>t+λ-t*a</p>
<h3 id="两级和多级页表"><a href="#两级和多级页表" class="headerlink" title="两级和多级页表"></a>两级和多级页表</h3><p><img src="https://i.imgur.com/a87JQe4.jpg" alt=""></p>
<p>两级页表的逻辑地址结构</p>
<p><img src="https://i.imgur.com/vAODx2G.png" alt=""></p>
<p><img src="https://i.imgur.com/dmvJmwv.png" alt=""></p>
<p>以前面的32位逻辑地址空间为例，当页面大小为4KB的时候(12位)，采用两级页表结构时，再对页表进行分页，使每页包含2^10个页表项，或者说，外层页表中的外层页内地址P2为10位，外层页号P1也为10位</p>
<p>（通过外部页号得到P2的始址，然后P2和d就可以通过上面说过的地址变换过程获得物理地址了）<br>外层页表的每个页表项中存放的是某页表分页的首地址，地址变换机构中同样要增加外层页表寄存器，用于存放外层页表的始址，并利用逻辑地址中的外层页号作为外层页表的索引，从中找到指定页表的始址（同上页表始址与页号和页表项长度乘积相加那个原理），再利用P2作为指定页表分页的索引，找到指定页表项，即含有该页在内存中的物理块号，用该块号P和页内地址d即可构成访问的内存物理地址</p>
<h4 id="一个练习小例子"><a href="#一个练习小例子" class="headerlink" title="一个练习小例子"></a>一个练习小例子</h4><p><img src="https://i.imgur.com/NzHTbzz.png" alt=""></p>
<p><img src="https://i.imgur.com/nzZDyXX.png" alt=""></p>
<p><img src="https://i.imgur.com/Pypgxvw.png" alt=""></p>
<h2 id="分段存储管理系统"><a href="#分段存储管理系统" class="headerlink" title="分段存储管理系统"></a>分段存储管理系统</h2><p>基本思想：按程序的逻辑结构，将程序的地址空间划分为若干段，各段大小可不相同，在进行存储分配时，以段为单位，这些段在内存中可以不相邻接<br>为什么引入：一方面程序可分为若干个段，主程序段，子程序段A，子程序段B，数据段，栈段等，另一方面实现和满足信息共享，信息保护，动态链接以及信息的动态增长等需要</p>
<h3 id="分段系统基本原理"><a href="#分段系统基本原理" class="headerlink" title="分段系统基本原理"></a>分段系统基本原理</h3><h4 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h4><p>每个段定义了一组逻辑信息，分段地址的地址具有如下结构</p>
<p><img src="https://i.imgur.com/lIzzMcm.png" alt=""></p>
<h4 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h4><p><img src="https://i.imgur.com/0jaI7D8.png" alt=""></p>
<h4 id="地址变换过程-1"><a href="#地址变换过程-1" class="headerlink" title="地址变换过程"></a>地址变换过程</h4><p><img src="https://i.imgur.com/NI7gUs6.png" alt=""></p>
<p>设置了段表寄存器，用于存放段表始址和段表长度TL，在进行地址变换时，系统将逻辑地址中的段号和段表长度TL进行比较，若S&gt;TL，表示段号太大，访问越界，若未越界，则根据段表始址和段号，计算出该段对应段表项的位置（物理地址），从中读出该段在内存的起始地址，然后检查段内地址d是否超过该段段长SL，若超过，即d&gt;SL，同样发出越界中断，若未越界，则该段基址d与段内地址相加，即可得到要访问的内存物理地址</p>
<p>分段同样需要访问两次内存，同样由联想存储器用于保存最近常用的段表项</p>
<h2 id="分页和分段主要区别"><a href="#分页和分段主要区别" class="headerlink" title="分页和分段主要区别"></a>分页和分段主要区别</h2><ul>
<li>页是信息的物理单位，段是逻辑单位</li>
<li>页长度固定由系统决定，段长度不固定</li>
<li>分页用户程序地址空间是一维的，分段是二维的，既要给出段名又要给出段内地址</li>
</ul>
<h2 id="段页式存储管理方式"><a href="#段页式存储管理方式" class="headerlink" title="段页式存储管理方式"></a>段页式存储管理方式</h2><p><img src="https://i.imgur.com/Epa98nQ.png" alt=""></p>
<p><img src="https://i.imgur.com/VyaIZ0X.png" alt=""></p>
<p><img src="https://i.imgur.com/kQnRsbQ.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/09/处理机调度与死锁/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MakaLoo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MakaL-0-">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/09/处理机调度与死锁/" itemprop="url">处理机调度与死锁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-09T16:56:18+08:00">
                2019-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/05/09/处理机调度与死锁/" class="leancloud_visitors" data-flag-title="处理机调度与死锁">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="处理机调度与死锁"><a href="#处理机调度与死锁" class="headerlink" title="处理机调度与死锁"></a>处理机调度与死锁</h1><h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>处理机调度分为三个层次</p>
<ul>
<li>高级调度：作业调度，调度对象是作业，根据某种算法，决定将外存上处于后备队列的哪几个作业调入内存，为它们创建进程，分配资源，并放入就绪队列，主要用在多道批处理系统，在分时和实时系统中不设置高级调度</li>
<li>低级调度：进程调度，根据某种算法，决定就绪队列中哪几个进程应获得处理机，并由分派程序将处理机分配给被选中的进程，最基本的调度</li>
<li>中级调度：内存调度，主要目的是提高内存利用率和系统吞吐量，把暂时不能运行的进程调至外存等待，此时进程状态称为就绪驻外存状态（或挂起状态），当进程具备运行条件且内存又有空闲时，由中级调度决定，把外存上已具备运行条件的就绪进程重新调入内存，并挂在就绪队列上等待，实际上中级调度是存储器管理的对换功能</li>
</ul>
<p>调度的运行频率是低&gt;中&gt;高</p>
<h4 id="调度队列模型"><a href="#调度队列模型" class="headerlink" title="调度队列模型"></a>调度队列模型</h4><p>仅有进程调度的调度队列模型</p>
<p><img src="https://i.imgur.com/yC8IKjo.png" alt=""></p>
<p>同时具有三级调度的调度队列模型</p>
<p><img src="https://i.imgur.com/NZoTVUp.png" alt=""></p>
<h3 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h3><p>多道批处理系统中，用户提交的作业先存放到外存，排成一个后备队列，作业调度程序按一定算法从后备队列中选择若干作业调入内存，使他们共享CPU和系统资源，当程序A因I/O而暂停执行时，再调度另一道程序B运行，这样可以保持CPU处于忙碌状态</p>
<p>周转时间常用于批处理系统，指从作业被提交给系统开始，到作业完成的时间，分为</p>
<ul>
<li>驻外等待调度时间</li>
<li>驻内等待调度时间</li>
<li>执行时间</li>
<li>阻塞时间</li>
</ul>
<p>平均周转时间可以表示为</p>
<p><img src="https://i.imgur.com/oHUPcXu.png" alt=""></p>
<p>带权周转时间描述进程在其周转时间中，等待和执行时间的具体分配情况，W=T/Ts，T是周转时间，Ts是系统为它提供服务的时间<br>平均带权周转时间表示为</p>
<p><img src="https://i.imgur.com/5R2w6fF.png" alt=""></p>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><h4 id="先来先服务-FCFS-和短作业优先-SJF-调度算法"><a href="#先来先服务-FCFS-和短作业优先-SJF-调度算法" class="headerlink" title="先来先服务(FCFS)和短作业优先(SJF)调度算法"></a>先来先服务(FCFS)和短作业优先(SJF)调度算法</h4><p>它们都可以用于作业调度和进程调度</p>
<p>FCFS(first-come first-served)就不解释了，SJF（short job first)以作业长短计算优先级，作业越短优先级越高，作业长度以作业所要求的运行时间来衡量，SJF缺点是必须预知作业的运行时间，对长作业非常不利，人机无法交互，未考虑作业紧迫程度。</p>
<h5 id="FCFS和SJF的比较"><a href="#FCFS和SJF的比较" class="headerlink" title="FCFS和SJF的比较"></a>FCFS和SJF的比较</h5><p><img src="https://i.imgur.com/cmZuzFf.png" alt=""></p>
<p>在SJF中，当A完成后，此时时间为4，B,C,D,E均已到达，因为D的作业最短，所以处理机先为D服务，然后为B，E，C服务</p>
<h4 id="高优先权优先调度算法"><a href="#高优先权优先调度算法" class="headerlink" title="高优先权优先调度算法"></a>高优先权优先调度算法</h4><p>可以作为作业调度和进程调度</p>
<p>优先级调度算法（PSA，priority-scheduling algorithm）分为非抢占式优先权算法和抢占式优先权算法，抢占式实时性更好</p>
<p>优先权的类型分为</p>
<ul>
<li>静态优先权：整个运行期不变</li>
<li>动态优先权：优先权随执行时间而下降，随等待时间而上升，响应比Pp=(等待时间+服务时间)/服务时间作为优先权，优点是长短兼顾，缺点是需要计算Rp</li>
</ul>
<h5 id="高响应比优先算法-HRRN-Highest-Response-Ratio-Next"><a href="#高响应比优先算法-HRRN-Highest-Response-Ratio-Next" class="headerlink" title="高响应比优先算法(HRRN,Highest Response Ratio Next)"></a>高响应比优先算法(HRRN,Highest Response Ratio Next)</h5><p>响应比Rp=(tw+ts)/ts，tw为等待时间，ts为服务时间</p>
<h4 id="基于时间片的轮转调度算法-RR"><a href="#基于时间片的轮转调度算法-RR" class="headerlink" title="基于时间片的轮转调度算法(RR)"></a>基于时间片的轮转调度算法(RR)</h4><p>进程调度算法，基于时间片的轮转(RR,round robin)让就绪队列上的每个进程每次仅运行一个时间片，每个进程每次大约都可获得1/n的处理机时间</p>
<h5 id="进程切换时间"><a href="#进程切换时间" class="headerlink" title="进程切换时间"></a>进程切换时间</h5><ul>
<li>若一个时间片尚未用完，正在运行的进程已经完成，则激活调度程序，将它从就绪队列中删除，再调度就绪队列中队首的进程运行，并启动一个新的时间片</li>
<li>若时间片用完，计时器中断处理程序激活，调度程序把它送往就绪队列的队尾</li>
</ul>
<h5 id="时间片大小的确定"><a href="#时间片大小的确定" class="headerlink" title="时间片大小的确定"></a>时间片大小的确定</h5><p>若时间片太大，则退化为FCFS，若太小，则系统开销过大，时间片大小确定应考虑系统对响应时间的要求，就绪队列中进程的数目和系统的处理能力（应保证一个时间片处理完常用命令）</p>
<h4 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h4><p>实时调度必须提供：</p>
<ul>
<li>就需时间：某任务成为就绪的起始时间</li>
<li>开始/完成截止时间</li>
<li>处理时间</li>
<li>资源要求</li>
<li>优先级</li>
</ul>
<p>非抢占式用时间片轮转，抢占式可以时钟中断或立即抢占（只要不在临界区就抢占）</p>
<h4 id="常见的实时调度算法"><a href="#常见的实时调度算法" class="headerlink" title="常见的实时调度算法"></a>常见的实时调度算法</h4><h5 id="最早截止时间优先EDF"><a href="#最早截止时间优先EDF" class="headerlink" title="最早截止时间优先EDF"></a>最早截止时间优先EDF</h5><p>根据任务的开始截止时间来确定任务优先级</p>
<h5 id="最低松弛度优先LLF"><a href="#最低松弛度优先LLF" class="headerlink" title="最低松弛度优先LLF"></a>最低松弛度优先LLF</h5><p>松弛（紧急）程度=完成截止时间-处理时间-当前时间</p>
<p>主要用于可抢占的调度方式</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁定义：如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件，那么该组进程是死锁的。</p>
<p>产生死锁的原因</p>
<ul>
<li>竞争资源引起死锁：竞争不可抢占的资源或可消耗资源引起死锁</li>
<li>进程推进顺序不当</li>
</ul>
<p>产生死锁必要条件</p>
<ul>
<li>互斥条件：资源必须互斥</li>
<li>请求和保持条件：进程已经保持至少一个资源但又提出新的资源请求</li>
<li>不可抢占条件：资源不可抢占</li>
<li>循环等待条件：发生死锁时，必然存在一个进程——资源的循环链，即P0等待P1占用的资源，P1等待P2占用的资源，Pn等待P0占用的资源</li>
</ul>
<p>解决死锁的方法</p>
<ul>
<li>预防死锁</li>
<li>避免死锁</li>
<li>检测死锁</li>
<li>解除死锁</li>
</ul>
<h3 id="解决死锁的方法"><a href="#解决死锁的方法" class="headerlink" title="解决死锁的方法"></a>解决死锁的方法</h3><h4 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h4><p>预防死锁：破坏产生死锁的4个必要条件之一，互斥条件一般是不能破坏的，所以主要是破坏产生死锁的后三个条件，预防死锁有效，但资源利用率低</p>
<p>摒弃请求和保持条件：资源一次性分配<br>摒弃不剥夺条件：新申请不能满足就释放已获得资源<br>摒弃环路条件：资源有序分配，为资源编号，申请时按编号进行</p>
<h4 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h4><p>避免死锁是在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁，最经典的避免死锁的算法是银行家算法</p>
<h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><ul>
<li>可利用资源向量Available：含有m个元素的数组，每个元素代表一类可利用的资源数目，初始值是系统配置的该类全部可用资源的数目，Available[j]=K表示系统中现有Rj类资源的最大数目K个</li>
<li>最大需求矩阵Max：是一个n*m的矩阵，定义了系统中n个进程中每一个进程对m类资源的最大需求，如果Max[i, j]=K，则表示进程i需要Rj类资源的最大数目为K</li>
<li>分配矩阵Allocation：n*m矩阵，定义了系统中每一类资源当前已分配给每一进程的资源数，如果Allocation[i, j]=K，则表示进程i当前已分得Rj类资源的数目为K</li>
<li>需求矩阵Need：n*m矩阵，用来表示每一个进程尚需的各类资源数，如果Need[i, j]=K，表示进程i还需要Rj类资源K个</li>
</ul>
<p>Need[i, j] = Max[i, j] - Allocation[i, j]</p>
<h5 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h5><p>设Requesti是进程Pi的请求向量，如果Requesti[j]=K，则表示进程Pi需要K个Rj类的资源，当Pi发出资源请求后，系统按下述步骤进行检查</p>
<ol>
<li>如果Requesti[j] &lt;= Need[i, j]，则转向步骤2，否则认为出错，因为它申请的资源大于它宣布的最大值</li>
<li>如果Requesti[j] &lt;= Available[j]，则转向步骤3，否则尚无足够资源，Pi需等待</li>
<li>系统试探把资源分配给进程Pi，并修改下面数据结构的数值<br> Available[j] = Available[j] - Requesti[j];<br> Allocation[i, j] = Allocation[i, j] + Requesti[j];<br> Need[i, j] = Need[i, j] - Requesti[j];</li>
<li>系统执行安全性算法，检查此次资源分配后系统是否处于安全状态，若安全，才正式分配资源给Pi，否则本次试探分配作废，恢复原来的资源分配状态，让进程Pi等待</li>
</ol>
<h5 id="安全性算法"><a href="#安全性算法" class="headerlink" title="安全性算法"></a>安全性算法</h5><p>如上面所述，<strong>安全性算法是试探性分配后（即修改了Available，Allocation，Need但未正式分配资源）进行的，若安全才正式分配，否则试探分配作废</strong>，算法如下</p>
<ol>
<li>设置两个向量：工作向量Work，表示系统可提供给进程继续运行所需的各类资源数目，含有m个元素，执行安全算法开始时，Work=Available；Finish，它表示系统是否有足够资源分配给进程，使之运行完成。开始时Finish[i]=false，当有足够资源分配给进程时，再令Finish[i]=true</li>
<li>从进程集合中找到一个满足下述条件的进程：<br>Finish[i]=false;<br>Need[i, j] &lt;= Work[j];<br>若找到，则转向步骤3，否则转向步骤4</li>
<li><strong>假如</strong>进程Pi获得资源，则进程Pi可顺利执行，直到完成，并释放分配给它的资源，故应执行<br>Work[j] = Work[j] + Allocation[i, j];<br>Finish[i] = true;<br>go to step 2;</li>
<li>如果所有进程的Finish[i]=true都满足，则表示系统处于安全状态，否则，系统处于不安全状态</li>
</ol>
<h5 id="银行家算法安全性检查的例子"><a href="#银行家算法安全性检查的例子" class="headerlink" title="银行家算法安全性检查的例子"></a>银行家算法安全性检查的例子</h5><p><img src="https://i.imgur.com/vd5ekYs.png" alt=""></p>
<p><img src="https://i.imgur.com/5XOTJlu.png" alt=""></p>
<p>一开始检查，发现p0不满足第2步的条件，p1满足，就把p1的资源释放，加到Work，然后继续检查，p2不满足，p3满足，则释放掉p3的资源，然后释放，最后所有的进程都释放了</p>
<p>P.S.解题的时候，画表，行是每个进程，列依次是Work,Need,Allocation,Work+Allocation,Finish</p>
<h4 id="检测死锁"><a href="#检测死锁" class="headerlink" title="检测死锁"></a>检测死锁</h4><h5 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h5><p><img src="https://i.imgur.com/itV3elJ.png" alt=""></p>
<p>资源分配图圆圈表示进程，方框表示资源，方框内点表示资源数，箭头由资源指向进程表示一个单位的资源分配给进程，进程指向资源表示进程请求一个单位的资源</p>
<h5 id="死锁定理"><a href="#死锁定理" class="headerlink" title="死锁定理"></a>死锁定理</h5><p>S为死锁状态的充分条件是当且仅当S状态的资源分配图是不可完全简化</p>
<h5 id="资源分配图的简化"><a href="#资源分配图的简化" class="headerlink" title="资源分配图的简化"></a>资源分配图的简化</h5><p>找出既不阻塞又非独立的进程结点Pi，去掉所有分配边和请求边，若能去掉所有结点的所有分配边和请求边，则不会发生死锁，否则发生死锁</p>
<h4 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁"></a>解除死锁</h4><p>主要方法</p>
<ul>
<li>抢占资源：从一个或多个进程抢占足够资源分配给死锁进程</li>
<li>终止进程</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/08/进程管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MakaLoo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MakaL-0-">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/08/进程管理/" itemprop="url">进程管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-08T22:06:18+08:00">
                2019-05-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/05/08/进程管理/" class="leancloud_visitors" data-flag-title="进程管理">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程的定义，与程序的区别"><a href="#进程的定义，与程序的区别" class="headerlink" title="进程的定义，与程序的区别"></a>进程的定义，与程序的区别</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位，是程序的一次执行。</p>
<h3 id="与程序的区别"><a href="#与程序的区别" class="headerlink" title="与程序的区别"></a>与程序的区别</h3><table>
<thead>
<tr>
<th style="text-align:left">进程</th>
<th style="text-align:left">程序</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">程序是指令的集合，是静态的概念</td>
<td style="text-align:left">进程是处理机上的一次执行过程，动态的概念</td>
</tr>
<tr>
<td style="text-align:left">程序是长期存在的</td>
<td style="text-align:left">进程有生命周期，有创建，活动和消亡</td>
</tr>
<tr>
<td style="text-align:left">程序是指令的有序集合</td>
<td style="text-align:left">进程由程序，PCB和数据组成</td>
</tr>
<tr>
<td style="text-align:left">程序和进程并非一一对应，同一程序同时运行在若干不同数据集上，它将属于若干个不同进程</td>
<td style="text-align:left">一个进程可以执行多个程序</td>
</tr>
</tbody>
</table>
<h2 id="进程的状态及其转换"><a href="#进程的状态及其转换" class="headerlink" title="进程的状态及其转换"></a>进程的状态及其转换</h2><p>进程三种基本状态分别是</p>
<ul>
<li>就绪状态</li>
<li>执行状态</li>
<li>阻塞状态</li>
</ul>
<p>它们的转换关系如下</p>
<p><img src="https://i.imgur.com/NKJai9R.png" alt=""></p>
<p>引入挂起状态（被换出内存的状态）后，进程的转换如下</p>
<p><img src="https://i.imgur.com/I6mlock.png" alt=""></p>
<h3 id="挂起状态"><a href="#挂起状态" class="headerlink" title="挂起状态"></a>挂起状态</h3><p>挂起状态是把进程从内存移出外存，不释放CPU</p>
<p>而阻塞状态是释放CPU，但不释放内存</p>
<p>引入挂起状态的原因是</p>
<ul>
<li>终端用户请求</li>
<li>父进程请求</li>
<li>负荷调节需要</li>
<li>操作系统需要</li>
</ul>
<h2 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a>进程控制块PCB</h2><h3 id="PCB的作用"><a href="#PCB的作用" class="headerlink" title="PCB的作用"></a>PCB的作用</h3><p>PCB是进程的唯一标识，它常驻内存</p>
<ul>
<li>它作为独立运行基本单位的标志</li>
<li>能实现间断性运行方式</li>
<li>提供进程管理所需要的信息</li>
<li>提供进程调度所需要的信息</li>
<li>实现与其他进程的同步和通信</li>
</ul>
<h3 id="PCB的信息"><a href="#PCB的信息" class="headerlink" title="PCB的信息"></a>PCB的信息</h3><p>PCB主要包括以下四个方面的信息</p>
<ul>
<li>进程标识符：外部标识符（针对用户即进程），内部标识符（针对系统）</li>
<li>处理机状态：通用寄存器，指令计数器，用户栈指针，程序状态字等</li>
<li>进程调度信息：进程状态，进程优先级，进程调度其他信息（已等待CPU时间等），事件（阻塞原因）</li>
<li>进程控制信息：程序和数据地址，进程同步和通信机制，资源清单，链接指针（所在队列下一个进程PCB的首地址）</li>
</ul>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>任务：对系统中所有进程从产生，存在到消亡的全过程实施有效的管理和控制</p>
<p>进程控制由内核中原语实现。</p>
<p>原语（Primitive）：由若干条指令组成，用于完成一定功能的一个过程，它们是原子操作，即所有动作要么全不做，要么全做，是不可分割的，不允许被中断的。原语由内核系统态执行，常驻内存。</p>
<p>常见的进程控制原语如下</p>
<ul>
<li>创建</li>
<li>撤销</li>
<li>阻塞：执行-&gt;阻塞</li>
<li>唤醒：阻塞-&gt;就绪</li>
<li>挂起：活动-&gt;静止</li>
<li>激活：静止-&gt;活动</li>
</ul>
<h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><p>进程创建的过程如下</p>
<ol>
<li>申请空白PCB</li>
<li>为新进程分配资源</li>
<li>初始化PCB</li>
<li>新进程插入到就绪队列</li>
</ol>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>同步指并发进程在执行次序上的协调，以达到有效资源共享和相互合作，是程序执行有可再现性。</p>
<p>进程有两种形式的制约关系，分别是</p>
<ul>
<li>资源共享关系：进程间接制约，需互斥地访问临界资源</li>
<li>相互合作关系：进程直接制约</li>
</ul>
<p>临界资源：一次仅允许一个进程访问的资源</p>
<p>临界区：进程访问临界资源的那段代码</p>
<p>同步机制应遵循：</p>
<ul>
<li>空闲让进</li>
<li>忙则等待</li>
<li>有限等待</li>
<li>让权等待：不能进入临界区的进程应放弃CPU执行权</li>
</ul>
<h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><p>实现进程同步有许多方法，其中比较经典的是信号量机制</p>
<h4 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h4><p>整型信号量定义为用于表示资源数目的整型量S，它除初始化外，仅能通过两个原子操作wait(S)和signal(S)来访问，这两个操作一直被称为P，V操作，wait，signal操作描述如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wait(S) &#123;</span><br><span class="line">	<span class="keyword">while</span> (S &lt;= <span class="number">0</span>);</span><br><span class="line">	S--;</span><br><span class="line">&#125;</span><br><span class="line">signal(S) &#123;</span><br><span class="line">	S++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个操作是原子操作，它们在执行的时候是不可中断的</p>
<h4 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h4><p>整型信号量并没有实现让权等待，而是让进程处于忙等状态，这个时候就需要引入记录型信号量来实现</p>
<p>记录型信号量有一个整型变量value表示资源数目，还有一个进程链表指针list，用于链接上述所有等待进程，定义和PV操作描述如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">process_control_block</span> *<span class="title">list</span>;</span></span><br><span class="line">&#125; semaphore;</span><br><span class="line"></span><br><span class="line">wait(semaphore *S) &#123;</span><br><span class="line">	S-&gt;value--;</span><br><span class="line">	<span class="keyword">if</span> (S-&gt;value &lt; <span class="number">0</span>) block(S-&gt;<span class="built_in">list</span>); <span class="comment">// block是阻塞原语，它的意思是把当前进程自我阻塞并插入到S-&gt;list中</span></span><br><span class="line">&#125;</span><br><span class="line">signal(semaphore *S) &#123;</span><br><span class="line">	S-&gt;value++;</span><br><span class="line">	<span class="keyword">if</span> (S-&gt;value &lt;= <span class="number">0</span>) wakeup(S-&gt;<span class="built_in">list</span>); <span class="comment">// wakeup是唤醒原语</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>S-&gt;value是系统中某类资源数目，对它每次wait，意味进程请求一个单位的该类资源，当S-&gt;value &lt; 0，表示该资源已分配完成，进程应调用block原语自我阻塞，并插入到信号量链表S-&gt;list中。当S-&gt;value &lt; 0，它的绝对值是链表中已阻塞进程的数目。对信号量每次signal操作表示执行进程释放一个单位资源，S-&gt;value++，若+1后S-&gt;value仍然&lt;=0，表示该信号量链表中仍有等待该资源的进程被阻塞，调用wakeup原语唤醒该进程.如果S-&gt;value初值为1，则只允许一个进程访问临界资源，此时信号量为互斥信号量。</p>
<h4 id="AND型信号量"><a href="#AND型信号量" class="headerlink" title="AND型信号量"></a>AND型信号量</h4><p>AND同步机制基本思想是：将进程整个运行过程中需要的所有资源，一次性全部分配给进程，使用后一次性释放，原语为Swait(Simultaneous wait)和Swakeup</p>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>引入原因：为了避免凡要使用临界资源的进程都自备同步操作wait(s)和signal(s)，将同步操作的机制和临界资源结合到一起，形成管程</p>
<p>定义：一个数据结构和能为并发进程所执行的一组操作，包括局部于管程的共享变量，对该数据结构进程操作的一组过程，对局部管程数据设置初值</p>
<p>管程语法描述如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Monitor monitor_name &#123; 		 <span class="comment">// 管程名</span></span><br><span class="line">	share variable declarations; <span class="comment">// 共享变量</span></span><br><span class="line">	cond declarations; 			 <span class="comment">// 条件变量</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">P1</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">	</span>&#123;...&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">	</span>&#123;...&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">void</span>(....)</span><br><span class="line">	&#123;...&#125;</span><br><span class="line">	&#123;							 <span class="comment">// 管程主体</span></span><br><span class="line">		initialization code;	 <span class="comment">// 初始化代码</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>用于进程的阻塞和挂起，形式为condition x, y，对条件变量的操作仅仅是wait和signal，每个条件变量保存一个链表，用于记录因该条件变量而阻塞的所有进程，同时提供两个操作x.wait和x.signal</p>
<p>x.wait：正在调用管程的进程因x条件需要被阻塞或挂起，调用x.wait将自己插入到x条件的等待队列上，并释放管程<br>x.signal：正在调用管程的进程发现x条件发生了变化，则调用它，重新启动一个因x条件而阻塞或挂起的进程</p>
<h2 id="进程同步的经典问题"><a href="#进程同步的经典问题" class="headerlink" title="进程同步的经典问题"></a>进程同步的经典问题</h2><h3 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h3><p>问题描述：一组生产者向一组消费者提供消息，它们共享一个包含n个缓冲区的有界缓冲池，生产者向其中投放消息，消费者从中取得消息</p>
<p>问题求解：<strong>互斥信号量mutex实现诸进程对缓冲池的互斥使用，信号量empty和full分别表示缓冲池中空缓冲区和满缓冲区的数量</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> in = <span class="number">0</span>, out = <span class="number">0</span>;</span><br><span class="line">item buffer[n];</span><br><span class="line">semaphore mutex = <span class="number">1</span>, empty = n, full = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		produce an item nextp;</span><br><span class="line">		...</span><br><span class="line">		wait(empty); <span class="comment">// 当空缓冲池数量为0，即缓冲池已满</span></span><br><span class="line">		wait(mutex);</span><br><span class="line">		buffer[in] = nextp;</span><br><span class="line">		in = (in + <span class="number">1</span>) % n;</span><br><span class="line">		signal(mutex);</span><br><span class="line">		signal(full);</span><br><span class="line">	&#125; <span class="keyword">while</span> (TRUE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		wait(full); <span class="comment">// 当满缓冲池为0，即缓冲池已空</span></span><br><span class="line">		wait(mutex);</span><br><span class="line">		nextc = buffer[out];</span><br><span class="line">		out = (out + <span class="number">1</span>) % n;</span><br><span class="line">		signal(mutex);</span><br><span class="line">		signal(empty);</span><br><span class="line">	consume the item in nextc;</span><br><span class="line">	...</span><br><span class="line">	&#125; <span class="keyword">while</span> (TRUE);	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cobegin</span><br><span class="line">		producer(); consumer();</span><br><span class="line">	coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>P操作很重要，假如颠倒了生产者的P操作，先拥有了缓冲池的使用权，但此时无空缓冲池，则会进入死锁</strong>，V操作顺序则无关紧要，<strong>当缓冲区只有一个时，mutex可以省略</strong></p>
<h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><p><img src="https://i.imgur.com/PST5Kvw.png" alt=""></p>
<p>哲学家进餐应定义5个信号量表示5只筷子，且初值均为1，而不能定义1个信号量，因为5个筷子位置不同，哲学家并不是随意拿5个筷子的，他们只能拿他们左右最靠近他们的筷子，描述如下<br><code>semaphore chopstick[5] = {1, 1, 1, 1, 1};</code></p>
<p>第i个哲学家的活动可描述为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	wait(chopstick[i]);</span><br><span class="line">	wait(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// eat</span></span><br><span class="line">	...</span><br><span class="line">	signal(chopstick[i]);</span><br><span class="line">	signal(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// think</span></span><br><span class="line">	...</span><br><span class="line">&#125; <span class="keyword">while</span>(TRUE)</span><br></pre></td></tr></table></figure>
<p>哲学家问题出现死锁的可能是：五个哲学家同时饥饿而各自拿起左边的筷子，就会使5个信号量chopstick均为0，当他们再试图去拿右边的筷子时，会因没有筷子可拿而无限等待</p>
<p>解决方法有如下几个：</p>
<p>1.至多允许有4位哲学家同时拿左边筷子，方法：设置信号量sm初值为4</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">philopher(i) &#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		wait(sm);</span><br><span class="line">		wait(chopstick[i]);</span><br><span class="line">		wait(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">		eat;</span><br><span class="line">		signal(sm);</span><br><span class="line">		signal(chopstick[i]);</span><br><span class="line">		signal(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">		signal(sm);</span><br><span class="line">		think;</span><br><span class="line">	&#125; <span class="keyword">while</span> (TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.规定奇数号哲学家先拿他左手边的筷子，再拿右手边的筷子，偶数号哲学家相反</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">philopher(i) &#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">			wait(chopstick[i]);</span><br><span class="line">			wait(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">			eat;</span><br><span class="line">			signal(chopstick[i]);</span><br><span class="line">			signal(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			wait(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">			wait(chopstick[i]);</span><br><span class="line">			eat;</span><br><span class="line">			signal(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">			signal(chopstick[i]);</span><br><span class="line">		&#125;	</span><br><span class="line">		think;</span><br><span class="line">	&#125; <span class="keyword">while</span> (TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.仅当左右手两只筷子均可用的时候，才拿起筷子进餐，利用AND信号量解决</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">philopher(i) &#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		Sswait(chopstick[i], chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>])</span><br><span class="line">		eat;</span><br><span class="line">		Ssignal(chopstick[i], chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">		think;</span><br><span class="line">	&#125; <span class="keyword">while</span> (TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h3><p>问题描述：读进程可共享同一对象，写进程不可共享同一对象</p>
<p>分析：整型变量readcount表示读者数，信号量rmutex互斥访问readcount，wmutex读写互斥，只要有一个进程在读，就不允许写进程去写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">semaphore rmutex = <span class="number">1</span>, wmutex = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> readcount = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		wait(rmutex); <span class="comment">// readcount的互斥访问</span></span><br><span class="line">		<span class="keyword">if</span> (readcount == <span class="number">0</span>) wait(wmutex); <span class="comment">// 读写互斥，当该进程为第一个读进程，判断是否有写进程在写，有则阻塞，无则加锁</span></span><br><span class="line">		readcount++;</span><br><span class="line">		signal(rmutex);</span><br><span class="line">		...</span><br><span class="line">		perform read operation;</span><br><span class="line">		...</span><br><span class="line">		wait(rmutex);</span><br><span class="line">		readcount--;</span><br><span class="line">		<span class="keyword">if</span> (readcount == <span class="number">0</span>) signal(wmutex);</span><br><span class="line">		signal(rmutex);</span><br><span class="line">	&#125; <span class="keyword">while</span> (TRUE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		wait(wmutex);</span><br><span class="line">		perform write operation;</span><br><span class="line">		signal(wmutex);</span><br><span class="line">	&#125; <span class="keyword">while</span> (TRUE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cobegin</span><br><span class="line">		reader(); writer();</span><br><span class="line">	coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="读-写问题的扩散——写者优先"><a href="#读-写问题的扩散——写者优先" class="headerlink" title="读-写问题的扩散——写者优先"></a>读-写问题的扩散——写者优先</h4><p>即当写进程到达后，后续的读进程必须等待</p>
<p>方法：增加信号量S（初值1），当写进程运行时上锁，封锁后续读者。增加信号量s后，当读进程读，先wait(s)，若后续读进程运行，都会进入s的阻塞队列，而不会在其他进程读的期间（上锁了s，没有上锁rmutex）进入wmutex的阻塞队列，当有写进程运行并进入s的阻塞队列，后续再有读进程进入s的阻塞队列，都排在写进程之后，当前面读进程释放s后，写进程就可以对s上锁，阻止后续读进程了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">semaphore rmutex = <span class="number">1</span>, wmutex = <span class="number">1</span>, s = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> readcount = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		wait(s);</span><br><span class="line">		wait(rmutex); <span class="comment">// readcount的互斥访问</span></span><br><span class="line">		<span class="keyword">if</span> (readcount == <span class="number">0</span>) wait(wmutex); <span class="comment">// 读写互斥，当该进程为第一个读进程，判断是否有写进程在写，有则阻塞，无则加锁</span></span><br><span class="line">		readcount++;</span><br><span class="line">		signal(rmutex);</span><br><span class="line">		signal(s);</span><br><span class="line">		...</span><br><span class="line">		perform read operation;</span><br><span class="line">		...</span><br><span class="line">		wait(rmutex);</span><br><span class="line">		readcount--;</span><br><span class="line">		<span class="keyword">if</span> (readcount == <span class="number">0</span>) signal(wmutex);</span><br><span class="line">		signal(rmutex);</span><br><span class="line">	&#125; <span class="keyword">while</span> (TRUE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		wait(s);</span><br><span class="line">		wait(wmutex);</span><br><span class="line">		perform write operation;</span><br><span class="line">		signal(wmutex);</span><br><span class="line">		signal(s);</span><br><span class="line">	&#125; <span class="keyword">while</span> (TRUE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cobegin</span><br><span class="line">		reader(); writer();</span><br><span class="line">	coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程通信实质是进程间的信息交换，有如下几种通信方式</p>
<ul>
<li>信号量机制：低级，效率低，对用户不透明</li>
<li>共享存贮器：共享存储区等</li>
<li>消息传递系统：交换报文，由一组通信原语实现</li>
<li>管道通信：管道是连接一个读进程和一个写进程之间通信的共享文件</li>
<li>客户机-服务器系统：套接字等</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/10/JavaScript09-事件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MakaLoo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MakaL-0-">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/10/JavaScript09-事件/" itemprop="url">JavaScript09-事件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-10T11:08:34+08:00">
                2019-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/04/10/JavaScript09-事件/" class="leancloud_visitors" data-flag-title="JavaScript09-事件">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JavaScript09-事件"><a href="#JavaScript09-事件" class="headerlink" title="JavaScript09-事件"></a>JavaScript09-事件</h1><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>事件流描述的是从页面中接收事件的顺序。如果单击某个按钮，那么单击事件不仅仅发生在按钮上，同样发生在按钮的容器元素，甚至整个页面上。<strong>事件冒泡就是最具体的元素最先接收这个事件，然后逐级向上，事件捕获则相反。</strong></p>
<h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>事件冒泡是IE提出的，即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>aha<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>点击&lt;div&gt;元素，那么这个click事件就按照如下顺序传播：</p>
<ol>
<li>&lt;div&gt;</li>
<li>&lt;body&gt;</li>
<li>&lt;html&gt;</li>
<li>document</li>
</ol>
<h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>Netscape Communicator团队提出的另一种事件流。事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。仍以上面html代码为例，单击&lt;div&gt;元素就会以下列顺序触发click事件</p>
<ol>
<li>document</li>
<li>&lt;html&gt;</li>
<li>&lt;body&gt;</li>
<li>&lt;div&gt;</li>
</ol>
<p>一般考虑到老版本，使用事件冒泡更多。</p>
<h3 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h3><p>DOM2级事件规定的事件流包括三个阶段：事件捕获阶段，处于目标阶段和事件冒泡阶段。</p>
<h2 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h2><p>事件处理程序名字以”on”开头，因此click事件的事件处理程序就是onclick，load事件的事件处理程序就是onload。</p>
<h3 id="HTML事件处理程序"><a href="#HTML事件处理程序" class="headerlink" title="HTML事件处理程序"></a>HTML事件处理程序</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    function showMessage() &#123;</span></span><br><span class="line"><span class="undefined">        alert("Hello World!");</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"showMessage()"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样指定事件处理程序会创建一个封装着元素属性值的函数，这个函数中有一个局部变量event，也就是事件对象</p>
<p><code>&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(event.type)&quot; /&gt; // &quot;click&quot;</code></p>
<p>通过event对象，可以直接访问事件对象，在这个函数内部，this值等于事件的目标元素</p>
<p><code>&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(this.value)&quot; /&gt; // 返回元素的value属性，这里为&quot;Click Me&quot;</code></p>
<p>关于这个动态创建的函数，可以像访问局部变量一样访问document及该元素本身的成员，使用with像下面这样扩展：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">with</span>(<span class="built_in">document</span>)  &#123;</span><br><span class="line">		<span class="keyword">with</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">			<span class="comment">// 元素属性值</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前元素是一个表单输入元素，则作用域还会包含访问表单元素的入口，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">with</span>(<span class="built_in">document</span>)  &#123;</span><br><span class="line">		<span class="keyword">with</span>(<span class="keyword">this</span>.form) &#123;</span><br><span class="line">			<span class="keyword">with</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">				<span class="comment">// 元素属性值</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>扩展这个作用域的方式，主要是想让事件处理程序无需引用表单元素就能访问其他表单字段，例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Echo Username"</span> <span class="attr">onclick</span>=<span class="string">"alert(username.value)"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="DOM0级事件处理程序"><a href="#DOM0级事件处理程序" class="headerlink" title="DOM0级事件处理程序"></a>DOM0级事件处理程序</h3><p>通过JavaScript指定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性。如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var btn = document.getElementById(&quot;myBtn&quot;);</span><br><span class="line">btn.onclick = function() &#123;</span><br><span class="line">    alert(&quot;Clicked&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用DOM0级方法执行的事件处理程序被认为是元素的方法，程序中的this引用的是当前元素。<br>只需把属性值设置为null就可以删除事件处理程序</p>
<h3 id="DOM2级事件处理程序"><a href="#DOM2级事件处理程序" class="headerlink" title="DOM2级事件处理程序"></a>DOM2级事件处理程序</h3><p>DOM2级事件定义了两个方法，用于处理指定和删除事件处理程序的操作：addEventListener()和removeEventListener()。所有DOM节点都包含这两个方法，它们接收3个参数：要处理的事件名，作为事件处理程序的函数和一个布尔值。这个布尔值若为true，表示捕获阶段调用事件处理程序；如果是false，表示冒泡阶段调用事件处理程序。</p>
<p>DOM2级方法主要好处是可以添加多个事件处理程序，如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"Hello World!"</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>通过addEventListener()添加的事件处理程序只能使用removeEventListener()来移除；移除时传入的参数要与添加处理程序时使用的参数相同，即添加的匿名参数无法移除。</p>
<p>大多数情况下，都是把事件处理程序添加到事件流的冒泡阶段，这样可以最大限度地兼容各种浏览器。最好只在需要在事件到达目标之前截获它的时候将事件处理程序添加到捕获阶段。如果不是特别需要，不建议在事件捕获阶段注册事件处理程序。</p>
<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>在触发DOM上某个事件时，会产生一个事件对象event，这个对象中包含所有与事件有关的信息，包括导致事件的元素，事件的类型以及其他与特定事件相关的信息。例如鼠标操作导致的鼠标位置的信息等。</p>
<h3 id="DOM中的事件对象"><a href="#DOM中的事件对象" class="headerlink" title="DOM中的事件对象"></a>DOM中的事件对象</h3><p>兼容DOM的浏览器会将一个event对象传入到事件处理程序中。</p>
<p>关于event的更多（比如其成员),可以看<a href="https://developer.mozilla.org/en-US/docs/Web/API/Event" target="_blank" rel="noopener">MDN的DOM Event接口</a></p>
<p>如果事件处理程序指定给目标元素，则this，currentTarget和target是相同的，事件处理程序内部，对象this始终等于currentTarget的值，如果事件处理程序存在于父节点中，则这些值是不同的，如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(event.currentTarget == <span class="built_in">document</span>.body);</span><br><span class="line">    alert(<span class="built_in">document</span>.body == <span class="keyword">this</span>);</span><br><span class="line">    alert(event.target == btn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要处理一个函数处理多个事件的时候，可以使用type属性，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(event.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"click"</span> :</span><br><span class="line">            alert(<span class="string">"clicked"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"mouseover"</span> :</span><br><span class="line">            event.target.style.backgroundColor = <span class="string">"red"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"mouseout"</span> :</span><br><span class="line">            event.target.style.backgroundColor = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">btn.onclick = handler;</span><br><span class="line">btn.onmouseover = handler;</span><br><span class="line">btn.onmouseout = handler;</span><br></pre></td></tr></table></figure>
<p>要阻止特定事件的默认行为，可以使用preventDefault()方法。例如，链接的默认行为就是在被单击的时候会导航到其href特性指定的URL。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.getElementById(<span class="string">"myLink"</span>);</span><br><span class="line">link.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有cancelable属性设置为true的事件，才可以使用preventDefault()方法来取消默认行为。</p>
<p>stopPropagation()方法用于立即停止事件在DOM层次中的传播，即取消进一步事件捕获或冒泡。例如，直接添加到一个按钮的事件处理程序可以调用stopPropagation()，从而避免触发注册在document.body上面的事件处理程序。</p>
<p>eventPhase属性可以用来确定事件当前位于事件流的哪个阶段。如果是在捕获阶段调用事件处理程序，那么eventPhase的值为1，如果事件处理程序在目标对象上，则eventPhase值为2，如果是在冒泡阶段调用的事件处理程序，eventPhase等于3。</p>
<h3 id="跨浏览器的事件对象"><a href="#跨浏览器的事件对象" class="headerlink" title="跨浏览器的事件对象"></a>跨浏览器的事件对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line"></span><br><span class="line">    addHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">            element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">            <span class="comment">// IE事件处理程序</span></span><br><span class="line">            element.attachEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            element[<span class="string">"on"</span> + type] = handler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    getEvent: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> event ? event : <span class="built_in">window</span>.event;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    getTarget: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> event.target || event.srcElement;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    preventDefault: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event.preventDefault) &#123;</span><br><span class="line">            event.preventDefault();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            event.returnValue = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    removeHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (element.removeEventListener) &#123;</span><br><span class="line">            element.removeEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</span><br><span class="line">            element.detachEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            element[<span class="string">"on"</span> + type] = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    stopPropagation: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event.stopPropagation) &#123;</span><br><span class="line">            event.stopPropagation();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与mouseout，mouseover事件相关的属性，见下面</span></span><br><span class="line">    getRelatedTarget: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event.relatedTarget) &#123;</span><br><span class="line">            <span class="keyword">return</span> event.relatedTarget;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.toElement) &#123;</span><br><span class="line">            <span class="comment">// 兼容IE8</span></span><br><span class="line">            <span class="keyword">return</span> event.toElement;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.fromElement) &#123;</span><br><span class="line">            <span class="keyword">return</span> event.fromElement;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 与mousedown，mouseout事件相关的鼠标属性</span></span><br><span class="line">	getButton: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">document</span>.implementation.hasFeature(<span class="string">"MouseEvents"</span>, <span class="string">"2.0"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> event.button;    </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span>(event.button) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><p>DOM3级事件规定了以下几类事件</p>
<ul>
<li>UI事件：当用户与页面上的元素交互时触发；</li>
<li>焦点事件：当元素获得或失去焦点时触发；</li>
<li>鼠标事件：当用户通过鼠标在页面上执行操作时触发；</li>
<li>滚轮事件：当使用鼠标滚轮时触发；</li>
<li>文本事件：当在文档中输入文本时触发；</li>
<li>键盘事件：当用户通过键盘在页面上执行操作时触发；</li>
<li>合成事件：当为IME（输入法编辑器）输入字符时触发；</li>
<li>变动事件：当底层DOM结构发生变化时触发。</li>
</ul>
<h3 id="UI事件"><a href="#UI事件" class="headerlink" title="UI事件"></a>UI事件</h3><p>UI事件指的是那些不一定与用户操作有关的事件，有如下UI事件。</p>
<ul>
<li>load：当页面完全加载后在window上触发，当所有框架都加载完毕时在框架集上触发，当图像加载完毕在&lt;img&gt;元素上触发，或者当嵌入的内容加载完毕时在&lt;object&gt;元素上触发。</li>
<li>unload：当页面完全卸载后在window上触发，当所有框架都卸载后在框架集上触发，或当嵌入的内容卸载后在&lt;object&gt;元素上触发。</li>
<li>abort：在用户停止下载过程时，如果浅入的内容没有加载完，则在&lt;object&gt;元素上触发。</li>
<li>error：当发生在JavaScript错误时在window上触发，当无法加载图像时在&lt;img&gt;上触发，当无法加载嵌入内容时在&lt;object&gt;上触发，或者当有一或多个框架无法加载时在框架集上触发。</li>
<li>select：当用户选择文本框（&lt;input&gt;或&lt;texterea&gt;）中的一或多个字符时触发。</li>
<li>resize：当窗口或框架大小变化时在window或框架上触发。</li>
<li>scroll：当用户滚动带滚动条的元素中的内容时，在该元素上触发。&lt;body&gt;元素中包含所加载页面的滚动条。</li>
</ul>
<p>确定浏览器是否支持DOM2级事件规定的HTML事件，可以用如下代码</p>
<p><code>var isSupported = document.implementation.hasFeature(&quot;HTMLEvents&quot;, &quot;2.0&quot;);</code></p>
<p>确定浏览器是否支持DOM3级事件定义的事件，可以用如下代码</p>
<p><code>var isSupported = document.implementation.hasFeature(&quot;UIEvent&quot;, &quot;3.0&quot;);</code></p>
<h4 id="load事件"><a href="#load事件" class="headerlink" title="load事件"></a>load事件</h4><p>当页面完全加载后（包括所有图像，JS文件，CSS等外部资源），就会触发window上的load事件。</p>
<p>有两种添加onload事件处理程序的方式，一个是使用上面的EventUtil，另一个就是给&lt;body&gt;元素添加onload特性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"loaded!"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>&lt;body onload=&quot;alert(&#39;Loaded!&#39;)&quot;&gt;&lt;/body&gt;</code></p>
<p>一般来说，在window上面发生的任何事件都可以在&lt;body&gt;元素中通过相应的特性来指定。</p>
<p>对于&lt;img&gt;元素，可以为其指定一个事件处理程序，以便图像加载完毕后给出提示。此时，<strong>最重要的是要在指定的属性之前先加载指定事件。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> image = <span class="built_in">document</span>.createElement(<span class="string">"img"</span>);</span><br><span class="line">    EventUtil.addHandler(image, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        event = EventUtil.getEvent(event);</span><br><span class="line">        alert(EventUtil.getTarget(event).src);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line">    image.src = <span class="string">"./a.jpg"</span>;    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>还有一些元素也以非标准方式支持load事件，&lt;script&gt;元素也会触发load事件，以便开发人员确定动态加载的JS文件是否加载完毕。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">    EventUtil.addHandler(script, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">"Loaded!"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    script.src = <span class="string">"example.js"</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="unload事件"><a href="#unload事件" class="headerlink" title="unload事件"></a>unload事件</h4><p>在文档被完全卸载后触发。只要用户从一个页面切换到另一个页面，就会发生unload事件。利用这个事件最多的情况就是清除引用，以避免内存泄漏。unload事件的对象同样是window。</p>
<h4 id="resize事件"><a href="#resize事件" class="headerlink" title="resize事件"></a>resize事件</h4><p>当浏览器窗口被调整到一个新的高度或宽度的时候，就会触发resize事件。这个事件在window上触发。不同浏览器resize事件处理不同，有可能是变化了1像素就触发，然后随着变化不断重复触发，也有可能用户停止调整窗口大小的时候才触发。</p>
<h4 id="scroll事件"><a href="#scroll事件" class="headerlink" title="scroll事件"></a>scroll事件</h4><p>scroll事件同样是在window上发生的，尽管它实际表示的是页面中相应元素的变化。scroll事件在滚动期间重复被触发。</p>
<h3 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h3><p>焦点事件会在页面元素获得或失去焦点时触发。利用这些元素并与document.hasFocus()方法及document.activeElement属性配合，可以知晓用户在页面上的行踪。有以下6个焦点事件。</p>
<ul>
<li>blur：在元素失去焦点时触发。这个事件不会冒泡。</li>
<li>focus：元素获得焦点的时候触发。不会冒泡。</li>
<li>focusin：元素获得焦点时触发，与HTML事件focus等价。</li>
<li>focusout：元素失去焦点时触发。</li>
</ul>
<p>当焦点从页面中一个元素移动到另一个元素，会依次触发下列事件：</p>
<ol>
<li>focusout在失去焦点元素上触发。</li>
<li>focusin在获得焦点元素上触发。</li>
<li>blur</li>
<li>focus</li>
</ol>
<p>确定浏览器是否支持这些事件：</p>
<p><code>var isSupported = document.implementation.hasFeature(&quot;FocusEvent&quot;, &quot;3.0&quot;);</code></p>
<h3 id="鼠标与滚轮事件"><a href="#鼠标与滚轮事件" class="headerlink" title="鼠标与滚轮事件"></a>鼠标与滚轮事件</h3><ul>
<li>click：用户单击主鼠标按钮或按下回车触发。</li>
<li>dblclick：用户双击主鼠标按钮触发。</li>
<li>mousedown：用户按下任意鼠标按钮触发。</li>
<li>mouseenter：鼠标光标从元素外部首次移动到元素范围之内时触发。这个事件不冒泡，在光标移动到后代元素上不会触发。</li>
<li>mouseleave：在位于元素上方的鼠标光标移动到元素范围之外时触发。这个事件不冒泡，光标移到后代元素上不会触发。</li>
<li>mousemove：鼠标指针在元素内部移动时重复触发。</li>
<li>mouseout：鼠标指针位于一个元素上方，然后用户将其移入到另一个元素时触发。另一个元素可以是该元素的外部元素或子元素。</li>
<li>mouseover：鼠标指针位于一个元素外部，首次移入另一个元素边界之内触发。</li>
<li>mouseup：用户释放鼠标按钮时触发。</li>
</ul>
<p>检查是否支持上面事件可以使用如下代码</p>
<p><code>var isSupported = document.implementation.hasFeature(&quot;MouseEvent&quot;, &quot;3.0&quot;);
alert(isSupported);</code></p>
<h4 id="客户区坐标位置"><a href="#客户区坐标位置" class="headerlink" title="客户区坐标位置"></a>客户区坐标位置</h4><p>鼠标事件都是在浏览器视口中的特定位置上发生的，这个位置信息保存在事件对象的clientX和clientY属性中。<br><a href="https://blog.csdn.net/zshsats/article/details/79942126" target="_blank" rel="noopener">视口坐标，页面坐标，屏幕坐标的区别可以看这个</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line">EventUtil.addHandler(div, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    alert(<span class="string">"Client coordinates: "</span> + event.clientX + <span class="string">","</span> + event.clientY);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="页面坐标位置"><a href="#页面坐标位置" class="headerlink" title="页面坐标位置"></a>页面坐标位置</h4><p>通过客户区坐标位置能够知道鼠标是在视口中什么位置发生的，而页面坐标通过事件对象的pageX和pageY属性，告诉你事件是在页面中什么位置发生的。这两个属性表示鼠标光标在页面中的位置。坐标是从页面本身而非视口左边和顶边计算。</p>
<p><strong>当页面没有滚动的的时候，页面坐标等于视口坐标，如果有滚动，页面坐标为滚动高度加上视口坐标。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line">EventUtil.addHandler(div, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    alert(<span class="string">"Page coordinates: "</span> + event.pageX + <span class="string">","</span> + event.pageY);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="屏幕坐标位置"><a href="#屏幕坐标位置" class="headerlink" title="屏幕坐标位置"></a>屏幕坐标位置</h4><p>屏幕坐标位置是相对于整个电脑屏幕的位置。属性为screenX和screenY。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line">EventUtil.addHandler(div, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    alert(<span class="string">"Screen coordinates: "</span> + event.screenX + <span class="string">","</span> + event.screenY);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="修改键"><a href="#修改键" class="headerlink" title="修改键"></a>修改键</h4><p>按下鼠标时键盘上的某些键的状态也可以影响到所要采取的操作。这些修改键是Shift，Ctrl，Alt和Meta（Windows的win键）。<strong>DOM为此规定了4个属性，表示这4个修改键的状态：shiftKey，ctrlKey，altKey和metaKey。这些属性中包含的都是布尔值</strong>，如果相应键按下，值为true，否则为false。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line">EventUtil.addHandler(div, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    <span class="keyword">var</span> keys = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event.shiftKey) &#123;</span><br><span class="line">        keys.push(<span class="string">"shift"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event.ctrlKey) &#123;</span><br><span class="line">        keys.push(<span class="string">"ctrl"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event.altKey) &#123;</span><br><span class="line">        keys.push(<span class="string">"alt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event.metaKey) &#123;</span><br><span class="line">        keys.push(<span class="string">"meta"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    alert(<span class="string">"Keys: "</span> + keys.join(<span class="string">","</span>));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="相关元素"><a href="#相关元素" class="headerlink" title="相关元素"></a>相关元素</h4><p>发生mouseover和mouseout事件时，还会涉及更多的元素。这两个事件都会涉及把鼠标指针从一个元素的边界之内移动到另一个元素的边界之内。<strong>对mouseover事件而言，事件的主目标是获得光标的元素，而相关元素是那个失去光标的元素。</strong>类似地，对mouseout事件而言，事件的主目标是失去光标的元素，而相关元素则是获得光标的元素。</p>
<p>DOM通过event对象的relatedTarget属性提供了相关元素的信息。这个属性只对mouseover和mouseout事件才包含值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line">EventUtil.addHandler(div, <span class="string">"mouseout"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    <span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line">    <span class="keyword">var</span> relatedTarget = EventUtil.getRelatedTarget(event);</span><br><span class="line">    alert(<span class="string">"Mouse out of "</span> + target.tagName + <span class="string">" to "</span> + relatedTarget.tagName);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="鼠标按钮"><a href="#鼠标按钮" class="headerlink" title="鼠标按钮"></a>鼠标按钮</h4><p>只有在主鼠标按钮被单击（或键盘回车被按下）的时候才会触发click事件，因此检测按钮的信息并不是必要的。但<strong>对于mousedown和mouseup事件来说，在其event对象内存在一个button属性，表示按下或释放的按钮。DOM的button属性可能有如下3个值：0表示主鼠标按钮，1表示中间鼠标按钮（滚轮按钮），2表示次鼠标按钮。</strong>IE8之前的button属性与DOM有很大差异，不做表述。具体的兼容鼠标检测见上面EventUtil</p>
<h4 id="更多的事件信息"><a href="#更多的事件信息" class="headerlink" title="更多的事件信息"></a>更多的事件信息</h4><p>DOM2级事件规范在event事件中还提供了detail属性，用于给出有关事件的更多信息。对于鼠标事件来说，detail中包含一个数值，表示在给定位置上发生了多少次单击。同一元素上相继发生一次mousedown和一次mouseup事件算一次单击。detail属性从1开始计数，每次单击后递增。如果鼠标在mouseup和mousedown之间移动了位置，detail会被重置为0.</p>
<h4 id="鼠标滚轮事件"><a href="#鼠标滚轮事件" class="headerlink" title="鼠标滚轮事件"></a>鼠标滚轮事件</h4><p>mousewheel事件，当用户通过鼠标滚轮与页面发生交互，在垂直方向上滚动页面时（无论向上向下），就会触发mousewheel事件。这个事件可以在任何元素上触发，最终冒泡到window对象。mousewheel事件包含一个特殊的wheelDelta属性。当用户向前滚动鼠标滚轮，wheelDelta是120的倍数，当用户向后滚动滚轮，wheelDelta是-120的倍数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">"mousewheel"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    alert(event.wheelDelta);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>跨浏览器的解决方案</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getWheelDelta: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.wheelDelta) &#123;</span><br><span class="line">        <span class="keyword">return</span> (client.engine.opera &amp;&amp; client.engine.opera &lt; <span class="number">9.5</span> ? -event.wheelDelta : event.wheelDelta);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -event.detail * <span class="number">40</span>; <span class="comment">//兼容Firefox</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="键盘与文本事件"><a href="#键盘与文本事件" class="headerlink" title="键盘与文本事件"></a>键盘与文本事件</h3><p>有三个键盘事件，如下：</p>
<ul>
<li>keydown：当用户按下键盘上的任意键时触发，如果按住不放，则重复触发。</li>
<li>keypress：当用户按下键盘上的字符键时触发，如果按住不放会重复触发。</li>
<li>keyup：当用户释放键盘上的键时触发。</li>
</ul>
<p>用户按下一个字符键时，首先触发keydown，其次是keypress，最后是keyup。键盘事件同样也有shiftKey，ctrlKey，altKey和metaKey。</p>
<h4 id="键码"><a href="#键码" class="headerlink" title="键码"></a>键码</h4><p>在发生keydown和keyup事件时，event对象的keyCode属性会包含一个代码。对数字字母字符键，keyCode属性的值与ASCII中对应小写字母或数字的编码相同。<a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode" target="_blank" rel="noopener">其他keyCode值在这里！</a></p>
<h4 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h4><p>charCode属性<strong>只有在发生keypress事件时</strong>才包含值，而且<strong>这个值是按下的那个键所代表的字符的ASCII编码</strong>。此时keyCode通常等于0或者也可能等于所按键的键码。对于IE8及其之前版本和Opera，则用keyCode来保存字符的ASCII编码，跨浏览器获取字符编码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getCharCode: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> event.charCode == <span class="string">"number"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> event.charCode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> event.keyCode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在DOM3级事件中，不再有charCode属性，而是key和char属性。<br>key属性是一个字符串，当按下字符键，他的值是字符键的值（如”A”，”k”），当按下非字符键，他的值是相应键的名（如”Shift”，”Down”）。<br>char属性按下字符键时显示字符键的值，按下非字符键，显示null。<br>（存在跨浏览器的问题，所以不推荐使用上面两个值，以及Chorme和Safari 5的KeyIdentifier）</p>
<h4 id="textInput事件"><a href="#textInput事件" class="headerlink" title="textInput事件"></a>textInput事件</h4><p>DOM3级事件规范引入的一个新事件，当用户在可编辑区域输入字符时，就会触发这个事件。任何可以获得焦点的元素都可以触发keypress事件，但只有可编辑区域才会触发textInput事件。textInput只会在用户按下能够输入实际字符的键时才会被触发，而keypress事件则在按下那些能够影响文本显示的键时也会触发（比如退格）。</p>
<p>textInput事件有一个data属性，表示用户输入的字符。</p>
<h3 id="变动事件"><a href="#变动事件" class="headerlink" title="变动事件"></a>变动事件</h3><p>DOM2级的变动事件能在DOM中某一部分发生变化时给出提示。为XML或HTML DOM设计。DOM2级定义了如下变动事件。</p>
<ul>
<li>DOMSubtreeModified：在DOM结构中发生任何变化时触发。这个事件在其他任何事件触发后都会触发。</li>
<li>DOMNodeInserted：在一个结点作为子节点被插入到另一个节点中触发。</li>
<li>DOMNodeRemoved：在结点从其父节点中被移除时触发。</li>
</ul>
<p><code>var isSupported = document.implementation.hasFeature(&quot;MutationEvents&quot;, &quot;2.0&quot;);</code>检查是否支持变动事件。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Mutation_events" target="_blank" rel="noopener">MDN的mutation事件</a></p>
<h3 id="设备事件与触摸手势事件"><a href="#设备事件与触摸手势事件" class="headerlink" title="设备事件与触摸手势事件"></a>设备事件与触摸手势事件</h3><p>主要用于智能手机和平板电脑</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/10/DNS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MakaLoo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MakaL-0-">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/10/DNS/" itemprop="url">计算机网络之DNS服务</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-10T11:08:34+08:00">
                2019-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/04/10/DNS/" class="leancloud_visitors" data-flag-title="计算机网络之DNS服务">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>DNS是计算机网络应用层一个很重要的服务，了解它基本就了解了整个网络中域名到IP转换的过程。</p>
<h2 id="DNS是什么"><a href="#DNS是什么" class="headerlink" title="DNS是什么"></a>DNS是什么</h2><p>在《计算机网络-自顶向下方法》中有这么一句话</p>
<blockquote>
<p>DNS：因特网的目录服务</p>
</blockquote>
<p>DNS（Domain Name System）其实就是一个目录，他的作用是通过用户给定域名，查出对应的IP地址。</p>
<p>而更为严格的定义就是：<br>DNS是：</p>
<ul>
<li>一个由分层的DNS服务器实现的分布式数据库</li>
<li>一个使得主机能够查询分布式数据库的应用层协议</li>
</ul>
<p>或者说DNS是一个黑盒子，它提供了主机名到IP地址的转换，一个简便的DNS黑盒子过程如下：</p>
<ol>
<li>同一台用户主机上运行着DNS应用的客户端</li>
<li>浏览器从URL中抽取出主机名，传给DNS应用的客户端</li>
<li>DNS客户向DNS服务器发送一个包含主机名的请求</li>
<li>DNS客户最终收到一份回答报文，其中含有对应该主机名的IP地址</li>
<li>一旦浏览器获得该地址，就可以向位于该IP地址的80端口的HTTP服务器进程发起一个TCP连接</li>
</ol>
<p>DNS主要任务是主机名到IP地址转换的目录服务<br>DNS除了有主机名到IP地址的转换服务外，还有如下服务：</p>
<ul>
<li>主机别名</li>
<li>邮件服务器别名</li>
<li>负载分配</li>
</ul>
<p>值得一提的是，DNS协议运行在UDP之上，使用53端口。</p>
<h2 id="DNS分布式，层次数据库"><a href="#DNS分布式，层次数据库" class="headerlink" title="DNS分布式，层次数据库"></a>DNS分布式，层次数据库</h2><p>DNS是一个分布式，层次数据库，大致有三类：根DNS服务器，顶级域(TLD)DNS服务器和权威DNS服务器。<br>还有一类是本地DNS服务器，每个ISP都有一台本地DNS服务器，本地DNS服务器起着代理的作用，将请求转发到DNS服务器的层次结构中。</p>
<p><img src="https://i.imgur.com/jsC0CRt.png" alt=""></p>
<p>在说服务器分层作用之前，先要说一下域名，常见的域名是例如<code>www.example.com</code>，但是它真正的域名是<code>www.example.com.root</code>，只是省略了后面的<code>.root</code>。<code>.root</code>称为根域名，<code>.com</code>，<code>.net</code>等等称为顶级域名(TLD)，<code>.example</code>称为次级域名，这个域名是用户可以注册的，再下一级是主机名(host)，比如<code>www</code>，又称为三级域名。</p>
<p>总结一下，域名的层级结构如下：</p>
<p><code>主机名(三级域名).次级域名.顶级域名.根域名</code></p>
<p>即<code>host.sld.tld.root</code></p>
<h3 id="根DNS服务器"><a href="#根DNS服务器" class="headerlink" title="根DNS服务器"></a>根DNS服务器</h3><p>它将返回顶级域名的TLD服务器的IP地址，根域名服务器的NS记录和IP地址一般是不会变化的</p>
<h3 id="顶级域DNS服务器"><a href="#顶级域DNS服务器" class="headerlink" title="顶级域DNS服务器"></a>顶级域DNS服务器</h3><p>它返回权威服务器的IP地址</p>
<h3 id="权威DNS服务器"><a href="#权威DNS服务器" class="headerlink" title="权威DNS服务器"></a>权威DNS服务器</h3><p>它返回主机名(如<a href="http://www.amazon.com)的IP地址" target="_blank" rel="noopener">www.amazon.com)的IP地址</a></p>
<h3 id="本地DNS服务器"><a href="#本地DNS服务器" class="headerlink" title="本地DNS服务器"></a>本地DNS服务器</h3><p>严格上来说它不属于DNS层次结构，但它也很重要。本地DNS服务器由ISP提供，当主机发出DNS请求时，通常被发往到本地DNS服务器，由本地DNS服务器代理转发到DNS服务器层次结构</p>
<h2 id="工作机理"><a href="#工作机理" class="headerlink" title="工作机理"></a>工作机理</h2><p><img src="https://i.imgur.com/4klvXoE.png" alt=""></p>
<p>以主机<code>cis.poly.edu</code>请求<code>gaia.cs.umass.ude</code>的IP地址为例，假设<code>cis.poly.edu</code>的本地DNS为<code>dns.poly.edu</code>，并且<code>gaia.cs.umass.edu</code>的权威DNS服务器为<code>dns.umass.edu</code></p>
<ol>
<li>主机<code>cis.poly.edu</code>首先向它的本地DNS服务器<code>dns.poly.edu</code>发送一个DNS查询报文</li>
<li>本地DNS服务器<code>dns.poly.edu</code>将报文转发到根DNS服务器，根DNS服务器注意到edu前缀并向本地DNS服务器返回负责edu的TLD的IP地址列表</li>
<li>该本地DNS服务器则再次向这些TLD服务器之一发送查询报文</li>
<li>该TLD服务器注意到<code>umass.edu</code>前缀，并用权威DNS服务器的IP地址进行响应</li>
<li>最后，本地DNS服务器直接向<code>dns.umass.edu</code>重发查询报文，<code>dns.umass.edu</code>将<code>gaia.cs.umass.edu</code>的IP地址进行响应</li>
</ol>
<p>从请求主机到本地DNS服务器的查询是递归的，其余的查询是迭代的</p>
<h2 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h2><p>为了改善时延性能并减少在因特网上到处传输的DNS报文数量，DNS广泛采用了缓存技术</p>
<p>它能够把回答中的信息缓存在本地存储器中，但该缓存不是永久的，由于主机和主机名与IP地址间的映射并不是永久的，所以DNS服务器一般在一段时间后（通常为2天）将丢弃缓存的信息。</p>
<h2 id="DNS报文和记录"><a href="#DNS报文和记录" class="headerlink" title="DNS报文和记录"></a>DNS报文和记录</h2><h3 id="DNS记录"><a href="#DNS记录" class="headerlink" title="DNS记录"></a>DNS记录</h3><p>共同实现DNS分布式数据库的所有DNS服务器存储了资源记录（Resource Record，RR），RR提供了主机名到IP地址的映射。</p>
<p>RR是一个包含了下列字段的4元组：<br>(Name, Value, Type, TTL)</p>
<p>TTL是该记录的生存时间，它决定了资源记录应当从缓存中删除的时间</p>
<ul>
<li>如果Type=A，则Name是主机名，Value是该主机名对应的IP地址</li>
<li>如果Type=NS，则Name是个域（如foo.com），Value是个知道如何获得该域中主机IP地址的权威DNS服务器的主机名。这个记录用于沿着查询链来路由DNS查询。（如(foo.com, dns.foo.com, NS)就是一个NS记录）</li>
<li>如果Type=CNAME，则Value是别名为Name的主机对应的规范主机名</li>
<li>如果Type=MX，则Value是个别名为Name的邮件服务器的规范主机名</li>
</ul>
<p>如果一台DNS服务器是用于某特定主机名的权威DNS服务器，那么该DNS服务器会有一条包含该主机名的类型A记录<br>如果服务器不是用于某主机名的权威服务器，那么该服务器将包含一条类型NS记录，该记录对应包含主机名的域；它还包括一条类型A记录，提供在NS记录的Value字段中的DNS的IP地址<br>（比如<strong>edu TLD服务器</strong>不是主机gaia.cs.umass.edu的权威DNS服务器，则该服务器将包含一条包括主机cs.umass.edu的域记录，如(umass.edu, dns.umass.edu, NS)，该TLD服务器还将包含一条类型A记录，如(dns.umass.edu, 128.199.40.111, A)，该记录将名字dns.umass.edu映射为一个IP地址）</p>
<h3 id="DNS报文"><a href="#DNS报文" class="headerlink" title="DNS报文"></a>DNS报文</h3><p><img src="https://i.imgur.com/Q7F2t9H.png" alt=""></p>
<h3 id="对分级查询的进一步解释"><a href="#对分级查询的进一步解释" class="headerlink" title="对分级查询的进一步解释"></a>对分级查询的进一步解释</h3><p>所谓”分级查询”，就是从根域名开始，依次查询每一级域名的NS记录，直到查到最终的IP地址，见下面的DNS记录可知</p>
<ol>
<li>从”根域名服务器”查到”顶级域名服务器”的NS记录和A记录（IP地址）</li>
<li>从”顶级域名服务器”查到”次级域名服务器”的NS记录和A记录（IP地址）</li>
<li>从”次级域名服务器”查出”主机名”的IP地址</li>
</ol>
<p>（根域名服务器的NS记录和IP地址一般是不会变化的，所以内置在DNS服务器中）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/25/对String,StringBuilder,StringBuffer的区分(源码剖析)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MakaLoo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MakaL-0-">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/25/对String,StringBuilder,StringBuffer的区分(源码剖析)/" itemprop="url">源码剖析-对String,StringBuilder,StringBuffer的区分</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-25T10:41:18+08:00">
                2019-03-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/03/25/对String,StringBuilder,StringBuffer的区分(源码剖析)/" class="leancloud_visitors" data-flag-title="源码剖析-对String,StringBuilder,StringBuffer的区分">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="源码剖析-对String-StringBuilder-StringBuffer的区分"><a href="#源码剖析-对String-StringBuilder-StringBuffer的区分" class="headerlink" title="源码剖析-对String,StringBuilder,StringBuffer的区分"></a>源码剖析-对String,StringBuilder,StringBuffer的区分</h1><p>首先观察他们继承的类和接口</p>
<p>String：<code>public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {}</code><br>StringBuilder：<code>public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, CharSequence {}</code><br>StringBuffer：<code>public final class StringBuffer extends AbstractStringBuilder implements java.io.Serializable, CharSequence {}</code></p>
<p>可以观察到，String对象继承了Serializable，Comparable，CharSequence接口<br>StringBuilder与StringBuffer均继承自AbstractStringBuilder父类，Serializable，CharSequence接口</p>
<p>Serializable是序列化接口，它的作用是：</p>
<blockquote>
<p>Serializability of a class is enabled by the class implementing the java.io.Serializable interface.</p>
</blockquote>
<h2 id="String-源码剖析"><a href="#String-源码剖析" class="headerlink" title="String 源码剖析"></a>String 源码剖析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Stable</span><br><span class="line">private final byte[] value;</span><br><span class="line"></span><br><span class="line">private final byte coder;</span><br><span class="line"></span><br><span class="line">public String() &#123;</span><br><span class="line">    this.value = &quot;&quot;.value;</span><br><span class="line">    this.coder = &quot;&quot;.coder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>String由value和coder组成，coder应该是它的编码格式，value就是它的值了，注意value是final类型的，即String对象是不可变的</p>
<h3 id="Comparable接口"><a href="#Comparable接口" class="headerlink" title="Comparable接口"></a>Comparable接口</h3><p>String实现了Comparable接口，即String对象可以通过调用<code>compareTo()</code>方法进行比较，这是String与StringBuilder和StringBuffer的第一个区别</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> v1[] = value;</span><br><span class="line">    <span class="keyword">byte</span> v2[] = anotherString.value;</span><br><span class="line">    <span class="keyword">if</span> (coder() == anotherString.coder()) &#123;</span><br><span class="line">        <span class="keyword">return</span> isLatin1() ? StringLatin1.compareTo(v1, v2)</span><br><span class="line">                          : StringUTF16.compareTo(v1, v2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isLatin1() ? StringLatin1.compareToUTF16(v1, v2)</span><br><span class="line">                      : StringUTF16.compareToLatin1(v1, v2);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>他主要实现了在当前字符编码上对字符串的比较，判断字符串是否相等</p>
<h2 id="StringBuilder与StringBuffer"><a href="#StringBuilder与StringBuffer" class="headerlink" title="StringBuilder与StringBuffer"></a>StringBuilder与StringBuffer</h2><h3 id="AbstractStringBuilder"><a href="#AbstractStringBuilder" class="headerlink" title="AbstractStringBuilder"></a>AbstractStringBuilder</h3><p>注意到在这个抽象类中定义了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] value;</span><br><span class="line"><span class="keyword">byte</span> coder;</span><br><span class="line"><span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure>
<p>但注意到value不是final类型，即他是可变的，这个是与String的第二个区别</p>
<p>他主要有扩容方法和添加方法，添加方法的参数类型有很多，比如String类型的，AbstactStringBuilder的，StringBuffer的，CharSequence的等等，下面是其中一个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> appendNull();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    putStringAt(count, str);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>扩容方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = value.length &gt;&gt; coder;</span><br><span class="line">    <span class="keyword">if</span> (minimumCapacity - oldCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        value = Arrays.copyOf(value,</span><br><span class="line">				newCapacity(minimumCapacity) &lt;&lt; coder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = value.length &gt;&gt; coder;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> SAFE_BOUND = MAX_ARRAY_SIZE &gt;&gt; coder;</span><br><span class="line">    <span class="keyword">return</span> (newCapacity &lt;= <span class="number">0</span> || SAFE_BOUND - newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        ? hugeCapacity(minCapacity)</span><br><span class="line">        : newCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码大概是若为utf16编码，则容量*2再+2，若为latin1编码，则容量+2，且设置了安全上限保护</p>
<h3 id="CharSequence"><a href="#CharSequence" class="headerlink" title="CharSequence"></a>CharSequence</h3><p><img src="https://i.imgur.com/PMITMBm.png" alt=""><br><!-- TODO: 这个是CharSequence.png --></p>
<h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>StringBuilder继承自AbstractStringBuilder，大部分代码都已经由其实现，StringBuilder只需要在构造器中调用super()方法即可，包括append()方法，delete()方法，replace()方法，insert()方法，indexOf()方法，lastIndexOf()方法，reverse()方法也都是调用super()方法即可。</p>
<h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><p>而StringBuffer则是在AbstractStringBuilder的方法上添加了synchronized的关键字，即它是线程安全的</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>String是可以比较的，通过compareTo()方法，而StringBuilder和StringBuffer只能通过toString()方法后再调用compareTo()方法来比较。</li>
<li>String对象是不可变的，其值是final类型，而StringBuilder和StringBuffer对象可变，并没有final修饰。</li>
<li>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。 </li>
</ol>
<p>对他们的使用，应该遵循下面原则：</p>
<ul>
<li>操作少量的数据 = String</li>
<li>单线程操作字符串缓冲区下操作大量数据 = StringBuilder</li>
<li>多线程操作字符串缓冲区下操作大量数据 = StringBuffer</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/17/git快速入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MakaLoo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MakaL-0-">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/17/git快速入门/" itemprop="url">Git快速入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-17T11:08:34+08:00">
                2019-03-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index">
                    <span itemprop="name">Git</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/03/17/git快速入门/" class="leancloud_visitors" data-flag-title="Git快速入门">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h2><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><p>通过<code>git init</code>把当前目录变为Git可以管理的仓库</p>
<h4 id="把文件放到Git仓库-add指令"><a href="#把文件放到Git仓库-add指令" class="headerlink" title="把文件放到Git仓库-add指令"></a>把文件放到Git仓库-add指令</h4><p>第一步,编写一个文件,放到该仓库目录下<br>第二步,用命令<code>git add yourFileName</code>告诉git把文件添加到仓库</p>
<p>可以添加多个文件<br><code>git add file1.txt file2.txt</code></p>
<h4 id="提交到仓库-commit指令"><a href="#提交到仓库-commit指令" class="headerlink" title="提交到仓库-commit指令"></a>提交到仓库-commit指令</h4><p><code>git add -m &quot;提本次提交的说明&quot;</code>,用参数<code>-m</code>输入本次提交的说明</p>
<h4 id="查看暂存区状态-status指令"><a href="#查看暂存区状态-status指令" class="headerlink" title="查看暂存区状态-status指令"></a>查看暂存区状态-status指令</h4><p>可以使用<code>git status</code>查看当前git状态</p>
<h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><h4 id="查看历史记录-log指令"><a href="#查看历史记录-log指令" class="headerlink" title="查看历史记录-log指令"></a>查看历史记录-log指令</h4><p><code>git log</code>可以查看历史提交记录<br>如果输出信息太多,可以加上<code>--pretty=oneline</code>参数</p>
<h4 id="版本回退-reset指令"><a href="#版本回退-reset指令" class="headerlink" title="版本回退-reset指令"></a>版本回退-reset指令</h4><p>git的当前版本用<code>HEAD</code>表示,上一个版本是<code>HEAD^</code>,上上个版本是<code>HEAD^^</code>,如果是上100个版本,可以表示为<code>HEAD~100</code></p>
<p><code>git reset --hard HEAD^</code>表示回退到上一个版本</p>
<p>如果后悔了,可以找到上面的命令行窗口,找到未来版本的<code>commit id</code>,比如当前版本最新ID为<code>1094adb...</code>,可以通过<code>git reset --hard 1094a</code>回到未来(可以不指定完整的id,git会自动寻找)</p>
<h4 id="记录命令-reflog指令"><a href="#记录命令-reflog指令" class="headerlink" title="记录命令-reflog指令"></a>记录命令-reflog指令</h4><p>可以通过<code>git reflog</code>查询执行过的命令,并依此找到版本号,这样就可以通过<code>git reset --hard 版本号</code>回到任何版本</p>
<h3 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h3><p>工作区就是电脑可以看到的目录<br>工作区有一个目录.git，是Git的版本库，里面存了很多东西，其中有称为stage(或者叫index)的暂存区，还有Git自动创建的第一个分支master，以及指向master的一个指针叫HEAD。<br><code>git add</code>实际是把文件修改添加到暂存区</p>
<p><img src="https://i.imgur.com/5AIU1bs.png" alt=""></p>
<p><code>git commit</code>实际是把暂存区的所有内容提交到当前分支</p>
<p><img src="https://i.imgur.com/xSVk704.png" alt=""></p>
<h4 id="查看工作区和版本库区别-diff指令"><a href="#查看工作区和版本库区别-diff指令" class="headerlink" title="查看工作区和版本库区别-diff指令"></a>查看工作区和版本库区别-diff指令</h4><p><code>git diff HEAD -- youFile.txt</code>：可以查看工作区和版本库最新版本的区别</p>
<h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><h4 id="丢弃工作区的修改-checkout"><a href="#丢弃工作区的修改-checkout" class="headerlink" title="丢弃工作区的修改-checkout"></a>丢弃工作区的修改-checkout</h4><p>可以使用<code>git checkout -- &lt;file&gt;</code>把工作区中file的修改全部撤销</p>
<h4 id="把暂存区的修改放回到工作区-reset"><a href="#把暂存区的修改放回到工作区-reset" class="headerlink" title="把暂存区的修改放回到工作区-reset"></a>把暂存区的修改放回到工作区-reset</h4><p><code>git reset HEAD &lt;file&gt;</code>把暂存区的修改撤销掉,重新放回工作区，然后使用<code>git checkout -- &lt;file&gt;</code>即可撤销修改</p>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>在Git中,删除文件也是一个修改操作</p>
<h4 id="删除暂存区文件-rm"><a href="#删除暂存区文件-rm" class="headerlink" title="删除暂存区文件-rm"></a>删除暂存区文件-rm</h4><p>在Linux中,对于已经通过<code>add</code>添加到暂存区的文件，如果使用<code>rm</code>删除了文件,删错的情况下,可以<code>git checkout -- &lt;file&gt;</code>恢复文件<br>如果确定删除，<code>git rm &lt;file&gt;</code>删掉，然后<code>git commit</code>提交<br>对于在工作区的文件，使用<code>rm</code>删除无法恢复。</p>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><p>1.在GitHub上create a new repo新建一个仓库，填写仓库名后其他默认（不要生成readme，生成后不是空远程库了，手动在本地库添加上传即可）<br>2.本地仓库与之关联，关联后远程库的名字是origin<br>3.把本地库内容推送到远程（实际是把master分支推送到远程）</p>
<h4 id="远程库关联本地库-remote-add"><a href="#远程库关联本地库-remote-add" class="headerlink" title="远程库关联本地库-remote add"></a>远程库关联本地库-remote add</h4><p>根据GitHub上的提示，在本地git bash上<br><code>git remote add origin https://github.com/youGithubName/youRepo.git</code></p>
<p>即可关联，若取消关联<br><code>git remote remove origin</code></p>
<h4 id="本地库推送到远程-push"><a href="#本地库推送到远程-push" class="headerlink" title="本地库推送到远程-push"></a>本地库推送到远程-push</h4><p>第一次推送的时候<br><code>git push -u origin master</code><br>-u不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>
<p>后续推送只需要<br><code>git push origin master</code></p>
<h3 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h3><h4 id="克隆远程库到本地-clone"><a href="#克隆远程库到本地-clone" class="headerlink" title="克隆远程库到本地-clone"></a>克隆远程库到本地-clone</h4><p><code>git clone git@github.com:otherName/otherRepo.git</code> 使用ssh克隆<br><code>git clone https://github.com/otherName/otherRepo.git</code> 使用https克隆</p>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><h3 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h3><p>每次提交时，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即<code>master</code>分支。<code>HEAD</code>严格来说不是指向提交，而是指向<code>master</code>，<code>master</code>才是指向提交的，所以，<code>HEAD</code>指向的就是当前分支。</p>
<p>一开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>，就能确定当前分支，以及当前分支的提交点：</p>
<p><img src="https://i.imgur.com/XgRLXHI.png" alt=""></p>
<p>每次提交时，master分支都会向前移动一步。</p>
<p>当我们创建分支的时候，例如<code>dev</code>时，Git会新建一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上：</p>
<p><img src="https://i.imgur.com/8P0fYIU.png" alt=""></p>
<p>从现在开始，对工作区任何修改和提交都是针对<code>dev</code>分支了，新提交一次后，<code>dev</code>和<code>HEAD</code>往前一步，<code>master</code>不变：</p>
<p><img src="https://i.imgur.com/vQVkEtc.png" alt=""></p>
<p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上，把<code>master</code>指向<code>dev</code>当前的提交即可：</p>
<p><img src="https://i.imgur.com/Tc19E7I.png" alt=""></p>
<p>合并完分支后，甚至可以删除<code>dev</code>分支：</p>
<p><img src="https://i.imgur.com/UX9AEPB.png" alt=""></p>
<h4 id="创建分支-branch"><a href="#创建分支-branch" class="headerlink" title="创建分支-branch"></a>创建分支-branch</h4><p><code>git branch dev</code>创建<code>dev</code>分支</p>
<h4 id="切换分支-checkout"><a href="#切换分支-checkout" class="headerlink" title="切换分支-checkout"></a>切换分支-checkout</h4><p><code>git checkout dev</code>切换到<code>dev</code>分支</p>
<h4 id="创建并切换分支-checkout-b"><a href="#创建并切换分支-checkout-b" class="headerlink" title="创建并切换分支-checkout -b"></a>创建并切换分支-checkout -b</h4><p><code>git checkout -b dev</code>可以新建<code>dev</code>分支并切换到<code>dev</code>分支<br>它相当于下面两条指令<br><code>git branch dev</code>创建<code>dev</code>分支<br><code>git checkout dev</code>切换到<code>dev</code>分支</p>
<p>现在，对git进行<code>add</code>和<code>commit</code>操作都是针对<code>dev</code>分支而言</p>
<p>修改完后<br><code>git checkout master</code>可以切换回<code>master</code>分支，此时，所有针对<code>dev</code>分支进行的改变都是不可见的</p>
<p><strong>注意！暂存区对所有分支来说都是可见的！</strong></p>
<h4 id="查看所有分支-branch"><a href="#查看所有分支-branch" class="headerlink" title="查看所有分支-branch"></a>查看所有分支-branch</h4><p><code>git branch</code>可以查看所有分支，当前分支前会有 <code>*</code> 指示出来</p>
<h4 id="合并分支-merge"><a href="#合并分支-merge" class="headerlink" title="合并分支-merge"></a>合并分支-merge</h4><p><code>git merge dev</code>把<code>dev</code>分支合并到当前分支上</p>
<h4 id="删除分支-branch-d"><a href="#删除分支-branch-d" class="headerlink" title="删除分支-branch -d"></a>删除分支-branch -d</h4><p><code>git branch -d dev</code>可以删除分支<code>dev</code>，删除前提是当前分支不是<code>dev</code>（即<code>HEAD</code>指针不是指向<code>dev</code>）</p>
<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>当两个分支修改的地方有冲突的时候，执行<code>merge</code>就会报错合并冲突，可以使用<code>git stauts</code>查看。<br>冲突发生时分支如下：</p>
<p><img src="https://i.imgur.com/E0DqQrA.png" alt=""></p>
<p>打开冲突的文件，可以看到大概类似下面的东西</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">xxxxxx</span><br><span class="line">=============</span><br><span class="line">XXXXXX</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure>
<p>这里xxxxxx是<code>HEAD</code>分支修改的内容，XXXXXX是<code>dev</code>分支修改的内容</p>
<p>只要把这一部分修改成想要的内容，再<br><code>git add xxx.txt</code><br><code>git commit -m &quot;conflict fixed</code><br>即可</p>
<p>此时分支如下：（使用下一小节的命令可以查看图形化的分支）</p>
<p><img src="https://i.imgur.com/GQ2Y6xf.png" alt=""><br>(P.S:对这样的分支树进行版本回退，他会退回到master的上一个版本而不是feature1）</p>
<p>然后删除<code>feature1</code>分支即可</p>
<p>也可以选择<code>git merge --abort</code>放弃合并</p>
<h4 id="查看分支合并情况-log-–graph"><a href="#查看分支合并情况-log-–graph" class="headerlink" title="查看分支合并情况-log –graph"></a>查看分支合并情况-log –graph</h4><p><code>git log --graph --pretty=oneline --abbrev-commit</code>可以以图形的信息查看分支情况</p>
<h3 id="分支策略管理"><a href="#分支策略管理" class="headerlink" title="分支策略管理"></a>分支策略管理</h3><p>通常，合并分支的时候，Git会用<code>Fast forward</code>模式，在这种模式下，删除分支后，会丢掉分支信息。</p>
<p>如果强制禁用<code>Fast forward</code>，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p>
<h4 id="禁用fast-forward-merge-–no-ff"><a href="#禁用fast-forward-merge-–no-ff" class="headerlink" title="禁用fast forward-merge –no-ff"></a>禁用fast forward-merge –no-ff</h4><p>e.g.<br>1.创建一个分支<code>git checkout -b dev</code><br>2.修改<code>readme.txt</code>并提交一个commit<code>git add readme.txt</code>，<code>git commit -m &quot;add merge&quot;</code><br>3.切换到<code>master</code>，<code>git checkout master</code><br>4.合并<code>dev</code>分支，<code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code></p>
<p>然后用<code>git log</code>可以看到merge的信息，使用</p>
<p>在<code>fast forward</code>模式下，log里是看不到merge的信息的，即</p>
<h4 id="禁用fast-forward的图示"><a href="#禁用fast-forward的图示" class="headerlink" title="禁用fast forward的图示"></a>禁用fast forward的图示</h4><p>执行<code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code>合并后，禁用fast forward时，在合并分支后，<code>git log</code>的图示如下</p>
<p><img src="https://i.imgur.com/05SBn91.png" alt=""></p>
<p>可以看到是有一条<code>merge</code>的<code>log</code>的。</p>
<p>删除<code>dev</code>分支之前的<code>git log --graph --pretty=oneline --abbrev-commit</code></p>
<p><img src="https://i.imgur.com/gnyFJ9d.png" alt=""></p>
<p><strong>此时虽然执行了<code>merge</code>操作，但<code>dev</code>和<code>master</code>并不指向同一目标，此时master指向的是在master分支下执行<code>merge</code>操作的log，而不是在<code>dev</code>分支下执行<code>commit</code>操作的log</strong></p>
<p>对比下面是执行<code>git merge dev</code>的图示</p>
<p><code>git log</code>如下：</p>
<p><img src="https://i.imgur.com/VZaOyd5.png" alt=""></p>
<p><code>git log --graph --pretty=oneline --abbrev-commit</code>如下：</p>
<p><img src="https://i.imgur.com/vl2ZO2m.png" alt=""></p>
<p>可以看到并没有<code>merge</code>操作的log，而只有<code>commit</code>操作的log，非<code>fast forward</code>下的合并，仅仅是把<code>master</code>指针指向<code>dev</code></p>
<h4 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h4><p>实际开发应该遵循下面的基本原则进行分支管理：<br><strong>首先，<code>master</code>分支是非常稳定的，仅仅用来发布新版本，平时不能在上面干活；<br>干活都在<code>dev</code>分支上，<code>dev</code>分支是不稳定的，到某个时候，比如发布1.0版本时，再把<code>dev</code>分支合并到<code>master</code>分支上，在<code>master</code>分支上发布1.0版本<br>多人开发时，每个人都有自己的分支，时不时往<code>dev</code>分支上合并就可以，如下图所示</strong></p>
<p><img src="https://i.imgur.com/NSqtpQr.png" alt=""></p>
<h3 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h3><p>每次出现Bug的时候，都可以新建一个临时分支来修复，修复后合并分支，然后删除临时分支，但如果出现BUG的时候当前手头工作未完成时，Git可以把当前工作现场保存，然后去修改BUG，再恢复现场继续工作</p>
<h4 id="保存工作现场-stash"><a href="#保存工作现场-stash" class="headerlink" title="保存工作现场-stash"></a>保存工作现场-stash</h4><p><code>git stash</code>可以保存当前工作现场，它大概就是，在工作区修改的文件，还没上传到暂存区，则保存工作区修改过的文件，或者已经上传到暂存区的文件，但还没有<code>commit</code>，则保存该文件，然后把工作区置干净(<code>git status</code>查看是干净的)，此时就可以放心创建分支来修复bug。<br>如果没有stash，切换到<code>master</code>分支上修改bug的时候，会发现在<code>dev</code>分支修改的东西还存在，但因为还没写完，所以修改完bug之后<code>commit</code>的话，没写完的东西也会<code>commit</code>上去，这明显是错误的，stash就是为此而生，它把工作区暂存区的东西保存下来，然后让工作区干净，这样在<code>dev</code>上正在工作的，未完成的东西就不会出现了，也不会因为修改bug而提交到<code>master</code>了，然后创建分支修改完bug之后再切换回<code>dev</code>分支恢复现场即可。</p>
<p><strong>注意！！，如果要在<code>master</code>分支上修复bug，则必须先切换到<code>master</code>分支，再新建一个分支！</strong><br>修改完分支后，切换回<code>master</code>分支并合并，然后删除bug分支即可</p>
<p>此时修复完bug，切换回工作分支，然后恢复刚刚<code>stash</code>的内容</p>
<h4 id="查看stash内容-stash-list"><a href="#查看stash内容-stash-list" class="headerlink" title="查看stash内容-stash list"></a>查看stash内容-stash list</h4><p><code>git stash list</code>可以查看stash内容</p>
<h4 id="恢复工作现场-stash-apply"><a href="#恢复工作现场-stash-apply" class="headerlink" title="恢复工作现场-stash apply"></a>恢复工作现场-stash apply</h4><p><code>git stash apply</code>恢复工作现场，然后<code>git stash drop</code>删除stash内容</p>
<p>多次<code>stash</code>的时候，先用<code>git stash list</code>查看，然后恢复指定的stash<br><code>git stash apply stash@{0}</code></p>
<h4 id="恢复工作现场-stash-pop"><a href="#恢复工作现场-stash-pop" class="headerlink" title="恢复工作现场-stash pop"></a>恢复工作现场-stash pop</h4><p><code>git stash pop</code>恢复工作现场同时把stash内容删除</p>
<h3 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h3><p>软件开发中，当要添加新功能时，可以新建一个feature分支来实现。</p>
<h4 id="强制删除分支—branch-D"><a href="#强制删除分支—branch-D" class="headerlink" title="强制删除分支—branch -D"></a>强制删除分支—branch -D</h4><p>如果新功能要舍弃，分支还没合并就要删除，可以通过<br><code>git branch -D &lt;name&gt;</code>来删除<br>参数-D是强制删除</p>
<h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><p>当从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin</p>
<h4 id="查看远程库的信息-remote"><a href="#查看远程库的信息-remote" class="headerlink" title="查看远程库的信息-remote"></a>查看远程库的信息-remote</h4><p><code>git remote</code>可以查看远程库的信息<br><code>git remote -v</code>可以显示更详细的信息，显示了可以抓取和推送的<code>origin</code>地址，如果没有推送权限，则看不到push地址</p>
<p><img src="https://i.imgur.com/e7Fp85S.png" alt=""></p>
<h4 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h4><p><code>git push origin master</code></p>
<p>如果要推送其他分支，比如<code>dev</code>，就改成<br><code>git push origin dev</code></p>
<p>下面是分支的简介</p>
<ul>
<li><code>master</code>分支是主分支，时刻与远程同步</li>
<li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步</li>
<li><code>bug</code>分支只用于本地修复bug，一般不需要推送到远程</li>
<li><code>feature</code>分支是否推送到远程，取决于是否合作开发</li>
</ul>
<h4 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h4><p>当另外一个人从远程库克隆的时候，默认情况下，他只能看到本地的<code>master</code>分支，如果要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地。</p>
<h5 id="创建远程分支到本地"><a href="#创建远程分支到本地" class="headerlink" title="创建远程分支到本地"></a>创建远程分支到本地</h5><p><code>git checkout -b dev origin/dev</code></p>
<h4 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h4><p><code>git pull</code>命令用于从另一个存储库或本地分支获取并集成，它的作用是：取回远程主机某个分支的更新，再与本地指定分支合并。</p>
<p>常见格式是<br><code>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code><br>若与当前分支合并，则冒号和之后的内容不需要</p>
<h4 id="多人协作的工作模式"><a href="#多人协作的工作模式" class="headerlink" title="多人协作的工作模式"></a>多人协作的工作模式</h4><ol>
<li><p>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</p>
</li>
<li><p>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</p>
</li>
<li><p>如果合并有冲突，则解决冲突，并在本地提交；</p>
</li>
<li><p>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</p>
</li>
</ol>
<p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p>
<h3 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h3><p><code>git rebase</code>：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了</p>
<h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p>它是版本的一个快照，发布一个版本时，先在版本库中打一个标签，然后将来某个时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。</p>
<p>实质上标签就是指向某个commit的指针（和分支很像，但它不能移动）</p>
<h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><h4 id="创建标签-tag"><a href="#创建标签-tag" class="headerlink" title="创建标签-tag"></a>创建标签-tag</h4><p>首先切换到需要打标签的分支上<br>然后输入<br><code>git tag v1.0</code>即可打上v1.0的标签</p>
<p>可以用命令<br><code>git tag</code>查看所有标签</p>
<p>默认标签是打在最新提交的commit上的，如果要打历史版本的标签，只需要找到历史提交的commit id，然后打上即可<br><code>git tag v0.9 &lt;commit ID&gt;</code></p>
<p>还可以指定带有说明的标签，参数-a表示标签名，-m表示说明文字<br><code>git tag -a v0.1 -m &quot;version 0.1 released&quot; &lt;commit ID&gt;</code></p>
<p><code>git show &lt;tagname&gt;</code>可以看到说明文字</p>
<h3 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h3><h4 id="删除标签-tag-d"><a href="#删除标签-tag-d" class="headerlink" title="删除标签-tag -d"></a>删除标签-tag -d</h4><p><code>git tag -d v0.1</code>可以删除这个标签</p>
<h4 id="推送标签到远程"><a href="#推送标签到远程" class="headerlink" title="推送标签到远程"></a>推送标签到远程</h4><p><code>git push origin &lt;tagname&gt;</code></p>
<h4 id="一次性推送全部标签"><a href="#一次性推送全部标签" class="headerlink" title="一次性推送全部标签"></a>一次性推送全部标签</h4><p><code>git push origin --tags</code></p>
<h4 id="删除远程标签"><a href="#删除远程标签" class="headerlink" title="删除远程标签"></a>删除远程标签</h4><ol>
<li><code>git tag -d &lt;tagname&gt;</code>删除本地标签</li>
<li><code>git push origin :refs/tags/&lt;tagname&gt;</code>删除远程标签</li>
</ol>
<h2 id="使用GitHub"><a href="#使用GitHub" class="headerlink" title="使用GitHub"></a>使用GitHub</h2><ol>
<li>点击<code>Fork</code>可以在自己账号下的远程仓库克隆一个别人的远程仓库</li>
<li>从自己账号下clone：<code>git clone git@github.com:makloao/xxx.git</code>，一定要克隆自己远程仓库到本地仓库，否则不能推送修改</li>
<li>如果想把自己的修改推送到官方，可以在GitHub上发起一个<code>pull request</code></li>
</ol>
<h2 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h2><p><code>git config --global.user.name &quot;Your name&quot;</code><br><code>git config --global user.email &quot;email@example.com&quot;</code><br>指定用户名和Email</p>
<p><code>git config --global color.ui true</code>让Git显示颜色</p>
<h3 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h3><p>有些时候要把某些文件放到Git工作目录但又不能提交它们，比如保存了数据密码的配置文件等等<br>只需要在Git工作区的目录下创建一个特殊的<code>.gitignore</code>文件，然后把要忽略的文件名填进去即可，如何写可以看<a href="https://github.com/github/gitignore" target="_blank" rel="noopener">GitHub的.gitignore文件写法</a></p>
<p>忽略文件的原则</p>
<ol>
<li>忽略操作系统自动生成的文件，比如缩略图等；</li>
<li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；</li>
<li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li>
</ol>
<p>如果想强行添加被<code>.gitignore</code>忽略的文件<br><code>git add -f xxx.class</code>即可</p>
<p><code>.gitignore</code>本身要放到版本库中，并且可以对其做版本管理</p>
<h3 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h3><p>可以给命令配置别名<br><code>git config --global alias.st status</code>：把<code>git status</code>配置别名成<code>git st</code>，同理可以配置其他</p>
<h4 id="一些比较推荐的别名"><a href="#一些比较推荐的别名" class="headerlink" title="一些比较推荐的别名"></a>一些比较推荐的别名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.st status</span><br><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.unstage &apos;reset HEAD&apos;</span><br><span class="line">git config --global alias.last &apos;log -1&apos; 显示最后一次提交</span><br><span class="line">git config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot; 设置log的显示颜色</span><br></pre></td></tr></table></figure>
<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>配置文件都放在<code>.git/config</code>文件中</p>
<p>而当前用户的Git配置文件放在用户主目录的<code>.gitconfig</code>中</p>
<h2 id="搭建Git服务器"><a href="#搭建Git服务器" class="headerlink" title="搭建Git服务器"></a>搭建Git服务器</h2><p>如果不想公开代码，又不想给GitHub交保护费</p>
<p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000" target="_blank" rel="noopener">教程在这</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/29/数据结构03-排序基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MakaLoo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MakaL-0-">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/29/数据结构03-排序基础/" itemprop="url">数据结构03-排序基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-29T11:08:34+08:00">
                2018-11-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/11/29/数据结构03-排序基础/" class="leancloud_visitors" data-flag-title="数据结构03-排序基础">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数据结构03-排序基础"><a href="#数据结构03-排序基础" class="headerlink" title="数据结构03-排序基础"></a>数据结构03-排序基础</h1><p>本章主要讲了几种基本的排序方法，分别为直接插入排序，希尔排序和基数排序，快排和归并排序由于用到了递归的思想，所以放在了后面递归章节来说。</p>
<h2 id="排序的概念与分类"><a href="#排序的概念与分类" class="headerlink" title="排序的概念与分类"></a>排序的概念与分类</h2><p>含有多个数据项的数据元素称为记录。用作记录唯一标识的数据项称为关键字域，其值为关键字。若关键字唯一标识一个记录，则称为主关键字，否则为次关键字，记录类型定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    KeyType key;</span><br><span class="line">    ...</span><br><span class="line">&#125; RecordType, RcdType;</span><br></pre></td></tr></table></figure>
<p>排序就是将无序的记录按关键字调整为有序记录序列的一种操作。一般排序都是对存储记录的顺序表排序。<strong>顺序表的0号单元留作它用</strong>。记录顺序表类型定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    RcdType *rcd;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">&#125; RcdSqList;</span><br></pre></td></tr></table></figure>
<h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>直接插入排序的思想是：<strong>每次将无序区的第一个记录按关键字插入到有序区的合适位置，并将有序区长度加1。</strong></p>
<p>具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(RcdSqList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.rcd[i+<span class="number">1</span>].key &lt; L.rcd[i].key) &#123; <span class="comment">// 需将L.rcd[i+1]插入到有序序列</span></span><br><span class="line">            L.rcd[<span class="number">0</span>] = L.rcd[i+<span class="number">1</span>]; <span class="comment">// 把记录L.rcd[i+1]保存在空闲的0号单元</span></span><br><span class="line">            j = i+<span class="number">1</span>; <span class="comment">// j为要后移的记录后移之前的位置</span></span><br><span class="line">            <span class="keyword">do</span> &#123; j--; L.rcd[j+<span class="number">1</span>] = L.rcd[j] <span class="comment">// 记录后移</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (L.rcd[<span class="number">0</span>].key &lt; L.rcd[j<span class="number">-1</span>].key) <span class="comment">// 判断是否需要继续移动</span></span><br><span class="line">            L.rcd[j] = L.rcd[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>这里的插排的做法是：<strong>无序区的第一个记录是i+1号记录，把它放到0号位置（即哨兵），然后依次比较0号记录与有序区记录的大小，对有序区中比0号位置记录要大的元素依次后移（第i个位置的记录为有序区的最大记录，若比无序区第一个记录i+1对应的值要大，就把它的值直接放到i+1的位置，然后依次后移），并用 j 记录要后移的记录后移之前的位置，最后把0号位置的记录放到j号位置即可。</strong></p>
<p>插入排序最好情况下比较次数n-1次，移动记录次数为0。最坏情况下，需要比较(n+2)(n-1)/2次，移动记录(n+4)(n-1)/2次，事件复杂度为O(n^2)，空间复杂度为O(1)。</p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序的思想是：<strong>把整个待排记录序列(R1,R2,R3,…,Rn)按增量d划分为d个子序列，其中第i(1&lt;=i&lt;=d)个子序列为(Ri,R(i+d),R(i+2d),…,R(i+kd)，并分别对各子序列进行直接插入排序，不断减小增量d，直到d减小到1，对整个序列进行一次直接插入排序。</strong></p>
<p>插入排序每次只对相邻记录进行比较，记录最多只移动一个位置，希尔排序每次对相隔较远距离的记录进行比较，使得记录移动时能跨过多个记录，实现宏观上的调整。</p>
<p>具体实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellInsert</span><span class="params">(RcdSqList &amp;L, <span class="keyword">int</span> dk)</span> </span>&#123; <span class="comment">// 对顺序表L进行一次希尔排序，增量为dk</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= L.length-dk; ++i) </span><br><span class="line">        <span class="keyword">if</span> (L.rcd[i+dk].key &lt; L.rcd[i].dk) &#123; <span class="comment">// 需将L.rcd[i+dk]插入有序序列</span></span><br><span class="line">            L.rcd[<span class="number">0</span>] = L.rcd[i+dk];</span><br><span class="line">            j = i + dk;</span><br><span class="line">            <span class="keyword">do</span> &#123;j -= dkl L.rcd[j+dk] = L.rcd[j]; </span><br><span class="line">            &#125; <span class="keyword">while</span> (j - dk &gt; <span class="number">0</span> &amp;&amp; L.rcd[<span class="number">0</span>].key &lt; L.rcd[j-dk].key);</span><br><span class="line">            L.rcd[j] = L.rcd[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(RcdSqList &amp;L, <span class="keyword">int</span> d[], <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 按增量序列d[0..t-1]对顺序表L作希尔排序</span></span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; t; k++) ShellInsert(L, d[k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h3><h4 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h4><p>这里希尔排序的做法是：<strong>给定一个增量序列（该序列应该是递减的，并且最后的一个值是1），依次取值作为增量dk，把记录按增量dk划分为dk个序列，依次对每个序列进行插入排序</strong></p>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>希尔排序的时间复杂度是所取增量序列的函数。当增量序列为d[k]=2^(t-k+1)-1时（t为排序趟数，1&lt;=k&lt;=t&lt;=log2(n+1)），事件复杂度为O(n^1.5)。</p>
<h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>若待排序列存在两个或以上关键字相等的记录，则排序结果不唯一。假设ki = kj（1&lt;=i&lt;=n,1&lt;=j&lt;=n,i≠j），且在排序前序列ki领先于kj，若在排序后序列ki仍领先于kj，则该排序方法稳定，反之不稳定。<strong>希尔排序是不稳定的排序方法</strong>。</p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>前面2种排序都是基于关键字比较，而基数排序不需要比较关键字，它借鉴了多关键字排序的思想，把单一关键字看成是多个关键字复合而成。</p>
<p>一般情况下，多关键字排序的定义为，<strong>假设含有n个记录的序列为(r1,r2,…,rn)。每个记录ri中含有m个关键字(ki(0),ki(1),…,ki(m-1))，如果对序列中任意两个记录ri和rj(1&lt;=i&lt;=j&lt;=n)都满足下列有序关系:<br>(ki(0),ki(1),…,ki(m-1))&lt;(kj(0),kj(1),…,kj(m-1))<br>则称记录对这m个关键字有序。其中k0被称为最主位关键字，k(m-1)被称为最次位关键字。</strong></p>
<p>实现多关键字排序有两种策略，MSD(高位优先排序)和LSD(低位优先排序)。</p>
<p>MSD的思路为<strong>先按最主位关键字k0进行排序，得到若干子序列，其中每个子序列中的记录都含有相同个k0值，之后分别对每个子序列按关键字k1进行排序，使得k1值相同的记录构成长度更短的子序列，依次重复直到对每个子序列按k(m-1)从小到大排序，最后所得序列就是排序结果</strong></p>
<p>LSD的思路为<strong>先按最低位关键字进行排序，接着按依次低位关键字实施排序，最后按最主位关键字进行排序</strong>，与MSD不同，其排序过程不产生子序列，每次都是对整个序列排序。</p>
<p>基数排序基本思路：<strong>先将所有关键字统一为相同的位数，位数少的前面补0，然后从最低位开始依次进行排序，直到按最高位排序完成。</strong></p>
<p>下面说的是<strong>以顺序存储的基数排序的LSD实现</strong></p>
<h3 id="基数排序定义的数据类型"><a href="#基数排序定义的数据类型" class="headerlink" title="基数排序定义的数据类型"></a>基数排序定义的数据类型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    KeysType *keys; <span class="comment">// 关键字</span></span><br><span class="line">    ...             <span class="comment">// 其他数据项</span></span><br><span class="line">&#125; KeysRcdType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    KeysRcdType *rcd; <span class="comment">// 0号位置作为哨兵</span></span><br><span class="line">    <span class="keyword">int</span> length;       <span class="comment">// 顺序表长度</span></span><br><span class="line">    <span class="keyword">int</span> size;         <span class="comment">// 顺序表容量</span></span><br><span class="line">    <span class="keyword">int</span> digitNum;     <span class="comment">// 关键字位数，即rcd.keys每个值的长度</span></span><br><span class="line">    <span class="keyword">int</span> radix;        <span class="comment">// 关键字基数，即关键字取值范围的长度，十进制为10，字母为26</span></span><br><span class="line">&#125; KeysSqList;</span><br></pre></td></tr></table></figure>
<p>实现基数排序，需要引入3个数组，其中，数组count用于统计关键字的r种取值，pos数组用于确定各子序列的起始位置，rcd1数组与rcd一样，各趟收集中，第一趟从数组rcd收集到数组rcd1，第二趟从rcd1收集到rcd，如此交替进行，若总趟数为奇数，最后要排序结果从rcd1复制回rcd。</p>
<h3 id="基数排序的过程与关键步骤"><a href="#基数排序的过程与关键步骤" class="headerlink" title="基数排序的过程与关键步骤"></a>基数排序的过程与关键步骤</h3><p>基数排序有3个关键步骤，分别为计数，计算位置和收集。如下</p>
<h4 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h4><p>计数是统计第i个关键字中取值范围内每个数的个数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; L.radix; ++j) count[j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>; k &lt;= n; k++) count[rcd[k].keys[i]]++;</span><br></pre></td></tr></table></figure>
<h4 id="计算位置"><a href="#计算位置" class="headerlink" title="计算位置"></a>计算位置</h4><p>计算位置是计算第i个关键字中取值范围内每个值应该存放(收集)的位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pos[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; radix; j++) pos[j] = count[j<span class="number">-1</span>] + pos[j<span class="number">-1</span>];</span><br></pre></td></tr></table></figure>
<h4 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h4><p>收集是把依次把k(k=1直到n)个记录存放到正确的位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">    j = rcd[k].keys[i];</span><br><span class="line">    rcd1[pos[j]++] = rcd[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完整的基数排序代码"><a href="#完整的基数排序代码" class="headerlink" title="完整的基数排序代码"></a>完整的基数排序代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">RadixSort</span><span class="params">(KeysSqList &amp;L)</span> </span>&#123;</span><br><span class="line">    KeysRcdType *rcd1;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j;</span><br><span class="line">    <span class="keyword">int</span> *count, *pos;</span><br><span class="line">    count = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*L.radix);</span><br><span class="line">    pos = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*L.radix);</span><br><span class="line">    rcd1 = (KeysRcdType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(KeysRcdType)*(L.length+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == count || <span class="literal">NULL</span> == pos || <span class="literal">NULL</span> == rcd1) <span class="keyword">return</span> OVERFLOW;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; L.digitNum) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; L.radix; ++j) count[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == i%<span class="number">2</span>)</span><br><span class="line">            RadixPass(L.rcd, rcd1, L.length, i++, count, pos, L.radix);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            RadixPass(rcd1, L.rcd, L.length, i++, count, pos, L.radix);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == L.digitNum%<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= L.length; ++j) L.rcd[j] = rcd1[j];</span><br><span class="line">    <span class="built_in">free</span>(count); <span class="built_in">free</span>(pos); <span class="built_in">free</span>(rcd1);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RadixPass</span><span class="params">(KeysRcdType rcd[], KeysRcdType rcd1[], <span class="keyword">int</span> n, <span class="keyword">int</span> i, <span class="keyword">int</span> count[], <span class="keyword">int</span> pos[], <span class="keyword">int</span> radix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k, j;</span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">1</span>; k &lt;= n; k++) count[rcd[k].keys[i]]++; <span class="comment">// count键为关键字基数，值为该基数的个数</span></span><br><span class="line">    pos[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 第j个关键字的起始位置为第j-1个关键字的起始位置加上j-1个关键字的个数</span></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; radix; j++) pos[j] = count[j<span class="number">-1</span>] + pos[j<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">1</span>; k &lt;= n; k++) &#123; <span class="comment">// 收集过程</span></span><br><span class="line">        <span class="comment">// k为第k个记录，j为第k个记录的第i个关键字的值</span></span><br><span class="line">        j = rcd[k].keys[i];</span><br><span class="line">        <span class="comment">// pos[j]的定义是：关键字j的起始位置，这里把位置k的记录放到位置pos[j]处</span></span><br><span class="line">        <span class="comment">// 并令pos[j]++，使下一个关键字收集到正确的位置</span></span><br><span class="line">        rcd1[pos[j]++] = rcd[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/22/数据结构02-线性数据结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MakaLoo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MakaL-0-">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/22/数据结构02-线性数据结构/" itemprop="url">数据结构02-线性数据结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-22T11:08:34+08:00">
                2018-11-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/11/22/数据结构02-线性数据结构/" class="leancloud_visitors" data-flag-title="数据结构02-线性数据结构">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数据结构02-线性数据结构"><a href="#数据结构02-线性数据结构" class="headerlink" title="数据结构02-线性数据结构"></a>数据结构02-线性数据结构</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是一种后入先出的数据结构</p>
<h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><p>顺序栈类型定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType *elem; <span class="comment">// 存储空间基址</span></span><br><span class="line">    <span class="keyword">int</span> top; <span class="comment">// 栈顶元素下一位标</span></span><br><span class="line">    <span class="keyword">int</span> size; <span class="comment">// 当前分配的存储容量</span></span><br><span class="line">    <span class="keyword">int</span> increment; <span class="comment">// 扩容时，增加的存储容量</span></span><br><span class="line">&#125; SqStack;</span><br></pre></td></tr></table></figure>
<p>顺序栈常用操作如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitStack_Sq</span><span class="params">(SqStack &amp;S, <span class="keyword">int</span> size, <span class="keyword">int</span> inc)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">DestroyStack_Sq</span><span class="params">(SqStack &amp;S)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">StackEmpty_Sq</span><span class="params">(SqStack S)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearStack_Sq</span><span class="params">(SqStack &amp;S)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">Push_Sq</span><span class="params">(SqStack &amp;S, ElemType e)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">Pop_Sq</span><span class="params">(SqStack &amp;S, ElemType &amp;e)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">GetTop_Sq</span><span class="params">(SqStack S, ElemType &amp;e)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="顺序栈的部分操作"><a href="#顺序栈的部分操作" class="headerlink" title="顺序栈的部分操作"></a>顺序栈的部分操作</h4><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitStack_Sq</span><span class="params">(SqStack &amp;S, <span class="keyword">int</span> size, <span class="keyword">int</span> inc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S = (ElemType*)<span class="built_in">malloc</span>(size*<span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">    <span class="keyword">if</span>(S == <span class="literal">NULL</span>) <span class="keyword">return</span> OVERFLOW;</span><br><span class="line">    S.top = <span class="number">0</span>;</span><br><span class="line">    S.size = size;</span><br><span class="line">    S.increment = inc;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push_Sq</span><span class="params">(SqStack &amp;S, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElemType* newbase;</span><br><span class="line">    <span class="keyword">if</span>(S.top &gt;= S.size) &#123;</span><br><span class="line">        newbase = (ElemType*)<span class="built_in">realloc</span>(S.elem, (S.size+S.increment)*<span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == newbase) <span class="keyword">return</span> OVERFLOW;</span><br><span class="line">        S.elem = newbase;</span><br><span class="line">        S.size += S.increment;</span><br><span class="line">    &#125;</span><br><span class="line">    S.elem[S.top++] = e;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop_Sq</span><span class="params">(SqStack &amp;S, ElemType e)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top &gt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        e = S.elem[--S.top];</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StackEmpty_Sq</span><span class="params">(SqStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">0</span>) <span class="keyword">return</span> TRUE;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="取栈顶元素"><a href="#取栈顶元素" class="headerlink" title="取栈顶元素"></a>取栈顶元素</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">(SqStack S, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top &gt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        e = S.elem(S.top - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="顺序栈的部分习题"><a href="#顺序栈的部分习题" class="headerlink" title="顺序栈的部分习题"></a>顺序栈的部分习题</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">【题目】若顺序栈的类型重新定义如下。试编写算法，</span></span><br><span class="line"><span class="comment">构建初始容量和扩容增量分别为size和inc的空顺序栈S。</span></span><br><span class="line"><span class="comment">typedef struct &#123;</span></span><br><span class="line"><span class="comment">  ElemType *elem; // 存储空间的基址</span></span><br><span class="line"><span class="comment">  ElemType *top;  // 栈顶元素的下一个位置</span></span><br><span class="line"><span class="comment">  int size;       // 当前分配的存储容量</span></span><br><span class="line"><span class="comment">  int increment;  // 扩容时，增加的存储容量</span></span><br><span class="line"><span class="comment">&#125; SqStack2;</span></span><br><span class="line"><span class="comment">***********/</span></span><br><span class="line"><span class="function">Status <span class="title">InitStack_Sq2</span><span class="params">(SqStack2 &amp;S, <span class="keyword">int</span> size, <span class="keyword">int</span> inc)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 构建初始容量和扩容增量分别为size和inc的空顺序栈S。*/</span> </span></span><br><span class="line"><span class="function"><span class="comment">/* 若成功，则返回OK；否则返回ERROR。                 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S.elem = (ElemType*)<span class="built_in">malloc</span>(size * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == S.elem) <span class="keyword">return</span> OVERFLOW;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span> || inc &lt;= <span class="number">0</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    S.top = S.elem+<span class="number">1</span>;</span><br><span class="line">    S.size = size;</span><br><span class="line">    S.increment = inc;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">【题目】若顺序栈的类型重新定义如下。试编写算法，</span></span><br><span class="line"><span class="comment">实现顺序栈的判空操作。</span></span><br><span class="line"><span class="comment">typedef struct &#123;</span></span><br><span class="line"><span class="comment">  ElemType *elem; // 存储空间的基址</span></span><br><span class="line"><span class="comment">  ElemType *top;  // 栈顶元素的下一个位置</span></span><br><span class="line"><span class="comment">  int size;       // 当前分配的存储容量</span></span><br><span class="line"><span class="comment">  int increment;  // 扩容时，增加的存储容量</span></span><br><span class="line"><span class="comment">&#125; SqStack2;</span></span><br><span class="line"><span class="comment">***********/</span></span><br><span class="line"><span class="function">Status <span class="title">StackEmpty_Sq2</span><span class="params">(SqStack2 S)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 对顺序栈S判空。                      */</span> </span></span><br><span class="line"><span class="function"><span class="comment">/* 若S是空栈，则返回TRUE；否则返回FALSE */</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (S.top == S.elem) <span class="keyword">return</span> TRUE;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">【题目】若顺序栈的类型重新定义如下。试编写算法，</span></span><br><span class="line"><span class="comment">实现顺序栈的入栈操作。</span></span><br><span class="line"><span class="comment">typedef struct &#123;</span></span><br><span class="line"><span class="comment">  ElemType *elem; // 存储空间的基址</span></span><br><span class="line"><span class="comment">  ElemType *top;  // 栈顶元素的下一个位置</span></span><br><span class="line"><span class="comment">  int size;       // 当前分配的存储容量</span></span><br><span class="line"><span class="comment">  int increment;  // 扩容时，增加的存储容量</span></span><br><span class="line"><span class="comment">&#125; SqStack2;</span></span><br><span class="line"><span class="comment">***********/</span></span><br><span class="line"><span class="function">Status <span class="title">Push_Sq2</span><span class="params">(SqStack2 &amp;S, ElemType e)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 若顺序栈S是满的，则扩容，若失败则返回ERROR。*/</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 将e压入S，返回OK。                          */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElemType* newbase; </span><br><span class="line">    <span class="keyword">if</span>((S.top - S.elem) / <span class="keyword">sizeof</span>(ElemType) &gt; S.size) &#123;</span><br><span class="line">        newbase = (ElemType*)<span class="built_in">realloc</span>(S.elem, (S.size+S.increment)*<span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == newbase) <span class="keyword">return</span> OVERFLOW;         </span><br><span class="line">        S.elem = newbase;</span><br><span class="line">        S.size += S.increment;</span><br><span class="line">    &#125;</span><br><span class="line">    *S.top++ = e;</span><br><span class="line">    <span class="keyword">return</span> OK;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">【题目】若顺序栈的类型重新定义如下。试编写算法，</span></span><br><span class="line"><span class="comment">实现顺序栈的入栈操作。</span></span><br><span class="line"><span class="comment">typedef struct &#123;</span></span><br><span class="line"><span class="comment">  ElemType *elem; // 存储空间的基址</span></span><br><span class="line"><span class="comment">  ElemType *top;  // 栈顶元素的下一个位置</span></span><br><span class="line"><span class="comment">  int size;       // 当前分配的存储容量</span></span><br><span class="line"><span class="comment">  int increment;  // 扩容时，增加的存储容量</span></span><br><span class="line"><span class="comment">&#125; SqStack2;</span></span><br><span class="line"><span class="comment">***********/</span></span><br><span class="line"><span class="function">Status <span class="title">Push_Sq2</span><span class="params">(SqStack2 &amp;S, ElemType e)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 若顺序栈S是满的，则扩容，若失败则返回ERROR。*/</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 将e压入S，返回OK。                          */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElemType* newbase; </span><br><span class="line">    <span class="keyword">if</span>((S.top - S.elem) / <span class="keyword">sizeof</span>(ElemType) &gt; S.size) &#123;</span><br><span class="line">        newbase = (ElemType*)<span class="built_in">realloc</span>(S.elem, (S.size+S.increment)*<span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == newbase) <span class="keyword">return</span> OVERFLOW;         </span><br><span class="line">        S.elem = newbase;</span><br><span class="line">        S.size += S.increment;</span><br><span class="line">    &#125;</span><br><span class="line">    *S.top++ = e;</span><br><span class="line">    <span class="keyword">return</span> OK;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">【题目】试写一算法，借助辅助栈，复制顺序栈S1得到S2。</span></span><br><span class="line"><span class="comment">顺序栈的类型定义为：</span></span><br><span class="line"><span class="comment">typedef struct &#123;</span></span><br><span class="line"><span class="comment">  ElemType *elem; // 存储空间的基址</span></span><br><span class="line"><span class="comment">  int top;        // 栈顶元素的下一个位置，简称栈顶位标</span></span><br><span class="line"><span class="comment">  int size;       // 当前分配的存储容量</span></span><br><span class="line"><span class="comment">  int increment;  // 扩容时，增加的存储容量</span></span><br><span class="line"><span class="comment">&#125; SqStack;        // 顺序栈</span></span><br><span class="line"><span class="comment">可调用顺序栈接口中下列函数：</span></span><br><span class="line"><span class="comment">Status InitStack_Sq(SqStack &amp;S, int size, int inc); // 初始化顺序栈S</span></span><br><span class="line"><span class="comment">Status DestroyStack_Sq(SqStack &amp;S); // 销毁顺序栈S</span></span><br><span class="line"><span class="comment">Status StackEmpty_Sq(SqStack S);    // 栈S判空，若空则返回TRUE，否则FALSE</span></span><br><span class="line"><span class="comment">Status Push_Sq(SqStack &amp;S, ElemType e); // 将元素e压入栈S</span></span><br><span class="line"><span class="comment">Status Pop_Sq(SqStack &amp;S, ElemType &amp;e); // 栈S的栈顶元素出栈到e</span></span><br><span class="line"><span class="comment">***********/</span></span><br><span class="line"><span class="function">Status <span class="title">CopyStack_Sq</span><span class="params">(SqStack S1, SqStack &amp;S2)</span> </span></span><br><span class="line"><span class="function"><span class="comment">/* 借助辅助栈，复制顺序栈S1得到S2。    */</span> </span></span><br><span class="line"><span class="function"><span class="comment">/* 若复制成功，则返回TRUE；否则FALSE。 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InitStack_Sq(S2, S1.size, S1.increment);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == S2.elem) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S1.top; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Push_Sq(S2, S1.elem[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h3><p>链栈类型定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LSNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LSNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LSNode, *LStack;</span><br></pre></td></tr></table></figure>
<p>接口定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack_LS</span><span class="params">(LStack &amp;S)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyStack_LS</span><span class="params">(LStack &amp;S)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">StackEmpty_LS</span><span class="params">(LStack S)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">Push_LS</span><span class="params">(LStack &amp;S, ElemType e)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">Pop_LS</span><span class="params">(LStack &amp;S, &amp;ElemType e)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">GetTop_LS</span><span class="params">(LStack S, ElemType &amp;e)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="入栈操作"><a href="#入栈操作" class="headerlink" title="入栈操作"></a>入栈操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push_LS</span><span class="params">(LStack &amp;S, ElemType e)</span> </span>&#123;</span><br><span class="line">    LSNode *t;</span><br><span class="line">    t = (LSNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LSNode));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == t) <span class="keyword">return</span> OVERFLOW;</span><br><span class="line">    t-&gt;data = e;</span><br><span class="line">    t-&gt;next = S;</span><br><span class="line">    S = t;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="出栈操作"><a href="#出栈操作" class="headerlink" title="出栈操作"></a>出栈操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop_LS</span><span class="params">(LStack &amp;S, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    LSNode *t = S;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == S) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = S-&gt;data;</span><br><span class="line">    S = S-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(t);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="部分习题"><a href="#部分习题" class="headerlink" title="部分习题"></a>部分习题</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">【题目】试写一算法，实现链栈的判空操作。</span></span><br><span class="line"><span class="comment">链栈的类型定义为：</span></span><br><span class="line"><span class="comment">typedef struct LSNode &#123;</span></span><br><span class="line"><span class="comment">  ElemType data;       // 数据域</span></span><br><span class="line"><span class="comment">  struct LSNode *next; // 指针域</span></span><br><span class="line"><span class="comment">&#125; LSNode, *LStack;    // 结点和链栈类型</span></span><br><span class="line"><span class="comment">***********/</span></span><br><span class="line"><span class="function">Status <span class="title">StackEmpty_L</span><span class="params">(LStack S)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 对链栈S判空。若S是空栈，则返回TRUE；否则返回FALSE */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S == <span class="literal">NULL</span>) <span class="keyword">return</span> TRUE;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">【题目】试写一算法，实现链栈的取栈顶元素操作。</span></span><br><span class="line"><span class="comment">链栈的类型定义为：</span></span><br><span class="line"><span class="comment">typedef struct LSNode &#123;</span></span><br><span class="line"><span class="comment">  ElemType data;       // 数据域</span></span><br><span class="line"><span class="comment">  struct LSNode *next; // 指针域</span></span><br><span class="line"><span class="comment">&#125; LSNode, *LStack;    // 结点和链栈类型</span></span><br><span class="line"><span class="comment">***********/</span></span><br><span class="line"><span class="function">Status <span class="title">GetTop_L</span><span class="params">(LStack S, ElemType &amp;e)</span> </span></span><br><span class="line"><span class="function"><span class="comment">/* 取链栈S的栈顶元素到e，并返回OK; */</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 若S是空栈，则失败，返回ERROR。  */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S == <span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = S-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType *elem;</span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear; <span class="comment">// 队尾位标，表示队尾元素的下一位置</span></span><br><span class="line">    <span class="keyword">int</span> maxSize;</span><br><span class="line">&#125; SqQueue;</span><br></pre></td></tr></table></figure>
<p>循环队列是把队列看成首尾相连的顺序队列。<br>有如下基本操作接口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQueue_Sq</span><span class="params">(SqQueue &amp;Q)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">DestroyQueue_Sq</span><span class="params">(SqQueue &amp;Q)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearQueue_Sq</span><span class="params">(SqQueue &amp;Q)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">QueueEmpty_Sq</span><span class="params">(SqQueue Q)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength_Sq</span><span class="params">(SqQueue Q)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">GetHead_Sq</span><span class="params">(SqQueue Q, ElemType &amp;e)</span></span>; </span><br><span class="line"><span class="function">Status <span class="title">EnQueue_Sq</span><span class="params">(SqQueue &amp;Q, ElemType e)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">DeQueue_Sq</span><span class="params">(SqQueue &amp;Q, ElemType &amp;e)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="循环队列的实现"><a href="#循环队列的实现" class="headerlink" title="循环队列的实现"></a>循环队列的实现</h4><p>入队时，对队尾循环加一，如下</p>
<p><code>Q.rear = (Q.rear+1)%Q.maxSize;</code></p>
<p>出队时同样操作</p>
<p>对于队空队满的判断可以有如下判断方法</p>
<ul>
<li>设一标志域标识队列的空或满</li>
<li>设一长度域记录队列中元素的个数</li>
<li>少用一个元素空间，一旦Q.front==(Q.rear+1)%Q.maxSize则队满</li>
</ul>
<h4 id="循环队列部分操作"><a href="#循环队列部分操作" class="headerlink" title="循环队列部分操作"></a>循环队列部分操作</h4><h5 id="初始化操作"><a href="#初始化操作" class="headerlink" title="初始化操作"></a>初始化操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQueue_Sq</span><span class="params">(SqQueue &amp;Q, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    Q.elem = (ElemType*)<span class="built_in">malloc</span>(size*<span class="keyword">sizeof</span>(ElemType))</span><br><span class="line">    <span class="keyword">if</span> (Q.elem == <span class="literal">NULL</span>) <span class="keyword">return</span> OVERFLOW;</span><br><span class="line">    Q.maxSize = size;</span><br><span class="line">    Q.front = Q.rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="出队操作"><a href="#出队操作" class="headerlink" title="出队操作"></a>出队操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue_Sq</span><span class="params">(SqQueue &amp;Q, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = Q.elem[Q.front];</span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % Q.maxSize;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="入队操作"><a href="#入队操作" class="headerlink" title="入队操作"></a>入队操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue_Sq</span><span class="params">(SqQueue &amp;Q, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == (Q.rear + <span class="number">1</span>) % Q.maxSize) <span class="keyword">return</span> ERROR;</span><br><span class="line">    Q.elem[Q.rear] = e;</span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % Q.maxSize;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="循环队列的部分习题"><a href="#循环队列的部分习题" class="headerlink" title="循环队列的部分习题"></a>循环队列的部分习题</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">【题目】试写一算法，求循环队列的长度。</span></span><br><span class="line"><span class="comment">循环队列的类型定义为：</span></span><br><span class="line"><span class="comment">typedef struct &#123;</span></span><br><span class="line"><span class="comment">  ElemType *base;  // 存储空间的基址</span></span><br><span class="line"><span class="comment">  int front;       // 队头位标</span></span><br><span class="line"><span class="comment">  int rear;        // 队尾位标，指示队尾元素的下一位置</span></span><br><span class="line"><span class="comment">  int maxSize;     // 最大长度</span></span><br><span class="line"><span class="comment">&#125; SqQueue;</span></span><br><span class="line"><span class="comment">***********/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength_Sq</span><span class="params">(SqQueue Q)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 返回队列Q中元素个数，即队列的长度。 */</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front &lt;= Q.rear) <span class="keyword">return</span> Q.rear - Q.front;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> Q.maxSize + Q.rear - Q.front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">【题目】如果希望循环队列中的元素都能得到利用，</span></span><br><span class="line"><span class="comment">则可设置一个标志域tag，并以tag值为0或1来区分尾</span></span><br><span class="line"><span class="comment">指针和头指针值相同时的队列状态是"空"还是"满"。</span></span><br><span class="line"><span class="comment">试编写与此结构相应的入队列和出队列的算法。</span></span><br><span class="line"><span class="comment">本题的循环队列CTagQueue的类型定义如下：</span></span><br><span class="line"><span class="comment">typedef struct &#123;</span></span><br><span class="line"><span class="comment">  ElemType elem[MAXQSIZE];</span></span><br><span class="line"><span class="comment">  int tag;</span></span><br><span class="line"><span class="comment">  int front;</span></span><br><span class="line"><span class="comment">  int rear;</span></span><br><span class="line"><span class="comment">&#125; CTagQueue;</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="function">Status <span class="title">EnCQueue</span><span class="params">(CTagQueue &amp;Q, ElemType x)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 将元素x加入队列Q，并返回OK；*/</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 若失败，则返回ERROR。       */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear &amp;&amp; Q.tag == <span class="number">1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    Q.elem[Q.rear] = x;</span><br><span class="line">    Q.rear = (Q.rear+<span class="number">1</span>)%MAXQSIZE;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front) Q.tag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DeCQueue</span><span class="params">(CTagQueue &amp;Q, ElemType &amp;x)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 将队列Q的队头元素退队到x，并返回OK；*/</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 若失败，则返回ERROR。               */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear &amp;&amp; Q.tag == <span class="number">0</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    x = Q.elem[Q.front];</span><br><span class="line">    Q.front=(Q.front+<span class="number">1</span>)%MAXQSIZE;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear) Q.tag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">【题目】假设将循环队列定义为：以域变量rear</span></span><br><span class="line"><span class="comment">和length分别指示循环队列中队尾元素的位置和内</span></span><br><span class="line"><span class="comment">含元素的个数。试给出此循环队列的队满条件，并</span></span><br><span class="line"><span class="comment">写出相应的入队列和出队列的算法（在出队列的算</span></span><br><span class="line"><span class="comment">法中要返回队头元素）。</span></span><br><span class="line"><span class="comment">本题的循环队列CLenQueue的类型定义如下：</span></span><br><span class="line"><span class="comment">typedef struct &#123;</span></span><br><span class="line"><span class="comment">  ElemType elem[MAXQSIZE];</span></span><br><span class="line"><span class="comment">  int length;</span></span><br><span class="line"><span class="comment">  int rear;</span></span><br><span class="line"><span class="comment">&#125; CLenQueue;</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="function">Status <span class="title">EnCQueue</span><span class="params">(CLenQueue &amp;Q, ElemType x)</span></span></span><br><span class="line"><span class="function">  <span class="comment">/* 将元素x加入队列Q，并返回OK；*/</span></span></span><br><span class="line"><span class="function">  <span class="comment">/* 若失败，则返回ERROR。       */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.length == MAXQSIZE) <span class="keyword">return</span> ERROR;</span><br><span class="line">    Q.rear = (Q.rear+<span class="number">1</span>)%MAXQSIZE;</span><br><span class="line">    Q.elem[Q.rear] = x;</span><br><span class="line">    Q.length++;    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Status <span class="title">DeCQueue</span><span class="params">(CLenQueue &amp;Q, ElemType &amp;x)</span></span></span><br><span class="line"><span class="function">  <span class="comment">/* 将队列Q的队头元素退队到x，并返回OK；*/</span></span></span><br><span class="line"><span class="function">  <span class="comment">/* 若失败，则返回ERROR。               */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.length == <span class="number">0</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    x = Q.elem[(MAXQSIZE + Q.rear - Q.length + <span class="number">1</span>)%MAXQSIZE];</span><br><span class="line">    Q.length--;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">【题目】已知k阶斐波那契序列的定义为:</span></span><br><span class="line"><span class="comment">    f0=0,  f1=0,  …,  fk-2=0,  fk-1=1;</span></span><br><span class="line"><span class="comment">    fn=fn-1+fn-2+…+fn-k,  n=k,k+1,…</span></span><br><span class="line"><span class="comment">试利用循环队列编写求k阶斐波那契序列中第</span></span><br><span class="line"><span class="comment">n+1项fn的算法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">本题的循环队列的类型定义如下：</span></span><br><span class="line"><span class="comment">typedef struct &#123;</span></span><br><span class="line"><span class="comment">  ElemType *base; // 存储空间的基址</span></span><br><span class="line"><span class="comment">  int front;      // 队头位标</span></span><br><span class="line"><span class="comment">  int rear;       // 队尾位标，指示队尾元素的下一位置</span></span><br><span class="line"><span class="comment">  int maxSize;    // 最大长度</span></span><br><span class="line"><span class="comment">&#125; SqQueue;</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 想着构造一个maxSize为n+1的循环队列来计算，但是没做出来。。。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Fib</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 求k阶斐波那契序列的第n+1项fn */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SqQueue</span> <span class="title">q</span>;</span></span><br><span class="line">    q.front = <span class="number">0</span>;</span><br><span class="line">    q.rear = <span class="number">0</span>;</span><br><span class="line">    q.maxSize = n+<span class="number">1</span>;    </span><br><span class="line">    q.base = (ElemType*)<span class="built_in">malloc</span>((n+<span class="number">1</span>)*<span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">    <span class="keyword">if</span>(q.base == <span class="literal">NULL</span>) <span class="keyword">return</span> OVERFLOW;</span><br><span class="line">    <span class="keyword">int</span> i, j, t;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q.base[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    q.base[i++] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(t = i; t &lt; n+<span class="number">1</span>; t++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = t<span class="number">-1</span>; j &gt;= t-k; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            q.base[t] += q.base[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q.base[n]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这种做法时间复杂度O(n2)，空间复杂度O(n)</span></span><br><span class="line"><span class="comment">/*    </span></span><br><span class="line"><span class="comment">    struct SqQueue q;</span></span><br><span class="line"><span class="comment">    q.front = 0;</span></span><br><span class="line"><span class="comment">    q.rear = 0;</span></span><br><span class="line"><span class="comment">    q.maxSize = n+1;    </span></span><br><span class="line"><span class="comment">    q.base = (ElemType*)malloc((n+1)*sizeof(ElemType));</span></span><br><span class="line"><span class="comment">    if(q.base == NULL) return OVERFLOW;</span></span><br><span class="line"><span class="comment">    int i, j, t;</span></span><br><span class="line"><span class="comment">    for(i = 0; i &lt; k - 1; i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        q.base[i] = 0;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    q.base[i++] = 1;</span></span><br><span class="line"><span class="comment">    for(t = i; t &lt; n+1; t++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        for(j = t-1; j &gt;= t-k; j--)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            q.base[t] += q.base[j];</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return q.base[n]; </span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure>
<h3 id="链队列"><a href="#链队列" class="headerlink" title="链队列"></a>链队列</h3><p>类型定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LQNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LQNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LQNode, *QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    QueuePtr front;</span><br><span class="line">    QueuePtr rear;</span><br><span class="line">&#125; LQueue;</span><br></pre></td></tr></table></figure>
<p>接口如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue_LQ</span><span class="params">(LQueue &amp;Q)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyQueue_LQ</span><span class="params">(LQueue &amp;Q)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">QueueEmpty_LQ</span><span class="params">(LQueue Q)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength_LQ</span><span class="params">(LQueue Q)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">GetHead_LQ</span><span class="params">(LQueue Q, ElemType &amp;e)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">EnQueue_LQ</span><span class="params">(LQueue &amp;Q, ElemType e)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">DeQueue_LQ</span><span class="params">(LQueue &amp;Q, ElemType &amp;e)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="入队操作-1"><a href="#入队操作-1" class="headerlink" title="入队操作"></a>入队操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue_LQ</span><span class="params">(LQueue &amp;Q, ElemType e)</span> </span>&#123;</span><br><span class="line">    LQNode *p;</span><br><span class="line">    p = (LQNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LQNode));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == p) <span class="keyword">return</span> OVERFLOW;</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == Q.front) Q.front = p;</span><br><span class="line">    <span class="keyword">else</span> Q.rear-&gt;next = p;</span><br><span class="line">    Q.rear = p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="出队操作-1"><a href="#出队操作-1" class="headerlink" title="出队操作"></a>出队操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQuquq_LQ</span><span class="params">(LQueue &amp;Q, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    LQNode *p;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == Q.front) <span class="keyword">return</span> ERROR;</span><br><span class="line">    p = Q.front;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    Q.front = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (Q.rear == p) Q.rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="部分习题-1"><a href="#部分习题-1" class="headerlink" title="部分习题"></a>部分习题</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">【题目】试写一算法，实现链队列的判空操作。</span></span><br><span class="line"><span class="comment">链队列的类型定义为：</span></span><br><span class="line"><span class="comment">typedef struct LQNode &#123;     </span></span><br><span class="line"><span class="comment">  ElemType  data;  </span></span><br><span class="line"><span class="comment">  struct LQNode  *next;  </span></span><br><span class="line"><span class="comment">&#125; LQNode, *QueuePtr; // 结点和结点指针类型</span></span><br><span class="line"><span class="comment">typedef struct &#123;     </span></span><br><span class="line"><span class="comment">  QueuePtr  front;  // 队头指针</span></span><br><span class="line"><span class="comment">  QueuePtr  rear;   // 队尾指针</span></span><br><span class="line"><span class="comment">&#125; LQueue;  // 链队列类型</span></span><br><span class="line"><span class="comment">***********/</span></span><br><span class="line"><span class="function">Status <span class="title">QueueEmpty_LQ</span><span class="params">(LQueue Q)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 判定链队列Q是否为空队列。           */</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 若Q是空队列，则返回TRUE，否则FALSE。*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == <span class="literal">NULL</span> &amp;&amp; Q.rear == <span class="literal">NULL</span>) <span class="keyword">return</span> TRUE;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">【题目】试写一算法，实现链队列的求队列长度操作。</span></span><br><span class="line"><span class="comment">链队列的类型定义为：</span></span><br><span class="line"><span class="comment">typedef struct LQNode &#123;     </span></span><br><span class="line"><span class="comment">  ElemType  data;  </span></span><br><span class="line"><span class="comment">  struct LQNode  *next;  </span></span><br><span class="line"><span class="comment">&#125; LQNode, *QueuePtr; // 结点和结点指针类型</span></span><br><span class="line"><span class="comment">typedef struct &#123;     </span></span><br><span class="line"><span class="comment">  QueuePtr  front;  // 队头指针</span></span><br><span class="line"><span class="comment">  QueuePtr  rear;   // 队尾指针</span></span><br><span class="line"><span class="comment">&#125; LQueue;  // 链队列类型</span></span><br><span class="line"><span class="comment">***********/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength_LQ</span><span class="params">(LQueue Q)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 求链队列Q的长度并返回其值 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">    LQNode *pt;</span><br><span class="line">    pt=Q.front;</span><br><span class="line">    <span class="keyword">while</span>(pt != Q.rear-&gt;next)&#123;</span><br><span class="line">         length++;</span><br><span class="line">         pt=pt-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(pt);</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">【题目】假设以带头结点的循环链表表示队列，并且</span></span><br><span class="line"><span class="comment">只设一个指针指向队尾元素结点(注意不设头指针)，</span></span><br><span class="line"><span class="comment">试编写相应的队列初始化、入队列和出队列的算法。</span></span><br><span class="line"><span class="comment">带头结点循环链队列CLQueue的类型定义为：</span></span><br><span class="line"><span class="comment">typedef struct LQNode &#123;</span></span><br><span class="line"><span class="comment">  ElemType data;</span></span><br><span class="line"><span class="comment">  struct LQNode *next;</span></span><br><span class="line"><span class="comment">&#125; LQNode, *CLQueue;</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="function">Status <span class="title">InitCLQueue</span><span class="params">(CLQueue &amp;rear)</span> <span class="comment">// 初始化空队列</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==(rear=(LQNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LQNode))))</span><br><span class="line">        <span class="keyword">return</span> OVERFLOW;</span><br><span class="line">    rear-&gt;next = rear;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">EnCLQueue</span><span class="params">(CLQueue &amp;rear, ElemType x)</span> <span class="comment">// 入队</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LQNode* oldRear = rear;</span><br><span class="line">    LQNode* head=rear-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==(rear=(LQNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LQNode))))</span><br><span class="line">        <span class="keyword">return</span> OVERFLOW;</span><br><span class="line">    rear-&gt;next = head;</span><br><span class="line">    rear-&gt;data = x;</span><br><span class="line">    oldRear-&gt;next = rear;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DeCLQueue</span><span class="params">(CLQueue &amp;rear, ElemType &amp;x)</span> <span class="comment">// 出队</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rear-&gt;next == rear) <span class="keyword">return</span> ERROR;</span><br><span class="line">    LQNode* head = rear-&gt;next;</span><br><span class="line">    LQNode* headNext = head-&gt;next;</span><br><span class="line">    x = headNext-&gt;data;</span><br><span class="line">    head-&gt;next = headNext-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(headNext);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>采用顺序存储结构表示的线性表为顺序表。存储位置相邻表示位序相继的两个元素之间的前驱和后继关系。因顺序表的结构，在表中插入或删除元素不方便，所以只考虑表尾插入和删除元素，这样的顺序表也可称为栈表，类型定义如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType *elem;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> increment;</span><br><span class="line">&#125; SqList;</span><br></pre></td></tr></table></figure>
<p>基本接口如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitList_Sq</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> size, <span class="keyword">int</span> inc)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">DestroyList_Sq</span><span class="params">(SqList &amp;L)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">ClearList_Sq</span><span class="params">(SqList &amp;L)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">ListEmpty_Sq</span><span class="params">(SqList L)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength_Sq</span><span class="params">(SqList L)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">GetElem_Sq</span><span class="params">(SqList L, <span class="keyword">int</span> i, ElemType &amp;e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Sq</span><span class="params">(SqList L, ElemType e)</span></span>; <span class="comment">// 顺序表中查找元素e，返回e出现第一个的位置，否则返回-1</span></span><br><span class="line">Status ListTraverse_Sq(SqList L, Status (*visit)(ElemType e)); // 遍历顺序表L，依次对每个元素调用visit()</span><br><span class="line"><span class="function">Status <span class="title">PutElem_Sq</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, ElemType e)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">Append_Sq</span><span class="params">(SqList &amp;L, ElemType e)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">DeleteLast_Sq</span><span class="params">(SqList &amp;L, ElemType &amp;e)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="删除表尾元素"><a href="#删除表尾元素" class="headerlink" title="删除表尾元素"></a>删除表尾元素</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeleteLast_Sq</span><span class="params">(SqList &amp;L, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L.length == <span class="number">0</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = L.elem[--L.length];</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Sq</span><span class="params">(SqList L, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;L.length &amp;&amp; L.elem[i] != e) i++;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; L.length) <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="有序顺序表的归并"><a href="#有序顺序表的归并" class="headerlink" title="有序顺序表的归并"></a>有序顺序表的归并</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList_Sq</span><span class="params">(SqList La, SqList Lb, SqList &amp;Lc)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 已知有序顺序表La和Lb中的数据元素按值非递减排序</span></span><br><span class="line">    <span class="comment">// 归并La和Lb得到新的有序顺序表Lc，Lc的数据元素也按值非递减排列</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, size, increment = <span class="number">10</span>;</span><br><span class="line">    ElemType ai, bj;</span><br><span class="line">    size = La.length + Lb.length;</span><br><span class="line">    InitList_Sq(Lc, size, increment);</span><br><span class="line">    <span class="keyword">while</span> (i &lt; La.length &amp;&amp; j &lt; Lb.length) &#123;</span><br><span class="line">        GetElem_Sq(La, i, ai);</span><br><span class="line">        GetElem_Sq(Lb, j, bj);</span><br><span class="line">        <span class="keyword">if</span> (ai &lt;= bj) &#123;</span><br><span class="line">            Append_Sq(Lc, ai);</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Append_Sq(Lc, bj);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; La.length) &#123;</span><br><span class="line">        GetElem_Sq(La, i++, ai);</span><br><span class="line">        Append_Sq(Lc, ai);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; Lb.length) &#123;</span><br><span class="line">        GetElem_Sq(Lb, j++, bj);</span><br><span class="line">        Append_Sq(Lc, bj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="部分习题-2"><a href="#部分习题-2" class="headerlink" title="部分习题"></a>部分习题</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">【题目】设A=(a1,…,am)和B=(b1,…,bn)均为有序顺序表，</span></span><br><span class="line"><span class="comment">A'和B'分别为A和B中除去最大共同前缀后的子表（例如，</span></span><br><span class="line"><span class="comment">A=(x,y,y,z,x,z)，B=(x,y,y,z,y,x,x,z)，则两者中最大</span></span><br><span class="line"><span class="comment">的共同前缀为(x,y,y,z)， 在两表中除去最大共同前缀后</span></span><br><span class="line"><span class="comment">的子表分别为A'=(x,z)和B'=(y,x,x,z)）。若A'=B'=空表，</span></span><br><span class="line"><span class="comment">则A=B；若A'=空表，而B'≠ 空表，或者两者均不为空表，</span></span><br><span class="line"><span class="comment">且A'的首元小于B'的首元，则A&lt;B；否则A&gt;B。试写一个比</span></span><br><span class="line"><span class="comment">较A和B大小的算法。（注意：在算法中，不要破坏原表A</span></span><br><span class="line"><span class="comment">和B，也不一定先求得A'和B'才进行比较）。</span></span><br><span class="line"><span class="comment">顺序表类型定义如下：</span></span><br><span class="line"><span class="comment">typedef struct &#123;</span></span><br><span class="line"><span class="comment">  ElemType *elem;</span></span><br><span class="line"><span class="comment">  int       length;</span></span><br><span class="line"><span class="comment">  int       size;</span></span><br><span class="line"><span class="comment">  int       increment;</span></span><br><span class="line"><span class="comment">&#125; SqList;</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">Compare</span><span class="params">(SqList A, SqList B)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 比较顺序表A和B,      */</span></span></span><br><span class="line"><span class="function"><span class="comment">/*   返回'&lt;', 若A&lt;B;    */</span></span></span><br><span class="line"><span class="function"><span class="comment">/*       '=', 若A=B;    */</span></span></span><br><span class="line"><span class="function"><span class="comment">/*       '&gt;', 若A&gt;B     */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = (A.length&lt;=B.length)?A.length:B.length;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; min; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(A.elem[i] == B.elem[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A.elem[i] &lt; B.elem[i]) <span class="keyword">return</span> <span class="string">'&lt;'</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A.elem[i] &gt; B.elem[i]) <span class="keyword">return</span> <span class="string">'&gt;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == A.length &amp;&amp; i == B.length) <span class="keyword">return</span> <span class="string">'='</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i == A.length) <span class="keyword">return</span> <span class="string">'&lt;'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">'&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">【题目】试写一算法，实现顺序表的就地逆置，</span></span><br><span class="line"><span class="comment">即利用原表的存储空间将线性表(a1,a2,…,an)</span></span><br><span class="line"><span class="comment">逆置为(an,an-1,…,a1)。</span></span><br><span class="line"><span class="comment">顺序表类型定义如下：</span></span><br><span class="line"><span class="comment">typedef struct &#123;</span></span><br><span class="line"><span class="comment">  ElemType *elem;</span></span><br><span class="line"><span class="comment">  int       length;</span></span><br><span class="line"><span class="comment">  int       size;</span></span><br><span class="line"><span class="comment">  int       increment;</span></span><br><span class="line"><span class="comment">&#125; SqList;</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inverse</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElemType temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length/<span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = L.elem[i];</span><br><span class="line">        L.elem[i] = L.elem[L.length-i<span class="number">-1</span>];</span><br><span class="line">        L.elem[L.length-i<span class="number">-1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">【题目】试对一元稀疏多项式Pn(x)采用存储量同多项式</span></span><br><span class="line"><span class="comment">项数m成正比的顺序存储结构，编写求Pn(x0)的算法（x0</span></span><br><span class="line"><span class="comment">为给定值）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一元稀疏多项式的顺序存储结构:</span></span><br><span class="line"><span class="comment">typedef struct &#123;</span></span><br><span class="line"><span class="comment">  int  coef;  // 系数</span></span><br><span class="line"><span class="comment">  int   exp;  // 指数</span></span><br><span class="line"><span class="comment">&#125; Term;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">typedef struct &#123;</span></span><br><span class="line"><span class="comment">  Term  *elem;   // 存储空间基址</span></span><br><span class="line"><span class="comment">  int    length; // 长度（项数）</span></span><br><span class="line"><span class="comment">&#125; Poly;</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Evaluate</span><span class="params">(Poly P, <span class="keyword">float</span> x)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* P.elem[i].coef 存放ai，                        */</span></span></span><br><span class="line"><span class="function"><span class="comment">/* P.elem[i].exp存放ei (i=1,2,...,m)              */</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 本算法计算并返回多项式的值。不判别溢出。       */</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 入口时要求0≤e1&lt;e2&lt;...&lt;em，算法内不对此再作验证 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> temp = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">float</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> exexp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; P.length; i++)</span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="keyword">for</span>(j = exexp; j &lt; P.elem[i].<span class="built_in">exp</span>; j++)</span><br><span class="line">            temp *= x;</span><br><span class="line">        result += temp * P.elem[i].coef;</span><br><span class="line">        exexp = P.elem[i].<span class="built_in">exp</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">【题目】假设有两个集合A和B分别用两个线性表LA和LB</span></span><br><span class="line"><span class="comment">表示(即：线性表中的数据元素即为集合中的成员），</span></span><br><span class="line"><span class="comment">试写一算法，求并集A＝A∪B。</span></span><br><span class="line"><span class="comment">顺序表类型定义如下</span></span><br><span class="line"><span class="comment">typedef struct &#123;</span></span><br><span class="line"><span class="comment">  ElemType *elem;     // 存储空间的基址</span></span><br><span class="line"><span class="comment">  int length;    // 当前长度</span></span><br><span class="line"><span class="comment">  int size;      // 存储容量 </span></span><br><span class="line"><span class="comment">  int increment; // 空间不够增加空间大小</span></span><br><span class="line"><span class="comment">&#125; SqList;  // 顺序表</span></span><br><span class="line"><span class="comment">可调用顺序表的以下接口函数：   </span></span><br><span class="line"><span class="comment">Status InitList_Sq(SqList &amp;L, int size, int inc); // 初始化顺序表L</span></span><br><span class="line"><span class="comment">int ListLength_Sq(SqList L);  // 返回顺序表L中元素个数</span></span><br><span class="line"><span class="comment">Status GetElem_Sq(SqList L, int i, ElemType &amp;e); </span></span><br><span class="line"><span class="comment">// 用e返回顺序表L中第i个元素的值</span></span><br><span class="line"><span class="comment">int Search_Sq(SqList L, ElemType e); </span></span><br><span class="line"><span class="comment">// 在顺序表L顺序查找元素e，成功时返回该元素在表中第一次出现的位置，否则返回-1</span></span><br><span class="line"><span class="comment">Status Append_Sq(SqList &amp;L, ElemType e);  // 在顺序表L表尾添加元素e</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(SqList &amp;La, SqList Lb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ListLength_Sq(Lb); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        GetElem_Sq(Lb, i, data);</span><br><span class="line">        <span class="keyword">if</span>(Search_Sq(La, data) == <span class="number">-1</span>)</span><br><span class="line">            Append_Sq(La, data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>链表和单链栈的结构体定义是一样的，它们的区别是性质和操作，链栈是一个栈，它的操作接口有入栈，出栈，取栈顶元素等，而链表是一个表，是有结构的数据的集合，它的操作有插入，删除，遍历等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br></pre></td></tr></table></figure>
<p>基本操作接口如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitList_L</span><span class="params">(LinkList &amp;L)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">DestroyList_L</span><span class="params">(LinkList &amp;L)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">ClearList_L</span><span class="params">(LinkList &amp;L)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">ListEmpty_L</span><span class="params">(LinkList L)</span></span>;</span><br><span class="line"><span class="function">init <span class="title">ListLength_L</span><span class="params">(LinkList L)</span></span>;</span><br><span class="line"><span class="function">LNode* <span class="title">Search_L</span><span class="params">(LinkList L, ElemType e)</span></span>;</span><br><span class="line"><span class="function">LNode* <span class="title">NextElem_L</span><span class="params">(LNode *p)</span></span>; <span class="comment">// 返回p结点的直接后继</span></span><br><span class="line"><span class="function">LNode* <span class="title">MakeNode_L</span><span class="params">(ElemType e)</span></span>; <span class="comment">// 构造元素e的结点，返回指向该结点指针</span></span><br><span class="line"><span class="function">Status <span class="title">InsertAfter_L</span><span class="params">(LNode *p, LNode *q)</span></span>; <span class="comment">// 结点p后插入结点q</span></span><br><span class="line"><span class="function">Status <span class="title">DeleteAfter_L</span><span class="params">(LNode *p, ElemType &amp;e)</span></span>; <span class="comment">// 删除p结点的直接后继结点，用e返回结点值</span></span><br><span class="line">void ListTraverse_L(LinkList L, Status (*visit)(ElemType e)); // 遍历单链表L</span><br></pre></td></tr></table></figure>
<h4 id="单链表初始化"><a href="#单链表初始化" class="headerlink" title="单链表初始化"></a>单链表初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitList_L</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)))</span><br><span class="line">        <span class="keyword">return</span> OVERFLOW;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="查找元素操作"><a href="#查找元素操作" class="headerlink" title="查找元素操作"></a>查找元素操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LNode* <span class="title">Search_L</span><span class="params">(LinkList L, ElemType e)</span> </span>&#123;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == L) <span class="keyword">return</span> ERROR;</span><br><span class="line">    p = L-&gt;next; <span class="comment">// 带头结点</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;data != e &amp;&amp; p != <span class="literal">NULL</span>)</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="求直接后继操作"><a href="#求直接后继操作" class="headerlink" title="求直接后继操作"></a>求直接后继操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LNode* <span class="title">NextElem_L</span><span class="params">(LNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="构造结点操作"><a href="#构造结点操作" class="headerlink" title="构造结点操作"></a>构造结点操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LNode *<span class="title">MakeNode_L</span><span class="params">(ElemType e)</span> </span>&#123;</span><br><span class="line">    LNode *p;</span><br><span class="line">    p = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != p) &#123;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;data = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插入直接后继结点操作"><a href="#插入直接后继结点操作" class="headerlink" title="插入直接后继结点操作"></a>插入直接后继结点操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InsertAfter_L</span><span class="params">(LNode *p, LNode *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == p || <span class="literal">NULL</span> == q) <span class="keyword">return</span> ERROR;</span><br><span class="line">    q-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = q;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除直接后继结点操作"><a href="#删除直接后继结点操作" class="headerlink" title="删除直接后继结点操作"></a>删除直接后继结点操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeleteAfter_L</span><span class="params">(LNode *p, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    LNode *q;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || p-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    q = p-&gt;next;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    e = q-&gt;data;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单链表的逆置"><a href="#单链表的逆置" class="headerlink" title="单链表的逆置"></a>单链表的逆置</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InverseList</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    LNode *q, *p;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == L-&gt;next || <span class="literal">NULL</span> == L-&gt;next-&gt;next) <span class="keyword">return</span>;</span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        InsertAfter_L(L, p);</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="部分习题-3"><a href="#部分习题-3" class="headerlink" title="部分习题"></a>部分习题</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">【题目】试写一算法，实现带头结点单链表的判空操作。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">单链表的类型定义为：</span></span><br><span class="line"><span class="comment">typedef struct LNode &#123;     </span></span><br><span class="line"><span class="comment">  ElemType  data;  </span></span><br><span class="line"><span class="comment">  struct LNode  *next;  </span></span><br><span class="line"><span class="comment">&#125; LNode, *LinkList; // 结点和结点指针类型</span></span><br><span class="line"><span class="comment">***********/</span></span><br><span class="line"><span class="function">Status <span class="title">ListEmpty_L</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 判定带头结点单链表L是否为空链表。   */</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 若L是空链表，则返回TRUE，否则FALSE。*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> TRUE; <span class="comment">// 带头结点，头结点保存了一些信息</span></span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">【题目】试写一算法，实现带头结点单链表的销毁操作。</span></span><br><span class="line"><span class="comment">单链表的类型定义为：</span></span><br><span class="line"><span class="comment">typedef struct LNode &#123;     </span></span><br><span class="line"><span class="comment">  ElemType  data;  </span></span><br><span class="line"><span class="comment">  struct LNode  *next;  </span></span><br><span class="line"><span class="comment">&#125; LNode, *LinkList; // 结点和结点指针类型</span></span><br><span class="line"><span class="comment">***********/</span></span><br><span class="line"><span class="function">Status <span class="title">DestroyList_L</span><span class="params">(LinkList &amp;L)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 销毁带头结点单链表L，并返回OK。*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode* n = L;</span><br><span class="line">    <span class="keyword">while</span>((n=n-&gt;next) != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">free</span>(n);</span><br><span class="line">    <span class="built_in">free</span>(L);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">【题目】试写一算法，实现带头结点单链表的清空操作。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">单链表的类型定义为：</span></span><br><span class="line"><span class="comment">typedef struct LNode &#123;     </span></span><br><span class="line"><span class="comment">  ElemType  data;  </span></span><br><span class="line"><span class="comment">  struct LNode  *next;  </span></span><br><span class="line"><span class="comment">&#125; LNode, *LinkList; // 结点和结点指针类型</span></span><br><span class="line"><span class="comment">***********/</span></span><br><span class="line"><span class="function">Status <span class="title">ClearList_L</span><span class="params">(LinkList &amp;L)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 将带头结点单链表L置为空表，并返回OK。*/</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 若L不是带头结点单链表，则返回ERROR。 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    LNode* n = L;</span><br><span class="line">    <span class="keyword">while</span>((n=n-&gt;next)!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">free</span>(n);</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 释放完内存后，L-&gt;next仍然指向之前分配的，尽管那片空间已经被释放</span></span><br><span class="line">    <span class="keyword">return</span> OK;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">【题目】试写一算法，实现带头结点单链表的求表长度操作。</span></span><br><span class="line"><span class="comment">单链表的类型定义为：</span></span><br><span class="line"><span class="comment">typedef struct LNode &#123;     </span></span><br><span class="line"><span class="comment">  ElemType  data;  </span></span><br><span class="line"><span class="comment">  struct LNode  *next;  </span></span><br><span class="line"><span class="comment">&#125; LNode, *LinkList; // 结点和结点指针类型</span></span><br><span class="line"><span class="comment">***********/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength_L</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 求带头结点单链表L的长度，并返回长度值。*/</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 若L不是带头结点单链表，则返回-1。      */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    LNode* p = L;</span><br><span class="line">    <span class="keyword">while</span>((p=p-&gt;next)!=<span class="literal">NULL</span>)</span><br><span class="line">        length++;</span><br><span class="line">    <span class="keyword">return</span> length;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">【题目】试写一算法，在带头结点单链表L插入第i元素e。</span></span><br><span class="line"><span class="comment">带头结点单链表的类型定义为：</span></span><br><span class="line"><span class="comment">typedef struct LNode &#123;</span></span><br><span class="line"><span class="comment">  ElemType      data;</span></span><br><span class="line"><span class="comment">  struct LNode *next;</span></span><br><span class="line"><span class="comment">&#125; LNode, *LinkList;</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="function">Status <span class="title">Insert_L</span><span class="params">(LinkList L, <span class="keyword">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 在带头结点单链表L插入第i元素e，并返回OK。*/</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 若参数不合理，则返回ERROR。              */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// i为第i个位置</span></span><br><span class="line">    <span class="comment">// 不能插入到0号位置头结点处</span></span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    LNode *p=L, *q;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=<span class="number">0</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span>((q=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)))==<span class="literal">NULL</span>) <span class="keyword">return</span> OVERFLOW;</span><br><span class="line">    <span class="keyword">for</span>(c=<span class="number">1</span>,p=L; c&lt;i; c++)</span><br><span class="line">    &#123; </span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;data = e;</span><br><span class="line">    q-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = q;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">【题目】试写一算法，在带头结点单链表删除第i元素到e。</span></span><br><span class="line"><span class="comment">带头结点单链表的类型定义为：</span></span><br><span class="line"><span class="comment">typedef struct LNode &#123;</span></span><br><span class="line"><span class="comment">  ElemType      data;</span></span><br><span class="line"><span class="comment">  struct LNode *next;</span></span><br><span class="line"><span class="comment">&#125; LNode, *LinkList;</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="function">Status <span class="title">Delete_L</span><span class="params">(LinkList L, <span class="keyword">int</span> i, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 在带头结点单链表L删除第i元素到e，并返回OK。*/</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 若参数不合理，则返回ERROR。                */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// p是第i个结点的前一个结点，q是第i个结点</span></span><br><span class="line">    <span class="comment">// 执行删除操作，要确保q结点不是NULL</span></span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    LNode *p=L, *q;        </span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span> || p-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span>(i &lt;= <span class="number">0</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">for</span>(c=<span class="number">1</span>,p=L; c&lt;i; c++) </span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> ERROR; </span><br><span class="line">    &#125;</span><br><span class="line">    q = p-&gt;next; </span><br><span class="line">    e = q-&gt;data;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">【题目】试写一算法，在带头结点单链表的第i元素起的</span></span><br><span class="line"><span class="comment">所有元素从链表移除，并构成一个带头结点的新链表。</span></span><br><span class="line"><span class="comment">带头结点单链表的类型定义为：</span></span><br><span class="line"><span class="comment">typedef struct LNode &#123;</span></span><br><span class="line"><span class="comment">  ElemType      data;</span></span><br><span class="line"><span class="comment">  struct LNode *next;</span></span><br><span class="line"><span class="comment">&#125; LNode, *LinkList;</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="function">Status <span class="title">Split_L</span><span class="params">(LinkList L, LinkList &amp;Li, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 在带头结点单链表L的第i元素起的所有元素 */</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 移除，并构成带头结点链表Li，返回OK。   */</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 若参数不合理，则Li为NULL，返回ERROR。  */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Li = <span class="literal">NULL</span>;   </span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;    </span><br><span class="line">    LNode* p = L;</span><br><span class="line">    LNode *t1, *t2;</span><br><span class="line">    Li = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="comment">// 到最后的时候，t2为L的尾指针，t3为Li的尾指针</span></span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">for</span>(c = <span class="number">0</span>; c &lt; i<span class="number">-1</span>; c++)</span><br><span class="line">        p = p-&gt;next; <span class="comment">// 此时p为i-1个元素</span></span><br><span class="line">    t2 = p;</span><br><span class="line">    p = p-&gt;next; <span class="comment">// 此时p为Li的头指针</span></span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Li = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> ERROR;    </span><br><span class="line">    &#125;</span><br><span class="line">    Li-&gt;next = p;</span><br><span class="line">    t2-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">【题目】试写一算法，在带头结点单链表删除第i元素</span></span><br><span class="line"><span class="comment">起的所有元素。</span></span><br><span class="line"><span class="comment">带头结点单链表的类型定义为：</span></span><br><span class="line"><span class="comment">typedef struct LNode &#123;</span></span><br><span class="line"><span class="comment">  ElemType      data;</span></span><br><span class="line"><span class="comment">  struct LNode *next;</span></span><br><span class="line"><span class="comment">&#125; LNode, *LinkList;</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="function">Status <span class="title">Cut_L</span><span class="params">(LinkList L, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 在带头结点单链表L删除第i元素起的所有元素，并返回OK。*/</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 若参数不合理，则返回ERROR。                         */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt;= <span class="number">0</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    LNode* p = L;</span><br><span class="line">    LNode* t1; <span class="comment">// 用于释放内存</span></span><br><span class="line">    LNode* t2; <span class="comment">// 用于保存第i-1个元素，删除后继节点后，使它的next为NULL</span></span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">for</span>(c = <span class="number">0</span>; c &lt; i<span class="number">-1</span>; c++)</span><br><span class="line">        p = p-&gt;next; <span class="comment">// 此时p为i-1个元素</span></span><br><span class="line">    t2 = p;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        t1 = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(t1);</span><br><span class="line">    &#125;</span><br><span class="line">    t2-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">【题目】试写一算法，删除带头结点单链表中所有值</span></span><br><span class="line"><span class="comment">为x的元素，并释放被删结点空间。</span></span><br><span class="line"><span class="comment">单链表类型定义如下：</span></span><br><span class="line"><span class="comment">typedef struct LNode &#123;</span></span><br><span class="line"><span class="comment">  ElemType      data;</span></span><br><span class="line"><span class="comment">  struct LNode *next;</span></span><br><span class="line"><span class="comment">&#125; LNode, *LinkList;</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="function">Status <span class="title">DeleteX_L</span><span class="params">(LinkList L, ElemType x)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 删除带头结点单链表L中所有值为x的元素，      */</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 并释放被删结点空间，返回实际删除的元素个数。*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*LNode* p = L;</span></span><br><span class="line"><span class="comment">    LNode* temp;</span></span><br><span class="line"><span class="comment">    int count=0;</span></span><br><span class="line"><span class="comment">    while(p-&gt;next != NULL)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        while(p-&gt;next-&gt;data == x)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            temp = p-&gt;next;</span></span><br><span class="line"><span class="comment">            p-&gt;next = p-&gt;next-&gt;next;</span></span><br><span class="line"><span class="comment">            free(temp);</span></span><br><span class="line"><span class="comment">            count++;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        p = p-&gt;next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return count;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    LNode *p1, *p2, *p3;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    p1=p2=L;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==p1) <span class="keyword">return</span> j;</span><br><span class="line">    <span class="keyword">while</span>(p2!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p2=p1-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(p2-&gt;data == x &amp;&amp; p2 != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p3 = p2;</span><br><span class="line">            p2 = p3-&gt;next;</span><br><span class="line">            p1-&gt;next = p2;</span><br><span class="line">            <span class="built_in">free</span>(p3);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p2-&gt;data != x)</span><br><span class="line">        &#123;</span><br><span class="line">            p1 = p2;</span><br><span class="line">            p2 = p1-&gt;next;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">【题目】试写一算法，删除带头结点单链表中所有值</span></span><br><span class="line"><span class="comment">小于x的元素，并释放被删结点空间。</span></span><br><span class="line"><span class="comment">单链表类型定义如下：</span></span><br><span class="line"><span class="comment">typedef struct LNode &#123;</span></span><br><span class="line"><span class="comment">  ElemType      data;</span></span><br><span class="line"><span class="comment">  struct LNode *next;</span></span><br><span class="line"><span class="comment">&#125; LNode, *LinkList;</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="function">Status <span class="title">DeleteSome_L</span><span class="params">(LinkList L, ElemType x)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 删除带头结点单链表L中所有值小于x的元素，    */</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 并释放被删结点空间，返回实际删除的元素个数。*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode* p = L;</span><br><span class="line">    LNode* temp;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 下面的while如果不加p-&gt;next!=NULL就报错</span></span><br><span class="line"><span class="comment">         * 到底为什么会这样我也不清楚，写blog的时候就用下面注释的代码吧 </span></span><br><span class="line"><span class="comment">         * 猜测是p-&gt;next = p-&gt;next-&gt;next; p = p-&gt;next;</span></span><br><span class="line"><span class="comment">         * 当p-&gt;next-&gt;next为NULL的时候，p=p-&gt;next就为NULL了，但此时p-&gt;next不为NULL</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next-&gt;data &lt; x &amp;&amp; p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = p-&gt;next;</span><br><span class="line">            p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    LNode *p1, *p2, *p3;</span></span><br><span class="line"><span class="comment">    int j = 0;</span></span><br><span class="line"><span class="comment">    p1=p2=L;</span></span><br><span class="line"><span class="comment">    if(NULL==p1) return j;</span></span><br><span class="line"><span class="comment">    while(p2!=NULL)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        p2=p1-&gt;next;</span></span><br><span class="line"><span class="comment">        if(p2-&gt;data &lt; x &amp;&amp; p2 != NULL)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            p3 = p2;</span></span><br><span class="line"><span class="comment">            p2 = p3-&gt;next;</span></span><br><span class="line"><span class="comment">            p1-&gt;next = p2;</span></span><br><span class="line"><span class="comment">            free(p3);</span></span><br><span class="line"><span class="comment">            j++;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        else if(p2-&gt;data &gt;= x)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            p1 = p2;</span></span><br><span class="line"><span class="comment">            p2 = p1-&gt;next;</span></span><br><span class="line"><span class="comment">        &#125;        </span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return j;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>双向链表可以访问结点的直接前驱，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">prior</span>, *<span class="title">next</span>;</span></span><br><span class="line">&#125; DuLNode, *DuLinkList;</span><br></pre></td></tr></table></figure>
<p>操作接口如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitList_DuL</span><span class="params">(DuLinkList &amp;L)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">DestroyList_DuL</span><span class="params">(DuLinkList &amp;L)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">ClearList_DuL</span><span class="params">(DuLinkList &amp;L)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">ListEmpty_DuL</span><span class="params">(DuLinkList L)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength_DuL</span><span class="params">(DuLinkList L)</span></span>;</span><br><span class="line"><span class="function">DuLNode* <span class="title">Search_DuL</span><span class="params">(DuLinkList L, ElemType e)</span></span>;</span><br><span class="line"><span class="function">DuLNode* <span class="title">PriorElem_DuL</span><span class="params">(DuLNode *p)</span></span>; <span class="comment">// 返回p结点的直接前驱结点指针</span></span><br><span class="line"><span class="function">DuLNode* <span class="title">NextElem_DuL</span><span class="params">(DuLNode *p)</span></span>;</span><br><span class="line"><span class="function">DuLNode* <span class="title">MakeNode_DuL</span><span class="params">(ElemType e)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">InsertBefore_DuL</span><span class="params">(DuLNode *p, DuLNode *q)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">InsertAfter_DuL</span><span class="params">(DuLNode *p, DuLNode *q)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">Delete_DuL</span><span class="params">(DuLNode *p, ElemType &amp;e)</span></span>;</span><br><span class="line">void ListTraverse_DuL(DuLinkList L, Status (*visit)(ElemType e));</span><br></pre></td></tr></table></figure>
<h4 id="插入前驱结点操作"><a href="#插入前驱结点操作" class="headerlink" title="插入前驱结点操作"></a>插入前驱结点操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InsertBefore_DuL</span><span class="params">(DuLNode *p, DuLNode *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == p || <span class="literal">NULL</span> == q || <span class="literal">NULL</span> == p-&gt;prior)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    q-&gt;prior = p-&gt;prior;</span><br><span class="line">    q-&gt;next = p;</span><br><span class="line">    q-&gt;prior-&gt;next = q;</span><br><span class="line">    p-&gt;prior = q;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除结点操作"><a href="#删除结点操作" class="headerlink" title="删除结点操作"></a>删除结点操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Delete_DuL</span><span class="params">(DuLNode *p, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == p || <span class="literal">NULL</span> == p-&gt;prior) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next != <span class="literal">NULL</span>) p-&gt;next-&gt;prior = p-&gt;prior;</span><br><span class="line">    p-&gt;prior-&gt;next = p-&gt;next;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><h4 id="单循环链表"><a href="#单循环链表" class="headerlink" title="单循环链表"></a>单循环链表</h4><p>单循环链表特点是尾元结点指针域指向头结点，类型和接口定义与单链表相似。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> LinkList CirLinkList;</span><br></pre></td></tr></table></figure>
<h4 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h4><p>双向链表中，若令尾元结点next指针域指向头结点，头结点prior指针域指向尾元结点，就构成双向循环链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> DuLinkList DuCirLinkList;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/09/JavaScript08-DOM扩展/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MakaLoo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MakaL-0-">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/09/JavaScript08-DOM扩展/" itemprop="url">JavaScript08-DOM扩展</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-09T11:08:34+08:00">
                2018-11-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/11/09/JavaScript08-DOM扩展/" class="leancloud_visitors" data-flag-title="JavaScript08-DOM扩展">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JavaScript08-DOM扩展"><a href="#JavaScript08-DOM扩展" class="headerlink" title="JavaScript08-DOM扩展"></a>JavaScript08-DOM扩展</h1><p>对JavaScript的两个主要扩展主要是Selectors API和HTML5</p>
<h2 id="选择符API"><a href="#选择符API" class="headerlink" title="选择符API"></a>选择符API</h2><p>根据CSS选择符选择与某个模式匹配的DOM元素。jQuery的核心就是通过CSS选择符查询DOM文档取得元素的引用，从而抛开了getElementById()和getElementsByTagName()，它有两个核心方法：querySelector()和querySelectorAll()，可以通过Document及Element类型的实例调用它们。</p>
<h3 id="querySelector-方法"><a href="#querySelector-方法" class="headerlink" title="querySelector()方法"></a>querySelector()方法</h3><p>它接收一个CSS选择符，返回与该模式匹配的第一个元素，如果没有就返回null。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得body元素</span></span><br><span class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.querySelector(<span class="string">"body"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得ID为myDiv的元素</span></span><br><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.querySelector(<span class="string">"#myDiv"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得类为"selected"的第一个元素</span></span><br><span class="line"><span class="keyword">var</span> selected = <span class="built_in">document</span>.querySelector(<span class="string">".selected"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得类为"button"的第一个图像元素</span></span><br><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.body.querySelector(<span class="string">"img.button"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="querySelectorAll-方法"><a href="#querySelectorAll-方法" class="headerlink" title="querySelectorAll()方法"></a>querySelectorAll()方法</h3><p>querySelectorAll()方法接收的参数和上面一样，都是一个CSS选择符，但返回的是所有匹配的元素，是一个NodeList实例。</p>
<h2 id="元素遍历"><a href="#元素遍历" class="headerlink" title="元素遍历"></a>元素遍历</h2><p><strong>Chrome Version 70.0.3538.77不支持</strong></p>
<p>Element Travelsal API为DOM元素添加以下5个属性，用于预防元素间空格造成的childNodes和firstChild等属性不一致的差异。</p>
<ul>
<li>childElementCount：返回子元素（不包括文本节点和注释）的个数</li>
<li>firstElementChild：指向第一个元素</li>
<li>lastElementChild：指向最后一个元素</li>
<li>previousElementSibling：指向前一个同辈元素</li>
<li>nextElementSibling：指向后一个同辈元素</li>
</ul>
<h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><h3 id="与类相关的扩充"><a href="#与类相关的扩充" class="headerlink" title="与类相关的扩充"></a>与类相关的扩充</h3><h4 id="getElementsByClassName-方法"><a href="#getElementsByClassName-方法" class="headerlink" title="getElementsByClassName()方法"></a>getElementsByClassName()方法</h4><p>可以通过document对象以及所有HTML元素调用该方法，它接收一个参数，即一个包含一个或多个类名的字符串，返回带有指定类的所有元素的NodeList。</p>
<p>取得所有类中包含”username”和”current”的元素，类先后无所谓<br><code>var allCurrentUsernames = document.getElementByClassName(&quot;username current&quot;);</code></p>
<p>取得ID为myDiv的元素中带有类名”selected”的所有元素<br><code>var selected = document.getElementById(&quot;myDiv&quot;).getElementsByClassName(&quot;selected&quot;);</code></p>
<h4 id="classList属性"><a href="#classList属性" class="headerlink" title="classList属性"></a>classList属性</h4><p>操作类名的时候，可以使用classList属性，classList属性是DOMTokenList的实例，他有一个表示自己包含多少元素的length属性，要取得每个元素，可以使用item()方法，也可以使用方括号。如下：</p>
<p><code>&lt;div class=&quot;bd user disabled&quot;&gt;&lt;/div&gt;</code></p>
<p>classList属性有三个值分别是bd user和disabled。</p>
<p>这个属性还定义了下面方法</p>
<ul>
<li>add(value)：将给定的字符串值添加到列表中。</li>
<li>contains(value)：表示列表中是否存在给定的值，存在返回true。</li>
<li>remove(value)：删除value</li>
<li>toggle(value)：如果列表中存在给定值，就删除它，如果不存在，就添加它。</li>
</ul>
<p>这样，就可以通过上述方法操控className了，如下</p>
<p><code>div.classList.remove(&quot;user&quot;); // 删除user类</code></p>
<h3 id="焦点管理"><a href="#焦点管理" class="headerlink" title="焦点管理"></a>焦点管理</h3><p>HTML5添加了辅助管理DOM焦点的功能。document.activeElement属性始终会引用DOM中当前获得焦点的元素。<br>元素获得焦点方式有页面加载，用户输入和在代码中调用focus()方法</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"myButton"</span>&gt;</span>Click Me!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"focusMethod()"</span>&gt;</span>Click me to focus on the button!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"./aha.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">focusMethod = <span class="function"><span class="keyword">function</span> <span class="title">getFocus</span>(<span class="params"></span>) </span>&#123;          </span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"myButton"</span>).focus();</span><br><span class="line">    alert(<span class="built_in">document</span>.activeElement == <span class="built_in">document</span>.getElementById(<span class="string">"myButton"</span>));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>文档刚刚加载完，<code>document.activeElement</code>中保存的是<code>document.body</code>元素的引用。</p>
<p><code>document.hasFocus()</code>用于确定文档是否获得了焦点。</p>
<h3 id="HTMLDocument的变化"><a href="#HTMLDocument的变化" class="headerlink" title="HTMLDocument的变化"></a>HTMLDocument的变化</h3><p>HTML5扩展了HTMLDocument，增加了新功能。</p>
<h4 id="readyState属性"><a href="#readyState属性" class="headerlink" title="readyState属性"></a>readyState属性</h4><p>Document的readyState属性可能有两个值</p>
<ul>
<li>loading：正在加载文档</li>
<li>complete：已经加载完文档</li>
</ul>
<p>基本用法如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">document</span>.readyState == <span class="string">"complete"</span>) &#123;</span><br><span class="line">	<span class="comment">// 执行操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="head属性"><a href="#head属性" class="headerlink" title="head属性"></a>head属性</h4><p>作为对document.body引用文档&lt;body&gt;元素的补充，HTML5新增了document.head属性，引用文档的&lt;head&gt;元素。</p>
<p><code>var head = document.head || document.getElementsByTagName(&quot;head&quot;)[0];</code></p>
<h3 id="字符集属性"><a href="#字符集属性" class="headerlink" title="字符集属性"></a>字符集属性</h3><p>charset属性表示文档中实际使用的字符集，也可以用来指定新字符集，可以通过&lt;meta&gt;元素，响应头部或直接设置charset属性修改这个值。</p>
<p><code>document.charset = &quot;UTF-8&quot;;</code></p>
<h3 id="自定义数据属性"><a href="#自定义数据属性" class="headerlink" title="自定义数据属性"></a>自定义数据属性</h3><p>HTML5可以为元素添加非标准的属性，但要添加前缀data-，目的是为元素提供与渲染无关的信息，或提供语义信息。<br>可以通过元素dataset属性访问这些自定义属性的值。dataset是一个DOMStringMap的实例，键为非标准属性名减去data-前缀（比如自定义属性是data-myname，映射对应属性就是myname）</p>
<p><code>&lt;div id=&quot;myDiv&quot; data-appid=&quot;12345&quot; data-myname=&quot;Nicholas&quot;&gt;&lt;/div&gt;</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> appId = div.dataset.appid;</span><br><span class="line"><span class="keyword">var</span> myName = div.dataset.myname;</span><br><span class="line"></span><br><span class="line">alert(appId);</span><br></pre></td></tr></table></figure>
<h3 id="插入标记"><a href="#插入标记" class="headerlink" title="插入标记"></a>插入标记</h3><h4 id="innerHTML属性"><a href="#innerHTML属性" class="headerlink" title="innerHTML属性"></a>innerHTML属性</h4><p>在读模式下，innerHTML属性返回与调用元素的所有子节点（包括元素，注释和文本节点）对应的HTML标记。写模式下，innerHTML会根据指定的值创建新的DOM树，然后用这个DOM树完全替换调用元素原先的所有子节点。</p>
<p>写模式下，innerHTML的值会被解析为DOM子树，替换调用元素原来的所有子节点。因为它的值被认为是HTML，所以其中的所有标签都会按照浏览器处理HTML的标准方式转换为元素。<br>设置了innerHTML之后，可以像访问文档中其他节点一样访问新创建的节点。</p>
<p>对下面代码的div块调用innerHTML，会返回其内部子元素（字符串形式）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a <span class="tag">&lt;<span class="name">strong</span>&gt;</span>paragraph<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> with a list following it.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>下面元素不支持innerHTML属性：&lt;col&gt;,&lt;colgroup&gt;,&lt;frameset&gt;,&lt;head&gt;,&lt;html&gt;,&lt;style&gt;,&lt;table&gt;,&lt;tbody&gt;,&lt;thead&gt;,&lt;tfoot&gt;和&lt;tr&gt;</p>
<h4 id="outerHTML属性"><a href="#outerHTML属性" class="headerlink" title="outerHTML属性"></a>outerHTML属性</h4><p>在读模式下，outerHTML返回调用它的元素及所有子节点的HTML标签。写模式下，outerHTML会根据指定的HTML字符串创建新的DOM子树，然后用这个DOM子树完全替换调用元素。</p>
<p>对上面代码div块调用outerHTML，会返回上面相同的代码，包括div本身。</p>
<p><code>div.outerHTML = &quot;&lt;p&gt;This is a paragraph.&lt;/p&gt;&quot;;</code></p>
<p>对上面代码的调用，等价于下面的代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.createElement(<span class="string">"p"</span>);</span><br><span class="line">p.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"This is a paragraph."</span>));</span><br><span class="line">div.parentNode.replaceChild(p, div);</span><br></pre></td></tr></table></figure>
<h4 id="insertAdjacentHTML-方法"><a href="#insertAdjacentHTML-方法" class="headerlink" title="insertAdjacentHTML()方法"></a>insertAdjacentHTML()方法</h4><p>它接收两个参数，插入位置和要插入的HTML文本。第一个参数必须是下列值之一：</p>
<ul>
<li>beforebegin：当前元素之前插入一个紧邻的同辈元素</li>
<li>afterbegin：当前元素之下插入一个新的子元素或在第一个子元素之前再插入新的子元素</li>
<li>beforeend：当前元素之下插入一个新的子元素或再最后一个子元素之后再插入一个新的子元素</li>
<li>afterend：当前元素之后插入一个紧邻的同辈元素</li>
</ul>
<h4 id="内存与性能问题"><a href="#内存与性能问题" class="headerlink" title="内存与性能问题"></a>内存与性能问题</h4><p>使用上面2个属性1个方法之前，最好先手工删除要被替换的元素的所有时间处理程序和JavaScript对象属性。</p>
<p>对上面2个属性，最佳做法是单独构建一个字符串，然后一次性把结果字符串赋值给innerHTML（或outerHTML），这样可以减少访问属性的开支。</p>
<h3 id="scrollIntoView-方法"><a href="#scrollIntoView-方法" class="headerlink" title="scrollIntoView()方法"></a>scrollIntoView()方法</h3><p>可以在所有HTML元素上调用，通过滚动浏览器窗口或某个容器元素，调用元素就可以出现在视口中，传入true作为参数，或者不传入参数，则窗口滚动之后会让调用元素的顶部与视口顶部尽可能平齐。传入false，调用元素会尽可能出现在视口中（可能的话，调用元素底部会与视口底部平齐）</p>
<p>Chrome不支持。。。</p>
<h2 id="专有扩展"><a href="#专有扩展" class="headerlink" title="专有扩展"></a>专有扩展</h2><h3 id="children属性"><a href="#children属性" class="headerlink" title="children属性"></a>children属性</h3><p>这个属性是HTMLCollection的实例，只包含元素中同样还是元素的子节点。children属性与childNodes没什么区别</p>
<h3 id="contains-方法"><a href="#contains-方法" class="headerlink" title="contains()方法"></a>contains()方法</h3><p>调用contains()方法的应该是祖先节点，这个方法接收一个参数，就是要检测的后代节点。如果被检测的节点是后代节点，就返回true。</p>
<h3 id="插入文本"><a href="#插入文本" class="headerlink" title="插入文本"></a>插入文本</h3><h4 id="innerText属性"><a href="#innerText属性" class="headerlink" title="innerText属性"></a>innerText属性</h4><p>通过这个属性可以操作元素中包含的所有文本内容，包括子文档树中的文本。在通过innerText读取值时，它会按照由浅入深顺序将子文档中所有文本拼接起来。在通过innerText写值时，结果会删除元素的所有子节点。插入包含相应文本值的文本节点。</p>
<h4 id="outerText属性"><a href="#outerText属性" class="headerlink" title="outerText属性"></a>outerText属性</h4><p>作用范围扩大到了包含调用它的节点，写操作下会替换整个元素（包括子节点）。</p>
<h3 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h3><ul>
<li>scrollIntoViewIfNeeded(alignCenter)：只在当前元素在视口中不可见的情况下，才滚动浏览器窗口或容器元素，最终让它可见。如果参数为true，尽量让元素显示在视口中部。</li>
<li>scrollByLines(lineCount)：元素内容滚动指定的行高，可以正或负值。</li>
<li>scrollByPages(pageCount)：元素内容滚动指定的页面高度。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="MakaLoo" />
            
              <p class="site-author-name" itemprop="name">MakaLoo</p>
              <p class="site-description motion-element" itemprop="description">Beautifully struggle every day</p>
          </div>

          <nav class="site-state motion-element">
		  
		  

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">50</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/makloao" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://www.zhihu.com/people/makaloo" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-globe"></i>知乎</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:xiehongjian1997@outlook.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-globe"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MakaLoo</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
      <div id="needsharebutton-float">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("oE3JvjxaL9UMPCdKOwyY8BNP-gzGzoHsz", "0mpd8MSRyvkSyuoF6lMMy84W");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">

  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>

  <script>
    
      pbOptions = {};
      
          pbOptions.iconStyle = "box";
      
          pbOptions.boxForm = "horizontal";
      
          pbOptions.position = "bottomCenter";
      
          pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
      flOptions = {};
      
          flOptions.iconStyle = "box";
      
          flOptions.boxForm = "horizontal";
      
          flOptions.position = "middleRight";
      
          flOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-float', flOptions);
    
  </script>

  

  

  

  

</body>
</html>
