<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java继承之子类访问父类的私有域]]></title>
    <url>%2F2018%2F06%2F01%2FJava%E7%BB%A7%E6%89%BF%E4%B9%8B%E5%AD%90%E7%B1%BB%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[在类的继承中,子类可以访问父类的公有方法和域,但对于父类的私有成员则不能访问,但很多情况下,子类也应当拥有父类的私有属性,例如一个雇员Employee有名字,薪资,雇佣时间等属性,经理Manager也属于雇员,那么经理也应当有名字,薪资,雇佣时间等,那么问题就来了,子类如何才能使用父类的私有成员?请看下面代码123456789101112131415161718public class Father &#123; private int a; // 默认构造方法,如果没有此方法,子类构造器第一句必须调用super() public Father() &#123; &#125; public Father(int a) &#123; this.a = a; &#125; public int getA() &#123; return a; &#125; public void setA(int a) &#123; this.a = a; &#125;&#125; 1234567891011121314151617public class Son extends Father&#123; public Son() &#123; // 如果子类没有显式调用super(),则自动调用父类默认(没有参数)的构造器,如果父类没有默认构造器,则报错 &#125; public Son(int a) &#123; super(a); // super()必须是子类构造器的第一句 &#125; public static void main(String[] args) &#123; Son son1 = new Son(); son1.setA(123); // 第一种给父类成员赋值的方法,调用setter() Son son2 = new Son(234); // 第二种给父类成员赋值的方法,构造器初始化 System.out.println(son.getA()); // 调用getter()获取父类成员 &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[algs之背包,队列和栈]]></title>
    <url>%2F2018%2F06%2F01%2Falgs%E4%B9%8B%E8%83%8C%E5%8C%85-%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88%2F</url>
    <content type="text"><![CDATA[背包(Bag)背包是一种不支持从中删除元素的集合数据类型—-它的目的就是帮助用例收集元素并迭代遍历所有收集到的元素(用例也可以检查背包是否为空或者获取背包中元素的数量) Bag 注释 public class Bag&lt;Item&gt; implements Iterable&lt;Item&gt; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bag() 创建一个空背包 boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isEmpty() 背包是否为空 int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size() 背包中的元素数量 具体实现(链表实现):代码均来自algs4配套代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116/** * The &#123;@code Bag&#125; class represents a bag (or multiset) of * generic items. It supports insertion and iterating over the * items in arbitrary order. * &lt;p&gt; * This implementation uses a singly linked list with a static nested class Node. * See &#123;@link LinkedBag&#125; for the version from the * textbook that uses a non-static nested class. * See &#123;@link ResizingArrayBag&#125; for a version that uses a resizing array. * The &lt;em&gt;add&lt;/em&gt;, &lt;em&gt;isEmpty&lt;/em&gt;, and &lt;em&gt;size&lt;/em&gt; operations * take constant time. Iteration takes time proportional to the number of items. * &lt;p&gt; * For additional documentation, see &lt;a href="https://algs4.cs.princeton.edu/13stacks"&gt;Section 1.3&lt;/a&gt; of * &lt;i&gt;Algorithms, 4th Edition&lt;/i&gt; by Robert Sedgewick and Kevin Wayne. * * @author Robert Sedgewick * @author Kevin Wayne * * @param &lt;Item&gt; the generic type of an item in this bag */public class Bag&lt;Item&gt; implements Iterable&lt;Item&gt; &#123; private Node&lt;Item&gt; first; // beginning of bag private int n; // number of elements in bag // helper linked list class private static class Node&lt;Item&gt; &#123; private Item item; private Node&lt;Item&gt; next; &#125; /** * Initializes an empty bag. */ public Bag() &#123; first = null; n = 0; &#125; /** * Returns true if this bag is empty. * * @return &#123;@code true&#125; if this bag is empty; * &#123;@code false&#125; otherwise */ public boolean isEmpty() &#123; return first == null; &#125; /** * Returns the number of items in this bag. * * @return the number of items in this bag */ public int size() &#123; return n; &#125; /** * Adds the item to this bag. * * @param item the item to add to this bag */ public void add(Item item) &#123; Node&lt;Item&gt; oldfirst = first; first = new Node&lt;Item&gt;(); first.item = item; first.next = oldfirst; n++; &#125; /** * Returns an iterator that iterates over the items in this bag in arbitrary order. * * @return an iterator that iterates over the items in this bag in arbitrary order */ public Iterator&lt;Item&gt; iterator() &#123; return new ListIterator&lt;Item&gt;(first); &#125; // an iterator, doesn't implement remove() since it's optional private class ListIterator&lt;Item&gt; implements Iterator&lt;Item&gt; &#123; private Node&lt;Item&gt; current; public ListIterator(Node&lt;Item&gt; first) &#123; current = first; &#125; public boolean hasNext() &#123; return current != null; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; public Item next() &#123; if (!hasNext()) throw new NoSuchElementException(); Item item = current.item; current = current.next; return item; &#125; &#125; /** * Unit tests the &#123;@code Bag&#125; data type. * * @param args the command-line arguments */ public static void main(String[] args) &#123; Bag&lt;String&gt; bag = new Bag&lt;String&gt;(); while (!StdIn.isEmpty()) &#123; String item = StdIn.readString(); bag.add(item); &#125; StdOut.println("size of bag = " + bag.size()); for (String s : bag) &#123; StdOut.println(s); &#125; &#125;&#125; 队列(Queue)先进先出队列是一种基于FIFO策略的集合类型,元素处理的顺序就是它们被添加到队列中的顺序,应用程序中使用队列的主要原因是在用集合保存元素的同时保存他们的相对顺序 Queue(FIFO) 注释 public class Queue&lt;Item&gt; implements Iterable&lt;Item&gt; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Queue() 创建一个空队列 void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enqueue(Item item) 添加一个元素 Item&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dequeue() 删除一个元素 boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isEmpty() 队列是否为空 int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size() 队列中的元素数量 具体实现(链表实现):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162/** * The &#123;@code Queue&#125; class represents a first-in-first-out (FIFO) * queue of generic items. * It supports the usual &lt;em&gt;enqueue&lt;/em&gt; and &lt;em&gt;dequeue&lt;/em&gt; * operations, along with methods for peeking at the first item, * testing if the queue is empty, and iterating through * the items in FIFO order. * &lt;p&gt; * This implementation uses a singly linked list with a static nested class for * linked-list nodes. See &#123;@link LinkedQueue&#125; for the version from the * textbook that uses a non-static nested class. * See &#123;@link ResizingArrayQueue&#125; for a version that uses a resizing array. * The &lt;em&gt;enqueue&lt;/em&gt;, &lt;em&gt;dequeue&lt;/em&gt;, &lt;em&gt;peek&lt;/em&gt;, &lt;em&gt;size&lt;/em&gt;, and &lt;em&gt;is-empty&lt;/em&gt; * operations all take constant time in the worst case. * &lt;p&gt; * For additional documentation, see &lt;a href="https://algs4.cs.princeton.edu/13stacks"&gt;Section 1.3&lt;/a&gt; of * &lt;i&gt;Algorithms, 4th Edition&lt;/i&gt; by Robert Sedgewick and Kevin Wayne. * * @author Robert Sedgewick * @author Kevin Wayne * * @param &lt;Item&gt; the generic type of an item in this queue */public class Queue&lt;Item&gt; implements Iterable&lt;Item&gt; &#123; private Node&lt;Item&gt; first; // beginning of queue private Node&lt;Item&gt; last; // end of queue private int n; // number of elements on queue // helper linked list class private static class Node&lt;Item&gt; &#123; private Item item; private Node&lt;Item&gt; next; &#125; /** * Initializes an empty queue. */ public Queue() &#123; first = null; last = null; n = 0; &#125; /** * Returns true if this queue is empty. * * @return &#123;@code true&#125; if this queue is empty; &#123;@code false&#125; otherwise */ public boolean isEmpty() &#123; return first == null; &#125; /** * Returns the number of items in this queue. * * @return the number of items in this queue */ public int size() &#123; return n; &#125; /** * Returns the item least recently added to this queue. * * @return the item least recently added to this queue * @throws NoSuchElementException if this queue is empty */ public Item peek() &#123; if (isEmpty()) throw new NoSuchElementException("Queue underflow"); return first.item; &#125; /** * Adds the item to this queue. * * @param item the item to add */ public void enqueue(Item item) &#123; Node&lt;Item&gt; oldlast = last; last = new Node&lt;Item&gt;(); last.item = item; last.next = null; if (isEmpty()) first = last; else oldlast.next = last; n++; &#125; /** * Removes and returns the item on this queue that was least recently added. * * @return the item on this queue that was least recently added * @throws NoSuchElementException if this queue is empty */ public Item dequeue() &#123; if (isEmpty()) throw new NoSuchElementException("Queue underflow"); Item item = first.item; first = first.next; n--; if (isEmpty()) last = null; // to avoid loitering return item; &#125; /** * Returns a string representation of this queue. * * @return the sequence of items in FIFO order, separated by spaces */ public String toString() &#123; StringBuilder s = new StringBuilder(); for (Item item : this) &#123; s.append(item); s.append(' '); &#125; return s.toString(); &#125; /** * Returns an iterator that iterates over the items in this queue in FIFO order. * * @return an iterator that iterates over the items in this queue in FIFO order */ public Iterator&lt;Item&gt; iterator() &#123; return new ListIterator&lt;Item&gt;(first); &#125; // an iterator, doesn't implement remove() since it's optional private class ListIterator&lt;Item&gt; implements Iterator&lt;Item&gt; &#123; private Node&lt;Item&gt; current; public ListIterator(Node&lt;Item&gt; first) &#123; current = first; &#125; public boolean hasNext() &#123; return current != null; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; public Item next() &#123; if (!hasNext()) throw new NoSuchElementException(); Item item = current.item; current = current.next; return item; &#125; &#125; /** * Unit tests the &#123;@code Queue&#125; data type. * * @param args the command-line arguments */ public static void main(String[] args) &#123; Queue&lt;String&gt; queue = new Queue&lt;String&gt;(); while (!StdIn.isEmpty()) &#123; String item = StdIn.readString(); if (!item.equals("-")) queue.enqueue(item); else if (!queue.isEmpty()) StdOut.print(queue.dequeue() + " "); &#125; StdOut.println("(" + queue.size() + " left on queue)"); &#125;&#125; 栈(Stack)下压栈是一种基于LIFO策略的集合类型,元素的处理顺序和它们被压入的顺序正好相反,应用程序中使用栈的主要原因是用集合保存元素的同时颠倒它们的相对顺序 Stack(LIFO) 注释 public class Stack&lt;Item&gt; implements Iterable&lt;Item&gt; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stack() 创建一个空栈 void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push(Item item) 添加一个元素 Item&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop() 删除一个元素 boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isEmpty() 栈是否为空 int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size() 栈中的元素数量 具体实现(链表实现):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163/** * The &#123;@code Stack&#125; class represents a last-in-first-out (LIFO) stack of generic items. * It supports the usual &lt;em&gt;push&lt;/em&gt; and &lt;em&gt;pop&lt;/em&gt; operations, along with methods * for peeking at the top item, testing if the stack is empty, and iterating through * the items in LIFO order. * &lt;p&gt; * This implementation uses a singly linked list with a static nested class for * linked-list nodes. See &#123;@link LinkedStack&#125; for the version from the * textbook that uses a non-static nested class. * See &#123;@link ResizingArrayStack&#125; for a version that uses a resizing array. * The &lt;em&gt;push&lt;/em&gt;, &lt;em&gt;pop&lt;/em&gt;, &lt;em&gt;peek&lt;/em&gt;, &lt;em&gt;size&lt;/em&gt;, and &lt;em&gt;is-empty&lt;/em&gt; * operations all take constant time in the worst case. * &lt;p&gt; * For additional documentation, * see &lt;a href="https://algs4.cs.princeton.edu/13stacks"&gt;Section 1.3&lt;/a&gt; of * &lt;i&gt;Algorithms, 4th Edition&lt;/i&gt; by Robert Sedgewick and Kevin Wayne. * * @author Robert Sedgewick * @author Kevin Wayne * * @param &lt;Item&gt; the generic type of an item in this stack */public class Stack&lt;Item&gt; implements Iterable&lt;Item&gt; &#123; private Node&lt;Item&gt; first; // top of stack private int n; // size of the stack // helper linked list class private static class Node&lt;Item&gt; &#123; private Item item; private Node&lt;Item&gt; next; &#125; /** * Initializes an empty stack. */ public Stack() &#123; first = null; n = 0; &#125; /** * Returns true if this stack is empty. * * @return true if this stack is empty; false otherwise */ public boolean isEmpty() &#123; return first == null; &#125; /** * Returns the number of items in this stack. * * @return the number of items in this stack */ public int size() &#123; return n; &#125; /** * Adds the item to this stack. * * @param item the item to add */ public void push(Item item) &#123; Node&lt;Item&gt; oldfirst = first; first = new Node&lt;Item&gt;(); first.item = item; first.next = oldfirst; n++; &#125; /** * Removes and returns the item most recently added to this stack. * * @return the item most recently added * @throws NoSuchElementException if this stack is empty */ public Item pop() &#123; if (isEmpty()) throw new NoSuchElementException("Stack underflow"); Item item = first.item; // save item to return first = first.next; // delete first node n--; return item; // return the saved item &#125; /** * Returns (but does not remove) the item most recently added to this stack. * * @return the item most recently added to this stack * @throws NoSuchElementException if this stack is empty */ public Item peek() &#123; if (isEmpty()) throw new NoSuchElementException("Stack underflow"); return first.item; &#125; /** * Returns a string representation of this stack. * * @return the sequence of items in this stack in LIFO order, separated by spaces */ public String toString() &#123; StringBuilder s = new StringBuilder(); for (Item item : this) &#123; s.append(item); s.append(' '); &#125; return s.toString(); &#125; /** * Returns an iterator to this stack that iterates through the items in LIFO order. * * @return an iterator to this stack that iterates through the items in LIFO order */ public Iterator&lt;Item&gt; iterator() &#123; return new ListIterator&lt;Item&gt;(first); &#125; // an iterator, doesn't implement remove() since it's optional private class ListIterator&lt;Item&gt; implements Iterator&lt;Item&gt; &#123; private Node&lt;Item&gt; current; public ListIterator(Node&lt;Item&gt; first) &#123; current = first; &#125; public boolean hasNext() &#123; return current != null; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; public Item next() &#123; if (!hasNext()) throw new NoSuchElementException(); Item item = current.item; current = current.next; return item; &#125; &#125; /** * Unit tests the &#123;@code Stack&#125; data type. * * @param args the command-line arguments */ public static void main(String[] args) &#123; Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); while (!StdIn.isEmpty()) &#123; String item = StdIn.readString(); if (!item.equals("-")) stack.push(item); else if (!stack.isEmpty()) StdOut.print(stack.pop() + " "); &#125; StdOut.println("(" + stack.size() + " left on stack)"); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Bag</tag>
        <tag>Queue</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让类实现for-each loop:Iterable与Iterator接口]]></title>
    <url>%2F2018%2F06%2F01%2FIterable%E4%B8%8EIterator%2F</url>
    <content type="text"><![CDATA[Interface Iterable&lt;T&gt;根据Java API上写: Implementing this interface allows an object to be the target of the “for-each loop” statement. 也就是说,实现该接口可以让类实现for循环阅读Iterable源码,该接口有3个方法 Modifier,Type and Method Description public interface Iterable&lt;T&gt; &nbsp; default void forEach(Consumer action) Performs the given action for each element of the Iterable until all elements have been processed or the action throws an exception. Iterator iterator() Returns an iterator over elements of type T. default Spliterator spliterator() Creates a Spliterator over the elements described by this Iterable. 可以知道,实现该接口,我们只需要实现Iterator iterator()由API: Iterator iterator()Returns an iterator over elements of type T.Returns:an Iterator. 我们只需要返回一个Iterator对象就可以了 Interface IteratorJava API中说到: An iterator over a collection. Iterator takes the place of Enumeration in the Java Collections Framework. Iterators differ from enumerations in two ways:Iterators allow the caller to remove elements from the underlying collection during the iteration with well-defined semantics.Method names have been improved. 其实就是一个迭代器啦… Modifier,Type and Method Description public interface Iterator&lt;E&gt; &nbsp; default void forEachRemaining(Consumer action) Performs the given action for each remaining element until all elements have been processed or the action throws an exception. boolean hasNext() Returns true if the iteration has more elements. E next() Returns the next element in the iteration. default void remove() Removes from the underlying collection the last element returned by this iterator (optional operation). 可以知道,实现该接口,只要实现next()与hasNext(),当有remove()需求时,也要实现该方法. 下面是具体实现1.类名中加上implements Iterable1public class ClassName&lt;E&gt; implements Iterable&lt;E&gt; 2.实现Iterator iterator(),返回Iterator对象1public Iterator&lt;E&gt; iterator() &#123; return new MyIterator&lt;E&gt;(); &#125; 3.实现内部类MyIterator1234567891011121314private class MyIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123; public boolean hasNext() &#123; //return true if the iteration has more elements &#125; public E next() &#123; if (!hasNext()) throw NoSuchElementException(); // returns the next element in the iteration &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Iterable</tag>
        <tag>Iterator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaDoc与Jar]]></title>
    <url>%2F2018%2F06%2F01%2FJavaDoc%E4%B8%8EJar%2F</url>
    <content type="text"><![CDATA[使用JavaDoc生成文档1javadoc -d 目录名 -encoding UTF-8 -charset UTF-8 xxx.java java内格式： /** 文档内容 / @author : 对类的说明，表明开发该类模块的作者 @version : 对类的说明，表明该模块版本 @see : 对类，属性，方法的说明，参考转向，也就是相关主题 @param : 对方法的说明，对方法中某参数的说明 @return : 对方法的说明，对方法返回值的说明 @exception : 对方法的说明，对方法可能抛出的异常进行说明 下为《算法》中StdRandom.java源码的注释与文档效果 使用jar打包（1）编译 javac A.java （2）打包 jar cvfm A.jar A.man A.class ——c表示创建(create)，v表示显示详情(verbose)，f表示指定文件名，m表示清单文件（3）运行 java -jar A.jar 其中A.man是清单文件（manifest），内容如下：·Manifest-Version：1.0Class-Path：.Main-Class：A]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaDoc</tag>
        <tag>Jar</tag>
      </tags>
  </entry>
</search>
