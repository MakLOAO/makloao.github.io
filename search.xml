<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring Boot 02-日志]]></title>
    <url>%2F2019%2F10%2F05%2FSpringBoot02%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[Spring Boot日志常见的日志抽象层有：JCL，SLF4j，jboss-logging日志实现有：Log4j，JUL，Log4j2，Logback SpringBoot底层Spring框架使用的是JCL，SpringBoot选用SLF4j和logback SLF4j使用日志记录方法的调用，要调用日志抽象层的方法 slf4j的官方文档 首先要给系统导入slf4j的jar包和logback的jar包 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info("Hello World"); &#125;&#125; 抽象层和具体实现之间需要导入的jar包及其关系如下（图来自官方文档）： 遗留问题可能应用里使用的不同框架底层都有自己的日志系统，比如Spring使用的是commons-logging，Hibernate使用的是jboss-logging，需要统一日志记录，让它们一起使用slf4j进行输出（图来自官方文档） 在系统中所有日志统一到slf4j 将系统其它日志框架先排除出去 用中间包替换原有日志框架 导入slf4j其他的实现 Spring Boot日志关系 Spring Boot已经帮我们适配所有日志，底层使用slf4j+logback的方式记录日志，如果我们要引入其他框架，只需要把这个框架的默认日志依赖移除掉即可 日志的使用123456Logger logger = LoggerFactory.getLogger(getClass());logger.trace(&quot;trace&quot;);logger.debug(&quot;debug&quot;);logger.info(&quot;info&quot;);logger.warn(&quot;warn&quot;);logger.error(&quot;error&quot;); 日志的级别是trace&lt;debug&lt;info&lt;warn&lt;error默认Spring Boot的日志级别是info，即默认只输出info及以上级别的日志信息可以在配置文件中加入logging.level.com.mkl.springbootdemo=trace这样就可以在 com.mkl.springbootdemo 这个包下输出trace级别的日志信息 还可以在配置文件中指定logging.file= ：如果不指定路径，日志输出到当前目录下指定的文件名（可以指定完整的路径）logging.path= ：日志输出到当前磁盘根目录下指定的文件目录的spring.log文件中，如果指定了logging.file，则它不生效 指定输出日志的格式 1234567891011logging.pattern.console=logging.pattern.file=如： %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n%d表示日期时间%thread表示线程名%-5level表示级别从左显示5个字符宽度%logger&#123;50&#125;表示logger名字最长50个字符%msg表示日志消息%n换行符 指定配置官方文档 在类路径下配置logback.xml即可（或logback-spring.xml） 如果使用logback.xml，则直接被日志框架识别如果使用logback-spring.xml，则日志框架不直接加载日志的配置项，由SpringBoot加载，它可以使用SpringBoot的一个高级特性 123456789101112&lt;springProfile name="staging"&gt; &lt;!-- configuration to be enabled when the "staging" profile is active --&gt; 可以指定某段配置在某个环境生效&lt;/springProfile&gt;&lt;springProfile name="dev | staging"&gt; &lt;!-- configuration to be enabled when the "dev" or "staging" profiles are active --&gt;&lt;/springProfile&gt;&lt;springProfile name="!production"&gt; &lt;!-- configuration to be enabled when the "production" profile is not active --&gt;&lt;/springProfile&gt; 切换日志框架按官网的日志适配图来切换]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 01-入门与配置]]></title>
    <url>%2F2019%2F10%2F04%2FSpringBoot01%E5%85%A5%E9%97%A8%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Spring Boot入门与配置简介Spring Boot是简化Spring应用开发的一个框架是整个Spring技术栈的一个大集合是J2EE开发的一站式解决方案 优点 快速创建独立运行的Spring项目以及与主流框架集成 使用嵌入式的Servlet容器，应用无需打成WAR包 starters自动依赖与版本控制 大量的自动配置，简化开发，也可修改默认值 无需配置XML，无代码生成，开箱即用 准生产环境的运行时应用监控 与云计算的天然集成 微服务一个应用应该是一组小型服务的组合，每个服务通过HTTP的方式进行互通，微服务架构里，每个功能元素放在一个独立的服务中，通过服务器分发这些服务进行动态扩展（在传统的单体应用中，是多个服务器复制这个单体进行扩展） Hello World从Spring Initializr创建一个Spring Boot应用，使用IDEA打开（打开pom） 然后导入 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 编写Controller 12345@ResponseBody@RequestMapping("/hello")public String hello() &#123; return "Hello World";&#125; 直接运行即可，甚至不需要配置TOMCAT和MVC 相关依赖我们在导入Spring Boot的依赖的时候，是不需要指定版本了，因为它的父依赖会帮我们指定 打包成jar包的话，pom里有一个配置是专门干这个的 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 然后在maven构建处点击package即可，打包后 java -jar xxx命令执行，也可以成功访问 POM里有一些 spring-boot-starter-xxx 的依赖，它们是Spring Boot抽取出来的对应功能场景的启动器，如上面我们使用的 spring-boot-starter-web ，就是Spring MVC相关的启动器 官方文档可以搜： starters，它可以帮助我们快速找到我们需要的starter @SpringBootApplication这个注解由许多子注解组合而成 其中一个是 @SpringBootConfiguration，这个注解里就有Spring使用的 Configuration ，用于配置 @EnableAutoConfiguration，开启自动配置功能 里面有一个 @AutoConfigurationPackage， 再往里看，有 @Import({Registrar.class})，这个类有一个方法如下： 1234public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123; AutoConfigurationPackages.register(registry, (new AutoConfigurationPackages.PackageImport(metadata)).getPackageName());// 把当前注解（主配置类，@SpringBootApplication标注的类）所在包及其子包所有组件扫描到Spring容器&#125; @EnableAutoConfiguration 内还有一个注解 @Import({AutoConfigurationImportSelector.class}) ，它负责给容器导入很多自动配置类（xxxAutoConfiguration），免去我们手动编写注入功能组件等工作 @RestController其实就是 @ResponseBody 和 Controller 的合体 配置文件SpringBoot使用一个全局的配置文件，配置文件是固定的，只能是下面2个之1： application.properties application.yml 配置文件的作用：修改Spring Boot自动配置的默认值 YAML语法.yml文件有自己的语法 k: v：表示一对键值对（v之前有空格） 以空格的缩进来控制层级关系，只要是左对齐的一列数据，都是同一个层级的 区分大小写 123server: port: 8081 path: /hello 基本类型： 字面量: 普通的值 k: v：字面直接写，默认不需要单引号或双引号 双引号用于转义正常输出 zs \n ls 会输出 zs 换行 ls 单引号防转义 zs \n ls 会输出 zs \n ls 对象，Map k: v，在下一行写对象的属性和值的关系，注意缩进 123friends: lastName: zhangsan age: 20 行内写法： 1friends: &#123;lastName: zhangsan,age: 20&#125; 数组（List，Set） 1234pets: - cat - dog - pig 行内写法 1pets: [cat,dog,pig] 为bean的属性配置值使用yml为属性配置值对于一个bean，可以为其配置注解 @ConfigurationProperties(prefix = &quot;在yml配置文件中的前缀&quot;)，告诉Spring Boot这个bean所有的属性都是 application.yml 配置的属性 e.g. 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 12345678910@Component@ConfigurationProperties(prefix = "person")public class Person &#123; String lname; int age; boolean b;// getter setter 略&#125; 1234person: lname: zhangsan age: 21 b: true 使用@Value为属性配置值1234567891011121314151617@Componentpublic class Person &#123; @Value("$&#123;person.lastName&#125;") String lastName; @Value("#&#123;11*2&#125;") int age; @Value("true") boolean b;// getter setter 略&#125;// 支持SpEL// `Value("$&#123;xxx&#125;")` 从配置文件中获取值// `Value("#&#123;xxx&#125;")` 计算xxx里面的表达式得出值 两个配置的区别 。 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定属性 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持（校验会失效） 复杂类型封装（如Map，List） 支持 不支持（用SpEL从配置文件获取会报错） @PropertySource在从配置文件中获取属性的时候，可以指定其他的配置文件，如新建一个person.yml，只需要为对应的bean配置 @PropertySource({&quot;classpath:person.yml&quot;}) 即可，注意value是一个数组，可以传入多个配置文件 1234567891011@Component@PropertySource(&#123;"classpath:person.yml"&#125;)@ConfigurationPropertiespublic class Person &#123; String lastName; int age; boolean b;//getter setter&#125; @ImportResource@ImportResource(locations = {&quot;xxx&quot;}) 可以让我们自己写的 spring-xxx.xml 的Spring配置文件生效 12345678@ImportResource(locations = &#123;"classpath:xxx.xml"&#125;)@SpringBootApplicationpublic class SpringbootdemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootdemoApplication.class, args); &#125;&#125; @Bean装载beanSpring推荐使用注解的方法来配置bean，而不是XML @Bean注解只能用于方法，它把方法的返回值添加到容器中，容器中这个组件默认的ID就是方法名 1234567@Configurationpublic class MyAppConfig &#123; @Bean public HelloService helloService() &#123; return new HelloService(); &#125;&#125; 注意此时HelloService不能被 @Component 及其3个子注解注解 @Bean与@Component的区别它们都是用于把bean注册到Spring容器中 @Component(@Controller,@Service,@Repository)通常通过路径扫描来自动侦测以及自动装配到Spring容器（在Spring Boot中，自动侦测通过@EnableAutoConfiguration默认配置，范围是主类的包及子包） @Bean通常在标有该注解的方法中定义产生这个bean的逻辑 yml(properties)配置文件的占位符 ${random.xxx}：可以设置随机的值 可以使用内部的其他值 1234567person.id = $&#123;random.int&#125;person.name = $&#123;person.id:123&#125;zhangsan;// 如果没有person.id，就使用123作为默认值随机数如下：$&#123;random.value&#125;,$&#123;random.int&#125;,$&#123;random.long&#125;$&#123;random.int(10)&#125;,$&#123;random.[123,456]&#125; ProfileProfile是Spring对不同环境提供不同配置功能的支持 如果使用的是properties在主配置文件编写的时候，文件名可以是 application-{profile}.properties。（比如生产环境是application-prod.properties，开发环境是application-dev.properties）默认使用的是application.properties的配置，如果要使用其他的环境，只需要在默认的环境加上： spring.profiles.active=dev（dev可以换成prod）即可 如果使用yml文档快可以使用文档块，然后在最上面的默认块使用 spring:profiles:actice 指定环境即可 12345678910111213141516171819server: port: 8081spring: profiles: active: dev---server: port: 80spring: profiles: dev---server: port: 8084spring: profiles: prod 也可以在命令行输入 java -jar xxx.jar --spring.prifile.actice=dev 来指定 配置文件的加载位置Spring Boot启动会扫描以下位置的application.properties或者application.yml文件作为默认配置文件，从下面的路径加载 file:./config/ （当前项目的根的config目录） file:./ （当前项目的根目录） classpath:/config/ classpath:/ 它们的优先级从高到低，高优先级的配置会覆盖低优先级的配置如果4个配置文件都存在，则它们是按优先级互补配置（比如高优先级的文件没有某个配置，则从低优先级的文件获取） Conditional所有ConditionnalXxx注解都是基于@Conditional的，比如 ConditionalOnClass ，它有一个 @Conditional({OnClassCondition.class}) 的注解，Conditional的扩展如下 @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean @ConditionalOnOnMissingBean 容器中不存在指定Bean @ConditionalOnOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResourve 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是Web环境 @ConditionalOnNotWebApplication 当前不是Web环境 @ConditionalOnJndi JNDI存在指定项 可以通过在配置文件中 debug=true 来让控制台打印自动配置报告，可以让我们知道哪些自动配置类生效 自动配置原理 Spring Boot启动的时候加载主配置类，开启自动配置功能 @EnableAutoConfiguration @EnableAutoConfiguration作用： Import注解引入AutoConfigurationImportSelector给容器导入一些组件，它调用selectImports方法获取 selectImports方法实质上调用的是 List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes); 它扫描所有jar包类路径下的 META-INF/spring.factories 这个文件 把扫描到的这些文件的内容包装成 Porperties 对象 （可能未完成或者不够充分，等以后再补） 综上，@EnableAutoConfiguration 的作用是将类路径下META-INF/spring.factories里配置的所有EnableAutoConfiguration的值加入到容器中（在org.springframework.boot:spring-boot-autoconfigure包），每一个xxxAutoConfiguration类都是容器的一个组件，都加入到容器中，用它们来做自动配置 每个自动配置类进行自动配置功能 以HttpEncodingAutoConfiguraion为例解释自动配置的流程 123456789101112@Configuration // 表示这是一个配置类@EnableConfigurationProperties(&#123;HttpProperties.class&#125;) // 启动指定类的ConfigurationProperties功能；将HttpProperties的值和配置文件中对应的值绑定起来@ConditionalOnWebApplication( type = Type.SERVLET) // 如果是Web应用，这个配置文件才生效，否则不生效@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;) // 判断当前项目有没有CharacterEncodingFilter这个类，有则生效@ConditionalOnProperty( prefix = "spring.http.encoding", value = &#123;"enabled"&#125;, matchIfMissing = true) // 判断配置文件是否存在spring.http.encoding这个配置，但是即使不存在，它也成立public class HttpEncodingAutoConfiguration &#123; 根据当前不同条件，判断自动配置类是否生效 它有一个注解 @EnableConfigurationProperties({HttpProperties.class}) ，作用是启动指定类的ConfigurationProperties功能，（告诉Spring Boot这个bean所有的属性都是 HttpProperties.class 配置） 这个HttpProperties有一个注解 @ConfigurationProperties(prefix = &quot;spring.http&quot;)，它的作用是从配置文件中获取 spring.http 前缀的值，然后封装到自己内部对应的属性上，然后交还给自动配置类去使用。 所有在配置文件中能配置的属性都是在xxxProperties类中封装，配置文件能配置什么就可以参照某个功能对应的这个属性类 自动配置类就去配置对应功能相关的Bean 综上所述： SpringBoot启动时会加载大量的自动配置类我们需要哪些功能，如果SpringBoot默认写好自动配置类，就不需要我们再去写需要配置某些属性的时候，可以在配置文件中配置，对应自动配置类会通过xxxProperties从中获取]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java IO]]></title>
    <url>%2F2019%2F09%2F26%2FJavaIO%2F</url>
    <content type="text"><![CDATA[Java IO https://zhuanlan.zhihu.com/p/28286559 框架要记住Java IO包是通过装饰者模式来实现IO的 对类结构进行分类，IO可以分为： 字节流和字符流： 字节流：以字节为单位，每次读入或读出都是8位数据，可以读任何类型的数据 字符流：以字符为单位，每次读入或读出都是16位数据，只能读取Unicode字符型数据 输出流和输入流： 输出流：从内存读出到文件，只能进行写操作 输入流：从文件读入到内存，只能进行读操作 节点流和处理流： 节点流：直接与数据源相连，读入或读出 处理流：与节点流一块使用，在节点流的基础上，再套接一层，套接在节点流上的就是处理流 图如下： 其他说明： 节点流中的字节/字符数组流，是在内存中开辟一个字节或字符数组 处理流有如下几种类型 缓冲流：Buffered开头的，缓冲区作用是减少硬盘IO次数 转换流：InputStreamReader和OutputStreamWriter，把字节转换为字符 基本类型数据流：DataInputStream和DataOutputStream，它提供readXxx()方法， 打印流：PrintStream和PrintWriter，一般是打印到控制台，可以进行控制打印的地方 对象流：ObjectInput(Output)Stream，对象序列化和反序列化的流 合并流：SequenceInputStream：可以认为是一个工具类，将两个或多个输入流当成一个输入流依次读取 File对象创建一个File对象如下： 123String fileName = "D:" + File.separator + "my.txt";File file = new File(fileName);// 然后把该File传递给对应的节点流 基本类型数据流12345678910String fileName= "c:" + File.separator + "Users" + File.separator + "MakaLoo" + File.separator + "Desktop" + File.separator + "hello.txt";File file = new File(fileName);OutputStream out = new DataOutputStream(new FileOutputStream(file));((DataOutputStream) out).writeDouble(123.456);out.close();DataInputStream in = new DataInputStream(new FileInputStream(file));double d = in.readDouble();System.out.println(d);in.close(); 字符流与字节流的转换InputStreamReader：输入的字节流转换为字符流 12345678String fileName = "d:" + File.separator + "hello.txt";File file = new File(fileName);// 不使用Buffered装饰也可以// Writer out = new OutputStreamWriter(new BufferedOutputStream(new FileOutputStream(file)));Writer out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file)));// 传入输出字节流对象，写的时候是写字符，它会转换out.write("hello");out.close(); OutputStreamWriter：输出的字节流转换为字符流 12345678String fileName = "d:" + File.separator + "hello.txt";File file = new File(fileName);// Reader in = new BufferedReader(new InputStreamReader(new FileInputStream(file)));Reader in = new InputStreamReader(new BufferedInputStream(new FileInputStream(file)));char[] c = new char[100];int length = in.read(c);System.out.println(String.valueOf(c, 0, length));in.close();]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HeadFirst设计模式-观察者模式]]></title>
    <url>%2F2019%2F09%2F05%2FHeadFirst%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[HeadFirst设计模式-观察者模式案例分析现在有一个项目，是要负责开发一个气象台实时显示的内容，如下： 气象站会提供给我们一个WeatherData对象，我们需要实现的是：建立一个应用，利用WeathrerData对象取得数据，并更新三个布告板：目前状况，气象统计和天气预报 123456public class WeatherData &#123; getTemperature() &#123; // 从气象台取得温度 &#125; getHumidity() &#123; // 从气象台取得湿度 &#125; getTemperature() &#123; // 从气象台取得压力 &#125; measurementsChanged() &#123; // 一旦气象测量更新，此方法会被调用，需要我们具体实现 &#125;&#125; 目前得到的情报： WeatherData类有对应参数的getter方法 新的测量数据备妥时，measurementsChanged()会自动调用 我们需要实现三个布告板：目前状况布告，气象统计布告和天气预报布告，一旦WeatherData有新的测量，这些布告马上更新 这个系统可以扩展，用户可以随心所欲添加或删除任何布告板 初步设计方案123456789101112public class WeatherData &#123; measurementsChanged() &#123; // 一旦气象测量更新，此方法会被调用，需要我们具体实现 float temp = getTemperature(); float humidity = getHumidity(); float pressure = getPressure(); currentConditionsDisplay.update(temp, humidity, pressure); statisticsDisplay.update(temp, humidity, pressure); forecastDisplay.update(temp, humidity, pressure); &#125;&#125; 遇到问题这个初步方案看似完成了功能，但实际上它会遇到如下问题： 对于每个新的布告板，我们都得修改代码 无法运行时动态增加或删除布告板 没有封装改变的部分 针对具体实现编程，而非针对接口 解决方案我们可以使用观察者模式来解决这个方案，什么是观察者模式？可以通过订阅报纸来类比： 报社的业务是出版报纸 向某家报社订阅报纸，只要他们有新的报纸出版，就会送上门，只要我们一直是订户，报社就会持续给我们送上报纸 当我们不想再看这家报社的报纸了，我们可以取消订阅，他们就不会再送报纸过来了 只要报社还在运营，就会持续有人订阅报纸和取订报纸 观察者模式就是这样，只不过它的专业名词有点区别，出版社实际上就是观察者模式的主题Subject，而订阅者就是观察者Observer 使用上面所述的观察者，气象台的应用可以如下设计： 1234567891011121314public interface Subject &#123; public void registerObserver(Observer o); public void removeObserver(Observer o); public void notifyObservers(); // 主题状态改变，则通知所有观察者&#125;public interface Observer &#123; public void update(float temp, float humidity, float pressure);&#125;public interface DisplayElement &#123; // 布告板的显示 public void display();&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class WeatherData implements Subject &#123; private ArrayList observers; private float temperature; private float humidity; private float pressure; public WeatherData() &#123; observers = new ArrayList(); &#125; public void registerObserver(Observer o) &#123; observers.add(o); &#125; public void removeObserver(Observer o) &#123; int i = observers.indexOf(o); if (i &gt;= 0) observers.remove(i); &#125; public void notifyObservers() &#123; for (int i = 0; i &lt; observers.size(); i++) &#123; Observer ob = (Observer) observers.get(i); observer.update(temperature, humidity, pressure); // 通知每个观察者去执行响应的update操作 &#125; &#125; public void measurementsChanged() &#123; notifyObservers(); &#125; public void setMeasurements(float temperature, float humidity, float pressure) &#123; this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; measurementsChanged(); &#125;&#125;public class CurrentConditionsDisplay implements Observer, DisplayElement &#123; private float temperature; private float humidity; private Subject weatherData; public CurrentConditionsDisplay(Subject weatherData) &#123; this.weatherData = weatherData; weatherData.registerObserver(this); // 订阅这个主题 &#125; public void update(float temperature, float humidity, float pressure) &#123; this.temperature = temperature; this.humidity = humidity; display(); &#125; public void display() &#123; System.out.println(xxxxx); &#125;&#125; 本章总结-观察者模式观察者模式：定义了对象之间一对多依赖，这样依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新 主题对象管理某些数据，当数据发生变化，就会通知观察者（推或拉），观察者就会针对这些新数据作出相应的更新操作，主题是真正拥有数据的人，观察者是主题的依赖者，在数据变化时更新，观察者模式也实现了编程一个约定俗成的设计原则：松耦合 观察者模式还有一个推和拉的区别： 推就是主题把自己的更新推给所有观察者，但问题就是部分观察者不想要所有的数据，如果有些观察者只需要一两个数据，但每次都接收所有的数据 拉就是观察者自己把主题的数据拉过来，但问题就是拉的时机不确定，如果过短则导致多次拉数据都是重复数据，过长则数据得不到实时有效更新 选择推或拉主要还是根据业务来决定 Java内置的观察者模式Java内置的观察者模式为java.util.Observer和java.util.Observable，它们分别是观察者和主题，内部使用vector维护所有观察者，使用布尔变量changed指示状态发生变化，每次都要调用setChanged()标记状态已经改变，然后调用notifyObservers()或notifyObservers(Object arg)（arg传送任何数据给观察者）来通知观察者 但它也有它不好的地方： 主题是一个类（Observable），不能实现多继承 setChanged()方法是protected，只能使用继承才能调用该方法，不能创建一个Observable实例然后组合到自己对象，违反了 多用组合，少用继承 原则]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>观察者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HeadFirst设计模式-入门&策略模式]]></title>
    <url>%2F2019%2F09%2F03%2FHeadFirst%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[HeadFirst设计模式-入门&amp;策略模式案例分析假设我们需要做一个模拟鸭子游戏，叫SimUDuck，游戏中会出现各类鸭子，一边游泳戏水，一边呱呱叫 初步设计方案123456789101112131415161718public abstract class Duck &#123; quack(); // 叫 swim(); // 游 display(); // 外观，抽象方法 // 其他办法&#125;class MallardDuck extends Duck &#123; display() &#123; // 外观是绿头 &#125;&#125;class RedheadDuck extends Duck &#123; display() &#123; // 外观是红头 &#125;&#125; 遇到问题鸭子需要添加fly()，但如果为超类添加fly()方法，会导致所有子类的有该方法，一些不应该的飞的鸭子（比如橡皮鸭，诱饵鸭等假鸭）也会飞起来，如果利用继承来提供Duck的行为，会导致下列缺点： 代码在多个子类中重复 运行时的行为不容易改变 很难知道所有鸭子的全部行为 改变会牵一发而动全身，造成其他鸭子不想要的改变 如果改用接口，如： 1234567891011121314151617181920212223242526272829public abstract class Duck &#123; swim(); // 游 display(); // 外观，抽象方法 // 其他办法&#125;interface Flyable &#123; fly();&#125;interface Quackable &#123; quack();&#125;class MallardDuck extends Duck implements Flyable, Quackable &#123; display() &#123; // 外观是绿头 &#125; fly() &#123; &#125; quack() &#123; &#125;&#125;class RedheadDuck extends Duck implements Flyable, Quackable &#123; display() &#123; // 外观是红头 &#125; fly() &#123; &#125; quack() &#123; &#125;&#125; 这样会导致重复的代码极多，比如我有200个鸭子，每个鸭子的飞行都只有一丁点的区别，这样，没有区别的代码量就会很多，且不能复用，导致代码质量极差 解决方案有一个设计原则，恰好适用于这种情况：找出应用中可能需要变化的地方，把他们独立出来，不要和那些不需要变化的代码混合在一起 我们把上面的会发生变化的飞行行为和鸣叫行为独立出来，设计成接口，然后再写它们的具体实现类，然后在超类Duck中定义这些类的成员，这样，对于每个Duck的不同子类，它们的飞行和鸣叫行为就可以独立出来，既做到了代码复用，也可以让不同子类的行为具有不同的实现方式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public interface FlyBehavior &#123; public void fly();&#125;public interface QuackBehavior &#123; public void quack();&#125;public class Quack implements QuackBehavior &#123; public void quack() &#123; // perform quack behavior &#125;&#125;public class FlyWithWings implements QuackBehavior &#123; public void fly() &#123; // perform fly behavior &#125;&#125;public class Duck &#123; FlyBehavior flyBehavior; QuackBehavior quackBehavior; public void setFlyBehavior(FlyBehavior fb) &#123; flyBehavior = fb; &#125; public void setQuackBehavior(QuackBehavior qb) &#123; quackBehavior = qb; &#125; performQuack() &#123; quackBehavior.quack(); &#125; performFly() &#123; flyBehavior.fly(); &#125; swim() &#123;&#125; display() &#123;&#125; // 其他行为&#125;public class MallardDuck extends Duck &#123; public MallardDuck() &#123; quackBehavior = new Quack(); flyBehavior = new FlyWithWinds(); &#125; performQuack() &#123; quackBehavior.quack(); &#125; performFly() &#123; flyBehavior.fly(); &#125; swim() &#123;&#125; display() &#123;&#125; // 其他行为&#125; 可以发现我们在Duck类使用的是接口类型的变量，而不是实际类型，这样鸭子类不会管这些行为的具体实现，具体实现由实现类来实现，且不同的鸭子可以有不同的实现，可以在运行时动态地改变它们的行为，这就是我们的第二个设计原则：针对接口编程，而不是针对实现编程 这种使用接口变量的方式，会比直接使用继承更好，代码会容易维护，这就是我们的第三个设计原则：多用组合，少用继承 本章总结 设计模式是前辈们对代码开发经验的总结，是解决特定问题的一系列套路，是一套用来提高代码可复用性，可维护性，可读性，稳健性以及安全性的解决方案 三个设计原则 把会发生变化的地方从不变的地方独立出来 针对接口编程，而不是针对实现编程，针对接口编程实际上就是针对超类编程，也就是多态性 多用组合，少用继承 上面所使用的设计模式，就是策略模式 策略模式作为一种软件设计模式，指对象有某个行为，但是在不同的场景中，该行为有不同的实现算法 策略模式的组成： 抽象策略角色：策略类，通常由一个接口或者抽象类实现 具体策略角色：包装了相关的算法和行为 环境角色：持有一个策略类的引用，最终给客户端调用 策略模式主要应用于多个类只区别在表现行为不同，或在不同情况下使用不同的策略的场景，它对客户隐藏了具体策略的实现细节]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OS（持续更新）]]></title>
    <url>%2F2019%2F09%2F01%2FOS%2F</url>
    <content type="text"><![CDATA[进程，线程和程序以及它们的区别进程：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位线程：是进程的实体，是CPU调度和分派的基本单位，比进程更小的能独立运行的基本单位 进程和线程的区别 调度的基本单位：线程是调度和分派的基本单位，进程是资源分配的最小单位 资源：进程可以拥有资源，并作为系统中拥有资源的一个基本单位，线程本身不拥有系统资源，而是仅有一点保证独立运行的资源，线程还允许多个线程共享该进程所拥有的资源 独立性：同一进程的不同线程之间的独立性要比不同进程的独立性低，线程往往是为了提高并发性和进行相互之间的合作而创建的，它们共享进程的内存地址空间和资源 系统开销：OS为进程的调度，创建和撤销的开销很大，需要OS内核的干预，而线程开销则小很多 阻塞，挂起和睡眠挂起：主动，由系统或程序发出（不释放CPU，可能释放内存，放在外存）阻塞：被动，抢占资源中得不到资源，被动的挂起在内存，等待某种资源或信号量将他唤醒（释放CPU，不释放内存） 形象的解释：挂起线程的意思就是你对主动对雇工说：“你睡觉去吧，用着你的时候我主动去叫你，然后接着干活”使线程睡眠的意思就是你主动对雇工说：“你睡觉去吧，某时某刻过来报到，然后接着干活”线程阻塞的意思就是，你突然发现，你的雇工不知道在什么时候没经过你允许，自己睡觉呢，但是你不能怪雇工，肯定你这个雇主没注意，本来你让雇工扫地，结果扫帚被偷了或被邻居家借去了，你又没让雇工继续干别的活，他就只好睡觉了。至于扫帚回来后，雇工会不会知道，会不会继续干活，你不用担心，雇工一旦发现扫帚回来了，他就会自己去干活的。因为雇工受过良好的培训。这个培训机构就是操作系统 挂起状态涉及中级调度，当内存中某个程序需要大的内存空间来执行，但这时内存没有空余空间了，OS就会根据调度算法把一些进程放到外存中 并发与并行并发指多个时间同一时刻发生，并行指多个时间同一时间间隔发生并发同一时刻只有一条指令执行，但多个进程指令快速轮流执行，使得宏观上具有多个进程同时执行的效果，但微观上并不是同时执行，并行无论宏观和微观都是同时执行多处理器系统中可以存在并发和并行，而单处理器系统只能有并发 中断和轮询轮询：系统对I/O轮流询问一遍有无处理要求，询问后有要求的，则加以处理中断：指CPU在正常运行程序的过程中，由于预先安排或发生了各种随机的内部或外部事件，使CPU中断正在运行的程序，而转到为响应的服务程序去处理 同步和异步，阻塞和非阻塞同步和异步： 它们关注的是消息通信机制所谓同步，就是发出一个调用时，该进程就一直等待接收响应，直到调用返回，取得返回值而异步则是调用在发出之后，调用者不需要等待响应，可以继续做其他事，或者主动挂起线程释放CPU 阻塞和非阻塞： 它们关注的是程序在等待调用结果（消息，返回值）时的状态阻塞：调用结果返回之前，调用者会被挂起，直到得到结果才继续非阻塞：调用者调用后，不会处于阻塞状态，而是继续运行 什么是线程安全当多个线程访问某段代码时，无论通过怎样的调用或者这些线程如何交替执行，在主程序不需要做任何的同步的情况下，多次执行的结果一致且是我们设想的正确结果，或者说和单线程环境执行的结果一致，那么这段代码就是线程安全的 临界区，解决冲突互斥访问：两个进程不能同时进入同一组共享变量的临界区域临界资源：各进程采取互斥访问方式实现共享的资源称为临界资源临界区：每个进程中访问临界资源的那段代码称为临界区 空闲让进：无进程处于临界区，表明临界资源空闲，允许一个请求进入临界区的进程进入自己的临界区忙则等待：已有进程进入临界区，其他试图进入临界区的进程必须等待有限等待：对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免陷入死等状态让权等待：当进程不能进入自己的临界区时，应立即释放处理机，防止进程陷入忙等状态 分段和分页（仅仅是概念，对分页和分段还需要去了解访问内存次数，地址变换机构，快表） 分页：分页主要是将用户程序的地址空间划分为若干个固定大小的区域，称为”页”或”页面”，典型的页面大小为1kb，相应地，也将内存空间分为若干个物理块或页框，页和块的大小相同，这样可以将用户程序的任一页放入任一物理块中，实现离散分配分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率；或者说，分页仅仅是由于系统管理的需要，而不是用户的需要 分段：按程序的逻辑结构，将程序的地址空间划分为若干段，各段大小可不相同，在进行存储分配时，以段为单位，这些段在内存中可以不相邻接为什么引入：一方面程序可分为若干个段，主程序段，子程序段A，子程序段B，数据段，栈段等，另一方面实现和满足信息共享，信息保护，动态链接以及信息的动态增长等需要 段页区别： 页是信息的物理单位，段是逻辑单位 页长度固定由系统决定，段长度不固定 分页用户程序地址空间是一维的，分段是二维的，既要给出段名又要给出段内地址 进程同步方法我们把异步环境下的一组并发进程因直接制约而互相发送消息、进行互相合作、互相等待，使得各进程按一定的速度执行的过程称为进程间的同步 原子操作：不会被线程调度机制打断的操作信号量机制：P,V原语自旋锁：互斥同步时，对性能影响最大的是阻塞（挂起和恢复线程要进入内核态完成），引入自旋锁，让后面请求锁的线程”稍等一下”，但不放弃处理机的执行时间，即执行一个忙循环（自旋），看看持有锁的对象是否很快就释放锁管程：管程是由局部于管程自己的若干公共变量及其说明和所有访问这些公共变量的过程所组成的软件模块 进程间通信管道：半双工通信，只能在具有亲缘关系的进程间使用命名管道：允许无亲缘关系消息队列共享内存信号量套接字 管道netstat -tulnp | grep 8080 ：把netstat -tulnp的输出作为grep 8080的输入，竖线是匿名管道，管道通信是单向的 命名管道：mkfifo test ： 生成一条test命名管道echo &quot;this is a pipe&quot; &gt; test 往这条管道写数据cat &lt; test ： 读数据 管道的通知机制类似于缓存，把数据放到某个缓存区域，等另一个线程去取，单向传输，缺点是效率低，a进程给b进程传输数据，只能等b进程取数据之后a进程才能返回，不适合频繁通信的进程，优点是简单，保证数据能够被取走 消息队列aa进程要给b进程发送消息，只需要把消息放在对应队列即可，b进程需要的时候直接从对应消息队列取出 优点是进程往消息队列放消息后就可以返回，缺点是如果发送的数据占用内存较大，通信特别频繁，会导致发送消息（拷贝）的过程需要花很多时间 共享内存可以让通信的2个进程各自取出1块虚拟地址空间映射到相同的物理内存，这样就实现了共享内存的机制，发送消息的时间也不存在了 信号量共享内存可能导致多进程竞争内存的问题，使用信号量来解决即可（内存的互斥访问） Socket远程主机的不同进程之间的通信使用Socket Linux文件属性十位，- — — —，第一个是文件类型标识符，-表示普通文件，c表示字符设备，b表示块设备，d表示目录，l表示链接文件，第一组—表示用户权限位，第二组表示组权限位，第三组表示其他权限位，—分别表示rwx权限 死锁死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁 产生死锁的必要条件： 互斥条件：一个资源每次只能被一个进程使用 请求和保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放 不可抢占条件：进程已获得的资源，在未使用完之前不能强行剥夺 循环等待条件：若干进程之间形成一种首尾相接的循环等待资源关系 处理死锁： 预防死锁：破坏产生死锁的后3个必要条件，比如资源一次性分配，新请求不能满足就释放已有资源，资源有序分配等 避免死锁：它与预防不一样，它不是事先采取限制措施的方法破坏产生死锁的必要条件，它允许进程动态申请资源，但系统在进行资源分配前，应先计算此次资源分配的安全性，若安全才分配，否则令进程等待，常见的安全性算法是银行家算法 检测死锁：资源分配图，死锁定理（化简资源分配图，不可完全简化就死锁） 解除死锁 生产者-消费者问题假定生产者和消费者之间的公用缓冲池具有n个缓冲区，此时可利用互斥信号量mutex实现诸进程对缓冲池的互斥利用；利用信号量empty和full分别表示缓冲池中空缓冲区和满缓冲区的数量，只要还有空缓冲区，生产者就可以往里面写消息，满缓冲区同理 1234567891011121314151617181920212223242526272829303132333435int in = 0, out = 0;item buffer[n];semaphore mutex = 1, empty = n, full = 0;void producer() &#123; do &#123; produce an item nextp; ... wait(empty); wait(mutex); buffer[in] = nextp; in = (in + 1) % n; signal(mutex); signal(full); &#125; while (TRUE);&#125;void consumer() &#123; do &#123; wait(full); wait(mutex); nextc = buffer[out]; out = (out + 1) % n; signal(mutex); signal(empty); consume the item in nextc; ... &#125; while (TRUE);&#125;void main() &#123; cobegin producer(); consumer(); coend&#125; 每个程序的多个wait操作顺序不能颠倒，必须要先执行对资源信号量的wait操作，然后再执行对互斥信号量的wait操作，否则可能引起死锁（如在生产者中，如果先申请缓冲池，然后再申请空池，但空池此时数量为0，则生产者会因为持有缓冲池但没有空池而进入死锁） 生产者消费者模型的作用是什么 通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用 解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约 哲学家进餐问题要把5只筷子定义为5个初值为1信号量（而不是一个初值为5的信号量，因为筷子位置不同，5个哲学家只能拿自己左右的筷子，而不是任意拿筷子） 解决方法可以有： 最多只允许4个哲学家同时去拿左边的筷子 仅当哲学家左右两只筷子均可用时，才允许他拿起筷子 规定奇数号哲学家先拿他左边的筷子，再拿右边的筷子，偶数号哲学家则相反 读者-写者问题读写互斥wmutex，rmutex对临界资源readcount的互斥访问 1234567891011121314151617181920212223242526272829303132semaphore rmutex = 1, wmutex = 1;int readcount = 0;void reader() &#123; do &#123; wait(rmutex); // 对readcount互斥访问 if (readcount == 0) wait(wmutex); readcount++; signal(rmutex); ... perform read operation; ... wait(rmutex); readcount--; if (readcount == 0) signal(wmutex); signal(rmutex); &#125; while (TRUE);&#125;void writer() &#123; do &#123; wait(wmutex); perform write operation; signal(wmutex); &#125; while (TRUE);&#125;void main() &#123; cobegin reader(); writer(); coend&#125; 独木桥问题对于东西两侧的车，桥是一个互斥资源，而对东西两侧各自而言，每辆车上桥是同步关系 12345678910111213141516171819202122232425262728// 分别表示独木桥，东侧车辆，西侧车辆在桥上数量semaphore mutex = 1, east = 1, west = 1int countE = 0, countW = 0;cobeginprocess PEast() &#123; P(east); if (countE == 0) P(mutex); countE++; V(east) // 过桥 P(east); countE--; if (countE == 0) V(mutex); V(east);&#125;process PWest() &#123; P(west); if (countW == 0) P(mutex); countW++; V(west); // 过桥 P(west); countW--; if (countW == 0) V(mutex); V(west);&#125; 进程调度策略先来先服务，短作业优先，优先级，时间片轮转，多级反馈 多级反馈指设置多个就绪队列，每个队列优先级不同（从第一个到最后一个依次降低），为不同队列中的进程赋予的执行时间片的大小也各不相同，优先级越高的队列时间片越小，每个队列按先来先服务调度，队列间按优先级调度，高优先级的队列非空，低优先级的队列就无法被调度 两个互为存在的条件并发和共享是 os 的两个最基本的特征,又互为存在的条件]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式（持续更新）]]></title>
    <url>%2F2019%2F09%2F01%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式（持续更新）策略模式策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户 缺点 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。 由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么这些类的数目就非常多了。 使用 一个抽象策略类（Strategy）（接口），它定义了具体策略类的具体算法的抽象公共接口，所有具体策略类都要实现该接口 一堆具体策略类（ConcreteStrategy） 环境类（Context）：维护一个对Strategy对象的引用，用一个ConcreteStrategy对象类配置，它可以定义setter接口来设置具体的ConcreteStrategy，定义另一个接口使用策略的算法 观察者模式观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象(主题)改变状态时，它的所有依赖者(观察者)都会收到通知并自动更新，主题真正拥有数据 使用Java内置有Observable和Observer类，Observer就是观察者，Observable是主题，Observable是类，而不是接口，限制复用能力，所以最好自己设计观察者模式 装饰者模式利用组合（composition）和委托（delegation）可以在运行时实现继承行为的效果，动态地给对象加上新的行为利用继承扩展子类的行为，是在编译时静态决定的；利用组合的做法，可以在运行时动态地扩展对象的行为 装饰者模式动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案装饰者模式中，装饰者可以在被装饰者的行为之前或之后，加上自己的行为，以实现特性的目的 软件设计原则：类应该对扩展开放，对修改关闭 缺点： 设计中加入大量的小类，代码不容易理解 客户端代码依赖于特定类型（违反针对接口编程） 使实例化组件的复杂度提升 使用 装饰者和被装饰对象具有相同的超类型（接口） 可以用一个或多个装饰者包装一个对象 每个装饰者都可以通过组合和构造器参数形式传入被装饰者 定义一个超类型的对象指向最外层装饰者，调用最外层装饰者对应的方法，最外层装饰者会依次调用内部装饰者直到被装饰者的方法 装饰者自己的方法在调用被装饰者的方法前后会加入自己的行为，以达到某个目的 工厂模式简单工厂模式工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类 它的优点是： 创建对象只需要知道其名字 扩展性高，如果增加一个产品，只需要扩展工厂类 屏蔽产品的具体实现，调用者只关心产品的接口 缺点： 每次增加一个产品时，都需要增加一个具体类和对象实现工厂 使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public interface Shape &#123; void draw();&#125;public class Rectangle implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Rectangle::draw() method."); &#125;&#125;public class Square implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Square::draw() method."); &#125;&#125;public class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Circle::draw() method."); &#125;&#125;public abstract class AbstractShapeFactory &#123; public abstract Shape getShape(String shapeType) &#123;&#125;&#125;public class ShapeFactory extends AbstractShapeFactory &#123; //使用 getShape 方法获取形状类型的对象 public Shape getShape(String shapeType)&#123; if(shapeType == null)&#123; return null; &#125; if(shapeType.equalsIgnoreCase("CIRCLE"))&#123; return new Circle(); &#125; else if(shapeType.equalsIgnoreCase("RECTANGLE"))&#123; return new Rectangle(); &#125; else if(shapeType.equalsIgnoreCase("SQUARE"))&#123; return new Square(); &#125; return null; &#125;&#125; 抽象工厂模式抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类 优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象 缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的实现类加代码 使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132public interface Shape &#123; void draw();&#125;public class Rectangle implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Rectangle::draw() method."); &#125;&#125;public class Square implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Square::draw() method."); &#125;&#125;public class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Circle::draw() method."); &#125;&#125;public interface Color &#123; void fill();&#125;public class Red implements Color &#123; @Override public void fill() &#123; System.out.println("Inside Red::fill() method."); &#125;&#125;public class Green implements Color &#123; @Override public void fill() &#123; System.out.println("Inside Green::fill() method."); &#125;&#125;public class Blue implements Color &#123; @Override public void fill() &#123; System.out.println("Inside Blue::fill() method."); &#125;&#125;public abstract class AbstractFactory &#123; public abstract Color getColor(String color); public abstract Shape getShape(String shape);&#125;public class ShapeFactory extends AbstractFactory &#123; @Override public Shape getShape(String shapeType)&#123; if(shapeType == null)&#123; return null; &#125; if(shapeType.equalsIgnoreCase("CIRCLE"))&#123; return new Circle(); &#125; else if(shapeType.equalsIgnoreCase("RECTANGLE"))&#123; return new Rectangle(); &#125; else if(shapeType.equalsIgnoreCase("SQUARE"))&#123; return new Square(); &#125; return null; &#125; @Override public Color getColor(String color) &#123; return null; &#125;&#125;public class ColorFactory extends AbstractFactory &#123; @Override public Shape getShape(String shapeType)&#123; return null; &#125; @Override public Color getColor(String color) &#123; if(color == null)&#123; return null; &#125; if(color.equalsIgnoreCase("RED"))&#123; return new Red(); &#125; else if(color.equalsIgnoreCase("GREEN"))&#123; return new Green(); &#125; else if(color.equalsIgnoreCase("BLUE"))&#123; return new Blue(); &#125; return null; &#125;&#125;public class FactoryProducer &#123; public static AbstractFactory getFactory(String choice)&#123; if(choice.equalsIgnoreCase("SHAPE"))&#123; return new ShapeFactory(); &#125; else if(choice.equalsIgnoreCase("COLOR"))&#123; return new ColorFactory(); &#125; return null; &#125;&#125;public class AbstractFactoryPatternDemo &#123; public static void main(String[] args) &#123; //获取形状工厂 AbstractFactory shapeFactory = FactoryProducer.getFactory("SHAPE"); //获取形状为 Circle 的对象 Shape shape1 = shapeFactory.getShape("CIRCLE"); //获取颜色工厂 AbstractFactory colorFactory = FactoryProducer.getFactory("COLOR"); //获取颜色为 Red 的对象 Color color1 = colorFactory.getColor("RED"); &#125;&#125; 工厂与抽象工厂的区别我个人觉得抽象工厂可以理解为产品族的工厂，它有一系列负责生产不同产品的方法，这些方法由子类去具体实现，不同子类负责具体某些（或某个）产品的生产，它是通过组合实现的而工厂模式主要是生产某个具体产品，通过继承实现 单例模式它的定义介绍 双检锁 1234567891011121314public class Singleton&#123; private static volatile Singleton single; private Singleton()&#123;&#125; public static Singleton getSingle() &#123; if(single == null) &#123; // 第一次检查是防止已有单例的情况下进入同步块增加开销 synchronized (Singleton.class) &#123; if (single == null) // 第二次是防止两个线程同时进入同步块，第一个返回一个new Singleton()后，第二个线程也创建一个新的Singleton() single = new Singleton(); &#125; &#125; return single; &#125;&#125; 设计原则 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起 这样可以方便以后对其进行改动或扩充，而不影响变化的其他部分 针对接口(超类型)编程，而不是针对实现编程 针对实现编程，要改变行为的时候十分不方便，但如果针对接口编程，就会很方便，实际实现不会具体绑定在实体类上 多用组合，少用继承 使用组合具有很大弹性，可以将算法族(每个算法)封装成类，也可以运行时动态改变行为 为了交互对象之间的松耦合设计而努力 类应该对扩展开放，对修改关闭 依赖倒置原则：要依赖抽象，不要依赖具体类]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程（持续更新）]]></title>
    <url>%2F2019%2F09%2F01%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[java多线程为什么引入多线程？进程创建和切换的开销大，引入线程是提高效率 线程状态 新建New 运行Runnable：包括Running和Ready（yield方法线程不会改变状态，仍然是Runnable） 无限等待Waiting：不会分配CPU时间，需要被其他线程显式唤醒，如下方法会导致 无Timeout参数的Object.wait()方法 无Timeout参数的Thread.join()方法 限期等待Timed Waiting：一定时间后由系统自动唤醒 设置了Timeout参数的Object.wait()方法 设置了Timeout参数的Thread.join()方法 Thread.sleep()方法 阻塞Blocked：阻塞与等待的区别是：阻塞在等待获取一个排他锁，是被动发生，等待则是等待一段时间或者唤醒动作的发生，主动行为 结束Terminated sleep和wait等区别 sleep是Thread类的静态方法，wait是Object类的实例方法 Thread.sleep()不会导致锁的改变，可以简单认为和锁相关的方法都定义在Object类中 调用wait后，需要别的线程调用notify/notifyAll才能重新获得CPU执行时间 sleep和yield不会释放锁，yield让步，让线程从运行状态转为就绪状态wait会释放锁 object.wait()机制 This method should only be called by a thread that is the owner of this object’s monitor 12345synchronized (obj) &#123; while (&lt;condition does not hold&gt;) obj.wait(); ... // Perform action appropriate to condition&#125; 在某一线程中调用obj的wait方法，前提是该线程必须持有obj的监视器（monitor，可以理解为锁），调用后，该线程会释放此监视器的所有权并等待，直到另一个线程调用notify或notifyAll方法通知等待该obj监视器的线程唤醒，然后线程等待，直到它可以重新获得监视器所有权并继续执行 线程以三种方式之一成为对象监视器的所有者： 通过执行该对象的同步实例方法 通过执行在对象上同步的synchronized语句的主体 对于Class类型的对象，通过执行该类的同步静态方法 为什么wait，notify，notifyAll被定义在Object类里Java每个对象都有一个monitor（可以理解为锁），并且wait，notify等方法用于等待对象的监视器或者通知其他的线程对象的监视器可用，即这些方法都是与监视器有关的，线程类没有可供对象使用的锁或同步器，所以这些方法是Object类的方法 为什么wait(), notify()和notifyAll()必须在同步方法或者同步块中被调用这些方法都需要通过对象的监视器（锁）实现对应的功能，因此需要同步方法或者同步块得到对象的监视器（锁） synchronized实现原理当一个线程试图访问同步代码块时，他首先必须得到锁，退出或抛出异常时必须释放锁。那么锁到底存在哪里呢？锁里面会存储什么信息呢？ JVM基于进入和退出Monitor对象来实现同步，代码块同步是使用monitorenter和monitorexit实现，线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁 synchronized对象锁与类锁synchronized修饰静态方法获取的是类锁(类的字节码文件对象)，synchronized修饰普通方法或代码块获取的是对象锁。 它俩是不冲突的，也就是说：获取了类锁的线程和获取了对象锁的线程是不冲突的！ synchronized的优化JDK 1.6后增加了如下优化：自旋锁，锁消除，锁粗化，轻量级锁，偏向锁首先对synchronizd加锁的对象先加偏向锁，当有其他线程来竞争，就升级为轻量级锁，这个轻量级锁通常是自旋锁，当自旋次数超过限制数，轻量级锁就再升级为重量级锁性能上和Lock锁相差不大 使用Lock的理由只有它的特性如：多个Condition，多个读线程同时访问共享资源 synchronized与Lock的区别 synchronized是java内置关键字，Lock是java类 synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁 synchronized会自动释放锁（运行完或异常），Lock需要在finally释放锁 synchronized得不到锁的线程会一直等待下去，Lock则不一定 synchronized可重入，非公平，Lock可重入，可判断，可公平 Callable与Future泛型接口Callable有一个 V call(); 方法，可以返回值，这是它与Runnable的区别对于一个任务需要多线程计算结果，可以使用Callable，使用Future来接收这个多线程计算的结果，FutureTask是Future接口的一个实现，同时也是Runnable接口的实现 用法如下： 123456789101112Callable&lt;Integer&gt; myComputation = ...; // 线程执行计算任务FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(myComputation);Thread t = new Thread(task);t.start();...Integer result = task.get();// 多线程执行任务Callable&lt;Integer&gt; task = ...;ExecutorService executor = Executors.newCachedThreadPool();Future&lt;Integer&gt; result = executor.submit(task);// 输出 result.get()就是该多线程任务的结果 同步器倒计时门栓CountDownLatch类让一个线程集等待直到计数变为0，倒计时门栓是一次性的，一旦计数为0，就不能重用 门栓两个方法：await()和countDown() 举例来说，假定一个线程集需要一些初始的数据来完成工作，工作器线程被启动并在门外等待。另一个线程准备数据，设置一个计数值为1的门栓，当数据准备好后，调用countDown，所有工作器线程就可以继续运行了。然后设置第二个门栓检查什么时候所有工作器线程完成工作，门栓计数为工作器线程个数 e.g. 12345678910111213141516171819202122232425262728293031323334353637// 摘自java3y公众号// 3y现在去做实习生了，其他的员工还没下班，3y不好意思先走，等其他的员工都走光了，3y再走public class Test &#123; public static void main(String[] args) &#123; final CountDownLatch countDownLatch = new CountDownLatch(5); System.out.println("现在6点下班了....."); // 3y线程启动 new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; // 这里调用的是await()不是wait() countDownLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("...其他的5个员工走光了，3y终于可以走了"); &#125; &#125;).start(); // 其他员工线程启动 for (int i = 0; i &lt; 5; i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("员工xxxx下班了"); countDownLatch.countDown(); &#125; &#125;).start(); &#125; &#125;&#125; 障栅CyclicBarrier类实现一个集结点称为障栅，可以被重用。考虑大量线程运行在一次计算的不同部分的情形，当所有部分准备好时，需要把结果组合在一起，当一个线程完成它的部分任务后，我们让它运行到障栅处，一旦所有线程都到达这个障栅，障栅就撤销，线程可以继续运行 123456789// CyclicBarrier(int parties, Runnable barrierAction) 所有等待的线程会继续执行，同时barrierAction也会开始执行// CyclicBarrier(int parties) 应该是所有等待的线程一起执行后面的动作CyclicBarrier barrier = new CyclicBarrier(nthreads);public void run()&#123; doWork(); barrier.await();&#125; CyclicBarrier和CountDownLatch区别 CyclicBarrier的某个线程运行到某个点上，该线程就暂停运行，直到所有线程都到达这个点，才一起重新运行；CountDownLatch某线程运行到某个点上，只是让某个数值-1，该线程继续运行 CyclicBarrier只能通过传入参数来让某一个线程唤起，而CountDownLatch可以通过给多个线程调用await()方法来实现唤起多个任务 CyclicBarrier可重用，CountDownLatch不可重用 信号量Semaphore(信号量)实际上就是可以控制同时访问的线程个数，它维护了一组”许可证” 当调用acquire()方法时，会消费一个许可证。如果没有许可证了，会阻塞起来 当调用release()方法时，会添加一个许可证。 这些”许可证”的个数其实就是一个count变量 线程安全如果你的代码在多线程和单线程环境下执行得到的结构永远一样，那么代码就是线程安全的 线程安全级别 不可变 绝对线程安全：不管任何环境，都不需要额外同步措施 相对线程安全：通常意义上的线程安全，像vector等 线程非安全 AQSJ.U.C包下子包locks的AbstractQueuedSynchronizer的简称 是一个可以给我们实现锁的框架，实现了AQS的常见的有ReentrantLock,CountDownLatch acquire()方法调用了tryAcquire()，release()方法调用了tryRelease()，需要继承AQS的实现类去实现 内部实现的关键：先进先出的阻塞等待队列CLH，state状态 拥有两种线程模式：独占和共享 对象每上一次锁，state就通过CAS操作加1 当有线程持有了锁，另外一个线程竞争不到锁，就让它进入CLH队列，该队列每个结点有标识该线程状态的waitStatus CASCAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值（B）。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作 读写锁 支持公平和非公平模式，公平模式下会去看FIFO队列线程是否是在队头（AQS的队列），而非公平模式下是没有的 state的变量高16位是读锁，低16位是写锁 写锁可以降级为读锁，读锁不能升级为写锁 写锁是互斥的，读锁是共享的 线程池线程池可以看做是线程的集合。在没有任务时线程处于空闲状态，当请求到来：线程池给这个请求分配一个空闲的线程，任务完成后回到线程池中等待下次任务(而不是销毁)。这样就实现了线程的重用 为什么使用线程池 降低资源消耗，通过重复利用已创建的线程降低线程创建和销毁造成的消耗 提高响应速度，当任务到达时，任务可以不需要等到线程创建就能立即执行 提高线程的可管理性，线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。但是要做到合理的利用线程池，必须对其原理了如指掌 线程池的用法ExecutorService executor = Executors.newCachedThreadPool(); 一共有以下5种池： newCachedThreadPool：必要时创建，空闲线程保留60s newFixedThreadPool：包含固定数量，空闲线程保留 newSingleThreadExecutor：只有一个线程的池 newScheduledThreadPool：用于预定执行而构建的固定线程池 newSingleThreadScheduledExecutor：用于预定执行而构建的单线程池 调用Executors类的静态方法newCachedThreadPool或newFixedThreadPool，得到ExecutorService对象 调用submit提交Runnable或Callable对象 如果想要取消一个任务或提交Callable对象，要保存好submit方法返回的Future对象 当不再提交任何任务时，调用 executor.shutdown() 前三种线程池实质是ThreadPoolExecutor对象，后两种线程池是ScheduledThreadPoolExecutor对象，后两种线程池可以提供预定执行（延后和定期执行） Executor接口只有一个execute()方法，是执行Runnable的任务 ExecutorService主要方法是shutdown()和submit()，submit()内部调用了execute() AbstractExecutorService抽象类实现了submit,invokeAll,invokeAny方法 ThreadPoolExecutor就是Executors那三个生成线程池方法返回的实际对象 JDK 1.7新增ForkJoinPool线程池，采用了工作窃取算法 ThreadPoolExecutor构造方法 12345678public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; ... &#125; corePoolSize：线程池的基本线程数（队列没满时，线程的最大并发数） maximumPoolSize：线程池允许创建的最大线程数（队列满后能够达到的最大并发数） keepAliveTime：线程活动保持时间。线程池的工作线程空闲后，保持活动的时间 workQueue：任务队列。用于保存等待执行的任务的阻塞队列 threadFactory：创建线程的工厂，可以通过线程工厂为每个创建出来的线程设置更有意义的名字 handler：饱和策略。当队列和线程池都满了，说明处于饱和，默认情况抛出异常。JDK 1.5提供4种策略 AbortPolicy：抛出异常 CallerRunsPolicy：只用调用者所在线程来运行任务 DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务 DiscardPolicy：不处理，丢弃掉 它们的关系如下： 创建线程池后，默认情况下线程池并没有任何线程，等待有任务来的时候才创建线程（除非调用prestartAllCoreThreads()或prestartCoreThread()方法） 当线程池中线程数小于corePoolSize，新提交任务创建一个新线程执行任务并加入到线程池，即使此时线程池中存在空闲线程 当线程池中线程数达到corePoolSize，新提交任务被放入workQueue中，等待线程池中任务调度执行 如果队列满，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程去执行任务，如果使用无界的任务队列，这个参数就没什么效果 如果提交任务数超过maximumPoolSize，任务提交给handler处理 当线程池中线程数超过corePoolSize，超过的这部分超时时，就回收它们 如果你提交任务时，线程池队列已满，这时会发生什么 如果使用的是无界队列LinkedBlockingQueue，可以继续添加任务到阻塞队列中等待执行 如果使用的是有界队列ArrayBlockingQueue，任务首先会添加到ArrayBlockingQueue，满了则根据maximumPoolSize增加线程数量，如果增加了还是处理不来，就使用拒绝策略，默认是AbortPolicy（抛出异常） 高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？ 高并发，任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换 并发不高，任务执行时间长的业务： 如果业务时间集中在IO操作，IO不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务 假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换 并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦 Thread.sleep(0)的作用是什么手动触发一次OS分配时间片的操作，平衡CPU控制权，让低优先级线程也能获取CPU控制权 一个最简单的死锁例子123456789101112131415161718192021222324252627282930313233343536373839404142public static void main(String[] args) &#123; Object obj1 = new Object(); Object obj2 = new Object(); Runnable r1 = new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + "尝试获取obj1锁..."); synchronized (obj1) &#123; System.out.println(Thread.currentThread().getName() + "成功获取obj1锁!"); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "尝试获取obj2锁..."); synchronized (obj2) &#123; System.out.println(Thread.currentThread().getName() + "成功获取obj2锁!"); &#125; &#125; &#125; &#125;; Runnable r2 = new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + "尝试获取obj2锁..."); synchronized (obj2) &#123; System.out.println(Thread.currentThread().getName() + "成功获取obj2锁!"); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "尝试获取obj1锁..."); synchronized (obj1) &#123; System.out.println(Thread.currentThread().getName() + "成功获取obj1锁!"); &#125; &#125; &#125; &#125;; new Thread(r1).start(); new Thread(r2).start();&#125; ABA问题使用CAS有个缺点就是ABA问题，ABA问题描述如下： 有一个变量count=10，三个线程A,B,C 线程A和线程C同时读到count变量，所以线程A和线程C的内存值和预期值都为10, 此时线程A使用CAS将count修改为100 修改完后，线程B进来了，读取到count的值为100（内存值和预期值都是100），将count修改为10 线程C拿到执行权，发现内存值是10，预期值也是10，将count修改为11 这样 线程C无法得知线程A和线程B修改过count的值，是有风险的 解决ABA问题可以使用JDK提供的AtomicStampedReference和AtomicMarkableReference类 简单来说就是给这个对象提供一个版本，并且这个版本如果被修改了，这个版本号是自动更新的多了这个版本号比较，就不会存在ABA的问题了 LongAdder性能LongAdder性能要比AtomicLong好，它减少乐观锁的重试次数 线程类的构造方法、静态块是被哪个线程调用的线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的 同步方法和同步块，哪个是更好的选择同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率，同步范围越小越好 写一个生产者消费者模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class ProducerAndConsumer &#123; private static int count = 0; private static final int FULL = 10; // 队列容量 private static final Object LOCK = new Object(); // 锁对象 public static void main(String[] args) &#123; ProducerAndConsumer pac = new ProducerAndConsumer(); ExecutorService es = Executors.newCachedThreadPool(); es.submit(pac.new Producer()); es.submit(pac.new Producer()); es.submit(pac.new Producer()); es.submit(pac.new Consumer()); es.submit(pac.new Consumer()); es.submit(pac.new Consumer()); es.shutdown(); &#125; class Producer implements Runnable &#123; @Override public void run() &#123; while (true) &#123; synchronized (LOCK) &#123; while (count == FULL) &#123; try &#123; LOCK.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; count++; System.out.println(Thread.currentThread().getName() + "生产者生产，目前总共有" + count); LOCK.notifyAll(); &#125; &#125; &#125; &#125; class Consumer implements Runnable &#123; @Override public void run() &#123; while (true) &#123; synchronized (LOCK) &#123; while (count == 0) &#123; try &#123; LOCK.wait(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; count--; System.out.println(Thread.currentThread().getName() + "消费者消费，目前总共有" + count); LOCK.notifyAll(); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Network（持续更新）]]></title>
    <url>%2F2019%2F09%2F01%2FNetwork%2F</url>
    <content type="text"><![CDATA[OSI，TCP/IP，五层协议的体系结构OSI 7层：物理层，数据链路层，网络层，运输层，会话层，表示层，应用层TCP/UP 4层：网络接口层，网际层IP，运输层，应用层 物理层：通过媒介传输比特,确定机械及电气规范（比特Bit） 会话层：建立、管理和终止会话 表示层：对数据进行翻译、加密和压缩 数据链路层功能数据链路层：将比特组装成帧和点到点的传递（帧Frame）数据链路层主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路 提供的功能有： 为网络层提供服务（无确认的无连接，有确认的无连接，有确认的面向连接） 链路管理（面向连接时连接的建立，维持和释放） 帧定界，帧同步和透明传输（定界定首尾部界限，同步指接收方可以区分界限，透明传输指怎么样的比特组合都可以传送） 流量控制 差错控制（CRC循环冗余检验，ARQ自动重传） 网络层功能 异构网络互联 路由选择与分组转发 拥塞控制 流量控制与拥塞控制的区别：流量控制往往指发送端和接收端之间点对点通信量的控制，流量控制要做的是抑制发送端发送数据的速率。而拥塞控制必须确保通信子网能够传送待传送的数据，是一个全局性的问题 IP数据报IPv4分组20字节的固定首部加上可变部分，最大60B IPv4地址分类 A类地址：以0开头，第一个字节范围：1&sim;126（1.0.0.0 - 126.255.255.255）； B类地址：以10开头，第一个字节范围：128&sim;191（128.0.0.0 - 191.255.255.255）； C类地址：以110开头，第一个字节范围：192&sim;223（192.0.0.0 - 223.255.255.255）； D类地址：以1110开头，第一个字节范围：224&sim;239（224.0.0.0 - 239.255.255.255）；（作为多播使用） E类地址：保留 &nbsp;特殊IP地址： 主机号全为0的表示本网络本身，如202.98.174.0 主机号全为1的表示本网络的广播地址，如202.98.174.255 127.0.0.0保留为环路自检地址，表示任意主机本身，目的地址为环路自检地址的IP数据报永远不会出现在任何网络上 32位全为0，即0.0.0.0表示本网络上的本主机 32位全为1，即255.255.255.255表示整个TCP/IP网络的广播地址，又称受限广播地址，实际使用时由于路由器对广播域的隔离，可以等效为本网络的广播地址 &nbsp; 网络地址转换(NAT)指通过将专用网络转换为共用地址留用的内部私有地址，私有IP地址只用于LAN，不用于WAN连接（私有IP地址不能直接用于Internet，必须通过网关利用NAT把私有IP地址转换为Internet中合法的全球IP地址后才能用于Internet），并且允许私有IP地址被LAN重复利用： A类：1个A类网段，即10.0.0.0∼10.255.255.255 B类：16个B类网段：172.16.0.0∼172.31.255.255 C类：256个C类网段：192.168.0.0∼192.168.255.255 &nbsp; 子网划分与子网掩码 在IP地址增加一个子网号字段，使2级IP地址变为3级IP地址，这种做法称为子网划分，从主机号借用若干比特作为子网号，IP地址={&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;} 子网掩码和IP地址按位与，即可得到网络号，剩余的是主机号 ARP地址解析协议工作原理 首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。 当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP请求报，该数据报包括的内容有：源主机IP地址，源主机MAC地址，目的主机的IP地址，目的MAC地址是FF-FF-FF-FF-FF-FF。 当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。 源主机收到ARP响应报后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送MAC帧。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败 广播发送ARP请求，单播发送ARP响应 传输层功能运输层为运行在不同主机上的进程之间提供逻辑通信，而网络层则提供主机之间的逻辑通信 提供应用进程之间的逻辑通信 复用和分用（复用指发送方不同的应用进程都可以使用同一个传输层协议发送数据，分用指接收方的传输层在剥去报文首部后能把这些数据正确交付到目的应用进程） 差错检测（检测数据部分和首部，网络层只检测首部） 提供TCP和UDP 端口端口标识主机中的应用进程，是传输层的服务访问点，相当于IP地址在网络层或MAC地址在数据链路层的作用 端口号长16位，能表示65536个不同的端口，0~1024是熟知端口号 应用程序 FTP TELNET SMTP DNS TFTP HTTP SNMP HTTPS 熟知端口号 21 23 25 53 69 80 161 443 TCP和UDP区别 TCP提供面向连接，可靠的数据流传输，UDP非面向连接，不可靠 TCP注重数据安全性，UDP数据传输快 TCP传输单位是TCP报文段，UDP传输单位是数据报 TCP面向字节流，把数据视为一连串无结构的字节流，UDP面向报文 TCP首部开销大，占20B，UDP首部开销小，只占8B TCP还提供流量控制和拥塞控制 TCP三次握手 客户机的TCP首先向服务器的TCP发送一个连接请求报文段，不含应用层数据，首部的SYN标志位置1，称为SYN报文段，另外，客户机会随机选择一个初始序号（client_isn），放置于该起始的TCP SYN报文段的序号字段中，然后该SYN报文段封装成IP数据报发送给服务器（TCP是面向字节流的，所以TCP连接传送的数据流中每个字节都编上一个序号） 一旦包含TCP SYN报文段的IP数据报到达服务器主机，服务器会从该数据报中提取出TCP SYN报文段，为该TCP连接分配TCP缓存和变量，并向该客户TCP发送允许连接的报文段，这个报文段也不包含应用层数据，SYN置1，确认号字段置为client_isn+1（确认号字段是期望收到对方的下一个报文段的数据的第一个字节的序号），服务器选择自己的初始序号server_isn置入TCP报文段首部的序号字段中，这个允许连接的报文段实际上表明：我收到了你发起建立连接的SYN分组，该分组有初始序号client_isn，我同意建立该连接，我自己的初始序号是server_isn，该允许连接的报文段称为SYNACK报文段 收到SYNACK报文段后，客户也要给该连接分配缓存和变量，客户机则向服务器发送另外一个报文段，这最后一个报文段对服务器的允许连接的报文段进行了确认（通过将值server_isn+1放置在TCP报文段首部的确认号字段中来完成），因为连接已经建立，所以该SYN比特置为0，第三个阶段可以在报文段负载中携带客户到服务器的数据 为什么会采用三次握手，若采用二次握手可以吗？三次握手是为了防止失效的连接请求报文突然又传送到主机B，从而使主机B以为主机A又发起新连接，于是同意连接，并向主机A发回确认，但主机A根本不理会，主机B一直等待主机A发送数据，导致主机B资源浪费失效报文指：因网络结点延迟导致客户端A第一次发送的连接请求报文超时，客户端A又重新发送请求报文，连接建立后，客户端A第一次发送的报文才送达服务器B，让服务器B误以为客户端A又发起连接 我的理解：采用三次握手，服务器B在收到客户端A对自己确定的确定报文后，才建立TCP连接，这样，失效的连接请求发到服务器B，服务器B发送SYNACK报文给客户端A，但客户端A不发回确认报文，则连接不会建立，服务器B也不会监听客户端A的数据发送但采用了二次握手的话，服务器B发送SYNACK报文给客户端A后，就建立了连接，但客户端A根本不发送数据，所以就浪费了服务器B的资源 TCP四次挥手参与TCP连接的两个进程中的任何一个都能终止该连接，TCP连接释放的过程称为四次握手 4次挥手可以理解为全双工的连接先从客户端到服务器的断开连接（半关闭状态），再从服务器到客户端的断开连接 客户机打算关闭连接时，向其TCP发送一个连接释放报文段，并停止发送数据，主动关闭TCP连接，该报文段的FIN标志位置1，seq（序号）=u，它等于前面已传送过的数据的最后一个字节的序号加1（FIN报文段不携带数据，消耗序号），TCP是全双工的，发送FIN报文时，发送FIN的一端不能再发送数据，但对方仍然可以发送 服务器收到连接释放报文段后发出确认，确认号是ack=u+1，这个报文段自身的序号是v，等于它前面已传送过的数据的最后一个字节的序号加1，此时，从客户机到服务器这个方向的连接就释放了，TCP连接处于半关闭状态 若服务器已经没有要向客户机发送的数据，就通知TCP释放连接，此时其发送一个FIN=1的连接释放报文段 客户机收到连接释放的报文段后，必须发出确认，确认报文段中，ACK置1，ack=w+1，seq=u+1，定时等待后连接关闭 四次挥手为什么要等待2MSL被动关闭的主机B无需任何wait time，直接释放资源但是主动关闭的主机A并不知道B是否接收到自己的ACK，所以需要等待，A此时要考虑以下两种情况： 如果B没有收到自己的ACK，会超时重传FIN，那么A再次接到重传的FIN，要再次发送ACK 如果B收到自己的ACK，就不会再发任何消息，包括ACK 为了应对最坏情况的发生（最坏情况：去向ACK消息最大存活时间（MSL）+来向FIN消息最大存活时间（MSL）=2MSL），主动发起断开连接的主机A在发出ACK后要等待2MSL，目的： ACK保证传送过去 消除网络中所有其他包（防止新连接使用老端口接收到老的活跃报文） 浏览器输入网址全过程 浏览器通过DNS解析到该网址的IP地址（DNS过程见下面一问） ARP地址解析得到MAC地址，存入ARP列表中 传输层通过三次握手与服务器的HTTP端口80建立TCP连接 浏览器给WEB服务器发送一个HTTP get请求 请求经网络层路由与转发送达服务器 服务器收到请求后，如果设置了反向代理服务软件如nginx，就会把请求转发到服务对应的端口 服务器处理请求并响应一个HTTP相应报文，通过TCP发回给浏览器 浏览器得到响应报文，进行解析 DNS域名系统工作原理 浏览器输入域名，浏览器首先检查自己的浏览器缓存是否有该域名对应的IP地址，如果没有则查找本地的hosts文件是否有网址映射关系，没有则进入路由器缓存检查 当路由器缓存也没有这个映射，就进入ISP（互联网服务供应商）的DNS缓存进行查询，即本地DNS服务器缓存查询映射 如果还找不到，本地DNS服务器就将查询报文转发到13台根DNS服务器，根DNS服务器注意到顶级域名(.com,.edu)，就返回负责该顶级域名的IP地址 然后本地DNS服务器就再次向这些顶级域名服务器(TLD服务器)发送查询报文 TLD服务器注意到baidu.com，就用权威DNS服务器的IP地址来响应 最后，本地DNS服务器直接向权威DNS服务器发送查询报文，权威DNS服务器响应对应的IP地址 本地DNS服务器把结果保存到缓存，并返回结果到客户端 从请求主机到本地DNS服务器的查询是递归的，其余的查询是迭代的 HTTP中GET和POST区别原理性： 根据HTTP规范，GET用于信息获取，并且应该是安全和幂等的（GET不应对服务器有副作用，所以是幂等的） 根据HTTP规范，POST请求表示可能修改服务器上资源的请求 表面上看： GET请求的数据会附在URL后面，POST的数据放在HTTP包里 POST安全性比GET安全性高 HTTP协议包括哪些请求GET，POSTHEAD：用于获取报头PUT：和POST类似，但PUT两个请求相同时，后一个请求会把第一个请求覆盖DELETE：发出一个删除指定文档的请求TRACE：跟踪其处理进程的请求OPTIONS：返回所有可用的方法，检查服务器支持哪些方法CONNECT：ssl隧道的基于代理的请求 HTTP1.0 1.1 2.0的区别 HTTP 区别 HTTP1.0 无状态，无连接 HTTP1.1 持久连接；请求管道化；增加缓存处理；增加Host字段；支持断点传输 HTTP2.0 二进制分帧；多路复用；服务器推送；头部压缩 HTTP1.1服务器必须按照客户请求的先后顺序回送相应的结果，不允许同时存在两个并行的响应 HTTP2.0引入二进制数据帧和流的概念，帧是HTTP2.0通信的最小单位，每个帧包含帧头部，至少标识当前帧所属的流，这样浏览器收到数据后可以按照序列对数据合并，而不会出现合并后数据错乱的情况，也就可以让服务器并行的传输数据了多路复用指HTTP2.0的TCP连接可以承载任意数量的双向数据流服务器推送指服务器除了对浏览器请求响应，还可以额外向客户端推送资源 HTTP和HTTPS区别 协议端口不同：HTTP80端口，HTTPS443端口 证书不同，HTTPS需要正规公司颁发的SSL证书才能开启 安全性不同：HTTPS安全性更高 HTTPS缺点： HTTP明文传输，HTTPS使用TLS/SSL加密 HTTP端口80，HTTPS端口443 HTTPS需要到CA申请证书，需要交费 HTTPS它主要在HTTP和TCP层之间多了一层SSL，SSL工作流程在下面的权威证书颁发机构 对称加密HTTP的传输都是明文传输，不做任何加密，可能会被窃取甚至篡改然后出现的是对称加密方式，约定一个随机生成的密钥，信息发送方使用密钥加密，接收方使用同样的密钥解密，常见的对称加密方式：AES,DES,IDEA,PBE,RC5,RC6等，但这样仍然不安全，第一次通信的时候，密钥和约定加密方式是明文传输的，如果被拦截，后续的加密内容仍然可以被窃取 没有权威的非对称加密这个时候，就出现了非对称加密，它包含一个公钥和一个私钥，明文可以用公钥加密，私钥解密，反之也可以。通信过程中，B首先把自己的公钥key1发送给A，A收到该公钥后，自己生成一个用于对称加密的密钥key2，使用key1加密，发送给B，B利用自己非对称加密的私钥来解开公钥key1的加密，获得key2的内容，然后两方就可以使用key2进行对称加密通信了（B的公钥私钥只用于对对称加密的key加密）常见的非对称加密：RSA,SSH,HTTPS,TLS,电子证书等 但是这样仍然不是安全的，因为中间的拦截可以截取到B的公钥后，自己生成另一对公钥私钥，把自己的公钥发送给A，A接收到中间人的公钥，加密对称加密的key，这样该key仍然能够被中间人所得知 权威证书颁发机构流程如下： 服务端的B，首先把自己的公钥key1发送给证书颁发机构，向其申请证书 证书颁发机构自己有一对公钥私钥，它利用自己的私钥来加密key1，然后通过服务器网址等信息生成一个证书签名（证书签名是利用服务器的信息生成，无法被篡改），证书签名同样经过机构的私钥加密，该证书发回给服务端B（证书由服务器公钥，证书主题，数字签名等内容组成） 证书三个作用： 身份授权：确保浏览器访问的网站是经过CA验证的可信任网站 分发公钥：证书包含服务器的公钥，SSL握手时通过certificate消息传给客户端 验证证书合法性： 客户端收到证书后需要验证其合法性 当A向B请求通信，B就把自己申请的证书发给A A收到证书后，需要验证其真伪，各大浏览器和OS已经维护了所有权威证书机构的名称和公钥，A只要知道是哪个机构颁发的证书，就可以从本地找到对应机构的公钥，解密出证书签名 然后A按照同样的签名规则，自己也生成一个证书签名，如果两个签名一致，则证书是有效的 验证成功后，A就可以利用机构公钥，解密出服务端B的公钥key1了 然后A生成自己的对称加密密钥key2，利用服务端的key1加密key2发送给服务端B即可，后面就可以用这个对称加密密钥key2来进行加密通信了 HTTPS验证流程 客户端发起一个HTTP请求，连接到服务端的443端口，该请求包含客户端支持的加密协议和版本 服务端选择合适的加密协议，返回证书，证书里面有服务器的公钥（证书由服务端信息组成，无法伪造） 客户端验证证书合法性（是否过期，是否来自想要的服务器） 客户端生成对称加密密钥（随机码），通过证书的公钥加密，发送给服务端 服务端使用私钥解密，获取对称加密密钥，使用对称加密密钥加密数据 客户端解密数据，SSL开始通信 为什么后面数据传输要使用对称加密非对称加密及其消耗CPU资源，只能用作对称密钥交换或者CA签名，不适合用来应用层内容传输的加解密 HTTP状态码 1XX：信息状态码 100：继续，初始的请求已经接受，请客户端继续发送剩余部分 101：切换协议，主要用于websocket，也可以用于http2的升级 2XX：成功状态码 200：成功，服务器已经成功处理请求 201：已创建，请求成功并且服务器已创建新资源 3XX：重定向状态码 301：重定向 302：临时重定向 4XX：客户端错误 401：未授权 403：禁止访问 404：页面不存在 5XX：服务器错误 500：服务器错误 交换机，路由器，网关的概念，各自的用途交换机：交换机工作于数据链路层，内部的CPU在每个端口成功连接时，通过ARP协议学习它的MAC地址，保存成一张ARP表。当控制电路收到数据包，处理端口会查找内存中的地址对照表以确定目的MAC的网卡挂接在哪个端口上，并迅速将数据包传送到目的端口。目的MAC不存在，则广播到所有端口，接收端口回应后交换机会学习新的地址，并添加到内部地址表 路由器：路由器工作于网络层，提供路由与转发机制，路由：决定数据包从来源端到目的端所经过的路由路径；转发：路由器输入端的数据包移送到适当的路由器输出端 网关：连接两个网络的设备，与路由器类似，但路由器是在不同网络之间移动数据，而网关是在不同协议间移动数据 字节流与数据报的区别TCP字节流是无结构的，是散乱的数据，在TCP持续连接的过程中，socket收到的数据都是由同一台主机发出，因此只要保证数据有序到达即可，并不需要考虑每次读取多少数据，发送端可以一次发100字节的数据，接收端分10次接收，也可以发送端分10次发送100字节的数据，接收端一次接收 UDP数据报是添加了标记，封装后的数据，UDP是没有连接的，因此接收到的数据可能来自不同主机，发送端调用几次write，接收端就要用相同次数read读完，如果UDP一次可以读取超过一个报文的数据，就可能会出现主机A和主机B发送给服务器的数据报合并在一起，这样的数据是没有意义的 什么是MTUMTU是最大传输单元，单位是字节，指一种通信协议在某一层面上能通过的最大数据包的大小 以太网帧的MTU为1500B，IP数据报的长度不能超过该MTU值 session与cookie区别 session数据放在服务器，cookie数据放在客户端 session多了对服务器压力大，cookie安全性不高 可以考虑将登陆信息等重要信息存放为session，不重要的信息可以放在cookie中 TCP协议端口11种状态服务端：closed -&gt; listen -&gt; syn_rcvd -&gt; established -&gt; close_wait -&gt; last_ack -&gt; close客户端：closed -&gt; syn_send -&gt; established -&gt; fin_wait1 -&gt; fin_wait2 -&gt; time_wait -&gt; close 三次握手： 客户端： 发送SYN到服务端，closed -&gt; syn_send(第一次握手) 连接成功后变为established 服务端： 开始监听：closed -&gt; listen 接收到SYN后，listen -&gt; syn_rcvd(第二次握手) 连接成功后变为established 四次挥手 客户端： 发送FIN，established -&gt; fin_wait1 接收到ACK后，fin_wait1 -&gt; fin_wait2 然后time_wait然后关闭 服务端： 收到FIN后，established -&gt; close_wait 然后发送FIN断开，close_wait -&gt; last_ack 收到客户端ACK后，last_ack -&gt; close 私有IP地址A类地址：10.0.0.0–10.255.255.255B类地址：172.16.0.0–172.31.255.255C类地址：192.168.0.0–192.168.255.255]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL（持续更新）]]></title>
    <url>%2F2019%2F09%2F01%2FMySQL%2F</url>
    <content type="text"><![CDATA[三个范式满足第三范式必定满足第二范式，满足第二范式必定满足第一范式第一范式：字段是最小的单元，不可再分 学生信息组成学生信息表，有年龄、性别、学号等信息组成。这些字段都不可再分，所以它是满足第一范式的 第二范式：满足第一范式，表中的字段必须完全依赖于全部主键而非部分主键 其他字段组成的这行记录和主键表示的是同一个东西，而主键是唯一的，它们只需要依赖于主键，也就成了唯一的 学号为1024的同学，姓名为Java3y，年龄是22岁。姓名和年龄字段都依赖着学号主键。 第三范式：满足第二范式，非主键外的所有字段必须互不依赖 就是数据只在一个地方存储，不重复出现在多张表中，可以认为就是消除传递依赖 比如，我们大学分了很多系（中文系、英语系、计算机系……），这个系别管理表信息有以下字段组成：系编号，系主任，系简介，系架构。那我们能不能在学生信息表添加系编号，系主任，系简介，系架构字段呢？不行的，因为这样就冗余了，非主键外的字段形成了依赖关系(依赖到学生信息表了)！正确的做法是：学生表就只能增加一个系编号字段。 什么是视图？视图的使用场景有哪些？ 视图是一种基于数据表的虚表 视图建立在已有表的基础上，视图赖以建立的表称为基表 向视图提供数据内容的语句为SELECT语句，可以将视图理解为存储起来的SELECT语句 视图向用户提供基表数据的另一种表现形式 视图没有存储真正的数据，真正的数据还是存储在基表中 程序员操作的虽然是视图，但最终还是会转换成操作基表 一个基表可以有0个或多个视图 视图的作用：视图主要用于把用户想要看到的数据展示给用户，而用户不需要的数据则不展示给他们看视图是基于查询的虚表，可以将查询出来的数据进行封装，在使用的时候会很方便，但不提高查询效率 创建视图 CREATE VIEW test_view_1 AS SELECT name FROM user查询视图 SELECT * FROM test_view_1创建视图并指定视图字段名 CREATE VIEW test_view_2(username) AS SELECT name FROM user drop，delete和truncate分别在什么场景使用drop table 属于DDL 不可回滚 不可带where 表内容和结构删除 删除速度快 truncate table 属于DDL 不可回滚 不可带where 表内容删除 删除速度快 delete from 属于DML 可回滚 可带where 表结构在，表内容根据where执行情况而定 删除速度慢，需要逐行删除 不再需要一张表的时候，用drop想保留部分数据行的时候，用delete，并且带上where保留表删除所有数据用truncate 索引是什么？有什么作用与优缺点？什么是索引？ 是一种快速查询表中内容的机制，类似于新华字典的目录 运用在表中某些字段上，但存储时，独立于表外 InnoDB的聚集索引使用B+树实现，叶节点存放整张表的行记录数据（称为数据页），B+树叶结点包含信息，非叶结点只起索引作用（非叶结点的值是主键，两个值A和B之间的子树内所有值大小不大于B，不小于A）辅助索引（非聚集索引）叶子节点不包含行记录的全部数据，它的索引行中还额外包含一个书签，用于告诉InnoDB哪里可以找到与索引相对应的行数据，查询语句中如果条件满足辅助索引，但查询列不在辅助索引，则通过辅助索引找到对应行后，需要使用这个书签回表查询该行记录的其他列（非叶结点的值是索引列，两个值A和B之间的子树内所有值大小不大于B，不小于A） 覆盖索引：一个查询语句的执行只要从索引中就能取得，不必从数据表中读取（只要查询列在辅助索引，就不需要回表查询，只要查询1次即可） CREATE INDEX index_name ON table_name (column_name) 表的数据行实际上存放在聚簇索引的叶子页中 索引的使用场合： 表经常SELECT操作 表很大，记录内容分布范围很广 列名经常在WHERE子句或连接条件中出现 不建议使用索引的场合 表经常进行INSERT/UPDATE/DELETE操作 表很小 列名不经常在WHERE子句或连接条件中出现 优缺点： 索引加快数据库的检索速度 索引降低了插入，删除，修改等维护任务的速度 索引要占用物理和数据空间 索引分类 唯一索引，主键索引，聚集索引，非聚集索引 最左匹配原则创建索引考虑哪些因素？查询概率比较高，经常作为where条件的字段设置索引 创建多列索引，where子句中使用最频繁的一列放在最左边，MySQL查询索引会遵循最左前缀匹配原则，检索数据时从最左边 底层就是把索引拼凑在一起，然后插入到B+树中 什么是事务事务：一个事务中所进行的所有操作，要么同时成功，要么同时失败 事务符合ACID特性： 原子性：整个事务操作为原子操作 一致性：事务将数据库从一种状态转变为下一种一致的状态，完整性约束没有被破坏 隔离性：每个读写事务的对象对其他事务的操作对象能互相分离，即提交前的事务对其他事务都不可见 持久性：事务一旦提交，其结果是永久性的 原子性关注状态，要么全部成功要么全部失败一致性关注的是数据的可见性，中间状态不可见，最初和最终状态对外可见，且必须符合数据完整性约束（转账的例子） 比如有A有500块存款，B有500块存款，A转200给B，则一致性操作如下：A-200;B+200如果这两条操作都执行完毕，那同时它也是原子性的如果操作变为A-200;B+100，且都完成了，那这个操作是原子性的，但不是一致性的 事务隔离级别 READ UNCOMMITTED 未提交读： READ COMMITTED 提交读： REPEATABLE READ 不可重复读： SERIALIZABLE 串行化： InnoDB默认事务隔离级别是REPEATABLE READ，并且添加了next-key lock算法避免幻读 事务隔离级别 脏读 不可重复读 幻读 加锁读 READ UNCOMMITTED 未提交读 √ √ √ × READ COMMITTED 提交读 × √ √ × REPEATABLE READ 可重复读 × × √ × SERIALIZABLE 串行化 × × × √ 脏读：一个事务读到另一个事务未提交的数据不可重复读：一个事务(还没COMMIT)读取到另一个事务已经提交(COMMIT)的数据，即一个事务可以看到其他事务所做的修改幻读：一个事务内读取到别的事务插入(或删除)的数据，导致前后读取不一致（幻读出现的前提是并发的事务中有事务发生了插入，删除操作） 不可重复读的重点是修改:同样的条件, 你读取过的数据, 再次读取出来发现值不一样了幻读的重点在于新增或者删除同样的条件, 第1次和第2次读出来的记录数不一样 对于不可重复读，只需要锁住满足条件的记录，而对于幻读，则需要锁住满足条件及其相近的记录 哈希索引和B+树索引的区别哈希索引使用哈希表，等值查询速度快，但不支持范围查询，也没有办法利用索引完成排序，不支持多列索引的最左匹配原则，大量重复键的时候，存在哈希碰撞，效率很低 MySQL锁lock锁事务，latch锁线程（轻量级） 行级锁：共享锁（S Lock）：允许事务读一行数据排他锁（X Lock）：允许事务删除或更新一行数据 只有共享锁与共享锁之间才兼容 &nbsp; 意向锁：为了支持在不同粒度上进行加锁操作，InnoDB支持一种额外的锁方式，称为意向锁 如果要给最下层即最细粒度的对象上锁，就要先对粗粒度对象上锁，如：对记录r上X锁，要先对数据库A，表，页上意向锁IX，最后对记录r上X锁 InnoDB的意向锁是表级的锁，设计目的是为了在一个事务中揭示下一行江北请求的锁的类型，支持意向排他锁(IS Lock)和意向共享锁(IX Lock) &nbsp; 一致性非锁定读 一致性非锁定读指InnoDB存储引擎通过多版本控制的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行DELETE或UPDATE操作，这时读操作不会因此去等待行上锁的释放，相反，InnoDB存储引擎会去读取行的一个快照（undo段的快照数据），非锁定读不会占用和等待表上的锁 READ COMMITTED和REPEATABLE READ下，InnoDB使用一致性非锁定读，区别是READ COMMITTED下的快照数据是锁定行的最新一份快照数据，REPEATABLE READ下的快照数据是本事务开始时的行数据版本 一致性锁定读 SELECT ... FOR UPDATE; 对读取的行记录加X锁SELECT ... LOCK IN SHARE MODE; 对读取的行记录加S锁 Next-Key Lock Next-Key Lock会锁住一个范围包括记录本身，可以解决幻读的问题比如：一个索引有10,11,13和20这四个值，则该索引可能被Next-Key Locking锁住的范围：(-∞,10],(10,11],(11,13],(13,20],(20,+∞)当查询的索引含有唯一属性时，InnoDB存储引擎会对Next-Key Lock进行优化，将其降级为Record Lock（只锁住行记录本身） 看下面例子： 123456CREATE TABLE z (a INT, b INT, PRIMARY KEY(a), KEY(b));INSERT INTO z SELECT 1,1;INSERT INTO z SELECT 3,1;INSERT INTO z SELECT 5,3;INSERT INTO z SELECT 7,6;INSERT INTO z SELECT 10,8; 当执行SELECT * FROM z WHERE b=3 FOR UPDATE，需要对2个索引分别加锁，聚集索引仅加上值为5的记录锁，而辅助索引会加上(1,3]的锁，同时，InnoDB会对辅助索引的下一个键值加上gap lock(只锁范围，不包括本身)，即在辅助索引加上(3,6)的锁，此时在辅助索引上，就加上了(1,6)的锁，而聚集索引只加上了值为5的锁 乐观锁与悲观锁悲观锁：总是假设最坏的情况，每次去拿数据都认为别人会修改，所以每次取数据都会上锁SELECT * FROM table WHERE condition FOR UPDATE;SELECT * FROM table WHERE condition LOCK IN SHARE MODE; 乐观锁：总是假设最好的情况，每次取取数据都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现通常实现步骤是这样的：表中进行数据操作时(更新)，先给数据表加一个版本(version)字段，每操作一次，将那条记录的版本号加1，每次查询那条记录，就获取version字段，如果要对记录进行操作，就判断此刻的version是否与刚刚查询出来的version一致，如果一致则说明此时没有其他程序对其操作，则可以更新，如果不一致则不更新UPDATE table SET num=num-1 WHERE id=10 and version=23 悲观锁用于多写场合，乐观锁用于多读场合 超键，候选键，主键，外键的概念超键：关系中唯一标识元组的属性集称为关系模式的超键，超键包含候选键和主键候选键：最小超键，没有冗余元素的超键主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能为null外键：在一个表中存在的另一个表的主键称为此表的外键 e.g. 邮寄地址（城市名，街道名，邮政编码，单位名，收件人） 超键：{城市名，街道名}，{街道名，邮政编码}，{城市名，街道名，邮政编码}，{城市名，街道名，邮政编码，单位名}等唯一标识元组的属性集 候选键：{城市名，街道名}和{街道名，邮政编码} 如果选取{城市名，街道名}作为唯一标识实体的属性，那么它就是主键 SQL约束有哪几种NOT NULLUNIQUEPRIMARY KEYFOREIGN KEYCHECK MySQL存储引擎InnoDB:提供对数据库ACID事务的支持，提供行级锁和外键的约束MyIASM：不支持事务，不支持行级锁和外键MEMORY：所有数据都在内存中，数据处理速度快，但安全性不高 如果一个表修改要求比较高的事务处理，可以选择InnoDB。这个数据库中可以将查询要求比较高的表选择MyISAM存储。如果该数据库需要一个用于查询的临时表，可以选择MEMORY存储引擎 MyIASM和InnoDB使使用的索引的数据结构是什么都是B+树MyIASM B+树的数据结构中存储的内容实际上是实际数据的地址值InnoDB B+树中数据结构存储的都是实际的数据 varchar和char的区别char固定长度，填充空格（但取数据时会自动去除空格），varchar可变长度，参数指定的是最大长度，存储效率没有char高 mysql有关权限的表user权限表：记录允许连接到服务器的用户账号信息，里面的权限是全局级的db权限表：记录各个账号在各个数据库上的操作权限table_priv权限表：记录数据表级的操作权限columns_priv：记录数据列级的操作权限host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响 mysql给离散度低的字段建立索引会出现什么问题，具体说下原因重复性较强的字段，不适合添加索引，比如性别，这样查询反而更慢索引是把一个或几个字段按规律排列，然后加上该字段所在行的数据的物理地址访问索引需要额外的IO开销，从索引中拿到的只是地址，如果建立离散度低的索引，比如100万行数据，一次索引定位能拿到50万行，访问完这50万行的索引后，再进行50万次访问表，IO开销就十分大，如果离散度高，则一次索引访问后只剩下几行数据，就十分值得 数据库系统的组成 硬件平台及数据库：大内存，大硬盘 软件： 数据库管理系统：为数据库建立，使用和维护配置的系统软件 OS 与数据库接口的高级语言及其编译系统 数据库应用系统 人员： 数据库管理员 系统分析员和数据库设计人员 应用程序员 用户 存储过程优点 允许模块化程序设计 不需要像解释执行的SQL语句那样在提出请求时才进行语法分析和优化工作，运行效率高 降低客户机和服务器之间的通信量，客户机的应用程序只要通过网络向服务器发出调用存储过程的名字和参数即可 安全性：没有权限执行存储过程的用户，也可授权他们执行存储过程 SQL语句HAVINT与WHEREWHERE语句在GROUP BY语句之前；SQL会在分组之前计算WHERE语句。HAVING语句在GROUP BY语句之后；SQL会在分组之后计算HAVING语句。 通配符 %：替代0个或多个字符 _：替代一个字符 [charlist]：字符列中任何单一字符 [^charlist]或[!charlist]：不在字符列中的任何单一字符 SQL语句没有时插入有则更新INSERT INTO 表名(字段) VALUES ON DUPLICATE KEY UPDATE 字段名=值 慢查询分析MySQL提供慢查询日志，日志会记录所有执行时间超过long_query_time（默认10s）的SQL及相关信息 SHOW VARIABLES LIKE &#39;long_query_time&#39;; ：慢查询时间SHOW VARIABLES LIKE &#39;slow_query_log&#39;; ：查看慢查询日志是否开启SHOW VARIABLES LIKE &#39;slow_query_log_file&#39;; ：查看慢查询日志的位置 在MySQL的配置文件my.cnf的[mysqld]项下可以配置慢查询日志 1234[mysqld]slow_query_low=1slow_query_log_file=/dir/xxx.loglong_query_time=2 分析： explain select xxx ...explain出现的分析结果如下： type列：连接类型，一个好的SQL语句至少达到range级别，杜绝出现all级别，（还有const级别，const是常数，比如 SELECT * FROM actor WHERE id = 1） key列：使用到的索引名，如果没有选择索引，值是NULL key_len列：索引长度 rows列：扫描行数，是个预估值 extra列：详细说明，常见不太友好的有：Using filesort,Using temporary 慢查询优化 最左前缀匹配原则：mysql会一致向右匹配直到遇到范围查询(&gt;,&lt;,between,like)就停止匹配，因此如果建立(a,b,c,d)的索引，查询的时候是a=1 and b=2 and c&gt;3 and d=4，d是用不到索引的 =和in可以乱序，MySQL的查询优化器会优化，IN包含值不应过多（IN做了优化，是使用数组排序，如果数值较多，消耗也大，对于连续的比如IN (1,2,3)，可以使用BETWEEN就使用它） 尽量选择区分度高的列作为索引，区分度公式：count(distinct col)/count(*)，比例越大，扫描的记录数越少，唯一键的区分度是1 索引列不能参与计算，保持列”干净” 尽量扩展索引，不要新建索引。如表中已有a索引，要加(a,b)索引，只需要修改原来的索引即可 当只需要一条数据，使用limit 1 SELECT指明字段名，如果SELECT *，会造成很多不必要的消耗 个人感觉面试的时候上面的够了，如果还不够这里还有一些 ER图实体-联系图，表示实体类型，属性和联系的方法，用来描述现实世界的概念模型 正方形内是实体类型，圆形内是属性，主属性名称有下划线，菱形是联系，两个实体之间有1对N，1对1，N对M的关系]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer（持续更新）]]></title>
    <url>%2F2019%2F09%2F01%2F%E5%89%91%E6%8C%87offer%2F</url>
    <content type="text"><![CDATA[剑指offer这里只写解题思路，代码在这里 善于利用 Ctrl+F 快速定位到想要的内容 1.二维数组中的查找Find题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 12345示例：1 2 8 92 4 9 124 7 10 136 8 11 15 解题思路观察这个矩阵的规律，从左下（右上）开始的结点，它上面的结点值都比它小，它右边的结点值都比它大，类比折半查找的思想 2.替换空格replaceSpace题目描述请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 解题思路如果可以开辟新的字符串，直接从头到尾遍历即可..如果只能在原来的字符串上操作，那就先遍历一次该字符串，找到对应的空格的个数spaceCount，然后对该字符串（StringBuilder）扩容（oldLength+2*spaceCount），设置扩容后的待插入位置指针和待插入元素指针，从后往前遍历插入（这样可以避免从前往后插入遇到空格时因为要替换成%20而导致后面的元素后移） 3.从尾到头打印链表printListFromTailToHead题目描述输入一个链表，按链表从尾到头的顺序返回一个ArrayList。 解题思路 自己设置一个头结点，然后使用头插法，再遍历输出 栈 递归 4.重建二叉树reConstructBinaryTree题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 123示例：前序遍历序列&#123;1,2,4,7,3,5,6,8&#125;中序遍历序列&#123;4,7,2,1,5,3,8,6&#125; 解题思路 使用递归，reConstructBinaryTree(int[] pre,int preStart,int preEnd,int[] in,int inStart,int inEnd) preStart为该子树的root，在in中找到preStart对应的值并记录其在中序的位标i 这样，root.left的inStart为inStart，inEnd为i-1，root.right的inStart为i+1，inEnd为inEnd 现在的目标是找到root.left和root.right的preStart和preEnd 首先可以确定的是：root.left的preStart为preStart+1，以及root.right的preEnd为preEnd 然后根据对应子树前序和中序序列的长度相等，把剩下的root.left的preEnd和root.right的preStart确定即可 （前序root.left所有子树的遍历必然在root.right所有子树之前，所以前序序列中属于root.left的必然连续，且在root.right之前） 5.用两个栈实现队列StackToQueue题目描述用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 解题思路栈是FILO，队列是FIFO，栈1作为主要栈使用，栈2作为辅助栈使用，每次push的时候都插入到栈1的栈顶，然后每次pop的时候，都把栈1所有元素全部pop到栈2，这样栈1的栈底就是栈2的栈顶，把栈2的栈顶出栈，就实现了2个栈的FIFO，然后再把栈2所有元素pop回栈1 6.旋转数组的最小数字minNumberInRotateArray题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 解题思路观察旋转数组的规律：把该数组分为两部分，后半部分的值都比前半部分要小，目标是找到后半部分的第一个数字，可以使用折半查找，如果array[mid]&gt;array[right]，则mid在前半部分，让left=mid+1，如果array[mid]==array[right]，则mid在后半部分，且从mid到right的数字都是重复一样的，让right=right-1，如果array[mid]&lt;array[right]，则mid在后半部分，让right=mid，这样一直缩减旋转数组的范围，最终缩减到只有一个值的范围时，就是后半部分的第一个值，即最小值 7.斐波那契数列Fibonacci题目描述大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39 解题思路递归的话，性能相对不好，最好还是用循环因为斐波那契是前两项相加，所以使用pre，now两个指针，初始化分别为0,1，设置一个temp保存now的值，每次n–，就让temp暂存now当前值，然后now=now+pre，然后pre=temp，当判断n==0，就输出now 8.跳台阶JumpFloor题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 解题思路DP问题最优子结构：跳上n-1级台阶的跳法+跳上n-2级台阶的跳法边界：跳上t级台阶时跳法为t（t&lt;=2）状态转移方程：f(n)=f(n-1)+f(n-2)（或者找规律来做） 9.变态跳台阶JumpFloorII题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 解题思路找规律，最后会发现跳法=2^(target-1)可以使用位运算加快上述算法速度： int a = 1; return a &lt;&lt; (target - 1); 10.矩形覆盖RectCover题目描述我们可以用2&times;1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2&times;1的小矩形无重叠地覆盖一个2&times;n的大矩形，总共有多少种方法？ 解题思路实质上和跳台阶是一样的最优子结构：2&times;(n-1)和2&times;(n-2)的矩形的种数之和边界：2&times;1时f(1)=1，2&times;2时f(2)=2状态转移方程：f(n)=f(n-1)+f(n-2) 11.二进制中1的个数NumberOf1题目描述输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 解题思路把一个数考虑成二进制数，考虑它的个位是否为1的算法是： (n &amp; 1) == 1 ，如果是，则另计数器+1，然后n无符号右移1位 12.数值的整数次方Power题目描述给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 保证base和exponent不同时为0 解题思路首先判断exponent是正还是负，一个Boolean类型的变量positive保存它是否为正，还要考虑特殊情况，如果为0，直接返回1，如果为负，且base为0，则抛出异常，否则让exponent变为正数 快速幂算法！！如 10^1101 // 2的13次幂 的结果为： 10^1101 = 10^0001 * 10^0100 * 10^1000 ，改为使用java描述就是： 使用一个curr初值为base 然后判断exponent==0，不等于就执行3 4 5步 判断if((exponent &amp; 1) == 1)，即判断exponent二进制数的个位是否为1，符合就让res *= curr 然后每次都让curr *= curr（每次右移都翻倍） 最后让exponent右移1位 最后判断positive，如果为正，则返回res，否则返回1/res 13.调整数组顺序使奇数位于偶数前面reOrderArray题目描述输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 解题思路使用插入排序的思想，前面是有序区，后面是待排序区，有序区的元素全部都是偶数，当遇到奇数时，就让前面的偶数记录后移即可 14.链表中倒数第k个结点FindKthToTail题目描述输入一个链表，输出该链表中倒数第k个结点。 解题思路快慢指针法，让快指针先走k-1步走到第k个结点，然后两个一起走，直到快指针走到尾（fast.next==null），慢指针所在的结点就是倒数第k个结点 15.反转链表ReverseList题目描述输入一个链表，反转链表后，输出新链表的表头。 解题思路头插法步骤 保存当前工作结点的next域 让工作结点p的next指向HEAD.next（插入过程1） 让HEAD.next指向p（插入过程2） 让p=next（此时已经断开了，所以需要next来保存） 16.合并两个排序的链表Merge题目描述输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 解题思路归并的思路 首先创建头结点head，工作结点p=head，辅助结点l1和l2 然后按照归并的思路做就行了 最后返回head.next 17.树的子结构HasSubtree题目描述输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 解题思路基本思路就是遍历大树，找到与子树跟节点相同的节点，然后传入判断函数进行遍历比较，判断函数的边界是：当判断函数中判断到大树为null，则返回false，表示未成功匹配。当判断到小树为null，则返回true，表示成功匹配，然后如果都不为null，且它们的val相等，就递归判断左右子树 在judge函数中，一定要先判断root2，因为当root1和root2同时为null，返回的结果也是true 18.二叉树的镜像Mirror题目描述操作给定的二叉树，将其变换为源二叉树的镜像。 123456789101112二叉树的镜像定义：源二叉树 8 / \ 6 10 / \ / \ 5 7 9 11 镜像二叉树 8 / \ 10 6 / \ / \ 11 9 7 5 解题思路镜像二叉树的过程： 12345678910111213141516171819201. 8 / \ 6 10 / \ / \ 5 7 9 112. 8 / \ 10 6 / \ / \ 9 11 5 73. 8 / \ 10 6 / \ / \ 11 9 7 5 即只需要依次交换非叶结点的左右子树即可实现镜像，（从上往下交换和从下往上交换均可） 19.顺时针打印矩阵printMatrix题目描述输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 解题思路定义4个变量up，down，left，right，然后不断收缩边界每走一次就让对应的边界变量-1，然后判断该边界变量是否超过(大于小于)它对应的对立边界变量的值，超过则表示遍历完成，中断循环 20.包含mid函数的栈minStack题目描述定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 解题思路使用2个栈去实现，一个是数据栈，一个是最小栈 12345678如入栈顺序依次为 2 3 1 5 3则 数据栈 最小栈 2 2 3 2 1 1 5 1 3 1 栈顶 栈顶 最小栈栈顶保存的是当前数据栈中的最小值，它的长度和数据栈一致 push操作时先让它进入data栈，然后peek最小栈栈顶，如果当前入栈元素小于最小栈栈顶元素，就让当前元素入栈，否则继续让peek出的值入栈 pop操作让两个栈同时出栈即可 top操作返回数据栈栈顶 min操作返回最小栈栈顶 21.栈的压入，弹出序列IsPopOrder题目描述输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 解题思路模拟这个过程就可以了，遍历第一个序列，并入栈，然后判断第二个序列是否等于栈顶元素，等于就让栈顶出栈，直到不等于栈顶为止，如果栈最后是空的，则符合 22.从上往下打印二叉树PrintFromTopToBottom题目描述从上往下打印出二叉树的每个节点，同层节点从左至右打印。 解题思路层次遍历二叉树，不详述了 23.二叉搜索树的后序遍历序列VerifySquenceOfBST题目描述输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 解题思路二叉搜索树：左子树比根都小，右子树比根都大后序：左右根则遍历序列数组的特征：最后一个结点为根，前面有连续的一部分是比根都要小，后面有连续的一部分是比根都要大根据这个特性，我们的算法设计如下：如果该子树对应的子序列的起始位置(start)大于等于终点位置(end)，则表示该子树对应的子序列是后序遍历数组，否则遍历找出左右子树的分界点（后半部分的第一个结点）并记录下来，然后继续遍历后半部分，当后半部分发现有结点值比root小，则此序列就不是后序遍历序列了，然后递归判断其左子树和右子树即可（只有左子树和右子树对应的子序列都是后序遍历序列，才能说该根节点的子树的子序列是后序遍历序列） 24.二叉树中和为某一值的路径FindPath题目描述输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) 解题思路paths是一个整型数组的数组，path是paths的元素，路径是从根到叶，则每进入一个子结点，都让值减去该子结点的val，直到判断进入到叶，如果叶的val等于该值，就把此时的path加入到paths中，否则分别对左右子树创建path，并递归左右子树（难点是这里：左子树继续使用从根延续下来的path，而右子树则新创建一条path，把根延续下来的path添加进来(addAll() method)，然后进入递归） 25.复杂链表的复制Clone题目描述输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 123456789public class RandomListNode &#123; int label; RandomListNode next = null; RandomListNode random = null; RandomListNode(int label) &#123; this.label = label; &#125;&#125; 解题思路map法：遍历链表，插入到hashmap中，key为原来链表的结点，value为一个新的node，其中label与key的label一致，然后复制的时候，把random域也设置就行了 26.二叉搜索树与双向链表Convert题目描述输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 解题思路使用一个数组中序保存，然后对数组的每个结点分别设置头尾结点即可 27.字符串的排序Permutation题目描述输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 输入描述： 1输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。 解题思路 把不变的字符串转换成可变的字符数组（str.toCharArray()） 依次遍历交换首元素和后面的每一个元素，例如abc，交换后有abc,bac和cba 然后固定住首元素，对后面的元素采用第2步的递归交换，得到abc,acb,bac,bca,cab,cab 一直递归下去 递归结束条件是判断到固定的元素的位标位于字符数组的最后一个，然后就把此结果转换为字符串（String.valueOf），然后存入结果数组 一定要注意，在遍历交换字符数组的时候，进入递归，在退出此递归之后，一定要把交换过的换回来，避免影响外部遍历 28.数组中出现次数超过一半的数字MoreThanHalfNum_Solution题目描述数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 解题思路因为要找出的数字超过数组一半，采用分形叶的思路，分形叶的思想是这样的：每次对数组同时抵消2个不同的数字，当数组剩下一个或多个数字是相同的时候，这个数字就是超过一半的元素首先暂定0号元素为被抵消元素，它的可抵消次数初始为1，然后从下标1开始遍历数组，如果判断到可抵消次数为0，就让遍历到数字作为新的被抵消元素，重置可抵消次数为1，否则(else if)当遍历的元素不等于被抵消元素，就让被抵消次数减1（即抵消了一次），当相等，就让被抵消次数加1，遍历结束后的被抵消数字，就是可能成为出现次数超过数组一半的数字，因此我们要重新计数判断它的出现次数，符合才返回它，否则返回0 29.最小的K个数GetLeastNumbers_Solution题目描述输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 解题思路使用优先队列实现即可，如果是库，则使用PriorityQueue 12345678// 默认是自然顺序，如果要使用其他顺序，传入Comparator，实现它的compare方法// 使用的方法是offer,peek,poll,size,containsPriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(new Comparaor&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return o2.compareTo(o1); &#125;&#125;) 一个控制空间复杂度在O(k)（k是最小的k个元素）的方法是：创建只有k个元素的大顶堆，遍历input数组，如果堆的容量不等于k，就直接offer进去，如果等于k，判断堆顶元素是否比待插入元素大，如果是则出堆，让待插入元素进堆，这样遍历结束后，堆就是只有最小的4个元素的堆 注意边界检查，如果k&gt;n或者k&lt;1则返回空List 30.连续子数组的最大和FindGreatestSumOfSubArray问题描述HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1) 解题思路一个记录最大值的域max（初始为array[0]），一个工作最大值temp（初始为array[0]），一个工作指针i（初始为1），指针i遍历array，每次遍历都先判断temp是否小于等于0，如果满足，则舍弃这个temp，取当前值作为temp，否则把当前值加到temp，然后把max和temp的更大值存到max 31.整数中1出现的次数NumberOf1Between1AndN_Solution问题描述求出1 ~ 13的整数中1出现的次数,并算出100 ~ 1300的整数中1出现的次数？为此他特别数了一下1 ~ 13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 解题思路从每一位出现1的次数去考虑，个位出现1次数受高位影响，十位出现1次数可能受个位和自己本身和高位的影响，百位出现1次数可能受低位，自身，高位影响，找出规律百位出现1的次数受高位和低位和自身的影响（这里的百位可以类比任何一位）如果百位为0，百位出现1的次数受高位影响，如12013，共有100-199，1100-1199，2100-2199，3100-3199，。。。，10100-10199，11100-11199，12&times;100，即高位数字&times;当前位数如果百位为1，百位出现1的次数受低位和高位影响，如12113，共有上面所说的1200个再加上12100-12113，即共有高位&times;位数+低位+1个如果百位大于1，百位出现1的次数受高位影响，如12313，共有100-199，。。。，11100-11199，12100-12199，共有(高位+1)&times;位数 使用一个变量v记录当前位数，然后高位 high = n / (v * 10)，当前位 now = n / v % 10，低位 low = n - n / v * v，然后根据now的值计算每一位count即可，每次迭代结束v指向下一位 v = v * 10，当v &gt; n，迭代结束 32.把数组排成最小的数PrintMinNumber问题描述输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 解题思路先把它们都放到一个List里，然后实现一个自定义Comparator进行排序，排序依据如下：如果ab&gt;ba，则a&gt;b，如果ab&lt;ba，则a&lt;b，如果ab=ba，则a=b，如： a=3,b=32,ab=332,ba=323，因为ab&gt;ba，所以a&gt;b，a放在b后面，因此，自定义的comparator可以这样写： 12345int compare(Integer o1, Integer o2) &#123; String ab = o1 + "" + o2; String ba = o1 + "" + o2; return ab.compareTo(ba);&#125; 排序完后把该List的值依次输出的StringBuilder并返回即可 33.丑数GetUglyNumber_Solution题目描述把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 解题思路如果p是丑数，那么p=2^x &times; 3^y &times; 5^z对于任何丑数p：（一）那么2&times;p,3&times;p,5&times;p都是丑数，即一个丑数由另一个丑数&times;2或&times;3或&times;5而得，并且2&times;p&lt;3&times;p&lt;5&times;p（二）如果p&lt;q, 那么2p&lt;2q,3p&lt;3q,5p&lt;5q一个丑数一定由另一个丑数乘以2或者乘以3或者乘以5得到，那么我们从1开始乘以2,3,5，就得到2,3,5三个丑数，在从这三个丑数出发乘以2,3,5就得到4,6,10,6,9,15,10,15,25九个丑数， 维护3个指针和1个丑数数组，丑数数组初始化1个元素，为1，这3个指针指向丑数数组的值，默认值都为0（即指向1），使用3个变量分别代表丑数数组中这3个指针指向的对应值乘以2，3，5后的值，把该值插入到丑数数组，然后对应指针+1 34.第一个只出现一次的数字FirstNotRepeatingChar题目描述在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）. 解题思路哈希法，可以使用LinkedHashMap（如果使用它，要遍历它，使用iterator或Map.Entry），如果不使用它的话，可以直接HashMap，然后在str.charAt(i++)作为key，找到第一个value为1的，就返回该key 35.数组中的逆序对InversePairs题目描述在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 输入描述： 123456789题目保证输入的数组中没有的相同的数字数据范围： 对于%50的数据,size&lt;=10^4 对于%75的数据,size&lt;=10^5 对于%100的数据,size&lt;=2*10^5 示例： 1234输入：1,2,3,4,5,6,7,0输出7 解题思路使用归并的思路，对数组 1,2,3,4,5,6,7,0 ，先比较 12,34,56,70 找出逆序对，然后把该逆序对交换顺序，然后回到外层递归继续判断 1234,5607查找逆序对的算法：两个数组使用一个指针指向末尾，比较两个值的大小，如果第一个子数组的值大于第二个数组的值，则构成逆序对，且逆序对为第二个子数组中剩余的数字个数每一次比较的时候，我们都把较大的数字从后面往前复制到一个辅助数组中，确保辅助数组（记为copy）中的数字是递增排序的，在把较大的数字复制到辅助数组之后，把对应的指针向前移动一位，接下来进行下一轮比较 36.两个链表的第一个公共结点FindFirstCommonNode题目描述输入两个链表，找出它们的第一个公共结点 解题思路要找出第一个公共结点，只需要让更长的链表先走两个链表长度差，然后再逐个比较链表的值是否相等，如果相等则返回该结点 37.数字在排序数组中出现的次数GetNumberOfK题目描述统计一个数字在排序数组中出现的次数 解题思路修改版的折半查找，通过折半查找找到第一个k和最后一个k的索引值，然后两者相减+1即为结果折半查找第一个k的算法：当array[mid]&gt;k，则high=mid-1，当array[key]&lt;k，则low=mid+1，当array[mid]==k且(array[mid-1]&gt;=0&amp;&amp;array[mid-1]==k)时，high=mid-1折半查找最后一个k的算法：当array[mid]&gt;k，则high=mid-1，当array[key]&lt;k，则low=mid+1，当array[mid]==k且(array[mid+1]&lt;len&amp;&amp;array[mid+1]==k)时，low=mid+1 38.二叉树的深度TreeDepth题目描述输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 解题思路使用可以计算层次的层次遍历即可（两个方法，一个是添加null作为层次的分界，但相对不太好理解，另一个是使用count，nextCount初始化为1，每次访问队列的结点，就让count++，当count==nextCount，表示当层访问完毕，让nextCount=queue.size(),count=0，然后深度+1，最后输出这个深度即可 39.平衡二叉树IsBalanced_Solution题目描述输入一棵二叉树，判断该二叉树是否是平衡二叉树 解题思路关键还是要理解二叉树的子树仍然是一棵二叉树的概念，一棵二叉树是平衡二叉树，则它的子树也是平衡二叉树，它的左右子树高度差不超过1，这里我直接贴代码了，代码也很好理解，对我个人而言，这题最大的意义是：进入递归，当判断到只要有一个子条件不符合，则最终结果也不符合的解决方案 真正的思路：进入递归计算子树的高度，如果子树为空，则该空树的高度为0，返回0，否则进入其左子树计算左子树的高度，进入右子树计算右子树的高度，该非空树的高度为左子树的高度减去右子树的高度的绝对值+1，一个比较技巧的方法是：只要判断到某子树其左右子树的高度差绝对值大于1，则直接返回-1，一直返回到根，这样能够加快效率 123456789101112131415public class Solution &#123; public boolean IsBalanced_Solution(TreeNode root) &#123; return getDepth(root) != -1; &#125; // 从下往上遍历，如果子树是平衡二叉树，则返回子树的高度；如果发现子树不是平衡二叉树，则直接停止遍历，这样至多只对每个结点访问一次 private int getDepth(TreeNode root) &#123; if (root == null) return 0; int left = getDepth(root.left); if (left == -1) return -1; int right = getDepth(root.right); if (right == -1) return -1; return Math.abs(left - right) &gt; 1 ? -1 : 1 + Math.max(left, right); &#125;&#125; 40.数组中只出现一次的数字FindNumsAppearOnce题目描述一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 解题思路两个相同数字异或结果为0，一个数和0异或结果是它本身，对数组所有元素进行异或，得到的结果就是这两个只出现一次的数字A，B异或的结果；该异或结果中二进制的1，实际意义是A和B二进制形式中不同的位（即A在该位如果表现为0(1)，则B在该位必然表现为1(0)），找出异或结果二进制中出现的第一个1，记录其位移量offset，然后再遍历该数组，以 (i&gt;&gt;offset)&amp;1 == 1 作为分组依据，对原数组分为两组数据，对这两组数据分别异或，最后的结果就是这两个不同的数字了 41.和为S的连续正数序列FindContinuousSequence题目描述小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! 输出描述 1输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序 解题思路滑动窗口Sliding Window，定义一个left=1，right=2，当sumOfSequence = (left + right) * (right - left + 1) / 2 等于 sum时，就把left到right的数值加入到结果，当sumOfSequence小于sum时，就让right++，否则让left++ 42.和为S的两个数字FindNumbersWithSum题目描述输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 输出描述 1对应每个测试案例，输出两个数，小的先输出。 解题思路这题同上一题一样也可以用两个指针解决，当两个指针相加的值相同，在最两边的时候乘积一定比在中间的小（如1,2,3,4，1+4=2+3,14&lt;23） 43.左旋转字符串LeftRotateString题目描述汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 解题思路一个O(1)复杂度的思路是：把这个str自身拼接，如”abcd1234”，自身拼接后就是”abcd1234abcd1234”，记为str2，取其循环左移的值t（如果大于str.length()，则要对其求余），返回str2.substring(t, str.length() + t) 44.翻转单词顺序列ReverseSentence题目描述牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 解题思路在Java中主要是通过 char[] in = str.toCharArray() 来操作翻转，首先翻转整个str，然后遇到空格时再逐个单词翻转回来即可（做一个reverse(char[] input, int begin, int end)函数） 易错点是要处理最后一个单词的转换，可以在原str的开头添加” “，第一次翻转后它就在str的末尾了，也可以作i==str.length的判断是否到达末尾，然后翻转最后一个单词 45.扑克牌顺子isContinuous题目描述LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。 解题思路首先排个序，统计大小王的个数k，统计过程中，只要判断到 numbers[i] != 0 &amp;&amp; numbers[i] == numbers[i+1] 则直接返回false，是顺子的话，numbers[4] - numbers[k] &lt; 5（因为还有大小王是0的情况，0,0,1,2,3也是顺子） 12345678910111213public boolean isContinuous(int [] numbers) &#123; if (numbers == null || numbers.length != 5) return false; int zeroCount = 0; Arrays.sort(numbers); // 考虑5个王的情况 if (numbers[4] == 0) return true; // 不用判断第5个，因为上面已经判断了，只要第5个数字也是0，则5个鬼，直接返回true for (int i = 0; i &lt; 4; i++) &#123; if (numbers[i] == 0) zeroCount++; else if (numbers[i] == numbers[i + 1]) return false; &#125; return numbers[4] - numbers[zeroCount] &lt; 5;&#125; 46.孩子们的游戏(圆圈中最后剩下的数)LastRemaining_Solution题目描述每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 如果没有小朋友，请返回-1 解题思路实质上就是约瑟夫环的问题用链表，首先把所有小朋友都加入到链表，然后按着顺序一个一个删就好了 还有就是使用数学归纳法，约瑟夫环第1次删除第m个结点的时候，把它变成子问题，子问题中第0个结点就是父问题的第m个结点，所以代码如下： 12345public int LastRemaining_Solution(int n, int m) &#123; if (n &lt;= 0) return -1; if (n == 1) return 0; return (LastRemaining_Solution(n - 1, m) + m) % n;&#125; 47.求1+2+3+…+nSum_Solution问题描述求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 解题思路利用逻辑与的短路特性（即判断到&amp;&amp;的左边不符合，就不会执行&amp;&amp;的右边了）代替if语句作为递归的出口 12345public int Sum_Solution(int n) &#123; int sum = n; boolean flag = (sum &gt; 0) &amp;&amp; (sum += Sum_Solution(n - 1)) &gt; 0; return sum;&#125; 48.不用加减乘除做加法Add题目描述写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 解题思路加法三步走：（以5+7为例）1.相加各位的值，不算进位，得22.计算进位，7+5的进位为103.重复上述2个步骤，只是相加的值变成上述两个步骤的结果2和10，得到12 二进制加法也同理（101+111）1.相加各位的值，不算进位得0102.计算进位得10103.010和1010继续执行上述两步 不算进位的加法是异或，计算进位是与操作再左移1位，当进位结果为0的时候，不算进位的相加结果就是答案 49.把字符串转换成整数StrToInt题目描述将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。 输入描述 1输入一个字符串,包括数字字母符号,可以为空 输出描述 1如果是合法的数值表达则返回该数字，否则返回0 示例1 1234567输入+2147483647 1a33输出2147483647 0 解题思路分开处理第一个和后续字符即可，第一个字符可能是’+’，’-‘和数字，后续字符只能是数字 可以作如下优化： c - &#39;0&#39; 等价于 c &amp; 0xf result = result * 10 + (c - &#39;0&#39;) 等价于 result = (result &lt;&lt; 1) + (result &lt;&lt; 3) + (c &amp; 0xf) 左移1位是&times;2，左移3位是&times;8，加起来就是&tims;10 50.数组中重复的数字duplicate题目描述在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2 12345678910111213public class Solution &#123; // Parameters: // numbers: an array of integers // length: the length of array numbers // duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation; // Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++ // 这里要特别注意~返回任意重复的一个，赋值duplication[0] // Return value: true if the input is valid, and there are some duplications in the array number // otherwise false public boolean duplicate(int numbers[],int length,int [] duplication) &#123; &#125;&#125; 解题思路这里只谈论最优解法，观察这个数组的特征，它的值都是限定在0到n-1范围内，这样，我们假设当前序列是一个值和下标相等的序列，遍历数组，如果相等，则什么都不做，直接遍历下一位，如果不等，则把i位置上的元素temp(numbers[i])和temp位置上的元素比较，当它们相等的时候，就把temp直接返回，否则交换它们，换完后下标为numbers[temp]的元素值为temp，numbers[i]的元素值为numbers[temp]，继续遍历 51.构建乘积数组multiply题目描述给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法。 解题思路123456789算法思路：把B[i]的值看作是下面矩阵每行的乘积B[0] | 1 A[1] A[2] A[3] ... A[n-3] A[n-2] A[n-1]B[1] | A[0] 1 A[2] A[3] ... A[n-3] A[n-2] A[n-1]B[2] | A[0] A[1] 1 A[3] ... A[n-3] A[n-2] A[n-1]...B[n-3] | A[0] A[1] A[2] A[3] ... 1 A[n-2] A[n-1]B[n-2] | A[0] A[1] A[2] A[3] ... A[n-3] 1 A[n-1]B[n-1] | A[0] A[1] A[2] A[3] ... A[n-3] A[n-2] 1这样，先计算下三角的值（B[i]的一部分），再计算上三角的值即可得出结果 52.正则表达式匹配match题目描述请实现一个函数用来匹配包括 . 和 * 的正则表达式。模式中的字符 . 表示任意一个字符，而 * 表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串 &quot;aaa&quot; 与模式 &quot;a.a&quot; 和 &quot;ab*ac*a&quot; 匹配，但是与 &quot;aa.a&quot; 和 &quot;ab*a&quot; 均不匹配 解题思路123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869当模式中的第二个字符不是“*”时：1、如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的。2、如果 字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。而当模式中的第二个字符是“*”时：如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配。如果字符串第一个字符跟模式第一个字符匹配，可以有2种匹配方式：1、模式后移2字符，相当于x*被忽略，匹配0个；2、字符串后移1字符，模式不变，即继续匹配字符下一位，因为*可以匹配多位，匹配多个（继续匹配下一个）；递归的终点判断如下：如果串到终点且模式到终点，则配对成功，返回true如果串到达终点而模式还没到终点，则表示匹配失败而如果串到终点，模式还没到终点，则不一定，因为可能有 &quot;&quot; 和 &quot;x*&quot; 的情况，需要继续判断``` ## 53.表示数值的字符串isNumeric### 题目描述请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串&quot;+100&quot;,&quot;5e2&quot;,&quot;-123&quot;,&quot;3.1416&quot;和&quot;-1E-16&quot;都表示数值。 但是&quot;12e&quot;,&quot;1a3.14&quot;,&quot;1.2.3&quot;,&quot;+-5&quot;和&quot;12e+4.3&quot;都不是。### 解题思路输入特征：- e之前的数字，第一位可以带±- e之前可以有一个小数点，小数点之前的数字可以带正负，也可以没有数字（只有正负号），小数点之后的数字不可以带正负- e之后的数字可以带正负，不能有小数点- e之前的±后可以直接带点，点前可以没有任何数字，但是点后必须要有数字考虑上面特征，大概的代码思路就是：```java/*int index，全局变量boolean isNumber，判断是否是数字，包括开头的+-号（判断开头的正负号后，再进入isUnsignedNumber判断是否是数字boolean isUnsignedNumber，判断是否是纯数字*/private int index;public boolean isNumeric(char[] str) &#123; if (str.length == 0 || str == null) return false; boolean flag = isNumber(str); // 如果遇到小数点，则判断小数点后面是否是纯数字 if (index &lt; str.length &amp;&amp; str[index] == &apos;.&apos;) &#123; index++; // 小数点之前可以无数字，因此这里使用 || flag = isUnsignedNumber(str) || flag; &#125; // 如果有E，判断E之后的是否为数字 if (index &lt; str.length &amp;&amp; (str[index] == &apos;E&apos; || str[index] == &apos;e&apos;)) &#123; index++; // E之前必须有数字，因此这里使用 &amp;&amp; flag = isNumber(str) &amp;&amp; flag; &#125; // e之后有数字，且只有数字 return flag &amp;&amp; index == str.length;&#125;private boolean isNumber(char[] str) &#123; if (index &lt; str.length &amp;&amp; (str[index] == &apos;+&apos; || str[index] == &apos;-&apos;)) index++; return isUnsignedNumber(str);&#125;private boolean isUnsignedNumber(char[] str) &#123; int start = index; while (index &lt; str.length &amp;&amp; str[index] &lt;= &apos;9&apos; &amp;&amp; str[index] &gt;= &apos;0&apos;) index++; return start &lt; index;&#125; 54.字符流中第一个不重复的字符FirstAppearingOnce题目描述请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。 解题思路使用LinkedHashMap 55.链表中环的入口结点EntryNodeOfLoop题目描述给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 解题思路快慢指针，快指针走2步慢指针走1步，当两指针相遇表示有环，然后让其中一个指针重新指向头，另一个指针原地不动，两个同时以同样速度往前走，再次相遇的时候的结点就是环的入口结点（画图算一下就知道了） 56.删除链表中重复的结点deleteDuplication题目描述在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 解题思路思路是挺直接的，关键是代码能不能写出来（需要考虑到的情况是，最后是需要返回头结点的，即可以维护一个自己的头结点head，然后返回head.next即可） 57.二叉树的下一个结点GetNext题目描述给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 解题思路规定一棵树左子树在根的左边，右子树在根的右边，则中序遍历的结果实质就是从左往右遍历这棵树，根的直接前驱是左子树的最右边，直接后继是右子树的最左边 二叉树中序遍历下一个结点的特征：它是该结点右子树的最左边，如果该结点右子树为空，则它的直接后继应该往父节点回溯，直到某个祖宗结点是该祖宗父的左子树 1234567 a b c d f e g如上面的树，a的直接后继是右子树的最左边当它没有右子树，如e或g，则往上回溯，找到祖宗b，b是它的父a的左子树，则a就是e的直接后继，g的话，g本身就是f的左子树，所以g的直接后继是f 58.对称的二叉树isSymmetrical题目描述请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 解题思路递归求解，如果左子树为空，右子树非空或者左子树非空，右子树空，则返回false，如果左右子树都为null，返回true，如果左右子树的val不相等，返回false，然后递归求解 isSymmetrical(left.left, right.right) &amp;&amp; isSymmetrical(left.right, right.left) 某次笔试做不出来的原因：对isSymmetrical(TreeNode left, TreeNode right)的理解错了，它的left和right不一定是物理上的左右子树，因为判断是否对称的时候，都是同一层进行判断的，因此只要递归判断左子树的左子树是否等于右子树的右子树并且左子树的右子树是否等于右子树的左子树即可，可以把参数left和right改名为node1和node2，可能会更好理解 59.按之字形顺序打印二叉树Print题目描述请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 解题思路其实就是带分层的层次遍历二叉树的变形而已，从右往左插入既可以通过LinkedList的descendingIterator实现，也可以通过栈（双端队列）实现 60.把二叉树打印成多行Print题目描述从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 解题思路层次遍历二叉树，不详述了 61.序列化二叉树Serialize题目描述请实现两个函数，分别用来序列化和反序列化二叉树 二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。 二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。 1234public class Solution &#123; String Serialize(TreeNode root) &#123;&#125; TreeNode Deserialize(String str) &#123;&#125;&#125; 解题思路因为序列化和反序列化一般是在不同环境下进行的，所以不能使用全局变量，使用 ‘#’ 代替空树，每个结点之间使用 ‘!’ 分隔，则随便选取一个遍历，使用StringBuilder来完成，序列化的时候，遇到空树，则StringBuilder添加 ‘#!’，然后直接返回toString()，否则添加该结点的值，然后添加 ‘!’ ，然后递归其左右子树；反序列化的时候，就 String[] nodes = str.split(&quot;!&quot;) ，全局变量index（在反序列的环境可以使用，或者添加一个Deserialize(String str, int index）的函数），开始构建该结点， 62.二叉搜索树的第k个结点KthNode题目描述给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。 解题思路中序遍历，每次访问的时候就–k，当k==0，就返回这个结点 63.数据流中的中位数GetMedian题目描述如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。 解题思路使用一个大顶堆和一个小顶堆，要求大顶堆的元素都比小顶堆要小，小顶堆的元素都比大顶堆要大，大顶堆堆顶和小顶堆堆顶元素就是整个数据流的最中间2个数 要实现上述的数据结构，则每次插入的时候，如果当前元素是偶数个元素，就把当前元素插入到大顶堆，然后弹出大顶堆堆顶，插入到小顶堆（即小顶堆的元素要么和大顶堆相同，要么比大顶堆多1），当前元素是奇数个元素（小顶堆比大顶堆多1个元素），则把元素插入到小顶堆，然后从小顶堆弹出堆顶插入到大顶堆，关键操作是把大顶堆堆顶弹出插入到小顶堆和把小顶堆堆顶弹出插入到大顶堆，这样可以保证大顶堆的元素都比小顶堆要小 64.滑动窗口的最大值maxInWindows题目描述给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 解题思路使用一个双端队列，它的队头存放当前滑动窗口最大值的下标，使用i遍历，i为当前滑动窗口的尾（从i=0开始），作局部变量begin指向滑动窗口的头（begin=i-size+1） 每次遍历，对于当前i和begin，如果begin大于双端队列的队头，则把队头移出（最大值已经过期），当队列前面的元素对应的值都比num[i]小，则把它们移出队列，然后判断只要begin大于0，就把当前队头插入到结果List，最后返回这个结果List 65.矩阵中的路径hasPath题目描述请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 1234public boolean hasPath(char[] matrix, int rows, int cols, char[] str)&#123; &#125; 解题思路路径问题，因为格子只能进入一次，所以设置一个布尔数组指示格子有没有被进入，然后两层for循环进入递归判断，当前的index=i&times;cols+j（i和j是两层for循环的i和j，递归子函数需要这两个参数），然后判断边界和当前值是否相等，不满足则返回false，然后判断是否到达str的尾部了，到达就返回true，否则返回往上下左右走的结果，注意最后不满足的话要把布尔数组对应的值重新设为false 66.机器人的运动范围movingCount题目描述地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 解题思路思路大概同上，略 67.剪绳子cutRope题目描述给你一根长度为n的绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0]xk[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 输入描述： 1输入一个数n，意义见题面。（2 &lt;= n &lt;= 60） 输出描述： 1输出答案。 示例1 12输入：8输出：18 解题思路]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>algs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[其他（持续更新）]]></title>
    <url>%2F2019%2F09%2F01%2F%E5%85%B6%E4%BB%96%2F</url>
    <content type="text"><![CDATA[其他正则表达式123456789101112131415161718192021222324252627282930313233343536^ 串的开始$ 串的结束\ 原义字符，八进制字符&quot;abc&quot; 匹配包含aaabcccc abc123* 前的子表达式匹配0-多次（ac*可以匹配acccc或a）+ 前的子表达式匹配1-多次（ac+可以匹配ac，acccc）? 前的子表达式匹配0次或1次（ac?可以匹配ac，a）&#123;n&#125; n是非负整数，表示匹配n次（ab&#123;2&#125;可以匹配abb）&#123;n,&#125; 匹配至少n次（ab&#123;2,&#125;，可以匹配abb，abbb）&#123;n,m&#125; 匹配n-m次（ab&#123;2,5&#125;，可以匹配abb，abbbbb）| 或. 任何符号[abc] a或b或c[^abc] 没有a，b，c[a-z] 存在一个a到z之间的字符[0-9] 存在一个0到9之间的字符[^a-z] 不存在a到z之间的字符^[a-z] 以a-z开头\d 一个数字\D 非数字\w 等价于[0-9a-zA-Z]\W 等价于[^0-9a-zA-Z]\f 换页\n 换行\r 回车\s 任何空白字符（空格，制表等）\S 任何非空白字符\t 制表贪婪匹配： 对于aabab，a.*b 会匹配aabab懒惰匹配： 对于aabab，a.*?B会匹配aab（只要加上问号就可以取消贪婪匹配） JSON1234对象：&#123;&quot;name&quot;: &quot;John Doe&quot;, &quot;age&quot;: 18, &quot;address&quot;: &#123;&quot;country&quot; : &quot;china&quot;, &quot;zip-code&quot;: &quot;10000&quot;&#125;&#125;数组：[3, 1, 4, 1, 5, 9, 2, 6]字符串：双引号数组]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>JSON</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux（持续更新）]]></title>
    <url>%2F2019%2F09%2F01%2FLinux%2F</url>
    <content type="text"><![CDATA[Linux查看文件内容 cat：第一行开始显示，显示所有内容 tac：从最后一行倒序显示所有内容 more：根据窗口大小一页一页显示内容 less：和more相似，但可以往前翻页，可以搜索字符 head：只显示头几行 tail：只显示最后几行 nl：类型于cat -n，显示时输出行号 链接对于ext4的文件系统，主要有2部分组成：小部分保存文件的inode信息，大部分保存block检索时，目录中只设置文件名和指向相应索引结点的指针，inode保存指向对于block的指针和一些文件信息（如访问计数，类型，长度，存取时间等） ln：命令默认产生硬链接，ln -s创建软链接 软链接和硬链接在原理上最主要的不同在于：硬链接不会建立自己的 inode 索引和 block（数据块），而是直接指向源文件的 inode 信息和 block，所以硬链接和源文件的 inode 号是一致的；而软链接会真正建立自己的 inode 索引和 block，所以软链接和源文件的 inode 号是不一致的，而且在软链接的 block 中，写的不是真正的数据，而仅仅是源文件的文件名及 inode 号 软链接 软链接是存放另一个文件的路径的形式存在 软链接可以跨文件系统，硬链接不可以 软链接可以对目录链接 l标识，权限777，真正权限取决源文件 删除源文件软链接只是找不到了目标文件，它的引用计数和源文件一致 硬链接 硬链接以文件副本形式存在 只有在同一文件系统才能创建 不允许给目录链接 删除一个硬链接文件不影响其他有相同inode号的文件 硬链接是一种引用关系，一个源文件建立1个硬链接，引用计数加1，删除一个文件（硬链接文件或者源文件），引用计数减1，当引用计数为0时，真正删除文件 文件权限对于 - rw- rw- r-- 1 cat cat 0 Aug 9 21:27 CAT1 的文件 d rw- rw- r– 1 cat cat 0 Aug 9 21:27 CAT 1 目录文件 用户权限 组权限 其他用户权限 文件链接数 用户ID 组ID 文件大小 文件创建日期时间 文件名 Linux中，每个文件权限都有可读(r)，可写(w)，可执行(x)三种权限，对于权限数值为：4,2,1 文件类型 -：一般文件（硬链接） l：符号文件（软链接） d：目录文件 c：字符设备文件 p：命名管道 s：套接字 b：块设备特殊文件 chmod 可以如下方式执行 1234567891011121314chmod [-cfvR] mode filemode格式如下：[ugoa...][[+-=][rwx]...][,...]u表示文件拥有者，g表示组，o表示其他用户，a表示这三者都是+表示增加权限，-表示取消权限，=表示唯一设定权限-c：若该文件权限确实已经更改，才显示其更改动作-f：若该文件权限无法被更改也不显示错误信息-v：显示权限变更的详细资料-R：递归更改其所有子目录的文件也可以使用数字chmod 777 file]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java常用API（持续更新）]]></title>
    <url>%2F2019%2F09%2F01%2FJava%E5%B8%B8%E7%94%A8API%2F</url>
    <content type="text"><![CDATA[Java常用API主要是一些常用的，容易忘的，像String的equals，substring这些就不写了 String indexOf(char)：返回指定字符的索引 charAt(int)：返回指定索引的字符 replace(oldChar, newChar)：字符串替换 trim()：去掉字符串两端空白 split(regex)：分隔字符串 getBytes()：返回字符串的byte类型数组 toCharArray()：返回字符串的字符数组（新的，不是内置的那个） static valueOf(double[or float int long Object])：参数转换为String 集合类要对List排序，使用 Collections.sort(list) ！！！要对数组排序，使用 Arrays.sort(array) ！！！ List转换为数组： ArrayList的toArray方法（实例方法）数组转换为List：对于引用类型的数组： new ArrayList&lt;&gt;(Arrays.asList())对于基本类型的数组： 写个for循环一个一个手动添加进去吧。。 排序的Comparator中的compare方法： int compare(T o1, T o2)a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. list.sort()中，默认是按照自然顺序（升序）来排序的，如果传入comparator参数，当compare方法返回的值大于0（o1&gt;o2），它就会交换o1和o2的位置 LinkedList有一个反向迭代器descendingIterator 遍历Map123456789Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; iterable=map.entrySet().iterator();while(iterable.hasNext())&#123; Map.Entry&lt;Integer,String&gt;entry=iterable.next(); System.out.println(entry.getKey()+&quot;-&gt;&quot;+entry.getValue());&#125;for(Map.Entry&lt;Integer,String&gt; entry:map.entrySet())&#123; System.out.println(entry.getKey()+&quot;-&gt;&quot;+entry.getValue());&#125;]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring（持续更新）]]></title>
    <url>%2F2019%2F09%2F01%2Fspring%2F</url>
    <content type="text"><![CDATA[Spring什么是Spring是Java企业级应用的开源框架，使用JavaBean来完成以前EJB完成的事 Spring框架好处 轻量 控制反转 面向切面的编程 容器 MVC框架 事务管理 异常处理 IOC和AOP理解IOC：控制反转，是一种设计思想，指应用程序本身不负责依赖对象的创建和维护，而是由外部容器负责创建和维护 IOC底层基于Java反射 IOC容器就像一个工厂，我们创建一个对象，只需要配置好配置文件/注解即可，不用考虑对象是如何被创建出来的，这样可以降低开发难度，增加项目可维护性 DI：依赖注入，是IOC的一种实现方式，指IOC容器在运行期间，动态地将某种依赖关系注入到对象中。注入方式有设值注入（getter，setter）和构造注入（通过构造器注入） AOP：能够将那些与业务无关，却为业务模块所共同调用的逻辑与责任（如事务处理，日志管理，权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并提高可拓展性和可维护性 AOP基于动态代理，如果要代理的对象实现了某个接口，那么Spring AOP就会使用 JDK Proxy 去创建代理对象，而对于没有实现接口的对象，就无法使用JDK Proxy，这时候就会去使用 CGLib 生成一个被代理对象的子类来作为代理 Spring AOP和AspectJ AOP的区别 Spring AOP是运行时织入，AspectJ是编译时织入（在编译阶段生成AOP代理类） Spring AOP基于代理，AspectJ基于字节码操作 AspectJ相比Spring AOP功能更强大（AOP仅支持方法级编织，AspectJ还可以编织字段，构造函数等），性能更好（编译时织入的性能更好） bean作用域 singleton：单例，唯一bean实例，默认就是singleton prototype：每次请求都会创建一个新的bean实例 request：每一次HTTP请求都会创建一个新的bean，该bean仅在当前HTTP Request内有效 session：每一此HTTP请求都会创建一个新的bean，该bean仅在当前HTTP session内有效 global-session：全局session作用于，仅用在protlet，spring 5已经取消 Spring中的单例bean的线程安全问题单例bean存在线程问题，主要是因为当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作存在线程安全问题 两种解决办法： Bean对象中尽量避免定义可变的成员变量 类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在ThreadLocal中 Spring Bean生命周期 Bean容器找到配置文件中的Spring Bean的定义 Bean容器利用反射创建一个Bean的实例 对于属性值利用 set()方法 设置 检查Aware相关接口并设置相关依赖，如Bean实现了 BeanNameAware 接口，调用setBeanName()方法，传入Bean的名字 BeanPostProcessor的前置处理 检查是否有InitializingBean以决定是否调用afterPropertiesSet方法 检查是否配置自定义的init-method方法，有则执行指定方法 BeanPostProcessor的后置处理 使用 销毁时，检查是否实现DisposableBean接口，有则调用destroy()方法 检查是否配置自定义的destroy-method方法，有则执行指定方法 对于Spring MVC的了解要了解一个东西，首先得知道它能干什么，MVC框架能做的事情如下： 将URL映射到java类或java类的方法 封装用户提交的数据 处理请求-调用相关的业务处理-封装响应的数据 将响应的数据进行渲染，jsp，html，freemarker等 SpringMVC是一个轻量级的，基于请求响应的mvc框架 Spring MVC可以把我们的后端项目分为Service层（处理业务），Dao层（数据库操作），Entity层（实体类），Controller层（控制层，返回数据给前台页面） 简单原理如下： 用户访问浏览器，发送request请求url 前端控制器（DispatcherServlet)接收用户请求和响应，并根据请求信息调用HandlerMapping，解析请求对应的Handler（即Controller） 解析到对应的Handler后，开始由HandlerAdapter适配器去处理 HandlerAdapter会根据Handler来调用真正的处理器处理请求，并处理相应业务逻辑 处理器处理完业务后，返回一个ModelAndView对象，Model是返回的数据对象，View是逻辑上的View DispatcherServlet把返回的Model传给View（视图渲染） 把View返回给请求者 Spring框架中用到了哪些设计模式 工厂设计模式：Spring使用工厂模式通过BeanFactory,ApplicationContext创建bean对象 代理设计模式：Spring AOP功能的实现 单例设计模式：Spring中的Bean默认都是单例的 模板方法模式：jdbcTemplate等以Template结尾的类，都使用了模板模式 包装器设计模式：需要连接多个数据库，不同的客户每次访问中根据需要会去访问不同的数据库。这种模式可以让我们根据客户的需求能够动态切换不同的数据源 观察者模式：Spring事件驱动模型就是观察者模式的一个应用 适配器模式：Spring AOP的增强或通知使用了适配器模式，spring MVC也是用到适配器模式适配Controller 策略模式：针对不同的底层资源，Spring 将会提供不同的 Resource 实现类，不同的实现类负责不同的资源访问逻辑 BeanFactory和ApplicationContext区别 ApplicationContext继承自BeanFactory，提供了比BeanFactory更多的功能，如AOP，访问资源（ResourceLoader），载入多个有继承关系的上下文，国际化等 BeanFactory提供getBean()方法，还有一些判断bean作用域的方法，常称它为IoC容器，ApplicationContext称为应用上下文 BeanFactory采用延迟加载形式来注入Bean，只有在使用到某个Bean时才加载，ApplicationContext则在容器启动时一次性创建所有Bean 它们都支持BeanPostProcessor，但BeanFactory需要手动注册，而ApplicationContext则是自动注册 @Component 和 @Bean 的区别是什么 @Component作用于类，@Bean作用于方法等其他（目前看不懂） 将一个类声明为spring的bean的注解有哪些@Autowired注解自动装配bean，要把类标识为可用于@Autowired注解自动装配的bean的类，需要用以下注解实现： @Component @Repository：对应Dao层 @Service：对应服务层 @Controller：对应MVC控制层，接收用户请求并调用Service层返回数据给前端页面 @Autowired不能用于静态变量 Spring事务隔离级别 TransactionDefinition.ISOLATION_DEFAULT：使用后端数据库默认的隔离级别 TransactionDefinition.ISOLATION_READ_UNCOMMITTED TransactionDefinition.ISOLATION_READ_COMMITTED TransactionDefinition.ISOLATION_REPEATABLE_READ TransactionDefinition.ISOLATION_SERIALIZABLE Mybatis的通配符#{}表示一个占位符号，它会在接收到参数后加上引号，#{}可以防止SQL注入${}表示拼接SQL串，它不会自动加上引号，不能防止SQL注入 123456789假如传入参数为1#&#123;&#125;: SELECT * FROM t_user WHERE uid = #&#123;uid&#125;$&#123;&#125;: SELECT * FROM t_user WHERE uid = &apos;$&#123;uid&#125;&apos;转换为：#&#123;&#125;: SELECT * FROM t_user WHERE uid = ?$&#123;&#125;: SELECT * FROM t_user WHERE uid = &apos;1&apos;最后：#&#123;&#125;: SELECT * FROM t_user WHERE uid = &apos;1&apos;$&#123;&#125;: SELECT * FROM t_user WHERE uid = &apos;1&apos; 12345678&lt;select id="allUserInfo" parameterType="java.util.HashMap" resultMap="userInfo1"&gt;&lt;![CDATA[SELECT newsEdit,newsId, newstitle FROM shoppingGuide WHERE 1=1 AND newsday &gt; #&#123;startTime&#125; AND newsday &lt;= #&#123;endTime&#125;]]&gt;&lt;if test="etidName!=''"&gt;AND newsEdit=#&#123;etidName&#125;&lt;/if&gt;&lt;/select&gt; CDATA防止XML转义 面向切面编程AOP使用方法：关键是切面，切入点和通知的理解和声明 首先有一个类的某个方法需要被通知，则它就是切入点，把该类注册为bean，然后需要一个切面类，里面是一些通知方法，也注册为bean，然后关键就是XML的配置了，如下：先定义一个config，然后里面是一个切面标签，ref就是该切面类，然后再往里就是切入点，匹配的是Biz结尾的类的任何方法，然后匹配到该方法时，就执行下面定义的各种通知 1234567&lt;aop:config&gt; &lt;aop:aspect id="myAspectAOP" ref="myAspect"&gt; &lt;aop:pointcut id="myPointcut" expression="execution(* com.mkl.*Biz.*(..))" /&gt; &lt;aop:before method="before" pointcut-ref="myPointcut" /&gt; &lt;aop:after method="after" pointcut-ref="myPointcut" /&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; AspectJAspectJ基于注解，它的使用方法如下： XML中配置： 1&lt;aop:aspectj-autoproxy /&gt; 然后定义一个切面和切入点（空方法上做注解）和通知（切入点是空方法名） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Component@Aspectpublic class MyAspectJ &#123; @Pointcut("execution(* com.mkl.*Biz.*(..))") public void pointcut() &#123;&#125; // 可以自定义一个注解，然后方法使用该注解，通过该注解的value传递参数 @Before("pointcut() &amp;&amp; @annotation(moocMethod)") public void beforeWithAnnotation(MoocMethod moocMethod) &#123; System.out.println("BeforeWithParam: " + moocMethod.value()); &#125; // 如果方法有参数，可以把参数通过args传递给通知 @Before("pointcut() &amp;&amp; args(arg)") public void beforeWithParam(String arg) &#123; System.out.println("BeforeWithParam: " + arg); &#125; @Pointcut("within(com.mkl.*)") public void bizPointcut() &#123;&#125; @Before("execution(* com.mkl.*Biz.*(..))") // @Before("com.mkl.aop.aspectj.MoocAspect.pointcut()") public void before() &#123; System.out.println("Before"); &#125; @AfterReturning(pointcut = "com.mkl.MyAspectJ.pointcut()", returning = "returnValue") public void afterReturning(Object returnValue) &#123; System.out.println("AfterReturning : " + returnValue); &#125; @AfterThrowing(pointcut = "com.mkl.MyAspectJ.pointcut()", throwing = "e") public void afterThrowing(RuntimeException e) &#123; System.out.println("AfterThrowing： " + e.getMessage()); &#125; @After("pointcut()") public void after() &#123; System.out.println("After"); &#125; @Around("pointcut()") public Object around(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println("Around 1"); Object obj = pjp.proceed(); System.out.println("Around 2"); System.out.println("Around：" + obj); return obj; &#125;&#125; 最后当检测到有对应方法执行的时候，就会执行对应的通知 注意，不是切入点的方法调用是切入点的方法时，通知不会执行 Servlet生命周期 实例化并调用init()方法初始化该Servlet，如果web.xml没有配置预装载（容器启动就装载），则第一次访问该servlet才创建 &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; service()方法根据请求方法不同调用doGet()或doPost()，传递参数是ServletRequest和ServletResponse destroy()方法，在服务端停止且卸载Servlet时执行该方法]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis（持续更新）]]></title>
    <url>%2F2019%2F09%2F01%2Fredis%2F</url>
    <content type="text"><![CDATA[LRU缓存设计思路（shopee有问到）]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础（持续更新）]]></title>
    <url>%2F2019%2F09%2F01%2Fjava%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[java基础关于继承的杂七杂八 子类重写父类方法，修饰符必须比父类范围大，private&lt;default&lt;protected&lt;public super()和this()都必须放在构造函数的第一行，因此不能共存 父类有其他构造器的时候，必须显式指定一个无参构造器，否则子类继承会出错，如果父类没有任何构造器，会默认有一个空的无参构造器，如果没有显式指定，子类会默认会在自己的构造器的第一行加上super() 继承的执行顺序：父类静态块-&gt;子类静态块-&gt;父类非静态块-&gt;子类非静态块-&gt;父类构造函数-&gt;子类构造函数 关于基本类型的杂七杂八 高精度向低精度转型会报错，反之不会（即可以double a = 12） 布尔型只能用布尔变量保存 不同的包装类型使用==判断的时候会报错 关于main方法的杂七杂八 main方法有一个本类的成员，该成员可以访问类的静态域和私有域，如下 123456789101112131415public class Main &#123; private static int x; public void incr() &#123; x++; &#125; public static void main(String[] args) &#123; Main main = new Main (); System.out.println(main.x); // 0 main.incr(); System.out.println(main.x); // 1 &#125;&#125; String可以被继承吗String的修饰符是 public final ，不可以被继承 判断String是否相等指向常量池的话，只要值相等，则一定相等，指向堆的话，如果指向的不是堆中的同一对象，则不相等 123456String a = &quot;aaa&quot;;String b = &quot;aa&quot; + &quot;a&quot;;String c = &quot;aaa&quot;;String d = new String(&quot;aaa&quot;);System.out.println(a == b); // trueSystem.out.println(c == d); // false ==和equals==：对于基本类型，比较的值是否相同；对于引用类型，比较的是引用是否相同equals：equals本质上是==，只不过String，Integer等重写了equals方法，把它变成值比较，Object类的equals方法就是直接使用==的 两个对象的hashCode()相同，则equals()也一定为true吗不对，哈希值相同，equals不一定为true final作用修饰类则为最终类，不能被继承修饰方法不能被重写修饰的变量为常量，必须初始化，初始化后不能被修改 重载，重写重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。 多态 继承关系 子类重写父类方法 父类引用指向子类（向上转型 成员变量：编译看父类，运行看父类成员方法：编译看父类，运行看子类（动态绑定）静态方法：编译看父类，运行看父类 java 中的 Math.round(-1.5) 等于多少？等于 -1，正数与负数相反 抽象类，接口抽象类和接口的区别： 抽象类本质是一个类，其方法和域可以有类所拥有的修饰符，而接口域默认是static final，方法默认是abstract public且不可修改，方法可以加static修饰符，但这个时候它是接口方法，必须要有实体 抽象类只能单继承，接口可以多实现 他们均不可以实例化，它们均不可以加上final修饰类 设计思想： 抽象类是子类需要某些属性和具体的特殊行为，所以才需要继承抽象类 接口是一种行为的规范 实现上来说： 抽象类的实现使用extends，不能有多继承 接口的实现使用implements，可以有多实现 实例化： 均不可以实例化，均不可以加上final修饰类 构造函数： 抽象类可以写构造函数 接口不能有 方法访问修饰符： 抽象类的方法修饰符可以任意 接口的方法默认是 public abstract且不可修改 接口的方法可以加上static，这个时候必须要有实体 属性访问修饰符： 抽象类的属性可以有任何修饰符 接口的属性默认是 public static final 且不可修改 接口类只能声明方法和常量 在接口类中定义int a = 123;是允许的，但是实际a的类型是public static final int 接口类定义int value()也是允许的，但它实际类型是abstract public int 接口类可以定义静态方法 Java类初始化顺序父类静态代码块，父类静态成员字段（两者并列优先级） -&gt; 子类静态代码块，子类静态成员字段 -&gt; 父类普通代码块，父类普通成员字段 -&gt; 父类构造函数 -&gt; 子类普通代码块，子类普通成员 -&gt; 子类构造函数 写一个认为最好的单例模式饿汉，懒汉 123456789101112131415161718192021222324252627282930/** * 饿汉模式 * 单例实例在类装载时进行创建 */public class SingletonExample2 &#123; // 单例对象 private static SingletonExample2 instance = new SingletonExample2(); // 静态的工厂方法 public static SingletonExample2 getInstance() &#123; return instance; &#125;&#125;/** * 懒汉模式 * 单例实例在第一次使用时进行创建 */public class SingletonExample1 &#123; // 单例对象 private static SingletonExample1 instance = null; // 静态的工厂方法 public static SingletonExample1 getInstance() &#123; if (instance == null) &#123; instance = new SingletonExample1(); &#125; return instance; &#125;&#125; 双检锁 123456789101112public class Singleton &#123; private volatile static Singleton instance; public static Singleton getInstance() &#123; if (null == instance) &#123; synchronized (Singleton.class) &#123; if (null == instance) &#123; instance = new Singleton(); &#125; &#125; &#125; &#125;&#125; B树和B+树是解决什么样的问题的，怎样演化过来，之间区别B树：平衡多叉查找树，减少遍历高度，它每个节点既放了key也放了valueB+树：每个节点只放key值，value值放在叶子节点，叶子节点的value值增加指向相邻节点的指针 String a = “Hello”相关问题1234567891011121314151617public static void main(String[] args) &#123; String a = "ab"; String b = "a" + "b"; System.out.println(a == b); /* 上面结果是返回true的，首先String a = "ab"的全过程是这样的： 它会首先创建"ab"常量存放到常量池，然后该字面量对应的java.lang.String对象会存放在堆中，它在一次运行中只有一份，不会被重复创建 然后String b = "a" + "b"的时候，经过优化后实质上是String b = "ab" 在常量池找到是否有对应常量，有的话就令b指向该常量对应的String对象，所以判断的时候，a==b是返回true的 */ String c = new String("ab"); String d = new String("a" + "b"); System.out.println(c == d); /* 这里返回的结果是false，因为c指向的String对象与d指向的String对象不是同一个对象，虽然它们同样都指向常量池的"ab" */&#125; int a = 1 是原子操作可以用for循环直接删除ArrayList的特定元素吗？可能会出现什么问题？怎样解决for循环中直接删除ArrayList的特定元素是错的，不同的for循环会发生不同的错误，泛型for会抛出ConcurrentModificationException错误（跟iterator迭代调用remove方法报的错是一致的），普通for想要删除集合中重复且连续的元素，只能删除第一个，因为remove(Object)方法调用fastRemove方法，执行System.arraycopy方法，导致删除元素时涉及到数组元素的移动，将后一个元素移动到当前位置，导致下一次遍历的时候，这个移动到当前位置的元素不会被遍历到，所以不会被删除 hashCode()和equals()是什么hashCode()方法和equals()方法的作用其实一样，在Java里都是用来对比两个对象是否相等一致 区别重写的equals（）里一般比较的比较全面比较复杂，这样效率就比较低，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高 hashCode()效率高那还需要equals()干什么因为hashCode()并不是完全可靠，有时候不同的对象他们生成的hashcode也会一样 使用规则对于需要大量并且快速的对比的话如果都用equals()去做显然效率太低，所以解决方式是，每当需要对比的时候，首先用hashCode()去对比，如果hashCode()不一样，则表示这两个对象肯定不相等（也就是不必再用equals()去再对比了）,如果hashCode()相同，此时再对比他们的equals()，如果equals()也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性 泛型通配符常用的T,E,K,V,?，只是编码时约定俗成的东西 ?：不确定的java类型 T：type，具体的一个Java类型 K V：key value E：element 上边界限定通配符： List&lt;? extends Father&gt; ，表示它的类型是Father类型的某种子类，它不关心是什么子类，但是只知道是Father的子类，因为具体类型确定不了，所以不能够往其中添加元素（所有参数为泛型类型的方法都不能使用），但是可以读取元素下边界限定通配符： List&lt;? super Son&gt; ，表示它的类型是Son的某种父类，虽然不知道具体父类是什么，但还是可以往其中添加Son及其子元素，但是不能读取这些元素无边界通配符： List&lt;?&gt; 它的类型是某种类型，但不知道具体类型，不能添加元素 综上： List&lt;? extends Father&gt;：不能添加元素(只能添加null)，可以读取元素(调用的方法为具体子类自身的方法) List&lt;? super Son&gt;：不能读取元素，可以添加元素，可以添加Son及其子类 List&lt;?&gt;：不能读取也不能添加 Unicdoe和UTF-8Unicode是字符集：为每一个字符分配一个唯一的ID（码位）（在内存中保存时用的是Unicode）UTF-8是编码规则：将码位转换为字节序列的规则（在硬盘存储和网络传输中，常用变长编码方式UTF-8）它把Unicode的字符集编码为1 ~ 4个字节的序列汉字在UTF-8占用3字节，在Unicode占用2字节（所以char类型可以保存汉字） 内部类 成员内部类可以被权限修饰符(eg. public,private 等)所修饰 成员内部类可以访问外部类的所有成员,（包括 private ）成员（只要名字没有被覆盖，直接使用外部类的方法成员的名字即可） 成员内部类是默认包含了一个指向外部类对象的引用 如同使用 this 一样，当成员名或方法名发生覆盖时，可以使用外部类的名字加.this指定访问外部类成员。如： Outer.this.name 成员内部类不可以定义 static 成员 成员内部类创建语法： 12Outer outer=new Outer();Outer.Inner inner=outer.new Inner(); OR NOT AND优先级优先级：not&gt;and&gt;or Java容器P.S：这个图错了一个地方，只有LinkedList是实现了Queue接口的（其实还有ArrayDeque） Collection和Collections区别Collection是一个集合接口，提供对集合进行基本操作的通用接口方法，其直接继承接口有List，Queue和SetCollections是集合类的一个工具类，提供一系列静态方法，用于对集合元素进行排序，搜索以及线程安全等操作 三个具体Map的用处如果只需要在Map中插入，删除和定位，则HashMap是最好选择如果需要一个有序的key集合进行遍历，则使用TreeMap会更好，TreeMap默认使用自然顺序，可以传入Comparator实现排序如果需要一个LRU算法的Map，则使用LinkedHashMap，它基于LRU算法，插入的时候会根据插入顺序形成链表，遍历的时候从表头输出到表尾，get方法会导致LinkedHashMap的顺序发生变化，get到的算法会重新插入到队尾 Java异常 派生于Error或RuntimeException类的所有异常称为非受查异常，所有其他异常称为受查异常，一个方法必须声明所有可能抛出的受查异常，非受查异常要么不可控制（Error），要么避免发生（RuntimeException） RuntimeException： 错误的类型转换 数组访问越界 访问null指针 对于受查异常，子类可以选择抛出父类throws的异常，也可以不抛出，但不能抛出父类没有throws的异常对于非受查异常，子类可以任意抛出 （线程的run方法不能抛出异常，只能try catch处理） 基本数据类型byte,boolean是1字节short,char是2字节int,float是4字节long,double是8字节 lang和utillang是基本包，不需要import，它主要有包装类，枚举类，线程相关的类，串相关的类，ThreadLocal，Object，Comparable，Iterable，System，Math，异常类，反射类等 util是工具包，有锁，线程，集合类等类 变量命名规则字母，下划线或美元符号开头 protected和default 同一包都可以访问proteceted和default 不同包的子孙不能访问default，不同包的子孙可以访问protected LinkedList for循环问题for循环每次遍历都是从第一个节点开始的，性能很差，最好用iterator 序列化一个对象数据，在反序列化过程中，如果序列化串中的serialVersionUID与当前对象值不同，则反序列化失败，否则成功 如果serialVersionUID没有显式生成，系统就会自动生成一个。生成的输入有：类名、类及其属性修饰符、接口及接口顺序、属性、静态初始化、构造器。任何一项的改变都会导致serialVersionUID变化 如果我们保持了serialVersionUID的一致，则在反序列化时，对于新增的字段会填入默认值null（int的默认值0）,对于减少的字段则直接忽略 如果父类序列化了，子类会继承父类的序列化，子类无需添加序列化接口（子类对父类的属性和自身的属性都会被序列化如果父类没有序列化，子类序列化了，子类中的属性能正常序列化，但父类的属性会丢失，不能序列化 ((Main)null).staticMethod()这种调用是可以的，null会被强制转换为Main类型（而不是Main实例），然后调用Main类型的静态方法即可当调用的是实例方法，则会报空指针异常 clone方法Object的clone方法是浅拷贝，对于引用对象，指向的仍然是同一个对象 hashCode与equalshashCode()方法和equals()方法的作用其实一样，在Java里都是用来对比两个对象是否相等一致 重写equals要考虑得比较全面复杂，效率会低，而hashCode()只需要比较hash值，效率会高hashCode不完全可靠，有时候不同对象也会有相同的hashCode equals相等，hashCode一定相等，反之不一定 需要对比的时候，首先使用hashCode，如果相等再使用equals，这样效率会高 只要重写equals，就必须重写hashCode Set存储的对象必须重写equals和hashCode（Set存储不重复的对象，依据hashCode和equals判断） 自定义对象作为Map的键，则必须重写hashCode和equals throw与throwsthrow是代码处抛出throw new IOExceptionthrows是方法处声明（没有类）]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[algs（持续更新）]]></title>
    <url>%2F2019%2F09%2F01%2Falgs%2F</url>
    <content type="text"><![CDATA[algs二叉树遍历略排序排序算法的过程gif图 排序算法总览在复习完后，记得再看看自己的理解对不对，再作修改补充 对于各种排序，要心中有数，知道它的过程是怎么样的我是这样理解的：交换排序中，交换的对象是两个指针的对象（冒泡中指针是相邻的，快排指针是不相邻的），交换的目的是让某元素处在全局有序的位置，每趟交换都有一个元素处于全局有序，直到交换完毕插入排序中，插入是插入到前面的有序区，需要有记录后移的步骤，让有序区慢慢变长最终从局部有序转变为全局有序选择排序中，只有一个指针，该指针选择处于该位置的值直接把它换过来 交换：交换是指根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置（全局有序）插入：每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成（局部有序）选择：每一趟（如第i趟）在后面n-i+1个待排序元素中选取关键字最小的元素，作为有序子序列的第i个元素（与第i个元素直接交换），直到第n-1趟做完，待排序元素只剩下一个，就不用再选了 排序算法的代码在复习完排序算法后，我个人觉得贴代码就够了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class ExchangeSort &#123; // 交换排序：冒泡排序，全局有序，从后往前冒泡 public static void bubbleSort(ArrayList&lt;Integer&gt; list) &#123; if (list == null || list.size() == 0) return; int length = list.size(); // i &lt; length - 1可以少一次进入循环，因为只有一个元素时就不需要再冒泡了 for (int i = 0; i &lt; length - 1; i++) &#123; boolean sorted = true; // 当进入第二层循环没有交换任何元素，就表明此时数组已经有序 for (int j = length - 1; j &gt; i; j--) &#123; if (list.get(j) &lt; list.get(j - 1)) &#123; swap(list, j, j - 1); sorted = false; &#125; &#125; if (sorted) return; &#125; &#125; // 交换排序：快速排序 public static void quickSort(ArrayList&lt;Integer&gt; list) &#123; if (list == null || list.size() &lt;= 1) return; int low = 0, high = list.size() - 1; quickSort(list, low, high); &#125; private static void quickSort(ArrayList&lt;Integer&gt; list, int low, int high) &#123; if (low &lt; high) &#123; int pivotPos = partition(list, low, high); quickSort(list, low, pivotPos - 1); quickSort(list, pivotPos + 1, high); &#125; &#125; private static int partition(ArrayList&lt;Integer&gt; list ,int low, int high) &#123; int pivot = list.get(low); while (low &lt; high) &#123; // 判断这两个指针的值的大小时，必须设置大于等于，否则当等于的时候会陷入死循环，也正是因为这个等于才导致快排是不稳定的 while (low &lt; high &amp;&amp; list.get(high) &gt;= pivot) high--; list.set(low, list.get(high)); while (low &lt; high &amp;&amp; list.get(low) &lt;= pivot) low++; list.set(high, list.get(low)); &#125; list.set(low, pivot); return low; &#125; private static void swap(ArrayList&lt;Integer&gt; list, int pos1, int pos2) &#123; int temp = list.get(pos1); list.set(pos1, list.get(pos2)); list.set(pos2, temp); &#125; // 交换排序：冒泡排序，全局有序，从后往前冒泡 public static void bubbleSort(int[] arr) &#123; &#125; // 交换排序：快速排序 public static void quickSort(int[] arr) &#123; &#125;&#125; 红黑树红黑树是一棵自平衡的二叉查找树，除了符合二叉查找树的基本特性，它还符合如下特性： 节点是红色或黑色 根节点是黑色 每个叶子节点都是黑色的空节点（NIL节点） 每个红色节点的两个子结点都是黑色（从每个叶子到根的所有路径上不能有两个连续的红色节点） 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点 这些约束强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长 红黑树失衡时可以通过旋转和变色来让红黑树重新恢复平衡并且保持上述特性不变，具体如何操作需要看失衡的情况来决定，略 散列表哈希函数的构造方法直接定址法：H(key) = a * key + b除留余数法：H(key) = key % p &nbsp;(p&lt;=m) Java集合框架的HashMap的哈希函数是：高16位不变，低16位为低16位与高16位异或的结果hash = (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)p = tab[i = (n - 1) &amp; hash] // n为哈希表长度，当哈希表长度为2的次幂时，实际就是取模运算 解决冲突的方法 链地址法 开放定址法 线性探测法：Hi = (H(key) + i) % m 二次探测法：Hi = (H(key) + di) % m，di = 1^2, -1^2, 2^2, -2^2, … k^2, -k^2 再哈希法：产生冲突再计算另一个哈希函数，直到不再发生冲突为止 公共溢出区法：建立一个公共溢出区域，把冲突的都放在另一个地方，不在表里面 哈夫曼树构造过程： 给定n个权值为w1,w2,…,wn的结点 将这n个结点分别作为n棵只有一个结点的二叉树，构成森林F 构造一个新的结点，从F中选取两颗根节点权值最小的树作为新节点的左右子树，并且将新节点的权值置为左右子树上根节点的权值之和 从F中删除刚才选出的两棵树，同时将新得到的树加入到F中 重复2和3直到F中只剩下一棵树 特点： 每个初始结点最终都成为叶子节点，权值越小，到达根的路径长度越大 共新建了n-1个结点，结点总数是2n-1 每次构造都选2棵树作为新结点的左右子树，所以哈夫曼树中不存在度为1的结点 哈夫曼树的总权值就是每个叶结点的高度乘以它的权值之和（根节点高度为0） KMPKMP用于串的模式匹配问题，即求一个子串在主串中位置，它返回这个子串在主串的首位置 印度小哥的KMP算法 如果是暴力硬解，则时间复杂度是O(m*n)，m是主串长度，n是子串长度，而KMP算法只需要O(m+n)的时间复杂度 它是这样做的：主串不需要从头重新匹配，当匹配到有不同的字符，判断已匹配的子串中某个前缀或后缀是否相同，相同则让模式串”走到”后缀处，然后继续匹配（继续从该后缀下一个字符匹配，而不需要回到前面重新匹配），否则模式串”走到”主串不匹配的下一个字符继续下一次匹配（暴力硬解是让模式串回到当次匹配的字符的下一个字符继续匹配） KMP的模式串不需要往回走，只需要一直走下去就好了，可以理解为匹配的工作指针i不需要回到前面，只需要一直往后面走 KMP过程演示如下： 1234567891011121314151617181920pos :0 1 2 3 4 5 6 7 8 9 10111213141516171819202122text :a b c x a b c d a b x a b c d a b c d a b c ypattern:a b c d a b c y// 开始匹配，一直到x与d不匹配，因为此时已匹配串中abc没有相同前缀和后缀，所以走到不匹配的下一个字符继续匹配pos :0 1 2 3 4 5 6 7 8 9 10111213141516171819202122text :a b c x a b c d a b x a b c d a b c d a b c ypattern: a b c d a b c y// 继续匹配，一直到a与y不匹配，此时已匹配子串中，具有ab既是前缀，又是后缀，所以走到相同后缀处继续匹配pos :0 1 2 3 4 5 6 7 8 9 10111213141516171819202122text :a b c x a b c d a b x a b c d a b c d a b c ypattern: a b c d a b c y// 继续匹配，x与c不匹配，已匹配子串没有相同前后缀，走到不匹配的下一个字符pos :0 1 2 3 4 5 6 7 8 9 10111213141516171819202122text :a b c x a b c d a b x a b c d a b c d a b c ypattern: a b c d a b c y// d和y不匹配，此时已匹配子串有abc既是前缀又是后缀，则子串往后走到后缀处pos :0 1 2 3 4 5 6 7 8 9 10111213141516171819202122text :a b c x a b c d a b x a b c d a b c d a b c ypattern: a b c d a b c y// 此时匹配了，返回位置15 计算next数组说实话时间不太够了，所以KMP我就随便看了一下，还没写完如何求next数组和如何利用next数组，这些王道的书都有写，我自己总结了一下快速手算next数组的方法：比如abcdabca，先拿出子串a，它的最长公共前缀后缀长度为0，然后ab最长公共前后缀长度0，abc最长公共前后缀长度0，abcd最长公共前后缀长度0，abcda最长公共前后缀长度1，abcdab最长公共前后缀长度2，abcdabc最长公共前后缀长度3，abcdabca最长公共前后缀长度1，所以next数组为：00001231，另一个例子也是这样：ababa：a最长公共前后缀长度0，ab最长公共前后缀长度0，aba最长公共前后缀长度1，abab最长公共前后缀长度2，ababa最长公共前后缀长度3，所以next数组00123 KMP的关键和难点就是计算next数组，看下面例子 构建next数组的时间和空间复杂度都是O(n) 123456789101112131415161718192021222324252627282930313233343536373839 j ipos :0 1 2 3 4 5 6 7pattern:a b c d a b c anext :0// i和j的值不相等，0填入next，i继续往前走 j ipos :0 1 2 3 4 5 6 7pattern:a b c d a b c anext :0 0// i和j的值不相等，0填入next，i继续往前走 j ipos :0 1 2 3 4 5 6 7pattern:a b c d a b c anext :0 0 0 j ipos :0 1 2 3 4 5 6 7pattern:a b c d a b c anext :0 0 0 0 j ipos :0 1 2 3 4 5 6 7pattern:a b c d a b c anext :0 0 0 0 1 j ipos :0 1 2 3 4 5 6 7pattern:a b c d a b c anext :0 0 0 0 1 2 j ipos :0 1 2 3 4 5 6 7pattern:a b c d a b c anext :0 0 0 0 1 2 3 j ipos :0 1 2 3 4 5 6 7pattern:a b c d a b c anext :0 0 0 0 1 2 3 1 递归的思想剑指offer58题，判断对错二叉树isSymmetrical，对boolean类型返回值的尾递归，实质上是一个&amp;&amp;问题，它是这样的：只要子问题有一个返回false，则整个系列问题都返回false，必须要所有子问题都返回true，最终结果才是true，即对于一个整体问题，递归求解它的子问题，只要有某一个子问题出现了错误，直接全局问题出错]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>algs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合（持续更新）]]></title>
    <url>%2F2019%2F09%2F01%2FJava%E9%9B%86%E5%90%88%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Java集合类HashMapHashMap相关问题为什么有了AVL树或BST树还要有红黑树？或者为什么HashMap要使用红黑树？AVL树要求每个节点的左右节点高度差都不超过1，这样的要求十分严格，导致在一些插入，删除很频繁的场合，会使得AVL树频繁的进行调整，导致平衡树的性能大打折扣 而红黑树不要求完全的平衡，可以把红黑树理解成不太严格的AVL树，是一个折中方案，它降低了对旋转的要求，从而提高了性能红黑树的算法时间复杂度和AVL树相同，但是统计性能更高 hashMap怎么实现的Entry数组+链表+红黑树，具体看源码解析那里 key的hash相同时是插入链表头还是尾JDK 1.8中插入尾部 HashMap扩容连珠炮什么条件下扩容bucket超过load factor * current capacity，就要resize，扩大2倍 长度为什么要是2的n次方HashMap底层实现对哈希值取余得到位置值的时候，为了提高效率，不是通过hash % length来计算的，而是通过hash &amp; (length - 1)来计算，这两个结果相等的前提是：length是2的次幂 为什么要先高16位异或低16位再取模运算表默认容量是16，即只有1-15的位置上是可以用的，位置的计算公式为：tab[i = (n - 1) &amp; hash]，在做&amp;运算的时候，只有后4位是有效的（因为容量只有16），如果我们key的哈希值高位变化很大，低位变化很小，直接拿去做&amp;运算，就会导致计算出来的hash值冲突次数会很多 而将key的哈希值的高位也做了运算（哈希值低位与高位做了异或运算，使得在做&amp;运算时，低位实际上是高低位的结合），这就增加了随机性，减少碰撞冲突的可能性** 我用LinkedList代替数组结构可以么?为什么HashMap不使用LinkedList代替？为什么不用ArrayList代替数组？可以，因为LinkedList效率没有数组高，通过哈希函数计算出位置后，需要随机访问该位置，LinkedList不支持随机访问 ArrayList虽然支持随机访问，但是ArrayList的扩容机制不是自己定义的，它内部的扩容机制是1.5倍扩容，HashMap数组扩容刚好是2的次幂，在做取模运算的效率高 get/put过程（请把每个字都记住） put主要调用putVal方法，先计算哈希值（哈希的高16位与低16位相异或作为低16位，高16位是原来的高16位）并传入给putVal方法 putVal方法先判断table是否为null或者table的容量是否为0，如果是则使用resize函数初始化它 然后再判断是否碰撞，没有碰撞就创建新的结点（newNode函数），直接放入bucket 如果碰撞，首先判断桶中元素的hash值与待插入元素是否相同，相同再判断key是否相等（==判断或key.equals判断，只要有个返回true则返回true），相等则更新该key对应的value，并返回旧的value if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) 当桶中key不相等时，就开始沿next域往下寻找，如果是红黑树就按红黑树方式查找，如果是链表就按照链表方式寻找 如果判断存在该key（第4点的判断方法），则更新新值返回旧值 如果找到末尾都没找到相等的key，就在末尾处插入该key的结点，然后判断结点个数是否大于8，大于8就转为红黑树 如果表长度大于容量*装载因子，则调用resize扩容 它还有afterNodeAccess和afterNodeInsertion方法，在HashMap中是空方法，主要用在LinkedHashMap访问结点后的更新链表 &nbsp; get主要调用getNode方法，先计算哈希值传入给getNode方法 getNode方法通过对哈希值取模计算出位置，如果直接命中则直接返回，如果桶为null或者table为null则返回null 否则顺着链表或红黑树去查找，直到找到就返回 命中的判定方法同put的方法 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) HashMap红黑树连珠炮Java 8的HashMap的更改 数组+链表结构改为数组+链表+红黑树 优化高位运算的hash算法：h ^ (h &gt;&gt;&gt; 16) 扩容后，元素要么是在原位置，要么是在原位置再移动2次幂的位置，且链表顺序不变（这条变动让HashMap不会再出现死循环问题） 为什么在解决hash冲突的时候，不直接用红黑树?而选择先用链表，再转红黑树?因为红黑树需要左旋，右旋，变色来保持平衡，而单链表不需要，当元素小于8个的时候，做查询操作，链表结构也能够保证查询性能，大于8个的时候就需要红黑树来加快查询速度了，如果一开始就用红黑树，则增加元素的效率慢，查找效率也不会高到哪，就很浪费性能 使用二叉查找树或者平衡二叉树可以吗？可以，但是二叉查找树特殊情况下会变成线性结构，平衡二叉树则对平衡的定义的太严格，使得AVL树频繁的进行调整，导致平衡树的性能大打折扣 什么时候二叉树退化成链表当树节点个数为6时退化，中间差值7可以防止链表和树之间频繁的转换 并发问题连珠炮并发编程环境下有什么问题 多线程扩容，引起死循环问题 多线程put的时候可能导致元素丢失 put非null元素后get出来的却是null JDK 1.8后解决了扩容死循环问题 怎么解决这些问题使用ConcurrentHashMap，Hashtable等线程安全集合类 HashMap的key连珠炮key可以为null吗可以 一般用什么作为keyInteget，String这些不可变类当key，因为HashMap底层使用的是hashCode，如果使用如List这些可变类，当插入元素后，hashCode出来的值会发生变化，就会导致同一个实例对象却得不到对应的value的情况 HashMap和Hashtable有什么区别它和HashMap的最大的不同是它是线程安全的，另外它不允许key和value为null。Hashtable是个过时的集合类，不建议在新代码中使用 不同点 HashMap Hashtable 数据结构 数组+链表+红黑树 数组+链表 继承的类 AbstractMap Dictionary 线程安全 否 是 性能高低 高 低 key和value为null 允许 不允许 默认初始化容量 16 11 扩容方式 原始容量* 2 原始容量*2 + 1 底层数组的容量 要求为2的整数次幂 不作要求 确认key在数组中的索引的方法 i = (n - 1) &amp; hash index = (hash &amp; 0x7FFFFFFF) % tab.length 遍历方式 Iterator Iterator和Enumeration Iterator遍历数组顺序 索引从小到大 索引从大到小 null问题HashMap和LinkedHashMap允许key，value为nullTreeMap，ConcurrentHashMap不允许key，value为null ConcurrentHashMap的区别ConcurrentHashMap是J.U.C包的类，是线程安全的哈希表JDK1.7之前的ConcurrentHashMap使用分段锁机制实现，JDK1.8则使用数组+链表+红黑树数据结构和CAS原子操作实现ConcurrentHashMap 在JDK 1.8中，ConcurrentHashMap的核心要点如下： 底层是散列表（数组+链表）+红黑树，与HashMap相同 Hashtable将所有方法进行同步，效率低下，而ConcurrentHashMap通过部分锁定+CAS算法来实现线程安全，CAS算法也可以认为是乐观锁的一种 高并发环境下，统计数据（计算size等）无意义，因为下一时刻size值就发生变化 get方法非阻塞，无锁。重写Node类，通过volatile修饰Node的next指针来实现每次获取都是最新设置的值 key和value不能为null 通过Thread.yield()保证只有一个线程初始化散列表 synchronizedMapCollections.synchronizedMap可以传入一个Map参数，它会把该Map转变为线程安全的Map，主要实现的原理是在每个方法外面添加一个synchronized(object)的同步机制 集合ArrayList底层是 transient Object[] elementData; 和 private int size初始容量是10add方法首先会调用 ensureCapacityInternal(size + 1); 如果判断加入元素后容量会超过数组最大容量，则扩容，扩容是扩1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); 常用集合常用APIArrayListLinkedListHashMapHashSetTreeMapLinkedHashMap]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM（持续更新）]]></title>
    <url>%2F2019%2F09%2F01%2Fjvm%2F</url>
    <content type="text"><![CDATA[JVMJVM组成类加载器（ClassLoader）运行时数据区（Runtime Data Area）执行引擎（Execution Engine）本地库接口（Native Interface） 程序在执行之前先要把java代码转换成字节码（class文件），jvm首先需要把字节码通过一定的方式 类加载器（ClassLoader） 把文件加载到内存中 运行时数据区（Runtime Data Area） ，而字节码文件是jvm的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器 执行引擎（Execution Engine） 将字节码翻译成底层系统指令再交由CPU去执行，而这个过程中需要调用其他语言的接口 本地库接口（Native Interface）来实现整个程序的功能，这就是这4个主要组成部分的职责与功能。 JVM内存模型 程序计数器：PC指针指向下一条需要执行的字节码指令，线程私有 虚拟机栈：方法栈，存储局部变量表，操作数栈，动态链接，方法出口等（线程请求的栈深度大于虚拟机允许的深度时，抛出StackOverflowError，虚拟机栈动态扩展时无法申请到足够内存，抛出OutOfMemoryError），线程私有 局部变量表存放的是8大基础类型加上一个引用类型，所以还是一个指向地址的指针 本地方法栈，Native方法，线程私有 堆：存放对象实例，GC主要区域，会抛出OOM错误，线程共享 方法区：存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据，线程共享 运行时常量池：存放编译器生成的字面量和符号引用 对象创建步骤 检查方法区常量池是否有该类的符号引用，没有则类加载（类加载过程在后面） 分配内存，策略有空闲表法和指针碰撞 分配的内存空间初始化为0 设置对象头的必要信息如哈希码，GC分代年龄等 Java执行init方法 Java对象结构 对象头：GC分代，锁，哈希码等，Java数组的话还有数组长度的数据 实例数据：对象真正有效的信息 对其填充：8字节的整数倍 Java对象定位方式 句柄访问：Java堆中有一个句柄池，句柄池每个对象有2个指针，一个是到对象实例数据的指针，一个是到对象类型数据的指针，栈的本地变量表的reference指向句柄池，句柄池到对象实例数据的指针指向对象实例数据，到对象类型数据的指针指向方法区的对象类型数据 直接指针访问：Hotspot使用的是这个访问方式，reference对象直接指向堆中对象，该对象有一个指向对象类型数据的指针指向方法区的对象类型数据 它们的区别主要是reference一个指向堆中的句柄池，通过句柄池再指向堆中的实例，而另一个reference直接指向对象实例 堆内的分区分为新生代和老年代（java 8取消永久代），新生代包括Eden+Survivor区，Survivor区分为from和to区 GC判定方法引用计数法：给对象添加引用计数器，每当一个地方引用它，计数器就加1，引用失效时，计数器减1，计数值为0就回收，无法解决相互循环引用的问题引用链法（可达性分析）：GC Roots开始往下搜索，所经过路径为引用链，只要对象与GC Roots没有任何引用链相连，证明此对象不可达，应被回收。GC Roots为：虚拟机栈引用的对象，本地方法栈引用的对象，方法区类静态属性引用的对象，方法区常量引用的对象 Java引用 强引用：常见的都是强引用，垃圾回收器不会回收被强引用引用的对象 软引用：有用但不是必需，发送内存溢出异常之前被回收 弱引用：有用但不是必需，下一次GC被回收 虚引用：无法通过虚引用获得对象，用在GC时返回一个通知 回收方法区回收价值很低 该类所有实例都被回收 加载该类的ClassLoader已经被回收 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方利用反射访问该类 垃圾回收算法 标记-清除：会导致不连续的内存碎片，分配较大对象触发GC 复制：内存分为大小相等的两块，每次GC将存活的对象复制到另外一块，然后把已使用的内存空间一次清理掉，代价是内存只有原来一半 现在的虚拟机都采用复制算法回收新生代，但是是将内存分为一块较大的Eden空间和两块较小的Survivor空间(8:1:1)，每次使用Eden和其中一块Survivor，新对象在Eden分配内存，回收时将Eden和Survivor中还存活的对象一次性复制到另外一块Survivor中 标记-整理：标记整理在标记后，把存活对象都向一端移动，然后直接清理端边界以外的内存，适用于老年代 安全点引用关系不会发生变化的点 垃圾回收器 Serial：单线程，新生代，采取复制算法 ParNew：多线程，新生代，采取复制算法 Parallel Scavenge：新生代，多线程，更注重吞吐量 Serial Old：Serial的老年代版本，采取标记-整理算法 Parallel Old：Parallel的老年代版本，多线程 CMS以最短回收停顿时间为目的 初始标记-&gt;并发标记-&gt;重新标记-&gt;并发清除 初始标记(单线程)和重新标记(多线程)需要Stop The World，初始标记主要标记GC Roots能直接关联到的对象，并发标记是GC Roots Tracing过程，重新标记是修正并发标记过程中因程序运行而变动的部分 缺点： 对CPU资源敏感，因为它是并发标记的，会占用一部分CPU导致程序变慢 无法处理浮动垃圾，可能导致Full GC 基于标记-清除算法，产生大量空间碎片 G1G1把Java堆内存划分为多个大小相等的Region，新生代老年代都是一部分Region的集合，G1跟踪各个Region的垃圾堆积的价值大小（回收可获得的空间和回收所需时间），后台维护一个优先队列，每次回收价值最大的Region 初始标记-&gt;并发标记-&gt;最终标记-&gt;筛选回收 G1整体看是基于 标记-整理 算法，局部（两个Region之间）看是基于 复制 算法 内存分配策略 对象优先在Eden分配，Eden没有足够空间时，发起一次Minor GC 大对象直接进入老年代（字符串，数组） 长期存活的对象进入老年代（默认15岁） 动态对象年龄判定：Survivor相同年龄所有对象大小总和大于Survivor空间的一半，年龄大于等于该年龄的对象直接进入老年代 空间分配担保：Minor GC前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果成立则Minor GC安全，不成立则查看相关参数是否允许担保失败，如果允许，会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于就进行一次Minor GC，尽管这次GC是有风险的，如果小于，进行一次Full GC JVM性能调优-Xmx：堆最大内存数-Xms：堆初始化大小-Xmn：堆新生代初始即最大大小-Xss：线程栈大小-XX:SurvivorRatio=n：Survivor与Eden大小比例是2:n，n默认为8-XX:NewRatio=n：年轻代和老年代比值为1：n-XX:newSize：新生代大小-XX:MaxNewSize：新生代最大大小 GC原因年轻代的GC是Minor GC，老年代的GC是Full GC Minor GC原因 Eden区满，触发新生代Minor GC将Eden和非空闲Survivor存活的对象复制到另一个空闲Survivor中 Survivor区满，Minor GC将对象复制到老年代 Full GC原因 老年代被写满 System.gc()调用 统计得到的Minor GC晋升到老年代的平均大小大于老年代的剩余空间 类文件结构Class文件为8字节为单位的二进制流，采用伪结构，只有两种数据类型：无符号数和表无符号数有u1，u2，u4和u8 从上往下Class文件结构为：魔数（0xCAFEBABE），次版本（2字节），主版本（2字节），常量池，访问标志，类索引，父类索引，接口索引，字段表，方法表，属性表 类生命周期加载-&gt;连接-&gt;初始化-&gt;使用-&gt;卸载 虚拟机类加载机制类加载指将Class文件的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构 加载-&gt;连接-&gt;初始化 连接又分为：验证-&gt;准备-&gt;解析 加载：文件加载到内存，通过类的完全限定名查找此类字节码文件，并利用字节码文件创建一个Class对象 验证：目的在于确保Class文件符合当前虚拟机要求，不会危害虚拟机自身安全，分为文件格式验证，元数据验证(类)，字节码(方法字段)验证，符号引用验证(能否通过全限定名找到该类) 准备：为类变量分配内存并设置初始值的阶段，初始值为0或null 解析：虚拟机将常量池内的符号引用转换为直接引用的过程，解析阶段可能发生在初始化之后（为了支持动态绑定） 初始化：执行类构造器&lt;clinit&gt;()方法，即执行类变量的赋值和静态语句块 类加载器Java自带的三种类加载器分别是：Bootstrap ClassLoader（启动类加载器），Extension ClassLoader（扩展类加载器），Application ClassLoader（应用程序类加载器），除此之外可以自定义类加载器 启动类加载器用来加载 Java 的核心库(jre/lib/rt.jar)，原生C++实现，并不继承自java.lang.ClassLoader扩展类加载器是加载jre/ext/*.jar系统类加载器（应用程序类加载器）根据 Java 应用的类路径（CLASSPATH）来加载 Java 类 双亲委派模型：除了顶层的启动类加载器外，其余的类加载器都有自己的父类加载器。如果一个类加载器收到类加载的请求，它不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，最终传送到顶层的启动类加载器中，只有父加载器反馈自己无法完成这个加载请求时（它的搜索范围没有找到所需的类），子加载器才自己去尝试加载 双亲委派模式的好处： 多加载器加载某个类时，最终都是由一个加载器加载，确保最终加载结果相同 如何写自己的ClassLoader 继承ClassLoader 重写findClass()方法 调用defineClass()方法 简述分派分派与多态性是相关的 静态分派：发生在编译时期，所有依赖静态类型来定位方法执行版本的分派称为静态分派，典型应用为方法重载（2个同名方法，一个参数是父类Human，另一个参数是其子类Man，Human man = new Man()，传入该man参数，调用的是参数为Human的方法） 动态分派：在运行期根据实际类型确定方法执行版本的分派过程。典型应用为方法重写（最终调用的方法一般上来说 是实际类型的方法，如果没有则往上搜索其父类的方法） 虚拟机运行时栈帧结构 局部变量表：存放方法参数和方法内部定义的局部变量 操作数栈：存放8大基本数据类型和reference（byte，short和char会转换为int，方法内int a = 123;a存放在局部变量表，123存放在操作数栈） 动态链接：运行期间转换为直接引用的符号引用 方法返回地址 Java内存模型 规定所有变量都存储在主内存中，每条线程都有自己的工作内存（可以类比高速缓存），线程的工作内存中保存了被该线程使用的变量的主内存副本拷贝，线程对变量的所有操作（读取，赋值等）都必须在工作内存中进行，而不能直接读写主内存的变量，这里的变量指的是实例字段，静态字段和构成数组对象的元素，而不包括线程私有的局部变量和方法参数 JMM可见性volatile关键字可以保证变量对所有线程的可见性，可见性指一个线程修改了变量的值，新的值立刻同步到主内存中，而其他线程读取这个变量的时候，也会从主内存中拉取最新的值 volatile的特性得益于先行发生原则，先行发生原则指两个事件的结果之间的关系，如果一个事件A发生在另一个事件B之前，事件A产生的影响能被B观察到 volatile只保证可见性，不保证原子性，如果定义100个线程，它们执行循环100次的count++，count最终值不一定是10000，因为count++这个操作并不是原子性的，可能发生这种情况：线程A读取变量count，此时count值为0，然后线程B读取count为0并执行+1操作，写回到主内存，然后线程A再执行+1操作，写回到主内存，则主内存的count的值为1而不是理想的2 volatile适用于以下场景： 运行结果不依赖当前值（count=count+1不行，count=t可以），或者能够确保只有单一线程修改变量的值 变量不需要与其他状态变量共同参与不变约束 volatile第二个语义是禁止指令重排优化，这样可以避免由于指令重排而导致的错误 volatile底层禁止指令重排是通过内存屏障来实现的，内存屏障用于实现对内存操作的顺序限制 总结： 工作内存中，每次使用volatile的变量时都必须先从主内存刷新最新的值 工作内存中，每次修改volatile的变量时都必须立即同步回主内存中 volatile的关键字不会被指令重排序优化，确保代码的执行顺序与程序相同 锁优化自旋锁：互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态完成，这些操作给系统的并发性能带来很大的压力如果物理机器上有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程稍等一下，但不放弃处理器的执行时间，看看持有锁的线程是否很快就释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁 锁消除：对加了同步代码但实际上不存在共享数据竞争的锁消除 锁粗化：一串零碎的操作都对同一个对象加锁，则把加锁的范围扩展到整个操作序列的外部（如循环体内一直加锁，直接把加锁操作放到循环体之外） 轻量级锁：无竞争的情况下使用CAS操作避免互斥量的开销 偏向锁：无竞争的情况下把整个同步都消除 导致OOM异常-XX:+HeapDumpOnOutOfMemory 堆溢出 方法区溢出，常量池溢出 栈中如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常 内存泄露和内存溢出内存溢出out of memory：程序申请内存时，没有足够的内存空间供其使用，出现OOM内存泄露memory leak：程序在申请内存后，无法释放已申请的内存空间（ThreadLocalMap的生命周期跟Thread是一样的，如果没有手动删除对应key就会导致内存泄漏，所以必须手动remove()） 永久代与方法区永久代是JDK 7之前的概念，是JVM规范里运行时数据区的一个组成部分，主要存储class，运行时常量池，字段，方法，代码，JIT代码等，它的具体实现一般为永久代，在JDK 8之后取消永久代，而使用metaspace来实现，它与永久代的区别是：它不是在堆内存中的，而是在本地内存中，-XX:MaxMetaspaceSize可以设置元空间大小]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发基础5-AQS,Atomic与ThreadLocal]]></title>
    <url>%2F2019%2F08%2F28%2FJava%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%805-AQS%2CAtomic%E4%B8%8EThreadLocal(%E8%A1%A5%E5%85%85%E6%80%A7%E8%B4%A8)%2F</url>
    <content type="text"><![CDATA[java3y AQS Java并发基础5-AQS,Atomic与ThreadLocal(补充)前言：我在多线程这块的学习可能有点乱，所以写出来的文章也有点乱，等日后有机会我再重新整理下多线程的笔记 AQSJ.U.C包下子包locks的AbstractQueuedSynchronizer的简称 是一个可以给我们实现锁的框架，实现了AQS的常见的有ReentrantLock,CountDownLatch acquire()方法调用了tryAcquire()，release()方法调用了tryRelease()，需要继承AQS的实现类去实现 内部实现的关键：先进先出的阻塞等待队列CLH，state状态 拥有两种线程模式：独占和共享 state对象每上一次锁，state就通过CAS操作加1，表示它是可重入的state的修改通过compareAndSetState（内部调用unsafe.compareAndSwapInt）函数实现 CLH队列Node的每个结点有标识该线程状态的waitStatusCLH的操作是这样的：当有线程持有了锁，另外一个线程竞争不到锁，就让它进入CLH队列，head代表持有锁的线程，tail指向队列的尾部在公平竞争的前提下，来竞争锁的线程都会依次进入CLH队列的尾部CLH还有一个内部类ConditionObject以及Node的状态CONDITION，是与条件队列有关的，这里先不去看了 队列源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142static final class Node &#123; // 共享与独占 static final Node SHARED = new Node(); static final Node EXCLUSIVE = null; // 线程状态，依次为被取消，需要唤醒，等待condition唤醒，无条件传播？ static final int CANCELLED = 1; static final int SIGNAL = -1; static final int CONDITION = -2; static final int PROPAGATE = -3; // 值为上面几种状态 volatile int waitStatus; volatile Node prev; volatile Node next; // 每个线程对应一个Node volatile Thread thread; // Link to next node waiting on condition, or the special value SHARED Node nextWaiter; final boolean isShared() &#123; return nextWaiter == SHARED; &#125; final Node predecessor() throws NullPointerException &#123; Node p = prev; if (p == null) throw new NullPointerException(); else return p; &#125; Node() &#123; // Used to establish initial head or SHARED marker &#125; Node(Thread thread, Node mode) &#123; // Used by addWaiter this.nextWaiter = mode; this.thread = thread; &#125; Node(Thread thread, int waitStatus) &#123; // Used by Condition this.waitStatus = waitStatus; this.thread = thread; &#125;&#125; acquire()12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; 123456789101112131415161718192021final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; acquire()方法调用子类实现的tryAcquire()方法来获取资源 如果失败（tryAcquire返回false），就通过addWaiter()方法把当前线程创建一个Node结点（排他锁方式）并插入到队尾 acquireQueued()使线程在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false（这个函数说实话我还没有看明白） 因此tryAcquire()需要我们实现的逻辑是获取资源 release()123456789public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false;&#125; release()方法调用子类实现的tryRelease()方法释放锁，然后沿队列找到第一个不是作废状态的结点唤醒 Atomiccount++操作不是原子操作，需要经过 读取-修改-写入 三个步骤，如果需要同步，则可以加上synchronized关键字，但是开销很大，所以可以使用原子变量，它通过CAS操作来实现原子性 CAS操作是：如果当前内存值=预期值，则把内存值改为想要修改的值，否则什么都不做（或重试），CAS操作是原子性的（虽然它是比较后再修改） 原子变量分类： 基本类型 AtomicBoolean AtomicInteger AtomicLong 数组 AtomicIntegerArray AtomicLongArray AtomicReferenceArray 引用类型 AtomicReference AtomicStampedReference：带有版本号的引用类型 AtomicMarkableReference：带有标记位的引用类型 对象的属性 AtomicIntegerFieldUpdater：对象的属性是整型 AtomicLongFieldUpdater：对象的属性是长整型 AtomicReferenceFieldUpdater：对象的属性是引用类型 JDK 8新增DoubleAccumulator,LongAccumulator,DoubleAdder,LongAdder，它们是对AtomicLong等类的改进，高并发情况下会更高效 Atomic包的类基本都是使用Unsafe实现的包装类，Unsafe提供了三种CAS方法 1234// 第一和第二个参数代表对象的实例以及地址，第三个参数代表期望值，第四个参数代表更新值public final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5);public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);public final native boolean compareAndSwapLong(Object var1, long var2, long var4, long var6); ABA问题使用CAS有个缺点就是ABA问题，ABA问题描述如下： 有一个变量count=10，三个线程A,B,C 线程A和线程C同时读到count变量，所以线程A和线程C的内存值和预期值都为10, 此时线程A使用CAS将count修改为100 修改完后，线程B进来了，读取到count的值为100（内存值和预期值都是100），将count修改为10 线程C拿到执行权，发现内存值是10，预期值也是10，将count修改为11 这样 线程C无法得知线程A和线程B修改过count的值，是有风险的 解决ABA问题可以使用JDK提供的AtomicStampedReference和AtomicMarkableReference类 简单来说就是给这个对象提供一个版本，并且这个版本如果被修改了，这个版本号是自动更新的多了这个版本号比较，就不会存在ABA的问题了 LongAdder性能LongAdder性能要比AtomicLong好，它减少乐观锁的重试次数 ThreadLocalThreadLocal设计的目的就是为了能够在当前线程中有属于自己的变量，并不是为了解决并发或者共享变量的问题 ThreadLocal提供了线程的局部变量，每个线程都可以通过set()和get()来对这个局部变量进行操作，但不会和其他线程的局部变量进行冲突，实现了线程的数据隔离 往ThreadLocal中填充的变量属于当前线程，该变量对其他线程而言是隔离的 set方法 12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; ThreadLocal内部使用的是ThreadLocalMap，ThreadLocalMap是ThreadLocal的一个静态内部类，也是Thread的一个域，由Thread去维护ThreadLocalMap变量 我们调用set()方法，值都是存储在这个Map上的，key就是当前的ThreadLocal对象 get方法 12345678910111213public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; Map.Entry和集合类的Entry是类似的，可以通过它获得value 总结： 每个Thread维护一个ThreadLocalMap的引用 ThreadLocalMap是ThreadLocal的内部静态类，用Entry来进行存储 调用ThreadLocal的set()方法，实际上就是往ThreadLocalMap设置值，key是ThreadLocal对象，值是传递进来的对象 ThreadLocal的get()方法，实际上就是往ThreadLocalMap获取值，key是ThreadLocal对象 ThreadLocal本身并不存储值，它只是作为一个key让线程从Thread维护的ThreadLocalMap获取value ThreadLocal的内存泄漏ThreadLocalMap的生命周期跟Thread是一样的，如果没有手动删除对应key就会导致内存泄漏，所以必须手动remove()]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>AQS</tag>
        <tag>ThreadLocal</tag>
        <tag>Atomic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码解析-Map相关]]></title>
    <url>%2F2019%2F08%2F22%2F%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Map%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[源码解析-Map相关 https://zhuanlan.zhihu.com/p/31805309 基于JDK8 红黑树在讲HashMap之前，先了解红黑树的基本概念： 红黑树是一棵自平衡的二叉查找树，除了符合二叉查找树的基本特性，它还符合如下特性： 节点是红色或黑色 根节点是黑色 每个叶子节点都是黑色的空节点（NIL节点） 每个红色节点的两个子结点都是黑色（从每个叶子到根的所有路径上不能有两个连续的红色节点） 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点 这些约束强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长 红黑树失衡时可以通过旋转和变色来让红黑树重新恢复平衡并且保持上述特性不变，具体如何操作需要看失衡的情况来决定，略 HashMap基础的东西注释从注释我们可以知道： HashMap允许null key和null values HashMap和HashTable大致相等，区别是HashMap方法unsynchronized和允许null值 初始容量太高和装载因子太低对遍历都不好 当 初始容量&times;装载因子 小于哈希表的容量时，哈希表会再散列，桶数会&times;2 装载因子默认是0.75，设置高虽然会减少空间，但会导致遍历开销大 如果要将大量数据加入到HashMap，最好手动指定其容量，而不是使用默认容量然后自动扩容（这样开销大） 不同步，如果要同步，使用Map m = Collections.synchronizedMap(new HashMap(...)); HashMap继承自父类AbstractMap，该抽象父类实现了一些常用的Map默认方法，唯一的抽象方法是entrySet()要求子类去具体实现HashMap实现接口Serializable，Cloneable，Map&lt;K,V&gt; 属性观察它的属性： 12345678910111213static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // 默认初始容量16static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 最大容量2^30static final float DEFAULT_LOAD_FACTOR = 0.75f; // 默认装填因子0.75static final int TREEIFY_THRESHOLD = 8; // 桶中链表个数大于8时，桶中链表会转换为树形结构（每次往桶添加元素都会判断桶的节点个数是否大于该值）static final int UNTREEIFY_THRESHOLD = 6; // 桶中树形转换成链表的桶节点个数static final int MIN_TREEIFY_CAPACITY = 64; // 当桶的容量大于等于64时（桶容量不包含链表）才触发链表转红黑树transient Node&lt;K,V&gt;[] table; // Node数组存储元素，长度为2的次幂transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; // 具体元素存放集transient int size; // 存放的元素个数，数组+链表transient int modCount; // 扩容和更改map的计数器int threshold; // 数组临界值 = 容量 * 装载因子，当size&gt;threshold，就调用resize()方法扩容（扩大2倍）final float loadFactor; // 装载因子，默认0.75，构造器可以修改 内部类Node&lt;K,V&gt;内部类主要有的属性是 123456789101112131415161718192021222324252627282930313233343536373839static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + "=" + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125;&#125; Node实现了Map.Entry接口Java散列表是通过数组+链表实现的，next就是链表的next指针 构造方法可以使用的构造方法： 默认无参构造方法 传递容量参数 传递容量+装载因子参数 直接传递一个Map作为参数 put方法123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; 可以看到它是直接调用putVal方法，并通过hash(key)计算哈希值，我们观察它是怎么计算哈希值的 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 当key==null时哈希值为0，否则哈希值为该键的哈希值与哈希值本身高16位作异或的结果（即哈希值高16位为hashCode()的高16位，低16位为hashCode()高16位与低16位相异或的结果）用这个作为哈希值的原因是： 我们是根据key的哈希值来保存在散列表中的，表默认容量是16，即只有1-15的位置上是可以用的，位置的计算公式为：tab[i = (n - 1) &amp; hash]，在做&amp;运算的时候，只有后4位是有效的，如果我们key的哈希值高位变化很大，低位变化很小，直接拿去做&amp;运算，就会导致计算出来的hash值冲突次数会很多而将key的哈希值的高位也做了运算（哈希值低位与高位做了异或运算，使得在做&amp;运算时，低位实际上是高低位的结合），这就增加了随机性，减少碰撞冲突的可能性 来看看putVal做了什么 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 当散列表为null，则通过resize()方法初始化散列表 // resize()函数的作用是当哈希表为null就初始化它，当哈希表需要扩容就扩大两倍（threshold在这里被计算） if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 没有冲突，直接插入到散列表 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); // 发生冲突 else &#123; Node&lt;K,V&gt; e; K k; // 要插入的元素中的key和hash在该散列表已存在，则用e记录下来 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 当为红黑树结构的时候，就调用树的插入方法 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 链表结构 else &#123; for (int binCount = 0; ; ++binCount) &#123; // 插入到链表的末尾，当插入后临界值大于TREEIFY_THRESHOLD，就把该链表转换为红黑树结构 if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; // 当链表中存在key与hash与待插入节点的key与hash相等的节点时，就退出循环（此时e保存的节点就是key相等的节点） if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; // e不为null，意味着插入时已存在该key，则用新的value覆盖旧value，并返回旧value if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; putVal的过程大致归纳： 先判断Node&lt;K,V&gt;[] table是否为null，若为null就通过resize()初始化它，设置它的初始容量为16和threshold为初始容量&times;装载因子 没有发生碰撞，就直接添加到散列表数组对应位置 发生碰撞，如果散列表table的元素已存在key和hash值，则记录该节点，然后更新值并返回旧值 如果桶中链表头不存在该key，判断是红黑树就使用红黑树的插入方法，是链表就使用链表的插入方法，并在插入后判断是否需要转换为红黑树 如果插入过程中（链表查找过程）找到key相等的节点，就更新值并返回旧值 插入成功后判断是否需要resize resize方法resize方法就不贴代码了，它主要实现的功能是：当哈希表为null（实际是Node&lt;K,V&gt;[] table为null）就初始化它，当哈希表需要扩容就扩大两倍（提供边界检查防止容量超过最大容量），并把旧的散列表赋值到新散列表中，threshold在这里被计算当Node&lt;K,V&gt;[] table为null，设置 get方法get方法主要调用了getNode方法 12345678910111213141516171819final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; 判断table是否为null，first = table[(n - 1) &amp; hash]是否为null（key对应的哈希的桶是否为null，为null则不存在该key） 不为null再判断first.hash是否等于给定key的hash，不等于则沿着链表或红黑树一直往下找，直到找到就返回该Node remove方法remove主要调用removeNode方法 12345678910111213141516171819202122232425262728293031323334353637383940final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; K k; V v; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) &#123; if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else &#123; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; &#125; &#125; return null;&#125; removeNode方法和getNode类似，先查找到对应桶，然后顺着链表或红黑树查找直到找到对应节点，然后判断节点是树节点还是桶首位还是链表节点来进行对应的删除操作 迭代调用entrySet()方法会返回一个Set&lt;Map.Entry&lt;K,V&gt;&gt;对象，该对象实现了iterator()方法和forEach()方法 forEach()方法的迭代过程是：先进入数组取得桶，然后顺着桶的链表或红黑树往下迭代，然后再取下一个桶依次重复 iterator()方法返回继承自HashIterator的EntryIterator对象，并重写了next()方法，该方法调用父类HashIterator的nextNode()方法 12345678910111213141516171819202122232425262728293031323334353637383940final class EntryIterator extends HashIterator implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public final Map.Entry&lt;K,V&gt; next() &#123; return nextNode(); &#125;&#125;abstract class HashIterator &#123; Node&lt;K,V&gt; next; // next entry to return Node&lt;K,V&gt; current; // current entry int expectedModCount; // for fast-fail int index; // current slot HashIterator() &#123; expectedModCount = modCount; Node&lt;K,V&gt;[] t = table; current = next = null; index = 0; if (t != null &amp;&amp; size &gt; 0) &#123; // advance to first entry do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); &#125; &#125; public final boolean hasNext() &#123; return next != null; &#125; final Node&lt;K,V&gt; nextNode() &#123; Node&lt;K,V&gt;[] t; Node&lt;K,V&gt; e = next; if (modCount != expectedModCount) throw new ConcurrentModificationException(); if (e == null) throw new NoSuchElementException(); if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) &#123; do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); &#125; return e; &#125; // remove方法，略&#125; nextNode()的执行是这样的： 首先调用iterator()方法返回EntryIterator的时候，会调用其父类的构造方法，该方法从table[0]开始找，直到找到第一个不为null的桶 然后调用next()的时候，next()调用nextNode()方法，它从这个不为null的桶开始顺着链表或者树往下遍历，每次遍历都判断该节点的next是否为null，如果为null，就让next指向下一个不为null的桶 总结 HashMap默认装载因子0.75，默认长度16，超过16*0.75的容量就会自动扩大2倍 HashMap底层使用的是Entry[]数组，数组每个元素是一个桶，元素类型是一个实现了Map.Entry接口的Node类型，存储键值对，且有next指针指向下一个Node 在JDK 1.8中，当链表长度大于8，并且Entry数组长度大于64，就会转换成红黑树，如果链表长度大于8，Entry数组长度不大于64，就扩大数组长度 初始容量太高和装载因子太低对遍历都不好 允许null，不同步 如果传入容量参数不是2的整数次幂，会计算得出大于参数且最接近2的整次幂的数 LinkedHashMap继承自HashMap，所以和HashMap大体上类似，增加了下面的的域，并且重写了get方法（下面有说） 123456789101112131415static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125;&#125;/** * The head (eldest) of the doubly linked list. */transient LinkedHashMap.Entry&lt;K,V&gt; head;/** * The tail (youngest) of the doubly linked list. */transient LinkedHashMap.Entry&lt;K,V&gt; tail; 它的每个Node&lt;K,V&gt;都多了一个before和after指针，用来指向按插入顺序先后的前后节点 如果设置了accessOrder参数，即使用 LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) 这个构造器（注意它的第二个参数是float不是double），则使用的是LRU算法，最近被用到的放在链表尾，最久没有被用到的放在链表头（get和put会更新链表状态），如果accessOrder为false，则get不会改变状态， 3个afterNodeXxx方法在HashMap中都是空方法，LinkedHashMap重写了它们 当调用put方法，它没有重写put方法，实际调用的是父类的put，父类put调用的是putVal，putVal中如果存在key，则更新，然后调用afterNodeAccess，如果不存在key则插入，然后调用afterNodeInsertion，afterNodeAccess内部会判断accessOrder，因此如果为false，则更新后并不会改变链表状态，只有设置了accessOrder参数put更新时才会改变链表状态 调用get方法，它重写了get方法，首先调用父类的get，父类get调用getNode，获得结点后，判断accessOrder，如果为true，则调用afterNodeAccess（LRU算法），只有设置了accessOrder参数get才会改变链表状态 调用remove方法，没有重写，调用的是父类的remove，然后调用afterNodeRemoval，无论是否设置accessOrder参数，remove都会改变链表状态 调用containsKey方法，无论有没有设置accessOrder参数，containsKey都不会改变链表状态 综上所述，LinkedHashMap在accessOrder为false的时候，本质上就是一个根据插入顺序排序的哈希链表，在accessOrder为true的时候，是根据LRU算法的哈希链表，containsKey无论如何都不会改变状态，它底层是通过调用HashMap的get方法实现的 TreeMap看了下注释 大概就是： 底层是红黑树，实现NavigableMap接口，可以根据key自然排序，可以传递Comparator实现Map的排序 containsKey，get，put，remove方法的时间复杂度是O(logn) 非同步 使用Comparator或者Conparable来比较key是否相等与排序的问题，如果为null，则使用自然顺序 key不能为null，否则抛出NullPointException ConcurrentHashMap很多实现都和HashMap类似，下面主要说区别： 1234567static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; volatile V val; volatile Node&lt;K,V&gt; next; ...&#125; Node类重写了，next指针使用了volatile关键字，保证在get方法是非阻塞的，可以访问到最新值 通过Thread.yield()保证只有一个线程初始化散列表 key和value不能为null Set相关HashSet的底层实现其实就是使用HashMap，key为HashMap的key，value为一个final Object类型的对象]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
        <tag>HashSet</tag>
        <tag>LinkedHashMap</tag>
        <tag>TreeMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的遍历]]></title>
    <url>%2F2019%2F08%2F20%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[二叉树的遍历12345678910// 二叉树的定义public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 中序遍历非递归中序遍历思路：p!=null，则往左走到底，边走边入栈，走到底后p==null，出栈，访问，然后往右走一步，如果p!=null，则再往左走到底，边走边入栈，走到底p==null，出栈，重复上述步骤 123456789101112131415void inOrderNonRecursive(TreeNode pRoot) &#123; if (pRoot == null) return; LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;(); TreeNode p = pRoot; while (p != null || stack.size() != 0) &#123; if (p != null) &#123; stack.push(p); p = p.left; &#125; else &#123; p = stack.pop(); visit(p); p = p.right; &#125; &#125;&#125; 递归1234567void inOrderRecursive(TreeNode pRoot) &#123; if (pRoot != null) &#123; inOrderRecursive(pRoot.left); visit(pRoot); inOrderRecursive(pRoot.right); &#125;&#125; 先序遍历非递归前序遍历：访问根，入栈，然后访问左子树，直到走到底，然后出栈，访问其右孩子，入栈，重复上述步骤 123456789101112131415void preOrderNonRecursive(TreeNode pRoot) &#123; if (pRoot == null) return; LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;(); TreeNode p = pRoot; while (p != null || !stack.isEmpty()) &#123; if (p != null) &#123; visit(p); stack.push(p); p = p.left; &#125; else &#123; p = stack.pop(); p = p.right; &#125; &#125;&#125; 递归1234567void preOrderRecursive(TreeNode pRoot) &#123; if (pRoot != null) &#123; visit(pRoot); preOrderRecursive(pRoot.left); preOrderRecursive(pRoot.right); &#125;&#125; 后序遍历非递归后序难点：王道书课后题第三题，需要判断上次访问的是左子树还是右子树，若是左子树，则要跳过根，去访问它的兄弟，然后再回头访问根，若是右子树，则直接访问根算法思想:往左走到底，并入栈，走到底后出栈，判断其右孩子是否为空||右孩子是否被访问了(pre)，若符合判断，则访问该结点（因为这个时候它的左右孩子都已经访问了），然后令pre=p（记录最近访问的结点是否是其父的右孩子），并重置p指针，让它指向null（使得下一次循环直接进入stack.pop()环节，避免无限循环的发生），如果不符合，说明这个结点的右孩子还没有被访问，则先让它入栈，然后再让p=p-&gt;rchild，然后再入栈，往左走到底，边走边入 123456789101112131415161718192021222324void postOrderNonRecursive(TreeNode pRoot) &#123; if (pRoot == null) return; LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;(); TreeNode p = pRoot, pre = null; while (!stack.isEmpty() || p != null) &#123; if (p != null) &#123; // 往左走到底并入栈 stack.push(p); p = p.left; &#125; else &#123; // 走到底后出栈判断 p = stack.pop(); if (p.right == null || p.right == pre) &#123; // 右孩子被访问了，此时要访问该结点 visit(p); pre = p; // 因为根也被访问了，说明这棵子树已经被访问完了，应该让下次循环继续出栈，访问它的父结点或它的兄弟 p = null; // 关键步骤！！！重置p指针，让下次循环继续出栈，防止无限循环 &#125; else &#123; // 右孩子存在且没有被访问 stack.push(p); p = p.right; &#125; &#125; &#125;&#125; 递归1234567void postOrderRecursive(TreeNode pRoot) &#123; if (pRoot != null) &#123; postOrderRecursive(pRoot.left); postOrderRecursive(pRoot.right); visit(pRoot); &#125;&#125; 层次遍历非递归借助队列实现即可，根入队，while(!queue.empty())循环体内出队并访问，然后判断左右子树是否空，非空则入队，依次类推 123456789101112void levelOrder(TreeNode pRoot) &#123; if (pRoot == null) return; LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); TreeNode p = pRoot; queue.addLast(p); while (!queue.isEmpty()) &#123; p = queue.removeFirst(); visit(p); if (p.left != null) queue.addLast(p.left); if (p.right != null) queue.addLast(p.right); &#125;&#125; 实现分层输出：层间隔间添加null作分隔符 1234567891011121314151617181920void levelOrder2(TreeNode pRoot) &#123; if (pRoot == null) return; LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.addLast(null); queue.addLast(pRoot); // 注意当size==1的时候，意味着只剩下一个null了，就退出循环 while (queue.size() != 1) &#123; TreeNode p = queue.removeFirst(); if (p == null) &#123; // 输出该层 Iterator&lt;TreeNode&gt; iterator = queue.iterator(); while (iterator.hasNext()) visit(iterator.next()); System.out.println(); queue.addLast(null); continue; // 输出该层后直接进入下一个循环，把该层的子结点加入到队列 &#125; if (p.left != null) queue.add(p.left); if (p.right != null) queue.add(p.right); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis基础]]></title>
    <url>%2F2019%2F08%2F05%2Fredis%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Redis基础 参考：1.https://www.jianshu.com/p/56999f2b8e3b2.https://www.runoob.com/redis/redis-lists.html3.http://how2j.cn/k/redis/redis-download-install/1367.html4.https://www.cnblogs.com/EasonJim/p/7803067.html5.https://blog.csdn.net/f641385712/article/details/846794566.https://blog.csdn.net/wwrzyy/article/details/85089463 源代码地址 概念Redis的引入在我们日常的Java Web开发中，无不都是使用数据库来进行数据的存储，由于一般的系统任务中通常不会存在高并发的情况，所以这样看起来并没有什么问题，可是一旦涉及大数据量的需求，比如一些商品抢购的情景，或者是主页访问量瞬间较大的时候，单一使用数据库来保存数据的系统会因为面向磁盘，磁盘读/写速度比较慢的问题而存在严重的性能弊端，一瞬间成千上万的请求到来，需要系统在极短的时间内完成成千上万次的读/写操作，这个时候往往不是数据库能够承受的，极其容易造成数据库系统瘫痪，最终导致服务宕机的严重生产问题 为了克服上述的问题，Java Web项目通常会引入NoSQL技术，这是一种基于内存的数据库，并且提供一定的持久化功能。Redis和MongoDB是当前使用最广泛的NoSQL，而就Redis技术而言，它的性能十分优越，可以支持每秒十几万此的读/写操作，其性能远超数据库，并且还支持集群、分布式、主从同步等配置，原则上可以无限扩展，让更多的数据存储在内存中，更让人欣慰的是它还支持一定的事务能力，这保证了高并发的场景下数据的安全和一致性 什么是RedisRedis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。换句话说，Redis就像是一个HashMap，不过不是在JVM中运行，而是以一个独立进程的形式运行。一般说来，会被当作缓存使用。 因为它比数据库(mysql)快，所以常用的数据，可以考虑放在这里，这样就提高了性能。 Redis在Java Web的应用 存储缓存用的数据 需要高速读/写的场合使用它快速读/写 缓存如果日常数据库访问中，读操作比写操作要大得多，使用数据库时需要去磁盘把对应数据索引取出来，这是一个相对较慢的过程 如果我们把数据放在Redis中，也就是直接放在内存中，让服务端直接去读取内存中的数据，这样速度明显会快上不少，并且会极大减小数据库的压力，但是使用内存进行数据存储开销也是比较大的，限于成本的原因，一般只是使用Redis存储一些常用和主要的数据，比如用户登录的信息等 一般使用Redis进行存储时，我们需要从以下几个方面来考虑： 业务数据常用吗？命中率如何？如果命中率低，就没有必要写入缓存 该业务数据是读操作多，还是写操作多？如果写操作多，频繁需要写入数据库，也没有必要使用缓存 业务数据大小如何？如果要存储几百兆字节的文件，会给缓存带来很大压力，这样也没有必要 对于写操作，要分别写入数据库和Redis，所以对写次数远大于读次数的情况，就没有必要使用Redis 快速读/写在如今的互联网中，越来越多的存在高并发的情况，比如天猫双11、抢红包、抢演唱会门票等，这些场合都是在某一个瞬间或者是某一个短暂的时刻有成千上万的请求到达服务器，如果单纯的使用数据库来进行处理，就算不崩，也会很慢的，轻则造成用户体验极差用户量流失，重则数据库瘫痪，服务宕机，而这样的场合都是不允许的！ 当一个请求到达服务器，只是把业务数据在Redis上进行读写，而没有对数据库进行任何操作，这样就能大大提高读写的速度，从而满足高速响应的需求 在一个请求操作完Redis的读/写后，会去判断该高速读/写业务是否结束，如果结束，就触发事件将Redis的缓存的数据以批量的形式一次性写入数据库，从而完成持久化的工作 运行RedisWindows的Redis安装 在命令行参数运行redis-server.exe和redis-cli.exe即可，Linux也类似，略 配置RedisRedis 的配置文件位于 Redis 安装目录下，文件名为 redis.conf(Windows 名为 redis.windows.conf)可以通过 CONFIG 命令查看或设置配置项CONFIG GET * 获取所有配置项CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUE 命令可以修改配置 配置文件参数如下： 配置项 说明 daemonize no Redis 默认不是以守护进程的方式运行，可以通过该配置项修改，使用 yes 启用守护进程（Windows 不支持守护线程的配置为 no ） pidfile /var/run/redis.pid 当 Redis 以守护进程方式运行时，Redis 默认会把 pid 写入 /var/run/redis.pid 文件，可以通过 pidfile 指定 port 6379 指定 Redis 监听端口，默认端口为 6379 bind 127.0.0.1 绑定的主机地址 timeout 300 当客户端闲置多长时间后关闭连接，如果指定为 0，表示关闭该功能 loglevel notice 指定日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice logfile stdout 日志记录方式，默认为标准输出，如果配置 Redis 为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给 /dev/null databases 16 设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id save &lt;seconds&gt; &lt;changes&gt; Redis 默认配置文件中提供了三个条件： save 900 1 save 300 10 save 60 10000 分别表示 900 秒（15 分钟）内有 1 个更改，300 秒（5 分钟）内有 10 个更改以及 60 秒内有 10000 个更改。 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合 rdbcompression yes 指定存储至本地数据库时是否压缩数据，默认为 yes，Redis 采用 LZF 压缩，如果为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变的巨大 dbfilename dump.rdb 指定本地数据库文件名，默认值为 dump.rdb dir ./ 指定本地数据库存放目录 slaveof &lt;masterip&gt; &lt;masterport&gt; 设置当本机为 slav 服务时，设置 master 服务的 IP 地址及端口，在 Redis 启动时，它会自动从 master 进行数据同步 masterauth &lt;master-password&gt; 当 master 服务设置了密码保护时，slav 服务连接 master 的密码 requirepass foobared 设置 Redis 连接密码，如果配置了连接密码，客户端在连接 Redis 时需要通过 AUTH &lt;password&gt; 命令提供密码，默认关闭 maxclients 128 设置同一时间最大客户端连接数，默认无限制，Redis 可以同时打开的客户端连接数为 Redis 进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息 maxmemory &lt;bytes&gt; 指定 Redis 最大内存限制，Redis 在启动时会把数据加载到内存中，达到最大内存后，Redis 会先尝试清除已到期或即将到期的 Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis 新的 vm 机制，会把 Key 存放内存，Value 会存放在 swap 区 appendonly no 指定是否在每次更新操作后进行日志记录，Redis 在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis 本身同步数据文件是按上面 save 条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为 no appendfilename appendonly.aof 指定更新日志文件名，默认为 appendonly.aof appendfsync everysec 指定更新日志条件，共有 3 个可选值：no：表示等操作系统进行数据缓存同步到磁盘（快），always：表示每次更新操作后手动调用 fsync() 将数据写到磁盘（慢，安全），everysec：表示每秒同步一次（折中，默认值） vm-enabled no 指定是否启用虚拟内存机制，默认值为 no，简单的介绍一下，VM 机制将数据分页存放，由 Redis 将访问量较少的页即冷数据 swap 到磁盘上，访问多的页面由磁盘自动换出到内存中 vm-swap-file /tmp/redis.swap 虚拟内存文件路径，默认值为 /tmp/redis.swap，不可多个 Redis 实例共享 vm-max-memory 0 将所有大于 vm-max-memory 的数据存入虚拟内存，无论 vm-max-memory 设置多小，所有索引数据都是内存存储的(Redis 的索引数据 就是 keys)，也就是说，当 vm-max-memory 设置为 0 的时候，其实是所有 value 都存在于磁盘。默认值为 0 vm-page-size 32 Redis swap 文件分成了很多的 page，一个对象可以保存在多个 page 上面，但一个 page 上不能被多个对象共享，vm-page-size 是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page 大小最好设置为 32 或者 64bytes；如果存储很大大对象，则可以使用更大的 page，如果不确定，就使用默认值 vm-pages 134217728 设置 swap 文件中的 page 数量，由于页表（一种表示页面空闲或使用的 bitmap）是在放在内存中的，在磁盘上每 8 个 pages 将消耗 1byte 的内存 vm-max-threads 4 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4 glueoutputbuf yes 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启 hash-max-zipmap-entries 64；hash-max-zipmap-value 512 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法 activerehashing yes 指定是否激活重置哈希，默认为开启 include /path/to/local.conf 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件 数据类型Redis支持5种数据类型，分别为：String，List，Hash，Set，Sorted Set 类型 简介 特性 场景 String 二进制安全 可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M — Hash 键值对集合,即编程语言中的Map类型 适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值 存储、读取、修改用户属性 List 链表(双向链表) 增删快,提供了操作某一段元素的API 1,最新消息排行等功能(比如朋友圈的时间线) 2,消息队列 Set 哈希表实现,元素不重复 1、添加、删除,查找的复杂度都是O(1) 2、为集合提供了求交集、并集、差集等操作 1、共同好友 2、利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐 Sorted Set 将Set中的元素增加一个权重参数score,元素按score有序排列 数据插入集合时,已经进行天然排序 1、排行榜 2、带权重的消息队列 Sorted Set的用法如下： 123456789101112131415161718redis 127.0.0.1:6379&gt; ZADD runoobkey 1 redis(integer) 1redis 127.0.0.1:6379&gt; ZADD runoobkey 2 mongodb(integer) 1redis 127.0.0.1:6379&gt; ZADD runoobkey 3 mysql(integer) 1redis 127.0.0.1:6379&gt; ZADD runoobkey 3 mysql(integer) 0redis 127.0.0.1:6379&gt; ZADD runoobkey 4 mysql(integer) 0redis 127.0.0.1:6379&gt; ZRANGE runoobkey 0 10 WITHSCORES1) &quot;redis&quot;2) &quot;1&quot;3) &quot;mongodb&quot;4) &quot;2&quot;5) &quot;mysql&quot;6) &quot;4&quot; Redis HyperLogLogRedis 在 2.8.9 版本添加了 HyperLogLog 结构。 Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。 在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。 但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。 12345678redis 127.0.0.1:6379&gt; PFADD runoobkey &quot;redis&quot;1) (integer) 1redis 127.0.0.1:6379&gt; PFADD runoobkey &quot;mongodb&quot;1) (integer) 1redis 127.0.0.1:6379&gt; PFADD runoobkey &quot;mysql&quot;1) (integer) 1redis 127.0.0.1:6379&gt; PFCOUNT runoobkey(integer) 3 Redis命令redis-cli -h host -p port -a password 连接远程服务 中文乱码的话 redis-cli.exe --raw启动 官方命令手册redis命令参考菜鸟教程的redis命令 发布订阅Redis支持发布订阅，发送者发送消息，订阅者接收消息，使用PUBLISH可以指定频道发布消息，SUBSCRIBE可以订阅频道，详情见手册 事务Redis事务可以一次执行多个命令， 并且带有以下三个重要的保证： 批量操作在发送 EXEC 命令前被放入队列缓存 收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行 在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中 一个事务从开始到执行会经历以下三个阶段： 开始事务 命令入队 执行事务 1234567891011121314151617redis 127.0.0.1:6379&gt; MULTIOKredis 127.0.0.1:6379&gt; SET book-name &quot;Mastering C++ in 21 days&quot;QUEUEDredis 127.0.0.1:6379&gt; GET book-nameQUEUEDredis 127.0.0.1:6379&gt; SADD tag &quot;C++&quot; &quot;Programming&quot; &quot;Mastering Series&quot;QUEUEDredis 127.0.0.1:6379&gt; SMEMBERS tagQUEUEDredis 127.0.0.1:6379&gt; EXEC1) OK2) &quot;Mastering C++ in 21 days&quot;3) (integer) 34) 1) &quot;Mastering Series&quot; 2) &quot;C++&quot; 3) &quot;Programming&quot; 单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的 事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做 It’s important to note that even when a command fails, all the other commands in the queue are processed – Redis will not stop the processing of commands. Redis 数据备份与恢复SAVA命令会在redis安装目录创建dump.rdb文件把备份文件移动到redis安装目录并启动服务即可恢复数据，CONFIG GET dir获取redis目录BGSAVE也是创建Redis备份文件（异步） Redis安全可以通过Redis的配置文件设置密码参数，这样客户端连接Redis就要密码验证 CONFIG get requirepass查看是否设置密码验证CONFIG set requirepass &quot;youpass&quot;设置密码AUTH password使用password连接Redis 其他命令Redis还有LUA脚本命令，连接命令，服务器命令，测试性能命令等，包括执行LUA脚本，后台异步保存当前数据库的数据到磁盘，同步保存数据到硬盘，关闭客户端连接等，详情见文档 JedisPOM添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt; 创建Jedis对象 1Jedis jedis = new Jedis("localhost"); 然后就可以用Java方法来操纵Redis了 使用Redis连接池跟数据库连接池相同，Java Redis也提供了类redis.clients.jedis.JedisPool来管理我们的Redis连接池对象，并且我们可以使用redis.clients.jedis.JedisPoolConfig来对连接池进行配置，代码如下： 123456789101112131415JedisPool pool;Jedis jedis;JedisPoolConfig poolConfig = new JedisPoolConfig();// 最大空闲数poolConfig.setMaxIdle(50);// 最大连接数poolConfig.setMaxTotal(100);// 最大等待毫秒数poolConfig.setMaxWaitMillis(20000);// 使用配置创建连接池pool = new JedisPool(poolConfig, "localhost");// 从连接池中获取单个连接jedis = pool.getResource();// 如果需要密码//jedis.auth("password"); Redis Spring集成Redis 只能支持六种数据类型（string/hash/list/set/zset/hyperloglog）的操作，但在 Java 中我们却通常以类对象为主，所以在需要 Redis 存储的五中数据类型与 Java 对象之间进行转换，如果自己编写一些工具类，比如一个角色对象的转换，还是比较容易的，但是涉及到许多对象的时候，这其中无论工作量还是工作难度都是很大的，所以总体来说，就操作对象而言，使用 Redis 还是挺难的，好在 Spring 对这些进行了封装和支持。 上面所说的Redis无法操作对象的问题，无法在基础类型和Java对象之间方便的转换，但在Spring中，这些问题都可以通过使用RedisTemplate得到解决 先引入jar包 Spring Data Redis 2.x binaries require JDK level 8.0 and above and Spring Framework 5.0.7.RELEASE and above. spring-data-redis 2.0以上需要jdk8和spring5以上，因为我的Spring版本是4.x，所以我使用的spring-data-redis版本如下，同时为了兼容，我把jedis也降级为2.x （2.x的spring-data-redis与spring 4不兼容，3.x的jedis与1.x的spring-data-redis不兼容，我人晕了…）最终可以兼容的spring-data-redis与jedis版本如下： 12345678910&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;1.8.22.RELEASE&lt;/version&gt;&lt;/dependency&gt; 使用Spring配置JedisPoolConfig对象 12345678&lt;bean class="redis.clients.jedis.JedisPoolConfig" id="jedisPoolConfig" &gt; &lt;!--最大空闲数--&gt; &lt;property name="maxIdle" value="50" /&gt; &lt;!--最大连接数--&gt; &lt;property name="maxTotal" value="100" /&gt; &lt;!--最大等待时间--&gt; &lt;property name="maxWaitMillis" value="20000" /&gt;&lt;/bean&gt; 为连接池配置工厂模型 12345&lt;bean id="jedisConnFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory"&gt; &lt;property name="hostName" value="localhost" /&gt; &lt;property name="port" value="6379" /&gt; &lt;property name="poolConfig" ref="jedisPoolConfig" /&gt;&lt;/bean&gt; 配置RedisTemplate 普通的连接根本没有办法直接将对象直接存入 Redis 内存中，我们需要替代的方案：将对象序列化（可以简单的理解为继承Serializable接口）。我们可以把对象序列化之后存入Redis缓存中，然后在取出的时候又通过转换器，将序列化之后的对象反序列化回对象，这样就完成了我们的要求 RedisTemplate可以帮助我们完成这份工作，它会找到对应的序列化器去转换Redis的键值 1&lt;bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate" p:connection-factory-ref="jedisConnFactory" /&gt; 编写测试的POJO类 1234567public class Student implements Serializable &#123; private String name; private int age; // getter setter toString()&#125; 编写测试类，获取redisTemplate对象 12345678910111213141516171819@RunWith(BlockJUnit4ClassRunner.class)public class TestSpringJedis extends UnitTestBase &#123;// UnitTestBase可以见我Spring相关的博客 public TestSpringJedis() &#123; super("classpath:spring-data-redis.xml"); &#125; @Test public void test() &#123; RedisTemplate redisTemplate = super.getBean("redisTemplate"); Student student = new Student(); student.setName("aha"); student.setAge(22); redisTemplate.opsForValue().set("student", student); Student student1 = (Student) redisTemplate.opsForValue().get("student"); System.out.println(student1); &#125;&#125; RedisTemplateSpring封装了RedisTemplate对象来进行对Redis的各种操作，它支持所有的Redis原生的api。RedisTemplate位于spring-data-redis包下 12345redisTemplate.opsForValue();//操作字符串redisTemplate.opsForHash();//操作hashredisTemplate.opsForList();//操作listredisTemplate.opsForSet();//操作setredisTemplate.opsForZSet();//操作有序set StringRedisTemplate与RedisTemplate的区别： 两者的关系是StringRedisTemplate继承RedisTemplate。 两者的数据是不共通的；也就是说StringRedisTemplate只能管理StringRedisTemplate里面的数据，RedisTemplate只能管理RedisTemplate中的数据。 SDR默认采用的序列化策略有两种，一种是String的序列化策略，一种是JDK的序列化策略。 StringRedisTemplate默认采用的是String的序列化策略，保存的key和value都是采用此策略序列化保存的。 RedisTemplate默认采用的是JDK的序列化策略，保存的key和value都是采用此策略序列化保存的。 RedisTemplate的序列化问题RedisTemplate可以帮助我们序列化对象，但使用默认的配置，会发现序列化对象在redis-cli中查找不到，如： 123456@Testpublic void test() &#123; RedisTemplate&lt;String, String&gt; redisTemplate = super.getBean("redisTemplate"); redisTemplate.opsForValue().set("myspringredis", "Hello World From Spring"); System.out.println(redisTemplate.opsForValue().get("myspringredis"));&#125; 会发现可以正常输出，但只要在redis-cli上GET myspringredis，发现输出的是null，使用keys *查看，发现有一个类似的\xac\xed\x00\x05t\x00\rmyspringredis网上查阅资料发现，原来是序列化的问题，RedisTemplate会默认使用JdkSerializationRedisSerializer，这个序列化器会导致上述问题的出现，它的优点和缺点如下： 它要求存储的对象都必须实现java.io.Serializable接口，他存储二进制数据，对开发者不友好 因为他存储的为二进制。但是有时候，我们的Redis会在一个项目的多个project中共用，这样如果同一个可以缓存的对象在不同的project中要使用两个不同的key来分别缓存，既麻烦，又浪费 序列化后的结果非常庞大，是JSON格式的5倍左右，这样就会消耗redis服务器的大量内存 优点是反序列化时不需要提供（传入）类型信息(class) 要解决上述问题，可以使用StringRedisSerializer，它是StringRedisTemplate默认的序列化方法，如下所示配置RedisTemplate 12345678&lt;bean id="stringRedisSerializer" class="org.springframework.data.redis.serializer.StringRedisSerializer" /&gt;&lt;bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate" p:connection-factory-ref="jedisConnFactory" &gt; &lt;property name="valueSerializer" ref="stringRedisSerializer" /&gt; &lt;property name="keySerializer" ref="stringRedisSerializer" /&gt; &lt;property name="hashValueSerializer" ref="stringRedisSerializer" /&gt; &lt;property name="hashKeySerializer" ref="stringRedisSerializer" /&gt;&lt;/bean&gt; 这样，序列化对象在redis-cli就可以成功找到了]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>序列化</tag>
        <tag>Redis</tag>
        <tag>Jedis</tag>
        <tag>RedisTemplate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程安全与锁优化]]></title>
    <url>%2F2019%2F08%2F03%2F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[线程安全与锁优化线程安全当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替运行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的 这个定义比较严谨，它要求线程安全的代码必须具备一个特征：代码本身封装了所有必要的正确性保障手段（如互斥同步等），令调用者无须关心多线程的问题，更无须自己采取任何措施来保证多线程的正确调用 Java语言中的线程安全我们把Java语言中各种操作共享的数据分为以下5类：不可变，绝对线程安全，相对线程安全，线程兼容和线程对立 不可变不可变的对象一定是线程安全的，如果共享数据是一个基本数据类型，那么只要在定义时使用final关键字修饰就可以保证它是不可变的。如果共享数据是一个对象，那就需要保证对象的行为不会对其状态产生影响才行。保证对象行为不影响自己的状态的途径有很多种，其中最简单的就是把对象中带有状态的变量都声明为final，如Integer，它通过将内部状态变量value定义为final来保障状态不变 Java API中符合不可变要求的类型，除了String，还有枚举类型，Number的部分子类，如Long和Double等数值包装类型，BigInteger和BigDecimal等大数据类型 绝对线程安全绝对的线程安全完全满足上面给出的线程安全的定义，不管运行环境如下，调用者都不需要进行额外的同步措施，在Java中标注自己是线程安全的类，大多数都不是绝对的线程安全 相对线程安全相对的线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性 Java中大部分线程安全类都属于这种类型，如Vector，HashTable，Collections的synchronizedCollection()方法保证的集合等 线程兼容线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确使用同步手段来保证对象在并发的环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数指的就是这一种情况 Java中大部分类都属于线程兼容，如ArrayList和HashMap等 线程对立线程对立指无论调用端是否采用同步措施，都无法在多线程环境中并发使用的代码 线程安全的实现方法互斥同步同步指多个线程并发访问共享数据时，保证共享数据在同一时刻只被一个线程使用（信号量机制下可以被一些使用）。互斥是实现同步的一种手段，临界区(Critical Section)，互斥量(Mutex)和信号量(Semaphore)都是主要的互斥实现方式，互斥是因，同步是果，互斥是方法，同步是目的 Java中最基本的互斥同步手段是synchronized关键字，编译后会在同步块前后形成monitorenter和monitorexit字节码指令，这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象。如果程序中synchronized明确指定了对象参数，那就是这个对象的reference；如果没有明确指定，那就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象 在执行monitorenter指令时，首先尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有那个对象的锁，把锁计数器加1，相应地，执行monitorexit指令时把锁计数器减1，当计数器为0，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止 synchronized同步块对同一条线程是可重入的，不会自己把自己锁死，其次，同步块在已进入线程执行完之前，会阻塞后面其他线程的进入。Java的线程是映射到OS的原生线程上的，如果要阻塞或唤醒一个线程，都需要OS来帮忙完成，这就需要从用户态转换到核心态中，因此需要耗费很多的处理器时间。对于代码简单的同步块（如synchronized修饰的getter和setter），状态转换消耗的时间可能比用户代码执行的时间还要长。所以synchronized关键字是Java语言的一个重量级的操作。在确实有必要的情况下才使用它，虚拟机本身也会进行一些优化，譬如在通知OS阻塞线程前加入一段自旋等待过程，避免频繁进入到核心态中 除了synchronized关键字，我们还可以使用java.util.concurrent的重入锁ReentrantLock来实现同步，基本用法上它们是类似的，只是代码写法上有些出入，一个表现为API层面的互斥锁（lock()和unlock()配合try/finally语句块完成），另一个表现为原生语法层面的互斥锁 不过，相比synchronized，ReentrantLock增加了一些高级功能：等待可中断，可实现公平锁，以及锁可以绑定多个条件 等待可中断指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情 公平锁指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁，synchronized的锁是非公平的，默认情况下ReentrantLock也是非公平的，但可以通过带布尔值的构造函数要求公平锁 锁绑定多个条件指一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait()和notify()或notifyAll()可以实现一个隐含的条件，如果要和多于一个条件关联，就不得不额外添加一个锁，而ReentrantLock只需要多次调用newCondition()方法即可 非阻塞同步互斥同步最主要的问题是进行线程阻塞和唤醒所带来的性能问题，因此这种同步称为阻塞同步。从处理问题方式上来说，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题，无论共享数据是否真的出现竞争，它都要进行加锁，用户态核心态转换，维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作 随着硬件发展，我们有了另外一种选择：基于冲突检测的乐观并发策略，通俗来说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他补偿措施（比如不断重试，直到成功），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步 我们需要操作和冲突检测这两个步骤具备原子性，只能靠硬件来完成它们的原子性，硬件保证一个从语义上来说需要多次操作的行为只通过一条处理器指令就能完成，这类指令常用的有： 测试并设置（Test-and-Set） 获取并增加（Fetch-and-Increment） 交换（Swap） 比较并交换（Compare-and-Swap，下文称CAS） 加载链接/条件存储（Load-Linked/Store-Conditional，下文称LL/SC） CAS指令需要3个操作数，分别是内存位置（V），旧的预期值（A）和新值（B）。CAS指令执行时，当且仅当V符合旧预期值A时，处理器用新值B更新V的值，否则它就不执行更新，但是无论是否更新了V的值，都会返回V的旧值，上述的处理过程就像一个原子操作 JDK 1.5后提供CAS操作，该操作由sun.misc.Unsafe类的compareAndSwapInt()和compareAndSwapLong()等几个方法包装提供，Unsafe类只能通过其他Java API来间接使用，如concurrent包的整数原子类（AtomicInteger），其中的compareAndSet()和getAndIncrement()等方法都用了Unsafe类的CAS操作 CAS操作常见的漏洞是”ABA”问题，即如果一个变量V初次读取的时候是A值，并且准备赋值时它仍然为A值，那也不能说明它就没有被改变过，因为它可能先被改成了B，再被改回A 无同步方案要保证线程安全，不一定需要同步，同步只是保证共享数据争用时的正确性的手段，如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的，主要介绍其中两类 可重入代码：也叫纯代码，可以在代码执行的任何时刻中断它，转而去执行其他代码，而在控制权返回后，原来的程序不会出现任何错误。可冲入代码都是线程安全的。可重入代码有一些共同特征，如不依赖存储在堆上的数据和公用的系统资源，用到的状态量都由参数传入，不调用非可重入的方法等。如果一个方法，它的返回结果是可以预测的，只要输入相同的数据，都能返回相同的结果，那它就满足可重入性的要求，当然也是线程安全的 线程本地存储：如果一段代码所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行，如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题符合这种特点的应用并不少见，大部分使用消息队列的架构模式都会将产品的消费过程尽量在一个线程中消费完，其中最重要的一个应用实例就是经典Web交互模型中的”一个请求对应一个服务器线程”的处理方式，这种处理方式广泛应用使得很多Web服务端应用都可以使用线程本地存储来解决线程安全问题 Java语言中，一个变量要被多线程访问，可以使用volatile关键字声明它是易变得，如果一个变量要被某个线程独享，可以通过java.lang.ThreadLocal类来实现线程本地存储的功能。每一个线程的Thread对象都有一个ThreadLocalMap对象，这个对象存储了一组以ThreadLocal.threadLocalHashCode为键，以本地线程变量为值得K-V值对，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，每一个ThreadLocal对象都包含了一个独一无二的threadLocalHashCode值，使用这个值就可以在线程K-V值中找回对应的本地线程变量 锁优化自旋锁与自适应自旋互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态完成，这些操作给系统的并发性能带来很大的压力，且许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。如果物理机器上有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程稍等一下，但不放弃处理器的执行时间，看看持有锁的线程是否很快就释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁 JDK 1.6引入自适应的自旋锁，自适应意味自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。另外，如果对于某个锁，自旋很少成功过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测越来越准确 锁消除锁消除指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除，锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断在一段代码上，堆上所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上的数据对待，认为它们是线程私有的，同步加锁自然就无须进行（很多同步措施都不是程序员自己想要加入的，而是Java方法本身就有） 锁粗化原则上我们编写代码的时候，总是推荐把同步块的作用范围限制得尽量小，只在共享数据的实际作用域才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快得到锁 大部分情况下，上面的原则是正确的，但是如果一系列连续操作都对同一个对象反复加锁和解锁，甚至加锁操作出现在循环体内，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗 如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，就会把加锁同步的范围扩展到整个操作序列的外部，这样只需要加锁一次即可，这个就是锁粗化 轻量级锁轻量级锁是JDK 1.6之中加入的新型锁机制，传统的锁机制是重量级锁，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用OS互斥量产生的性能消耗 要理解轻量级锁，必须要从HotSpot虚拟机的对象（对象头部分）的内存布局开始介绍。HotSpot虚拟机的对象头分为两部分信息，第一部分用于存储对象自身的运行时数据，如哈希吗，GC分带年龄等，这部分数据长度在32位和64位虚拟机中分别为32bit和64bit，官方称它为”Mark Word”，它是实现轻量级锁和偏向锁的关键。另外一部分用于存储指向方法区对象类型数据的指针，如果是数组对象的话，还会有一个额外的部分用于存储数组长度 在代码进入同步块的时候，如果此同步对象没有被锁定，虚拟机首先将在当前线程的栈帧中建立一个名为锁记录的空间，用于存储锁对象目前的Mark Word的拷贝，然后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，如果这个操作成功了，那么这个线程就拥有了该对象的锁，并且对象的Mark Word的锁标志位转变为”00”，代表此对象处于轻量级锁定状态，如下图所示： 如果这个更新操作失败了，虚拟机首先检查对象的Mark Word是否指向当前线程的栈帧，如果只说明当前线程已经拥有这个锁，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志状态值变为”10”，Mark Word中存储的就是指向重量级锁的指针，后面等待锁的线程也要进入阻塞状态 轻量级锁的加锁和解锁过程都是通过CAS操作来完成的 轻量级锁能提升程序同步性能的依据是”对于绝大部分的锁，在整个同步周期都不存在竞争”，这是一个经验数据，如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外发送了CAS操作，因此有竞争的情况下，轻量级锁会比传统的重量级锁更慢 偏向锁偏向锁的目的是消除在无竞争情况下的同步原语，进一步提高程序的运行性能，如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了 偏向锁的偏，就是偏心的偏，它的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他线程获取，则持有偏向锁的线程永远不需要再进行同步 当锁对象第一次被线程获取的时候，虚拟机会把对象头的标志位设为”01”，即偏向模式，同时CAS操作把获取这个锁的线程的ID记录在对象的Mark Word中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作 当有另外一个线程去尝试获取这个锁，偏向模式就结束，根据锁对象目前是否处于被锁定的状态，撤销偏向后恢复到未锁定或轻量级锁定的状态，后续同步操作就如上面的轻量级锁那样执行 偏向锁可以提高带有同步但无竞争的程序性能，同样是一个带有效益权衡性质的优化]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>线程安全</tag>
        <tag>锁优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存模型与线程]]></title>
    <url>%2F2019%2F08%2F03%2FJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Java内存模型与线程Java内存模型Java虚拟机规范试图定义一种Java内存模型（JMM）来屏蔽各种硬件和OS的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果 主内存与工作内存Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节，这里的变量指实例字段，静态字段和构成数组对象的元素，而不包括局部变量和方法参数，因为它们是线程私有的，不会被共享 Java内存模型规定所有变量都存储在主内存中，每条线程都有自己的工作内存（可以类比高速缓存），线程的工作内存中保存了被该线程使用的变量的主内存副本拷贝，线程对变量的所有操作（读取，赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量，不同线程之间也不能直接访问对方工作内存的变量，线程间变量值的传递均需要通过主内存来完成，如下图所示： 内存间交互操作Java内存模型定义了下面8种操作来完成主内存与工作内存之间的交互协议，虚拟机实现必须保证这8种操作的每一种都是原子性的 lock：作用于主内存的变量，它把一个变量标识为一条线程独占的状态 unlock：作用于主内存的变量，它把一个处于锁定状态的变量释放出来 read：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用 load：作用于工作内存的变量，它把read操作从主内存得到的变量值放入工作内存的变量副本中 use：作用于工作内存的变量，它把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值得字节码指令时就会执行这个操作 assign：作用于工作内存的变量，它把一个从执行引擎收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作 store：作用于工作内存的变量，它把工作内存中一个变量的值传送给主内存中，以便随后的write操作使用 write：作用于主内存的变量，它把store操作从工作内存得到的变量值写入主内存的变量中 read和load，store和write必须顺序执行（但可以不连续），上述8种操作还必须满足下面规则： 不允许read和load，store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现 不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步写回主内存 不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load，assign）的变量，换句话说，就是对一个变量实施use，store之前，必须先执行过了assign和load操作 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock之后，只有执行相同次数的unlock，变量才会被解锁 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值 如果一个变量实现没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量 对一个变量执行unlock之前，必须先把此变量同步回主内存中 对于volatile型变量的特殊规则volatile可以说是Java虚拟机提供的最轻量级的同步机制，当一个变量定义volatile后，它将具备两种特性： 第一是保证此变量对所有线程的可见性，可见性指一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的，而普通变量做不到这一点，普通变量的值在线程间传递均需要通过主内存来完成（可见性并不能保证并发安全，详见另一篇blog：Java并发基础2-同步） volatile适用于以下的运算场景： 运行结果不依赖变量当前值（即不能count=count+t，可以count=t)，或者能够确保只有单一的线程修改变量的值 变量不需要与其他状态变量共同参与不变约束 下面例子就很适合使用volatile变量来控制并发 1234567891011volatile boolean shutdownRequested;public void shutdown() &#123; shutdownRequested = true;&#125;public void doWork() &#123; while (!shutdownRequested) &#123; // do stuff &#125;&#125; 使用volatile的第二个语义是禁止指令重排序优化，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取正确的结果，而不能保证变量赋值与程序代码中的执行顺序一致 1234567891011121314151617Map configOptions;char[] configText;volatile boolean initialized = false;// 线程A执行// 模拟读取配置信息，当读取完毕后将initialized设置为true通知其他线程配置可用configOptions = new HashMap();configText = readConfigFile(fileName);processConfigOptions(configText, configOptions);initialized = true;// 线程B执行// 等待initialized为true，代表线程A已经把配置信息初始化完成while (!initialized) &#123; sleep();&#125;doSomethingWithConfig(); 如果不声明为volatile，则可能会由于指令重排而导致initialized被提前执行，在配置没有配置好的情况下线程B就使用配置了 volatile变量读操作的性能消耗和普通变量几乎没有差别，但是写操作会有一些额外的开销，因为它需要在本地代码插入许多内存屏障指令来保证处理器不发送乱序执行，大多情况下，volatile的开销都比锁要低 volatile的特殊规则（操作层面略）： 在工作内存中，每次使用volatile的变量时都必须先从主内存刷新最新的值，用于保证能看见其他线程对变量所做的修改后的值 在工作内存中，每次修改volatile的变量时都必须立即同步回主内存中，用于保证其他线程可以看到自己对变量所做的修改 要求volatile修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序顺序相同 对于long和double型变量的特殊规则Java内存模型要求lock，unlock等8个操作都具有原子性，但是对于64位的数据类型，允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为2次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load，store，read和write的原子性，这就是long和double的非原子性协定 如果有多个线程共享一个未声明为volatile的long或double变量，并且同时对它们进行读取和修改操作，则可能会读取到一个非原值也不是其他线程修改值的数值，但这种情况很少出现，因为虽然规范允许long和double的读写不是原子操作，但还是强烈建议虚拟机实现把这些操作实现为具有原子性的操作，且虚拟机实现几乎都把64位数据的读写操作作为原子操作来对待 原子性，可见性与有序性原子性：由Java内存模型来直接保证原子性变量操作包括read，load，assign，use，store和write，我们大致可以认为基本类型的访问读写是具备原子性的synchronized块的内部其实就是lock与unlock操作，块之间的操作也具备原子性 可见性：可见性指一个线程修改了共享变量的值，其他线程能够立即知道这个修改。Java内存模型是通过在变量修改后将新值立即同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，除了volatile，Java还有两个关键字可以实现可见性，即synchronized和final 有序性：Java程序天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句指”线程内表现为串行的语义”（即使重排序，单线程内最终结果也不会改变），后半句指”指令重排序”现象和”工作内存与主内存同步延迟”现象 先行发生原则先行发生是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说发生操作B之前，操作A产生的影响能被操作B观察到，”影响”包括修改了内存中共享变量的值，发送了消息，调用了方法等 看下面的例子 12345678// 以下操作在线程A中执行i = 1;// 以下操作在线程B中执行j = i;// 以下操作在线程C中执行i = 2; 假设线程A中的操作先行发送于线程B，那么可以确定线程B执行后，j一定等于1，得出这个结论的依据有两个：一是根据先行发生原则，i=1的结果可以被观察到，二是线程C还没有执行如果线程A和线程B之间的先行发生仍然保持，但线程C出现在线程A和线程B的操作之间，但是线程C与线程B没有先行发生关系，那j的值是不确定的，有可能是1也有可能是2，因为线程C对变量i的影响可能会被线程B观察到，也可能不会，这时线程B就存在读取到过期数据的风险，不具备多线程安全性 下面是Java内存模型下一些天然的先行发生关系，不需要任何同步器就已经存在，可以在编码中直接使用 程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作 管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock的操作。强调同一个锁，且”后面”指时间上的先后顺序 volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的”后面”同样指时间上的先后顺序 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作 线程终止规则：线程中的所有操作先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束，Thread.isAlive()的返回值等手段检测到线程已经终止执行 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断时间的发生 对象终结规则：一个对象的初始化完成先行发生于它的finalize()方法的开始 传递性：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论 注意”时间上的先后顺序”和”先行发生”之间没有任何关联，看下面的例子 123456789private int value = 0;public void setValue(int value) &#123; this.value = value;&#125;public int getValue() &#123; return value;&#125; 线程A先(时间上的先后)调用了”setValue(1)”，然后线程B调用了同一个对象的”getValue()”，那么线程B会收到什么？依次分析先行发生原则中的各项规则，发现没有任何一个适合的先行发生规则，那么就可以说明，尽管线程A在操作时间上是先于线程B，但是无法确定线程B中”getValue()”方法的返回结果，换句话说，这里面的操作不是线程安全的要修复这个问题，可以把getter/setter定义为synchronized方法，就可以套用管程锁定规则，要么就把value定义为volatile，这样就可以套用volatile变量规则 通过上面例子，我们可以得出结论：一个操作”时间上的先发生”不代表这个操作会是”先行发生”，同样也可以证明一个操作”先行发生”不能推导出这个操作必定是”时间上的先发生” 123// 下面操作在同一线程执行int i = 1;int j = 2; 他们是符合先行发生规则的，但是由于指令重排，他们不一定是时间上的先发生 综上，时间先后顺序和先行发生原则之间没有太大的关系，衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准 Java与线程线程的实现线程是比进程更轻量级的调度执行单位，线程的引入，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址，文件I/O等），又可以独立调度（线程是CPU调度的基本单位） 主流的OS都提供了线程实现，Java语言则提供了不同硬件和OS下对线程操作的统一处理，每个已经执行了start()且还未结束的java.lang.Thread类的实例代表了一个线程，Thread类所有关键方法都是Native的，即这个方法没有使用或无法使用平台无关的手段来实现，实现线程主要有3种方式：使用内核线程实现，使用用户线程实现和使用用户线程加轻量级进程混合实现 使用内核线程实现内核线程（KLT）就是直接由OS内核支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器对线程进行调度，并负责将线程任务映射到各个处理器上程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程（LWP），轻量级进程就是我们通常意义上所讲的线程，每个轻量级进程都由一个内核线程支持，这种轻量级进程与内核线程之间1:1的关系称为一对一的线程模型 （P代表进程，KLT代表内核线程，LWP代表轻量级进程） 由于内核线程的支持，每个轻量级进程都成为一个独立的调度单位，即使有一个轻量级进程在系统调用中阻塞了，也不会影响整个进程继续工作 轻量级进程局限性表现为：基于内核线程实现，所以各种线程操作，如创建，析构及同步，都需要进行系统调用，而系统调用的代价相对较高，需要在用户态和内核态中来回切换，其次，每个轻量级进程都需要有一个内核线程的支持，因此轻量进程要消耗一定的内核资源，因此一个系统支持轻量级进程的数量有限 使用用户线程实现广义上说，一个线程只要不是内核线程，就可以认为是用户线程，狭义上说，用户线程是指完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。用户线程的建立，同步，销毁和调度完全在用户态中完成，不需要内核的帮助。如果程序实现得当，这种线程不需要切换到内核态，因此操作可以是非常快速且低消耗的，也可以支持规模更大的线程数量，部分高性能数据库中的多线程就是由用户线程实现，这种进程与用户线程之间1:N的关系称为一对多的线程模型 （UT代表用户线程，P代表进程） 用户线程的优势和劣势都体现在不需要系统内核支援，因此诸如”阻塞如何处理”，”多处理器系统中如何将线程映射到其他处理器上”等问题解决起来异常困难，甚至不可能完成，所以用的很少 使用用户线程加轻量级进程混合实现在这种混合实现下，既存在用户线程，也存在轻量级进程。用户线程完全建立在用户空间中，因此创建，切换等操作依旧廉价，并且可以支持大规模的用户线程并发，OS提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级进程完成，大大降低整个进程被完全阻塞的风险。这种关系是N:M关系 Java线程的实现目前的JDK版本中，OS支持怎样的线程模型，很大程度上决定了Java虚拟机的线程是怎么样映射的，这点在不同的平台上没有办法达成一致，虚拟机规范也没有限定Java线程要使用哪种模型实现 对于Sun JDK来说，它的Windows版本和Linux都是使用一对一的线程模型实现的，一条Java线程就映射一条轻量级进程中 Java线程调度线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是协同式线程调度和抢占式线程调度 协同式调度，线程的执行时间由线程本身决定，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上抢占式调度，每个线程由系统来分配执行时间，线程的切换不由线程本身决定（当然，可以使用Thread.yield()让出执行时间），Java使用的线程调度方式就是抢占式调度 可以通过设置优先级来给某些线程多分配一些执行时间，Java提供了从Thread.MIN_PRIORITY到Thread.MAX_PRIORITY共10种优先级，两个线程同时处于Ready状态时，高优先级的线程越容易被系统选择执行 Windows系统只提供了7种优先级，会导致Java优先级会有几个相同，如下图所示： 状态转换Java语言定义了5种线程状态，任意一个时间点，一个线程只能有且只有其中的一种状态，这5种状态分别如下： 新建New：创建后未启动的线程处于这种状态 运行Runable：包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待CPU为它分配时间 无限期等待Waiting：处于这种状态的线程不会被分配CPU执行时间，它们要等待被其他线程显式唤醒，以下方法会导致线程陷入无限期的等待状态： 没有设置Timeout参数的Object.wait()方法 没有设置Timeout参数的Thread.join()方法 LockSupport.park()方法 限期等待Timed Waiting：处于这种状态的线程也不会被分配CPU执行时间，不过无须等待被其他线程显式地唤醒，一定时间后它们会由系统自动唤醒，以下方法会让线程进入限期等待状态： Thread.sleep()方法 设置了Timeout参数的Object.wait()方法 设置了Timeout参数的Object.join()方法 LockSupport.parkNanos()方法 LockSupport.parkUntil()方法 阻塞Blocked：线程被阻塞了，阻塞与等待的区别是：阻塞在等待获取一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；而等待则是等待一段时间，或者唤醒动作的发生，在程序等待进入同步区域的时候，线程将进入这种状态 结束Terminated：已终止线程的线程状态，线程已经结束执行 这5种状态在遇到特定时间发生时会互相转换，它们的转换关系如下图所示：]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>volatile</tag>
        <tag>JMM</tag>
        <tag>Java线程</tag>
        <tag>先行发生原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序编译与代码优化]]></title>
    <url>%2F2019%2F08%2F02%2F%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[程序编译与代码优化Java语言的编译期既可能是一个前端编译器把.java文件转变成.class文件的过程，也有可能是指虚拟机的后端运行期编译器（JIT编译器）把字节码转变为机器码的过程，还可能是静态提前编译器（AOT编译器）直接把*.java文件编译成本地机器代码的过程 这3类编译过程中一些比较有代表性的编译器如下： 前端编译器：Sun的Javac JIT编译器：HotSpot的C1，C2编译器 AOT编译器：GNU Complier for the Java（GCJ） 早期(编译期)优化Javac编译器Javac编译器的编译过程可以分为3个步骤： 解析与填充符号表 插入式注解处理器的注解处理 分析与字节码生成 Java语法糖泛型与类型擦除Java的泛型只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型，并在相应地方插入了强制类型转换代码 123Map&lt;String, String&gt; map = new HashMap&lt;&gt;();map.put("hello", "你好");System.out.println(map.get("hello")); 编译成Class文件，再用字节码反编译工具反编译后，会如下所示： 123Map map = new HashMap();map.put("hello", "你好");System.out.println((String) map.get("hello")); 泛型擦除导致以下代码会报错 12345678910public class GenericTypes &#123; public static void method(List&lt;String&gt; list) &#123; System.out.println("list&lt;String&gt;"); &#125; public static void method(List&lt;Integer&gt; list) &#123; System.out.println("list&lt;Integer&gt;"); &#125;&#125; 因为泛型擦除，它们的特征签名变得一模一样，方法重载要求方法具备不同的特征签名但只要返回值不同即可，因为描述符不是完全一致的两个方法就可以完全共存 自动装箱，拆箱和遍历循环12345678910111213public class SyntaxSugars &#123; public static void main(String[] args)&#123; List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5); int sum = 0; for(int i : list)&#123; sum += i; &#125; System.out.println("sum = " + sum); &#125;&#125; 1234567891011121314151617181920public class SyntaxSugars &#123; public static void main(String[] args) &#123; List list = Arrays.asList(new Integer[]&#123; Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3), Integer.valueOf(4), Integer.valueOf(5) &#125;); int sum = 0; for (Iterator iterable = list.iterator(); iterable.hasNext(); ) &#123; int i = ((Integer) iterable.next()).intValue(); sum += i; &#125; System.out.println("sum = " + sum); &#125;&#125; 条件编译根据布尔常量值的真假，编译器会把分支中不成立的代码块消除 1234567public static void main(String[] args) &#123; if (true) &#123; System.out.println("block 1"); &#125; else &#123; System.out.println("block 2"); &#125;&#125; 反编译结果如下 123public static void main(String[] args) &#123; System.out.println("block 1");&#125; 晚期(运行期)优化在部分商业虚拟机中，Java 最初是通过解释器解释执行的，当虚拟机发现某个方法或者代码块的运行特别频繁时，就会把这些代码认定为”热点代码”（Hot Spot Code）。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器（JIT） 即时编译器不是虚拟机必须的部分，Java 虚拟机规范并没有规定虚拟机内部必须要有即时编译器存在，更没有限定或指导即时编译器应该如何实现。但是 JIT 编译性能的好坏、代码优化程度的高低却是衡量一款商用虚拟机优秀与否的最关键指标之一 HotSpot虚拟机内的即时编译器解释器与编译器解释器与编译器两者各有优势： 当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地机器码之后，可以获得更高的执行效率 当程序运行环境中内存资源限制较大（如部分嵌入式系统），可以使用解释器执行来节约内存，反之可以使用编译执行来提升效率 HotSpot内置两个即时编译器，分别称为Client Compiler和Server Compiler，或者简称为C1编译器和C2编译器，默认是混合模式，即解释器与编译器搭配使用，可以使用参数-Xint强制让虚拟机运行于解释模式，或-Xcomp使虚拟机强制运行编译模式 HotSpot虚拟机还启用分层编译策略，其中包括如下三层： 第0层，程序解释执行，解释器不开启性能监控功能 第1层，也称为C1编译，将字节码编译为本地代码，进行简单，可靠的优化，如有必要将加入性能监控的逻辑 第2层，也称为C2编译，将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化 Client Compiler有更高的编译速度，Server Compiler有更好的编译质量 编译对象与触发条件在运行过程会被即时编译器编译的热点代码有两类： 被多次调用的方法体 被多次执行的循环体 注意的是，第二种情况，虽然编译动作由循环体触发，但编译器仍然会以整个方法（而不是单独的循环体）作为编译对象 多次的判定可以由基于采样的热点探测或基于计数器的热点探测来判定 基于采样的热点探测：采用这种方法的虚拟机会周期性地检查各个线程栈顶，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是「热点方法」。基于采样的热点探测的好处是实现简单、高效，还可以很容易地获取方法调用关系（将调用栈展开即可），缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因数的影响而扰乱热点探测 基于计数器的热点探测：采用这种方法的虚拟机会为每个方法（甚至代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值就认为它是「热点方法」。这种统计方法实现起来麻烦一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，但是统计结果相对来说更加精确和严谨 HotSpot使用的是第二种，整个JIT编译的交互过程如下图 编译优化技术虚拟机设计团队几乎把对代码的所有优化措施都集中在JIT编译器中，一个简单的例子如下：（注意底层使用的是字节码或机器码指令的优化） 123456789101112static class B &#123; int value; final int get() &#123; return value; &#125;&#125;public void foo() &#123; y = b.get(); z = b.get(); sum = y + z;&#125; 首先是内联，它可以去除方法调用的成本（栈帧等），并且为其他优化建立良好的基础，内联后如下： 12345public void foo() &#123; y = b.value; z = b.value; sum = y + z;&#125; 然后是冗余访问消除 12345public void foo() &#123; y = b.value; z = y; sum = y + z;&#125; 然后是复写传播，这段程序的逻辑中并不需要用一个额外的变量z 12345public void foo() &#123; y = b.value; y = y; sum = y + y;&#125; 然后是无用代码消除 1234public void foo() &#123; y = b.value; sum = y + y;&#125; 最后的代码和一开始的代码效果是一样的，但是省略了很多语句（尤其体现在字节码和机器码指令上） 接下来看几项最具有代表性的优化技术 语言无关的经典优化技术之一：公共子表达式消除 语言相关的经典优化技术之一：数组范围检查消除 最重要的优化技术之一：方法内联 最前沿的优化技术之一：逃逸分析 公共子表达式消除如果一个表达式 E 已经计算过了，并且从先前的计算到现在 E 中所有变量的值都没有发生变化，那么 E 的这次出现就成了公共子表达式。对于这种表达式，没有必要花时间再对它进行计算，只需要直接使用前面计算过的表达式结果代替 E 就好了。如果这种优化仅限于程序的基本块内，便称为局部公共子表达式消除，如果这种优化的范围覆盖了多个基本块，那就称为全局公共子表达式消除 数组边界检查消除如果有一个数组 array[]，在 Java 中访问数组元素 array[i] 的时候，系统会自动进行上下界的范围检查，即检查 i 必须满足 i &gt;= 0 &amp;&amp; i &lt; array.length，否则会抛出一个运行时异常：java.lang.ArrayIndexOutOfBoundsException，这就是数组边界检查 对于虚拟机执行子系统来说，每次数组元素的读写都带有一次隐含的条件判定操作，对于拥有大量数组访问的程序代码，这是一种不小的性能开销。为了安全，数组边界检查是必须做的，但是数组边界检查并不一定每次都要进行。比如在循环的时候访问数组，如果编译器只要通过数据流分析就知道循环变量是不是在区间 [0, array.length] 之内，那在整个循环中就可以把数组的上下界检查消除 方法内联前面代码已经解释过 逃逸分析逃逸分析不是直接优化代码的手段，而是为其它优化手段提供依据的分析技术。逃逸分析的基本行为就是分析对象的动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其它方法中，称为方法逃逸。甚至还有可能被外部线程访问到，例如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸 如果能证明一个对象不会逃逸到方法或者线程之外，也就是别的方法和线程无法通过任何途径访问到这个方法，则可能为这个变量进行一些高效优化。比如： 栈上分配：如果确定一个对象不会逃逸到方法之外，那么就可以在栈上分配内存，对象所占的内存空间就可以随栈帧出栈而销毁。通常，不会逃逸的局部对象所占的比例很大，如果能栈上分配就会大大减轻 GC 的压力 同步消除：如果逃逸分析能确定一个变量不会逃逸出线程，无法被其它线程访问，那这个变量的读写就不会有多线程竞争的问题，因而变量的同步措施也就可以消除了 标量替换：标量是指一个数据无法再拆分成更小的数据来表示了，Java 虚拟机中的原始数据类型都不能再进一步拆分，所以它们就是标量。相反，一个数据可以继续分解，那它就称作聚合量，Java 中的对象就是聚合量。如果把一个 Java 对象拆散，根据访问情况将其使用到的成员变量恢复成原始类型来访问，就叫标量替换。如果逃逸分析证明一个对象不会被外部访问，并且这个对象可以被拆散，那程序执行的时候就可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来替代。对象被拆分后，除了可以让对象的成员变量在栈上分配和读写，还可以为后续进一步的优化手段创造条件。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>JIT编译器</tag>
        <tag>Javac编译器</tag>
        <tag>早期优化</tag>
        <tag>晚期优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机字节码执行引擎]]></title>
    <url>%2F2019%2F08%2F01%2F%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[虚拟机字节码执行引擎执行引擎是Java虚拟机最核心的组成部分之一，物理机的执行引擎是直接建立在处理机，硬件，指令集和操作系统层面上的，而虚拟机的执行引擎是自己实现的，可以自行制定指令集与执行引擎的结构体系，所有Java虚拟机的执行引擎都是输入字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果 运行时栈帧结构栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中虚拟机栈的栈元素，栈帧存储了方法的局部变量表，操作数栈，动态链接和方法返回地址等信息。每一个方法从调用开始到执行完成的过程，都对应着一个栈帧在虚拟机栈里入栈到出栈的过程 每一个栈帧都包括局部变量表，操作数栈，动态链接，方法返回地址和一些额外的附加信息。在编译程序代码的时候，栈帧需要多大的局部变量表，多深的操作数栈都已经完全确定，并且写入方法表的Code属性中，因此一个栈帧需要分配多少内存，不会受程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现 一个线程的方法调用链可能很长，很多方法都同时处于执行状态。对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧，与这个栈帧相关联的方法称为当前方法。执行引擎运行的所有字节码指令都只针对当前栈帧进行操作，概念模型上，典型的栈帧结构如下图： 局部变量表局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量 操作数栈操作数栈是一个后进先出栈。同局部变量表一样，操作数栈的最大深度也可以在编译阶段写入Code属性中，数据项为max_stacks。操作数栈的每一个元素可以是任意Java数据类型，32位数据类型所占栈容量为1，64位为2 一个方法刚开始运行的时候，操作数栈是空的，在方法执行过程中，会有各种字节码指令往操作数栈写入和提取内容，也就是入栈和出栈操作 动态链接每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接。Class文件的常量池中存在大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态链接，另外一部分符号引用将在每一次运行期间转化为直接引用，这部分称为动态链接 方法返回地址当一个方法开始执行后，只有两种方式可以退出这个方法 一种是执行引擎遇到任意一个方法返回的字节码指令，这时候可能有返回值传递给上层方法的调用者，是否有返回值和返回值的类型将根据何种方法返回指令来决定，这种退出方法称为正常完成出口 另外一种退出方法是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表没有搜索到匹配的异常处理器，就会导致方法退出。这种称为异常完成出口，一个方法使用异常完成出口的方式退出，是不会给上层调用者产生任何返回值的 无论采用何种退出方式，在方法退出后都需要返回到方法被调用的位置，程序才能继续运行，方法返回时可能需要在栈帧中保存一些信息，用来恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的PC计数值可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址要通过异常处理表来确定，栈帧中一般不会保存这部分信息 方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上次方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等 方法调用方法调用不是方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。在程序运行时，方法调用是最普遍最频繁的操作，但Class文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局的入口地址（即直接引用），这个特性给Java带来啊了强大的动态扩展能力，但也让Java方法调用过程变得相对复杂起来，需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用 解析所有方法调用中的目标方法在Class文件里都是一个常量池中的符号引用，在类加载的解析阶段，会将其中一部分符号引用转化为直接引用，这种解析能成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。换句话说，调用目标在程序代码写好，编译器进行编译时就必须确定下来。这类方法的调用称为解析 在Java语言中符合”编译期可知，运行期不可知”这个要求的方法，主要包括静态方法和私有方法两大类，这两种方法各自的特点决定了它们不可能通过继承或别的方法重写其他版本，因此它们都适合在类加载阶段进行解析 只要能被invokestatic和invokespecial（调用实例构造器&lt;init&gt;方法，私有方法和父类方法）指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法，私有方法，实例构造器，父类方法4类，它们在类加载的时候就会把符号引用解析为该方法的直接引用，这些方法称为非虚方法，与之相反的方法称为虚方法（final除外） 对于final修饰的方法，虽然使用invokevirtual指令来调用，但是由于它无法被覆盖，所以也无须对方法接收者进行多态选择，final方法也是一种非虚方法 解析调用一定是静态的过程，在编译期就完全确认，在类装载的解析阶段就会把涉及的符号引用转变为可确定的直接引用，不会延迟到运行期再去完成 分派分派调用过程会揭示多态性特征的一些最基本的体现，如”重载”和”重写”在Java虚拟机是如何实现的 静态分派123456789101112131415161718192021222324252627282930313233public class StaticDispatch &#123; private static abstract class Human &#123; &#125; private static class Man extends Human &#123; &#125; private static class Woman extends Human &#123; &#125; private void sayHello(Human guy) &#123; System.out.println("Hello, guy!"); &#125; private void sayHello(Man man) &#123; System.out.println("Hello, man!"); &#125; private void sayHello(Woman woman) &#123; System.out.println("Hello, woman!"); &#125; public static void main(String[] args) &#123; Human man = new Man(); Human woman = new Woman(); StaticDispatch dispatch = new StaticDispatch(); dispatch.sayHello(man); dispatch.sayHello(woman); &#125;&#125;/* 输出结果：Hello, guy!Hello, guy!*/ 上面main函数的代码中，Human称为变量的静态类型，或者叫做外观类型，而后面的Man或者Woman则是变量的实际类型，静态类型和实际类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在使用时（方法调用时）发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么，如下： 123456// 实际类型变化Human man = new Man();man = new Woman();// 静态类型变化sr.sayHello((Man) man);sr.sayHello((Woman) man); 虚拟机（编译器）在重载时通过参数的静态类型而不是实际类型作为判定依据，编译阶段Javac编译器会根据参数的静态类型决定使用哪个重载版本，并将这个方法的符号引用写到invokevirtual指令参数中。所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派典型应用是方法重载。静态分派发生在编译阶段 很多情况下重载版本不是唯一的，往往只能确定一个更加合适的版本，如下： 12345678910111213141516171819202122232425262728293031323334public class Overload &#123; static void sayHello(Object arg) &#123; System.out.println("Hello, Object!"); &#125; static void sayHello(int arg) &#123; System.out.println("Hello, int!"); &#125; static void sayHello(long arg) &#123; System.out.println("Hello, long!"); &#125; static void sayHello(Character arg) &#123; System.out.println("Hello, Character!"); &#125; static void sayHello(char arg) &#123; System.out.println("Hello, char!"); &#125; static void sayHello(char... arg) &#123; System.out.println("Hello, char...!"); &#125; static void sayHello(Serializable arg) &#123; System.out.println("Hello, Serializable!"); &#125; public static void main(String[] args) &#123; sayHello('a'); &#125;&#125; 它会输出”Hello, char!”，注释掉sayHello(char arg)，会输出”Hello int!”，这时发生了一次自动类型转换，它会按照char-&gt;int-&gt;long-&gt;float-&gt;double的顺序转型进行匹配（不会匹配到byte和short，因为是不安全的），继续注释到sayHello(long)，会输出”Hello, Character!”，这次发生了自动装箱，继续注释则”Hello, Serializable!”，装箱类实现了序列化类的接口，所以可以自动转型，注意Character不会转型为Integer，它只能安全地转型为它实现的接口或父类，如果实现了多个接口，且优先级一样，则会提示类型模糊，拒绝编译，如果有多个父类，则在继承关系中从下往上搜索，越靠近上层优先级越低，变长参数的重载优先级是最低的 动态分派动态分派和动态性的另一个重要体现—重写有很密切关系 123456789101112131415161718192021222324252627282930313233public class DynamicDispatch &#123; static abstract class Human &#123; abstract void sayHello(); &#125; static class Man extends Human &#123; @Override void sayHello() &#123; System.out.println("Man say hello!"); &#125; &#125; static class Woman extends Human &#123; @Override void sayHello() &#123; System.out.println("Woman say hello!"); &#125; &#125; public static void main(String[] args)&#123; Human man = new Man(); Human woman = new Woman(); man.sayHello(); woman.sayHello(); man = new Woman(); man.sayHello(); &#125;&#125; 静态类型同样都是Human的两个变量man和woman在调用sayHello()方法的时候执行了不同的行为，关键是invokevirtual指令的多态查找过程，invokevirtual指令的运行时解析过程大致分为以下几个步骤： 找到操作数栈顶的第一个元素所指向的对象的实际类型，记为C 如果在类型C中找到与常量中描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过则返回java.lang.IllegalAccessError异常 否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程 如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常 即重写使用的是动态分派，最终调用的方法一般上来说是实际类型的方法，如果没有则往上搜索其父类的方法 单分派与多分派方法的接收者与方法的参数统称为方法的宗量，根据分派基于多少种宗量，可以将分派划分为单分派和多分派，单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Dispatch &#123; static class QQ &#123; &#125; static class _360 &#123; &#125; static class Father &#123; public void hardChoice(QQ qq) &#123; System.out.println("Father choose QQ!"); &#125; public void hardChoice(_360 qiHu360) &#123; System.out.println("Father choose 360!"); &#125; &#125; static class Son extends Father &#123; @Override public void hardChoice(QQ qq) &#123; System.out.println("Son choose QQ!"); &#125; @Override public void hardChoice(_360 _360) &#123; System.out.println("Son choose 360!"); &#125; &#125; public static void main(String[] args) &#123; Father father = new Father(); Father son = new Son(); father.hardChoice(new QQ()); son.hardChoice(new _360()); &#125;&#125;/* 输出结果Father choice QQ!Son choice 360!*/ 首先看编译阶段编译器的选择过程，也就是静态分派的过程，这时选择目标方法的依据有两点：一是静态类型是Father还是Son，二是方法参数是QQ还是360，这次选择结果的最终产物是产生了两条invokevirtual指令，两条指令的参数分别为常量池中指向Father.hardChoice(360)及Father.hardChoice(QQ)方法的符号引用。因为是根据两个宗量进行选择，所以Java语言的静态分派属于多分派类型 再看看运行阶段虚拟机的选择，也就是动态分派的过程。在执行”son.hardChoice(new QQ())”的时候，由于编译期已经决定目标方法的签名必须是hardChoice(QQ)，唯一影响虚拟机选择的因素只有此方法的接受者的时机类型是Father还是Son，因为只有一个宗量可以选择，所以Java语言的动态分派属于单分派类型 综上，目前Java语言是一门静态多分派，动态单分派的语言 基于栈的字节码解释执行引擎Java虚拟机的执行引擎在执行Java代码的时候都有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择 解释执行Java 语言常被人们定义成「解释执行」的语言，但随着 JIT 以及可直接将 Java 代码编译成本地代码的编译器的出现，这种说法就不对了。只有确定了谈论对象是某种具体的 Java 实现版本和执行引擎运行模式时，谈解释执行还是编译执行才会比较确切。 无论是解释执行还是编译执行，无论是物理机还是虚拟机，对于应用程序，机器都不可能像人一样阅读、理解，然后获得执行能力。大部分的程序代码到物理机的目标代码或者虚拟机执行的指令之前，都需要经过下图中的各个步骤。下图中最下面的那条分支，就是传统编译原理中程序代码到目标机器代码的生成过程；中间那条分支，则是解释执行的过程。 如今，基于物理机、Java 虚拟机或者非 Java 的其它高级语言虚拟机的语言，大多都会遵循这种基于现代编译原理的思路，在执行前先对程序源代码进行词法分析和语法分析处理，把源代码转化为抽象语法树。对于一门具体语言的实现来说，词法分析、语法分析以至后面的优化器和目标代码生成器都可以选择独立于执行引擎，形成一个完整意义的编译器去实现，这类代表是 C/C++。也可以为一个半独立的编译器，这类代表是 Java。又或者把这些步骤和执行全部封装在一个封闭的黑匣子中，如大多数的 JavaScript 执行器。Java 语言中，Javac 编译器完成了程序代码经过词法分析、语法分析到抽象语法树、再遍历语法树生成字节码指令流的过程。因为这一部分动作是在 Java 虚拟机之外进行的，而解释器在虚拟机的内部，所以 Java 程序的编译就是半独立的实现 基于栈的指令集与基于寄存器的指令集Java 编译器输出的指令流，基本上是一种基于栈的指令集架构。基于栈的指令集主要的优点就是可移植，寄存器由硬件直接提供，程序直接依赖这些硬件寄存器则不可避免的要受到硬件约束。栈架构的指令集还有一些其他优点，比如相对更加紧凑（字节码中每个字节就对应一条指令，而多地址指令集中还需要存放参数）、编译实现更加简单（不需要考虑空间分配的问题，所有空间都是在栈上操作）等 栈架构指令集的主要缺点是执行速度相对来说会稍慢一些。所有主流物理机的指令集都是寄存器架构也从侧面印证了这一点 虽然栈架构指令集的代码非常紧凑，但是完成相同功能需要的指令集数量一般会比寄存器架构多，因为出栈、入栈操作本身就产生了相当多的指令数量。更重要的是，栈实现在内存中，频繁的栈访问也意味着频繁的内存访问，相对于处理器来说，内存始终是执行速度的瓶颈。由于指令数量和内存访问的原因，所以导致了栈架构指令集的执行速度会相对较慢]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>运行时栈帧结构</tag>
        <tag>解析</tag>
        <tag>分派（解释重写与重载的虚拟机实现）</tag>
        <tag>基于栈的指令集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机类加载机制]]></title>
    <url>%2F2019%2F07%2F31%2F%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[虚拟机类加载机制虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制 与编译时需要进行连接工作的语言不同，Java语言里，类型的加载，连接和初始化过程都是在程序运行期间完成的 类加载的时机类从被加载到虚拟机内存开始，到卸载出内存为止，整个生命周期包括：加载，验证，准备，解析，初始化，使用和卸载 7个阶段，其中验证，准备，解析 3个部分统称为连接，发生顺序如下图所示 加载，验证，准备，初始化和卸载这5个阶段的顺序是确定的，类加载过程必须按照这种顺序按部就班的开始（这些阶段都是互相交叉混合进行的，通常会在一个阶段执行的过程中调用，激活另一阶段），而解析阶段则不一定，它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定 对于什么时候开始加载阶段，Java虚拟机规范中并没有强制约束，可以交给虚拟机具体实现来自由把握，而对于初始化阶段，虚拟机规范严格规定有且只有5种情况必须立即对类进行初始化（加载，验证，准备要在初始化之前开始）： 遇到new，getstatic，putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令最常见的Java代码场景是：使用new关键字实例化对象的时候，读取或设置一个类的静态字段（被final修饰，已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化 虚拟机启动时，用户需要指定一个要执行的主类（main()方法那个类），虚拟机会先初始化这个主类 动态语言支持时，如果java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic的方法句柄并且这个句柄所对应的类没有初始化，则需要先触发其初始化 这5个场景会触发类进行初始化的场景，它们的行为称为对一个类进行主动引用，所有其他场景都不会触发初始化，称为被动引用，如下面例子： 12345678910111213141516171819202122232425262728// 通过子类引用父类的静态字段，不会导致子类的初始化public class SuperClass &#123; static &#123; System.out.println("SuperClass init!"); &#125; public static int superValue = 123;&#125;public class SubClass extends SuperClass &#123; static &#123; System.out.println("SubClass init!"); &#125;&#125;public class test &#123; public static void main(String[] args) &#123; System.out.println(SubClass.superValue); &#125;&#125;// 输出结果：/*SuperClass init!123*/ 1234// 通过数组定义来引用类，不会触发此类的初始化public static void main(String[] args) &#123; SuperClass[] sca = new SuperClass[10];&#125; 123456789101112131415161718192021222324252627282930// 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化public class ConstClass &#123;/** * @program: MyAlgothrims * * @description: * * @author: makaloo * * @create: 2019-07-19 12:00 **/ static &#123; System.out.println("ConstClass init!"); &#125; public static final String HELLOWORLD = "hello world!";&#125;public class test &#123; public static void main(String[] args) &#123; System.out.println(ConstClass.HELLOWORLD); &#125;&#125;// 输出结果/*hello world!*/ 接口和类的区别是：当类在初始化时，要求其父类全部都已经初始化，而接口并不要求父接口全部完成初始化，只有在真正使用到父接口的时候才会初始化（如引用接口中定义的常量） 类加载的过程加载加载是类加载过程的一个阶段，加载阶段，虚拟机需要完成以下3件事情 通过一个类的全限定名来获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 常见的获取二进制字节流的例子为：从ZIP包读取（以及之后的JAR,EAR,WAR包），其他文件生成（JSP）等 非数组类的加载阶段可控性最强，它既可以使用系统提供的引导类加载器来完成，也可以用用户自定义的类加载器去完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式（即重写一个loadClass()方法）对于数组类，它本身不通过类加载器创建，而是由Java虚拟机直接创建，但数组类的元素类型最终还是要靠类加载器去完成，一个数组类（下面简称为C）创建过程遵循以下规则： 如果数组的组件类型是引用类型，就递归采用本节中定义的加载过程去加载这个组件类型，数组C将在加载该组件类型的类加载器的类名称控件上被标识 如果数组的组件类型不是引用类型，Java虚拟机将会把数组C标记为与引导类加载器关联 数组类的可见性与它的组件类型的可见性一致，如果数组类型不是引用类型，那数组类的可见性将默认为public 加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区中，方法区中的数据存储格式由虚拟机自行定义（虚拟机规范未规定此区域的具体数据结构），然后在内存中实例化一个java.lang.Class类的对象（规范里没有说明在Java堆，但HotSpot虚拟机Class对象存放在方法区里），这个对象将作为程序访问方法区的这些类型数据的外部接口 加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能就已经开始 验证验证是连接阶段的第一步，这一阶段目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全 Java语言是相对安全的语言，使用纯粹Java代码无法做到访问数组边界以外的数据，对象转型为未实现的类型等，如果这样做，编译器拒绝编译。但Class文件不要求用Java源代码编译而来，可以使用任何途径包括十六进制编辑器等，从字节码语言层面上讲，这些途径是可以实现Java代码无法做到的事情（至少语义上可以表达出来），因此虚拟机需要检查输入的字节流。验证是虚拟机对自身保护的一项重要工作 整体上讲，验证分为4个阶段：文件格式验证，元数据验证，字节码验证，符号引用验证 文件格式验证这一阶段可能包含下面验证点 是否以魔数0xCAFEBABE开头 主，次版本号是否在当前虚拟机处理范围内 常量池的常量中是否有不被支持的常量类型（检查常量tag标志） 指向常量的各种索引值是否有指向不存在的常量或不符合类型的常量 CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据 Class文件中各个部分及文件本身是否有被删除的或附加的其他信息…… 第一阶段还有许多验证点，该验证阶段确保输入的字节流能正确解析并存储于方法区内，格式上符合一个Java类型信息的要求。这阶段的验证是基于二进制字节流进行的，只有通过这个阶段的验证后，字节流才会进入内存的方法区中进行存储，后面3个阶段全部是基于方法区的存储结构进行的，不再直接操作字节流 元数据验证对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，可能包括的验证点如下 这个类是否有父类（除了java.lang.Object，其他所有类都有父类） 这个类的父类是否继承了不允许被继承的类（被final修饰的类） 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法 类中的字段，方法是否与父类产生矛盾（覆盖父类final字段，出现不符合规则的方法重载等） 第二阶段主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息 字节码验证第三阶段是验证过程最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的。在第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件 保证任何时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现操作栈放置一个int类型的数据，使用时却按long类型来加载到本地变量表 保证跳转指令不会跳转到方法体以外的字节码指令中 保证方法体的类型转换是有效的，例如父类对象赋值给子类数据类型，对象赋值给与它无关的数据类型都是危险的，不合法的 没通过字节码验证的类方法体肯定有问题，通过字节码验证的方法体不一定没有问题：通过程序去校验程序逻辑是无法做到绝对准确的 为了避免过多时间消耗在字节码验证阶段，JDK 1.6之后Javac编译器和Java虚拟机进行一项优化是给方法体的Code属性的属性表增加一项名为”StackMapTable”的属性，这项属性描述方法体中所有基本块开始时本地变量表和操作栈应有的状态，字节码验证期间，不需要根据程序推导这些状态的合法性，只需要检查StackMapTable属性的记录是否合法即可，这样将字节码验证的类型推导转变为类型检查从而节省时间 符号引用验证最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作在连接的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，通常需要校验下列内容： 符号引用中通过字符串描述的全限定名是否能找到对应的类 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段 符号引用中的类，字段和方法的访问性（private等）是否可以被当前类访问 符号引用验证的目的是确保解析动作能正常执行，如果无法通过符号引用验证，会抛出一个java.lang.IncompatibleClassChangeError异常的子类，如java.lang.IllegalAccessError,java.lang.NoSuchFieldError,java.lang.NoSuchMethodError等 验证阶段是非常重要但不是必要的阶段，如果所运行的全部代码都已经被反复使用和验证过，那么实施阶段可以考虑使用-Xverify:none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间 准备准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这个阶段进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量将会在对象实例化的时候随着对象一起分配到Java堆中。初始值”通常情况下”是数据类型的零值，假设一个类变量定义为：public static int value = 123;，这时变量value在准备阶段后的初始值为0，而不是123，因为这时还没有执行任何Java方法，把value赋值为123的putstatic指令是程序被编译后，存放于类构造器&lt;clinit&gt;()方法之中，所以把value赋值为123的动作将在初始化阶段才会执行，零值表如下： 数据类型 int long short char byte boolean float double reference 零值 0 0L (short) 0 ‘\u0000’ (byte) 0 false 0.0f 0.0d null 特殊情况指类字段的字段属性表中存在ConstantValue属性，那么准备阶段变量value就会被初始化为ConstantValue属性所指定的值，如public static final int value = 123;，编译时javac将为value生成ConstantValue属性，在准备阶段，虚拟机根据ConstantValue的设置将value赋值为123 解析解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，在Class文件中符号引用以CONSTANT_Class_info,CONSTANT_Fieldref_info,CONSTANT_Methodref_info等类型的常量出现，符号引用和直接引用的关联如下： 符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时无歧义的定位到目标即可。符号引用和虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但能接受的符号引用必须一致，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中 直接引用：可以是直接指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内部布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在 虚拟机规范没有规定解析阶段发生的具体时间，具体虚拟机实现可以根据需要来判断到底是在类被加载器加载时就对常量池的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它 解析动作主要针对类或接口，字段，类方法，接口方法，方法类型，方法句柄和调用点限定符7类符号引用进行，对应常量池的CONSTANT_Class_info,CONSTANT_Fieldref_info,CONSTANT_Methodref_info,CONSTANT_InterfaceMethodref_info,CONSTANT_MethodType_info,CONSTANT_MethodHandle_info和CONSTANT_InvokeDynamic_info 7种常量类型 主要分为类或接口的解析，字段解析，类方法解析和接口方法解析，过程略 初始化类初始化阶段是类加载过程的最后一步。在初始化阶段才真正执行类中定义的Java程序代码 初始化阶段是执行类构造器&lt;clinit&gt;()方法的过程 &lt;clinit&gt;()方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，顺序由语句在源文件中出现的顺序决定，静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但不能访问，如下 1234567public class Test &#123; static &#123; i = 0; // 正常编译通过 System.out.println(i); // 提示非法向前引用 &#125; static int i = 1;&#125; &lt;clinit&gt;()方法与类的构造函数（或者说与实例构造器&lt;init&gt;()方法）不同，它不需要显式地调用父类构造器，虚拟机会保证子类的&lt;clinit&gt;()方法执行之前，父类的&lt;clinit&gt;()方法已经执行完毕，所以虚拟机第一个被执行的&lt;clinit&gt;()方法的类是java.lang.Object &lt;clinit&gt;()方法不是必须的，如果一个类没有为类变量赋值和静态语句块，就不会有&lt;clinit&gt;()方法 &lt;clinit&gt;()方法会在多线程环境被正确加锁，同步 类加载器类与类加载器，双亲委派模型，破坏双亲委派模型，略]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>虚拟机类加载机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络6-思维导图]]></title>
    <url>%2F2019%2F07%2F31%2F%E7%BD%91%E7%BB%9C6-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[网络6-思维导图]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>思维导图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络5-应用层]]></title>
    <url>%2F2019%2F07%2F31%2F%E7%BD%91%E7%BB%9C5-%E5%BA%94%E7%94%A8%E5%B1%82%2F</url>
    <content type="text"><![CDATA[网络4-应用层 网络应用模型客户/服务器模型；P2P模型 域名系统DNS层次域名控件；域名服务器；域名解析过程 文件传输协议FTPFTP的工作原理；控制连接与数据连接 电子邮件E-mail电子邮件系统的组成结构；电子邮件格式与MIME；SMTP与POP3 万维网WWWWWW的概念与组成结构；HTTP 网络应用模型客户/服务器模型C/S模型中，服务器总是处于打开状态，它服务于许多来自其他客户机的主机请求，工作流程如下 服务器处于接收请求的状态 客户机发出服务请求，并等待接收结果 服务器收到请求后，分析请求，进行必要的处理，得到结果并发送给客户机 P2P模型P2P模型的思想是整个网络中的传输内容不再被保存在中心服务器上，每个结点都同时又下载，上传的功能 P2P优点是减轻服务器压力，可扩展性好，网络健壮性强，多个客户机之间可以直接共享文档；缺点是占用内存，对硬盘损伤大，使网络非常拥塞 域名系统DNSDNS是计算机网络应用层一个很重要的服务，了解它基本就了解了整个网络中域名到IP转换的过程。 DNS是什么在《计算机网络-自顶向下方法》中有这么一句话 DNS：因特网的目录服务 DNS（Domain Name System）其实就是一个目录，他的作用是通过用户给定域名，查出对应的IP地址。 而更为严格的定义就是：DNS是： 一个由分层的DNS服务器实现的分布式数据库 一个使得主机能够查询分布式数据库的应用层协议 或者说DNS是一个黑盒子，它提供了主机名到IP地址的转换，一个简便的DNS黑盒子过程如下： 同一台用户主机上运行着DNS应用的客户端 浏览器从URL中抽取出主机名，传给DNS应用的客户端 DNS客户向DNS服务器发送一个包含主机名的请求 DNS客户最终收到一份回答报文，其中含有对应该主机名的IP地址 一旦浏览器获得该地址，就可以向位于该IP地址的80端口的HTTP服务器进程发起一个TCP连接 DNS主要任务是主机名到IP地址转换的目录服务DNS除了有主机名到IP地址的转换服务外，还有如下服务： 主机别名 邮件服务器别名 负载分配 值得一提的是，DNS协议运行在UDP之上，使用53端口。 DNS分布式，层次数据库DNS是一个分布式，层次数据库，大致有三类：根DNS服务器，顶级域(TLD)DNS服务器和权威DNS服务器。还有一类是本地DNS服务器，每个ISP都有一台本地DNS服务器，本地DNS服务器起着代理的作用，将请求转发到DNS服务器的层次结构中。 在说服务器分层作用之前，先要说一下域名，常见的域名是例如www.example.com，但是它真正的域名是www.example.com.root，只是省略了后面的.root。.root称为根域名，.com，.net等等称为顶级域名(TLD)，.example称为次级域名，这个域名是用户可以注册的，再下一级是主机名(host)，比如www，又称为三级域名。 总结一下，域名的层级结构如下： 主机名(三级域名).次级域名.顶级域名.根域名 即host.sld.tld.root 根DNS服务器它将返回顶级域名的TLD服务器的IP地址，根域名服务器的NS记录和IP地址一般是不会变化的 顶级域DNS服务器它返回权威服务器的IP地址 权威DNS服务器它返回主机名(如www.amazon.com)的IP地址 本地DNS服务器严格上来说它不属于DNS层次结构，但它也很重要。本地DNS服务器由ISP提供，当主机发出DNS请求时，通常被发往到本地DNS服务器，由本地DNS服务器代理转发到DNS服务器层次结构 工作机理 以主机cis.poly.edu请求gaia.cs.umass.edu的IP地址为例，假设cis.poly.edu的本地DNS为dns.poly.edu，并且gaia.cs.umass.edu的权威DNS服务器为dns.umass.edu 主机cis.poly.edu首先向它的本地DNS服务器dns.poly.edu发送一个DNS查询报文 本地DNS服务器dns.poly.edu将报文转发到根DNS服务器，根DNS服务器注意到edu前缀并向本地DNS服务器返回负责edu的TLD的IP地址列表 该本地DNS服务器则再次向这些TLD服务器之一发送查询报文 该TLD服务器注意到umass.edu前缀，并用权威DNS服务器的IP地址进行响应 最后，本地DNS服务器直接向dns.umass.edu重发查询报文，dns.umass.edu将gaia.cs.umass.edu的IP地址进行响应 从请求主机到本地DNS服务器的查询是递归的，其余的查询是迭代的 DNS缓存为了改善时延性能并减少在因特网上到处传输的DNS报文数量，DNS广泛采用了缓存技术 它能够把回答中的信息缓存在本地存储器中，但该缓存不是永久的，由于主机和主机名与IP地址间的映射并不是永久的，所以DNS服务器一般在一段时间后（通常为2天）将丢弃缓存的信息。 DNS报文和记录DNS记录共同实现DNS分布式数据库的所有DNS服务器存储了资源记录（Resource Record，RR），RR提供了主机名到IP地址的映射。 RR是一个包含了下列字段的4元组：(Name, Value, Type, TTL) TTL是该记录的生存时间，它决定了资源记录应当从缓存中删除的时间 如果Type=A，则Name是主机名，Value是该主机名对应的IP地址 如果Type=NS，则Name是个域（如foo.com），Value是个知道如何获得该域中主机IP地址的权威DNS服务器的主机名。这个记录用于沿着查询链来路由DNS查询。（如(foo.com, dns.foo.com, NS)就是一个NS记录） 如果Type=CNAME，则Value是别名为Name的主机对应的规范主机名 如果Type=MX，则Value是个别名为Name的邮件服务器的规范主机名 如果一台DNS服务器是用于某特定主机名的权威DNS服务器，那么该DNS服务器会有一条包含该主机名的类型A记录如果服务器不是用于某主机名的权威服务器，那么该服务器将包含一条类型NS记录，该记录对应包含主机名的域；它还包括一条类型A记录，提供在NS记录的Value字段中的DNS的IP地址（比如edu TLD服务器不是主机gaia.cs.umass.edu的权威DNS服务器，则该服务器将包含一条包括主机cs.umass.edu的域记录，如(umass.edu, dns.umass.edu, NS)，该TLD服务器还将包含一条类型A记录，如(dns.umass.edu, 128.199.40.111, A)，该记录将名字dns.umass.edu映射为一个IP地址） DNS报文 对分级查询的进一步解释所谓”分级查询”，就是从根域名开始，依次查询每一级域名的NS记录，直到查到最终的IP地址，见下面的DNS记录可知 从”根域名服务器”查到”顶级域名服务器”的NS记录和A记录（IP地址） 从”顶级域名服务器”查到”次级域名服务器”的NS记录和A记录（IP地址） 从”次级域名服务器”查出”主机名”的IP地址 （根域名服务器的NS记录和IP地址一般是不会变化的，所以内置在DNS服务器中） 文件传输协议FTPFTP提供以下功能： 提供不同种类主机系统之间的文件传输能力 以用户权限管理的方式提供用户对远程FTP服务器上的文件管理能力 以匿名FTP的方式提供公用文件共享的能力 FTP采用C/S工作方式，使用TCP可靠传输服务，FTP服务器进程由两大部分组成：一个主进程负责就收新的请求；另外若干从属进程，负责处理单个请求，工作步骤如下： 打开端口21（控制端口），等待客户进程发连接请求 启动从属进程来处理客户进程发来的请求 控制连接与数据连接FTP工作时使用两个并行的TCP连接，一个是控制连接（端口21），一个是数据连接（端口20） 控制连接用来传输控制信息（连接请求，传送请求，中止传输等），并且控制信息都以7位ASCII格式传送 电子邮件组成结构电子邮件系统主要由用户代理，邮件服务器和电子邮件协议组成，常见电子邮件协议是SMTP,POP3等 常见的用户代理是Outlook,Foxmail等，邮件服务器采用C/S工作方式，但它能同时充当客户和服务器，发送方是客户，接收方的服务器，SMTP采用”推”的他通信方式，SMTP客户端是主动将邮件”推”到SMTP服务器的，POP3采用的是”拉”的通信方式，用户读取邮件时，用户代理向邮件服务器发出请求，”拉”取用户邮箱中的邮件 发送方发送邮件到邮件服务器和发送方邮件服务器发送邮件到接收方服务器采用的都是SMTP 电子邮件格式与MIME电子邮件分为信封和内容两大部分，邮件内容又分为首部和主体两部分 常见的邮件内容如下： 1234From: xxx@xxx.comTo : xxx@xxx.comSubjuect: xxxxx主体 SMTP只能传送一定长度的ASCII码，MIME（多用途网际邮件扩充）的意图是继续使用目前SMTP的格式，但增加了邮件主体的结构，并定义了传送非ASCII码的编码规则 MIME增加了5个新的邮件首部字段，包括MIME版本，内容描述，内容标识，内容传送编码和内容类型 定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化 定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变 SMTP和POP3SMTP采用C/S方式，TCP连接，端口号25，有连接建立，邮件传送，连接释放三个阶段 OPO3采用C/S方式，TCP连接，端口号110 万维网WWW万维网是一个资料空间，这个空间中：一样有用的事务称为一样”资源”，并由一个全域”统一资源定位符”(URL)标识，这些资源通过超文本传输协议HTTP传送给使用者 万维网使用链接的方法能让用户非常方便从因特网一个站点访问另一个站点，万维网内核部分由3个标准构成：统一资源定位符URL，超文本传输协议HTTP，超文本标记语言HTML URL一般格式是：&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;常见协议有http，ftp等，主机是存放资源的主机在因特网的域名，也可以是IP地址，端口和路径有时可以省略，URL不区分大小写 万维网以C/S方式工作，浏览器是客户机 超文本传输协议HTTP每个万维网站点都有一个服务器进程，它不断监听TCP的端口80，当监听到连接请求后便与浏览器建立连接，用户单击鼠标后发生的事件按顺序如下： 浏览器分析链接指向页面的URL 浏览器向DNS请求解析 域名系统DNS解析出服务器的IP地址 浏览器与该服务器建立TCP连接（HTTP默认端口80） 浏览器发出HTTP请求，GET /xx/index.html 服务器通过HTTP响应把文件index.html发送给浏览器 TCP连接释放 浏览器解释文件index.html，并将WEB页显示给用户 HTTP特点HTTP是无状态的，通常使用Cookie加数据库的方式来跟踪用户的活动，HTTP采用TCP作为运输层协议，但HTTP本身是无连接的，通信双方交换HTTP报文之前不需要先建立HTTP连接 HTTP非持久连接会对网页元素对象（JPEG图形，Flash等）的传输单独建立一个TCP连接，HTTP/1.1支持持久连接，服务器发送响应后仍保持这条连接，这样可以继续上传后续HTTP请求与响应报文持久连接又分为流水线和非流水线，非流水线是客户收到前一个响应之后才能发出下一个请求，HTTP/1.1默认是流水线的持久连接，客户每遇到一个对象引用就立即发出一个请求，客户可以逐个地连续发出对各个引用对象的请求 HTTP/1.0与HTTP/1.1的区别 长连接：HTTP/1.0发送一个响应后就关闭连接，可以使用keep-alive参数来告知服务器建立一个长连接，而HTTP/1.1默认就支持长连接 节约带宽：HTTP/1.1支持只发送header信息（不带任何body），如果服务器认为客户端有权限请求服务器，就返回100，客户端接收到100才开始把请求body发送到服务器，当服务器返回401，客户端就可以不用发送请求body了，节约了带宽 HOST域：HTTP/1.0认为每台服务器都绑定一个唯一的IP地址，因此请求消息中的URL并没有传递主机名，现在一台物理服务器可以存在多个虚拟主机，且他们共享同一个IP地址，所以HTTP/1.1引入HOST头域 HTTP/1.1与HTTP/2.0的区别 多路复用：HTTP/2.0同一个连接可以并发处理多个请求，且并发数量比HTTP/1.1大了好几个数量级 数据压缩：HTTP/1.1不支持header数据的压缩，HTTP/2.0使用HPACK算法对header的数据进行压缩 服务器推送：当我们请求数据的时候，HTTP/2.0的服务器可以顺便把一些客户端需要的资源一起推送到客户端 HTTP报文请求报文，CR LF是回车和换行，sp是空格 响应报文 HTTP请求常用的几个方法如下： 方法 意义 GET 请求读取由URL标识的信息 HEAD 请求读取由URL标识的信息的头部 POST 给服务器添加信息 CONNECT 用于代理服务器 请求报文一般用不到实体主体 常见应用层的协议和熟知端口 应用程序 FTP数据连接 FTP控制连接 TELNET SMTP DNS TFTP HTTP POP3 SNMP HTTPS 使用协议 TCP TCP TCP TCP UDP UDP TCP TCP TCP TCP 熟知端口号 20 21 23 25 53 69 80 110 161 443 思维导图]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>应用</tag>
        <tag>HTTP</tag>
        <tag>SMTP</tag>
        <tag>POP</tag>
        <tag>WWW</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络4-传输层]]></title>
    <url>%2F2019%2F07%2F31%2F%E7%BD%91%E7%BB%9C4-%E4%BC%A0%E8%BE%93%E5%B1%82%2F</url>
    <content type="text"><![CDATA[网络4-传输层 传输层提供的服务传输层的功能；传输层寻址与端口；无连接服务和面向连接服务 UDPUDP数据报；UDP校验 TCPTCP段；TCP连接管理；TCP可靠传输；TCP流量控制与拥塞控制 传输层提供的服务传输层的功能运输层为运行在不同主机上的进程之间提供逻辑通信，而网络层则提供主机之间的逻辑通信 传输层的功能如下： 传输层提供应用进程之间的逻辑通信（网络层提供主机之间），逻辑通信指传输层之间的通信像是沿水平方向传送数据，但事实上这两个传输层之间并没有一条水平方向的物理连接 复用和分用。复用指发送方不同的应用进程都可使用同一个传输层协议传送数据；分用指接收方的传输层在剥去报文首部后能够把这些数据正确交付到目的应用进程 差错检测，应用层检查首部和数据部分，而网络层只检查IP数据报的首部，不检验数据部分是否出错 提供两种不同的传输协议，TCP和UDP。而网络层无法同时实现两种协议（网络层要么只提供面向连接服务，如虚电路，要么只提供无连接服务，如数据报，不可能同时存在这两种方式） 传输层的寻址与端口端口的作用端口能够让应用层的各种应用进程将其数据通过端口向下交付给传输层，以及让传输层直到应当将其报文段的数据向上通过端口交付给应用层相应的进程。端口是传输层服务访问点（TSAP），它在传输层的作用类似于IP地址在网络层的作用或MAC地址在数据链路层的作用，区别是端口标识的是主机中的应用进程，而IP地址和MAC地址标识的是主机（数据链路层的SAP是MAC地址，网络层的SAP是IP地址，传输层的SAP是端口） 端口号端口号长度16位，能够表示65536个不同的端口，用于标识本计算机应用层的各进程，按端口范围分为两类： 服务端使用的端口。这里又分为2类，最重要的一类是熟知端口号，数值0&sim;1023，这些端口指派给了TCP/IP最重要的一些应用程序。另一类是登记端口号，数值为1024&sim;49151，它是供没有熟知端口号的应用程序使用的，使用它们必须在IANA登记防止重复，常见熟知端口号如下： 应用程序 FTP TELNET SMTP DNS TFTP HTTP SNMP 熟知端口号 21 23 25 53 69 80 161 客户端使用的端口号，数值为49152&sim;65535，客户进程运行时才动态选择，又称为短暂端口号 套接字网络中通过IP地址来标识和区别不同的主机，端口号来标识和区别一台主机中的不同应用进程。在网络中采用发送方和接收方的套接字组合来识别端点，套接字实际上是一个通信端点，即 套接字 =（主机IP地址，端口号） 它唯一标识网络中一台主机和其上一个应用 无连接服务与面向连接服务TCP是面向连接的传输控制协议，采用全双工，TCP不提供广播或组播服务，要提供面向连接的可靠服务，要增加许多开销，如确认，流量控制，计时器及连接管理等，使协议数据单元头部增大，占用处理机资源。主要用于FTP，HTTP，TELNET等 UDP是无连接的用户数据报协议，它在IP之上仅提供多路复用和对数据的错误检查，UDP主要用于TFTP（小文件传送协议），DNS，SNMP和RTP（实时传输协议） UDP协议UDP数据报UDP只做传输协议能够做的最少工作，仅在IP数据报服务之上增加了两个最基本的功能：复用和分用以及差错检测。UDP优点如下： 无须建立连接 无连接状态（接收和发送缓存，拥塞控制参数和序号与确定号的参数） 分组首部开销小（TCP 20B首部开销，UDP 8B） 应用层能够更好地控制要发送的数据和发送时间（没有拥塞控制） UDP是面向报文的，发送方UDP对应用层交下来的报文，在添加首部后就向下交付给IP层，不合并也不拆分，接收方UDP对IP层交上来的UDP用户数据报，在去除首部后就交付给上层应用进程，报文是UDP数据报处理的最小单位 UDP首部格式UDP数据报包含两部分：UDP首部和用户数据UDP首部有8B，由4个字段组成，每个字段长度都为2B，各字段意义如下： 源端口：需要对方回信时使用，不需要时可为0 目的端口 长度：UDP数据报的长度（包括首部和数据），最小值为8（只有首部） 校验和：检测UDP数据报在传输中是否有错，可选，若不想计算校验和就该字段为0 如果接收方UDP发现收到的报文中的目的端口号不正确，则丢弃该报文，并由ICMP发送 端口不可达 差错报文给发送方 UDP校验计算校验和时，要在UDP数据报之前增加12B的伪首部（伪首部不传送也不递交） 然后和IP数据报的首部检验和计算方法相似，先二进制反码运算求和再取反（IP只校验IP数据报首部，UDP则校验首部和数据部分），UDP校验既可以检查UDP数据报，又对IP数据报的源IP地址和目的IP地址进行校验 发送方首先把全0放入校验和字段并添加伪首部，然后把UDP数据报视为许多个16位的字连接起来（若数据部分不是偶数个字节，则在数据部分末尾增加一个全0字节，此字节不发送），然后按二进制反码计算出这些16位字的和，将此和的二进制反码写入校验和字段接收方把收到的UDP数据报加上伪首部，按二进制反码计算出这些16位字的和，当无差错时结果应全为1，否则表明有差错，接收方就丢弃这个UDP数据报 TCP协议特点： 面向连接 每个TCP连接只有2个端点，每条TCP连接只能点对点 提供可靠的交付服务 全双工通信 面向字节流（应用程序和TCP的交互是一次一个数据块，但TCP把数据仅视为一连串无结构的字节流） 面向字节流指的是封装的仍然是报文段，但是报文段中的序号是根据字节来编号的 TCP报文段TCP传送的数据单元称为报文段。一个TCP报文段分为TCP首部和TCP数据两部分TCP首部前20B是固定的，后面4N字节是根据需要而增加的选项，通常长度为4B的整数倍 各字段意义如下： 源端口和目的端口，各2B 序号字段，4B，TCP是面向字节流的，所以TCP连接传送的数据流中每个字节都编上一个序号 确认号字段，4B，期望收到对方的下一个报文段的数据的第一个字节的序号，若确认号为N，则表明序号N-1为止的所有数据都正确收到（如B正确收到A发送过来的一个报文段，序号字段为501，数据长度为200B，则B发送给A的确认报文段中把确认号置为701） 数据偏移，4位，表示首部长度，指出TCP报文段的数据起始处距离TCP报文段的起始处有多远，单位是4B（可以退出TCP首部最大长度为60B） 保留字段，6位，目前全置为0 紧急位URG，URG=1表明紧急指针字段有效，它告诉系统报文段中有紧急数据，应尽快处理 确认位ACK，ACK=1确认号字段有效，TCP规定连接建立后所有传送的报文段都必须把ACK置1 推送位PSH，接收TCP收到PSH=1的报文段，就尽快交付给接收应用进程，而不再等缓存满后再交付 复位为RST，RST=1，表明TCP连接中出现严重差错，必须释放连接然后重连 同步位SYN，SYN=1表示这是一个连接请求或连接接收报文，当SYN=1，ACK=0，这时一个连接请求报文，当SYN=1，ACK=1，是一个连接接收报文 终止为FIN，用来释放一个连接，当FIN=1表示此报文段发送方已发送完毕，要求释放传输连接 窗口字段，2B，指出现在允许对方发送的数据量，接收方的数据缓存空间有限，用窗口值作为接收方让发送方设置其发送窗口的依据，单位为字节 校验和，2B，和UDP基本一样（把UDP伪首部的第4个字节17改为6，其他和UDP一样） 紧急指针字段，16位，指出紧急数据有多少字节（紧急数据放在本报文段数据的最前面） 选项字段，长度可变 填充字段，整个首部长度是4B的整数倍 TCP连接管理TCP把连接作为最基本的抽象，连接的端点为套接字，TCP连接的建立采用客户/服务器方式，主动发起连接建立的应用进程称为客户机，被动等待连接建立的应用进程称为服务器 TCP连接的建立三次握手 客户机的TCP首先向服务器的TCP发送一个连接请求报文段，不含应用层数据，首部的SYN标志位置1，称为SYN报文段，另外，客户机会随机选择一个初始序号（client_isn），放置于该起始的TCP SYN报文段的序号字段中，然后该SYN报文段封装成IP数据报发送给服务器 一旦包含TCP SYN报文段的IP数据报到达服务器主机，服务器会从该数据报中提取出TCP SYN报文段，为该TCP连接分配TCP缓存和变量，并向该客户TCP发送允许连接的报文段，这个报文段也不包含应用层数据，SYN置1，确认号字段置为client_isn+1，服务器选择自己的初始序号置入TCP报文段首部的序号字段中，这个允许连接的报文段实际上表明：我收到了你发起建立连接的SYN分组，该分组有初始序号client_isn，我同意建立该连接，我自己的初始序号是server_isn，该允许连接的报文段称为SYNACK报文段 收到SYNACK报文段后，客户也要给该连接分配缓存和变量，客户机则向服务器发送另外一个报文段，这最后一个报文段对服务器的允许连接的报文段进行了确认（通过将值server_isn+1放置在TCP报文段首部的确认号字段中来完成），因为连接已经建立，所以该SYN比特置为0，第三个阶段可以在报文段负载中携带客户到服务器的数据 TCP连接的释放参与TCP连接的两个进程中的任何一个都能终止该连接，TCP连接释放的过程称为四次握手 客户机打算关闭连接时，向其TCP发送一个连接释放报文段，并停止发送数据，主动关闭TCP连接，该报文段的FIN标志位置1，seq（序号）=u，它等于前面已传送过的数据的最后一个字节的序号加1（FIN报文段不携带数据，消耗序号），TCP是全双工的，发送FIN报文时，发送FIN的一端不能再发送数据，但对方仍然可以发送 服务器收到连接释放报文段后发出确认，确认号是ack=u+1，，这个报文段自身的序号是v，等于它前面已传送过的数据的最后一个字节的序号加1，此时，从客户机到服务器这个方向的连接就释放了，TCP连接处于半关闭状态 若服务器已经没有要向客户机发送的数据，就通知TCP释放连接，此时其发送一个FIN=1的连接释放报文段 客户机收到连接释放的报文段后，必须发出确认，确认报文段中，ACK置1，ack=w+1，seq=u+1，定时等待后连接关闭 TCP可靠传输TCP使用校验，序号，确认和重传等机制完成可靠传输这一目的，TCP校验机制和UDP一样，不再赘述 TCP序号建立在字节流的基础上，而不建立在报文段之上，TCP为数据流中每个字节都编上一个序号，序号字段的值是指本报文段锁发送的数据的第一个字节的序号 TCP首部的确认号是期望收到对方的下一个报文段的数据的第一个字节的序号 有两件事会导致TCP对报文段重传，超时和冗余ACK 超时：TCP每发送一个报文段，就对这个报文段设置一个计时器，设置的重传时间到期但还未收到确认时，就重传这一报文段 冗余ACK：每当比期望序号大的失序报文段到达时，就发送一个冗余ACK，指明下一个期待字节的序号，当发送方收到对同一报文段的3个冗余ACK时，就可以认为跟在这个被确认报文段之后的报文段已经丢失，如发送方发送了序号为1,2,3,4,5的TCP报文段，其中2丢失了，3,4,5就成了失序报文段，接收方就发送3个对1号报文的冗余ACK，表示自己期望收到2号报文段 TCP流量控制TCP提供流量控制服务来消除发送方使接收方缓存区溢出的可能性，它是一个速度匹配服务（匹配发送方发送速率和接收方接收速率） TCP提供一种基于滑动窗口协议的流量控制机制，在通信过程，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，称为接收窗口，即调整TCP报文段首部中的 窗口 字段值，来限制发送方向网络注入报文的速率，同时，发送方根据其对当前网络拥塞程序的估计而确定的窗口值，称为拥塞窗口 TCP拥塞控制拥塞控制指防止过多的数据注入网络，以使网络中的路由器或链路不致过载 拥塞控制和流量控制都是通过控制发送方发送数据的速率来达到控制效果，区别是：拥塞控制是让网络能够承受现有的网络负荷，是一个全局性过程，涉及所有主机，路由器等因素，流量控制往往是指点对点的通信量的控制，它的目的是抑制发送端发送数据的速率来使得接收端来得及接收 TCP协议要求发送方维护两个窗口 接收窗口rwnd：接收方根据目前接收缓存大小所许诺的最新窗口值，反映接收方的容量 拥塞窗口cwnd，发送方根据自己估算的网络拥塞程度而设置的窗口值，反映网络的当前容量 发送窗口的上限值=min(rwnd,cwnd) 接收窗口大小可以根据TCP报文首部的 窗口 字段来通知发送方，而发送方如何维护拥塞窗口要用到慢开始和拥塞避免算法或快重传和快恢复算法，略 思维导图]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>运输层</tag>
        <tag>TCP</tag>
        <tag>UDP</tag>
        <tag>套接字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络3-网络层]]></title>
    <url>%2F2019%2F07%2F25%2F%E7%BD%91%E7%BB%9C3-%E7%BD%91%E7%BB%9C%E5%B1%82%2F</url>
    <content type="text"><![CDATA[网络3-网络层 网络层的功能异构网络互联；路由与转发；拥塞控制 路由算法静态路由与动态路由：距离-向量路由算法；链路状态路由算法；层次路由 IPv4IPv4分组：IPv4地址与NAT；子网划分与子网掩码，CIDR，路由聚集ARP，DHCP与ICMP IPv6IPv6主要特点，IPv6地址 路由协议自治系统；域内路由与域间路由；RIP路由协议；OSPF路由协议；BGP路由协议 IP组播组播的概念：IP组播地址 移动IP移动IP的概念：移动IP通信过程 网络层设备路由器的组成和功能；路由表与路由转发 网络层的功能异构网络互联要解决数以万计的网络互联，需要解决许多问题，如不同的寻址方案，不同的网络接入机制，不同的差错处理方法，不同的路由选择机制等网络互联指将两个以上的计算机网络，通过一定方法，用一种或多种通信处理设备（中间设备）相互连接起来，中间设备又称中继系统，分为以下4种： 物理层中继系统：中继器，集线器 数据链路层中继系统：网桥或交换机 网络层中继系统：路由器 网络层以上的中继系统：网关 TCP/IP体系在网络互联上采用的做法是在网络层（IP层）采用标准化协议，但相互连接的网络可以是异构的 路由与转发路由器主要完成两个功能：一是路由选择（确定路径），二是分组转发（一个分组到达时采取的动作）。前者根据特定的路由选择协议构造出路由表，经常或定期和相邻路由器交换路由信息而不断更新维护路由表。后者处理通过路由器的数据流，关键操作是转发表查询，转发及相关的队列管理和任务调度 路由选择：指按照复杂的分布式算法，根据从各相邻路由器所得到的关于整个网络拓扑的变化情况，动态地改变所选择的路由 分组转发：指路由器根据转发表将用户的IP数据报从合适的端口发送出去 拥塞控制通信子网中，因出现过量的分组而引起的网络性能下降的现象称为拥塞。拥塞控制主要解决的问题是如何获取网络中发生拥塞的信息，从而利用这些信息进行控制，以避免由于拥塞而出现分组的丢失，以及严重拥塞而产生网络死锁的现象 流量控制与拥塞控制的区别：流量控制往往指发送端和接收端之间点对点通信量的控制，流量控制要做的是抑制发送端发送数据的速率。而拥塞控制必须确保通信子网能够传送待传送的数据，是一个全局性的问题 拥塞控制有如下两种方法： 开环控制：设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞，是静态的预防方法 闭环控制：事先不考虑有关发生拥塞的各种因素，采用监测网络系统去监视，及时监测哪里发生拥塞，然后调整，基于反馈环路的概念，是动态的方法 路由算法静态路由与动态路由从能否随网络通信量或拓扑自适应地进行调整变化来划分，路由算法可分为如下两大类 静态路由算法：指网络管理员手工配置的路由信息，当网络的拓扑结构或链路状态发生变化时，网络管理员需要手工去修改路由表中相关的静态路由信息动态路由算法：指路由器上的路由表项是通过相互连接的路由器之间彼此交换信息，然后按照一定的算法优化出来的，这些路由信息会在一定时间间隙里不断更新，以适应不断变化的网络，随时获得最优的寻路效果 距离-向量路由算法所有结点都定期将它们的整个路由选择表传送给所有与之直接相连的结点。这些路由选择表包含： 每条路径的目的地（另一结点） 路径的代价（距离） 这种算法中，所有结点都监听从其他结点传来的路由选择更新信息，在下列情况下更新它们的路由选择表： 被通告一条新的路由，该路由在本结点的路由表中不存在，此时本地系统加入这条新的路由 发来的路由信息中有一条到达某个目的地的路由，该路由与当前使用的路由相比，有较短的距离 距离-向量算法的实质是：迭代计算一条路由中的站段数或延迟时间，从而得到到达一个目标的最短通路。它要求每个结点在每次更新时将它的全部路由表发送给所有相邻的结点 典型的距离-向量算法是RIP算法，它采用跳数（源到目的所经过的路由个数）作为距离的度量 链路状态路由算法要求每个参与该算法的结点都具有完全的网络拓扑信息，它们执行下述两项任务，第一，主动测试所有邻接结点的状态。两个共享一条链路的结点是相邻结点，它们连接到同一条链路，或者连接到同一广播型物理网络。第二，定期地将链路状态传播给所有其他结点。典型的链路状态算法是OSPF算法 一个链路状态路由选择中，一个结点检查所有直接链路的状态，并将所得的状态信息发送给网上的所有其他结点，而不是仅送给那些直接相连的结点，每个结点用这种方式从网上所有其他的结点接收包含直接链路状态的路由选择信息，每当链路状态报文到达，路由结点使用这些状态信息去更新自己的网络拓扑和状态视野图，一旦链路状态发生变化，就利用Dijsktra最短路径算法重新计算路由，从单一源触发计算到达所有目的结点的最短路径 OSPF算法中，链路状态的度量主要表示费用，距离，时延，带宽等 两者比较距离-向量路由算法中，每个结点仅与它的直接邻居交谈，它为它的邻居提供从自己到网络中所有其他结点的最低费用估计，最低费用估计是由迭代计算得出链路状态路由中，每个结点通过广播与所有其他结点交谈，但它仅告诉它们与它直接连接的链路的费用，然后让其它结点自行计算单一源到所有目的结点的最短路径 层次路由因特网将整个互联网划分为许多较小的自治系统，每个自治系统有权自主决定本系统内采用何种路由选择协议。如果两个自治系统需要通信，就需要一种在两个自治系统间的协议来屏蔽这些差异，据此因特网把路由选择协议划分为两大类： 一个自治系统内部所使用的路由选择协议称为内部网关协议（IGP），具体有RIP和OSPF等 自治系统间的路由选择协议称为外部网关协议（EGP），在不同自治系统的路由器之间交换路由信息，具体有BGP等 IPv4IPv4分组IPv4即现在普遍使用的IP（版本4）。IP定义数据传送的基本单元——IP分组及其确切的数据格式，IP也包括一套规则，指明分组如何处理，错误怎么控制。特别是IP还包含非可靠投递的思想，以及与此关联的分组路由选择的思想 IPv4分组的格式 IP分组由首部和数据组成，首部前一部分是长度固定，共20B，是所有IP分组必须具有的，首部固定部分后面有一些可选字段，长度可变，用来提供错误检测及安全等机制，重要字段如下： 版本：IP的版本，目前广泛版本号4 首部长度：4位，以32位为单位，最大值为60B（4位最大值15,32位=4字节，4*15=60B），最常用首部长度是20B 总长度：16位，指首部和数据之和的长度，单位为字节，因此数据报最大长度为2^16-1=65535B。以太网帧的最大传送单元（MTU）为1500B，因此一个IP数据报封装成帧时，数据报长度不能超过链路层的MTU值 标识：16位，是一个计数器，每产生一个IP数据报就加1，并赋值给标识字段（但不是序号，IP是无连接服务）。当一个数据报长度超过网络的MTU时，必须分片，此时每个数据报片都赋值一次标识号，以便能正确重装成原来的数据报 标志：3位，最低位为MF，MF=1表示后面还有分片，MF=0表示最后一个分片，中间位是DF，只有当DF=0才允许分片 片偏移：13位，指出较长的分组在分片后，某片在原分组中的相对位置。片偏移以8个字节为偏移单位，即每个分片的长度一定是8B的整数倍 首部校验和：16位，IP数据报的首部校验和只校验分组的首部，而不校验数据部分 生存时间（TTL）：8位，数据报在网络中可通过的路由器数的最大值，标识分组在网络中的寿命，以确保分组不会永远在网络中循环。路由器转发分组前，先把TTL减1，若TTL减为0，则丢弃该分组 协议：8位，指出该分组携带的数据使用何种协议，即分组数据部分应交给哪个传输层协议，如TCP,UDP等，值为6表示TCP，17表示UDP 源地址字段：4B，标识发送方的IP地址 目的地址字段：4B，标识接收方的IP地址 IP数据报分片一个链路层数据报能承载的最大数据量称为最大传送单元(MTU)。IP数据报是被封装在链路层数据报中，因此链路层的MTU严格限制IP数据报的长度，且在IP数据报的源和目的地路径上的各段链路可能使用不同的链路层协议，有不同的MTU。如以太网的MTU为1500B，许多广域网的MTU不超过576B，当IP数据报总长度大于链路MTU时，就需要将IP数据报的数据分装在两个或多个较小的IP数据报中，这些较小的数据报称为片 网络层转发分组的流程 从数据报首部提取目的主机的IP地址D，得出目的网络地址N 若网络N与此路由器直接相连，则把数据报直接交付给目的主机D，这称为路由器的直接交付；否则是间接交付，执行步骤3 若路由表中有目的地址D的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则执行步骤4 若路由表有到达网络N的路由，则把数据报传送给路由表指明的下一跳路由，否则执行步骤5 若路由表有一条默认路由，则把数据报传送给路由表指明的默认路由器，否则执行步骤6 报告转发分组出错 IPv4地址与NAT连接到因特网上的每台主机都分配一个32比特的全球唯一标识符，即IP地址，分为A,B,C,D,E五类，无论哪类，都由网络号和主机号两部分组成，网络号是整个因特网范围内唯一的，主机号是该网络号的网络范围内唯一的 有些IP地址具有特殊用途，不用做主机的IP地址 主机号全为0的表示本网络本身，如202.98.174.0 主机号全为1的表示本网络的广播地址，如202.98.174.255 127.0.0.0保留为环路自检地址，表示任意主机本身，目的地址为环路自检地址的IP数据报永远不会出现在任何网络上 32位全为0，即0.0.0.0表示本网络上的本主机 32位全为1，即255.255.255.255表示整个TCP/IP网络的广播地址，又称受限广播地址，实际使用时由于路由器对广播域的隔离，可以等效为本网络的广播地址 &nbsp; 网络地址转换(NAT)指通过将专用网络转换为共用地址，从而对外隐藏内部管理的IP地址。它使得整个专用网只需要一个全球IP地址就可以与因特网连通，专用网本地IP地址是可重用的，NAT大大节省了IP地址的消耗。同时，它隐藏了内部网络结构，降低内部网络受到攻击的风险 此外，为了网络安全，划出了部分IP地址为私有IP地址，私有IP地址只用于LAN，不用于WAN连接（私有IP地址不能直接用于Internet，必须通过网关利用NAT把私有IP地址转换为Internet中合法的全球IP地址后才能用于Internet），并且允许私有IP地址被LAN重复利用，私有IP地址网段如下： A类：1个A类网段，即10.0.0.0&sim;10.255.255.255B类：16个B类网段：172.16.0.0&sim;172.31.255.255C类：256个C类网段：192.168.0.0&sim;192.168.255.255 对目的地址是私有地址的数据报一律不进行转发 使用NAT需要在专用网连接到因特网的路由器上安装NAT软件，NAT路由器至少有一个有效的外部全球地址。使用本地地址的主机和外界通信时，NAT路由器使用NAT转换表将本地地址转换成全球地址，或将全球地址转换成本地地址。NAT转换表存放着 {本地IP地址: 端口}到{全球IP地址: 端口}的映射。通过{IP地址: 端口}的映射方式，可以让多个私有IP地址映射到同一个全球IP地址 以宿舍共享宽带上网为例，假设某个宿舍办理了电信宽带，就获得一个全球IP地址如138.76.29.7，而宿舍内4台主机使用私有地址（如192.168.0.0网段）。宿舍的网关路由器应该开启NAT功能，并且某时刻路由器的NAT转换表如下： WAN端 LAN端 138.76.29.7:5001 192.168.0.2:2233 138.76.29.7:5060 192.168.0.3:1234 当路由器从LAN端收到源IP及源端口号的数据报时，会映射为对应的WAN端的IP和端口号，从WAN端发送到因特网，当路由器从WAN收到目的IP及目的端口号，会映射为LAN端的IP和端口号，这样只需要一个全球地址，就可以让多台主机同时访问因特网 子网划分与子网掩码，CIDR子网划分两级IP地址的缺点是：IP地址空间的利用率有时很低；给每个物理网络分配一个网络号会使得路由表变得太大而使网络性能变坏；两级IP地址不够灵活 1985年在IP地址增加一个子网号字段，使2级IP地址变为3级IP地址，这种做法称为子网划分，基本思路如下： 子网划分纯属一个单位内部的事情，单位对外仍然表现为没有划分子网的网络 从主机号借用若干比特作为子网号，三级IP地址结构如下：IP地址={&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;} 凡是从其他网络发往本单位某台主机的IP数据报，仍然是根据IP数据报的目的网络号先找到连接到本单位网络上的路由器，然后该路由器在收到IP数据报后，按目的网络号和子网号找到目的子网。最后把IP数据报直接交付给目的主机 不能从网络号判断是否为子网划分；IPv4子网划分时，子网号不能全为0或1，但CIDR可以使用全为0或全为1的子网号；不论是分类的IPv4地址还是CIDR，主机号都不能全0或全1，主机号全0表示子网的网络号，主机号全1表示子网的广播地址 子网掩码为了告诉主机或路由器对一个A类，B类，C类网络进行了子网划分，使用子网掩码来表达对原网络号中主机号的借位子网掩码是一个与IP地址相对应的，长32bit的二进制串，它由一串1和跟随的一串0组成。其中1对应于IP地址中的网络号及子网号，0对应于主机号。计算机只需要将IP地址和其对应的子网掩码逐位与，就可得到相应子网的网络地址（网络号）现在因特网标准规定所有网络都必须使用子网掩码，如果一个网络未划分子网，那么采用默认的子网掩码。A，B，C类地址的默认子网掩码分别为255.0.0.0 , 255.255.0.0 , 255.255.255.0。如某主机的IP地址为192.168.5.56，子网掩码为255.255.255.0，则该主机的网络号为192.168.5路由器交换路由信息时也必须交换子网掩码，路由表的每个条目也必须给出该目的网络的子网掩码 使用子网掩码的情况下，每台主机必须设置IP地址信息和子网掩码；同属于一个子网的所有主机及路由器的相应端口，必须设置相同的子网掩码；路由器的路由表中，所包含信息主要内容必须有目的网络地址，子网掩码，下一跳地址 使用子网掩码的分组转发算法如下： 从收到的分组首部提取目的主机的IP地址D（不需要得出目的网络地址，下面步骤使用子网掩码按位与即可） 先判断是否为直接交付，对路由器直接相连的网络逐个进行检查：用各网络的子网掩码和D逐位相与，结果是否和相应的网络地址匹配，若匹配则分组直接交付，否则间接交付，执行步骤3 若路由表中有目的地址为D的特定主机路由，则将该分组传送给路由表中所指明的下一跳路由器，否则执行步骤4 对路由表中的每一行中的子网掩码和D逐位相与，结果为N，若N与该行的目的网络地址匹配，则将该分组传送给该行指明的下一跳路由器，否则执行步骤5 若路由器中有一个默认路由，则将分组传送给路由表中所指明的默认路由器；否则执行步骤6 报告转发分组出错 无分类域间路由选择(CIDR)无分类域间路由选择是在变长子网掩码的基础上提出的一种消除传统A,B,C类网络划分，并且可以在软件的支持下实现超网构造的一种IP地址的划分方法，略 ARP，DHCP与ICMPIP地址与硬件地址IP地址是网络层使用的地址，是分层次等级的，而硬件地址是数据链路层的地址（如MAC地址），是平面式的。网络层及其以上使用IP地址，IP地址放在IP数据报的首部，MAC地址放在MAC帧的首部。数据链路层看不到数据报分组中的IP地址 IP地址是逻辑上的概念，是网络层及其上层使用的地址，由软件实现，而MAC地址是数据链路层和物理层使用的地址，它们的区别见下面图 IP数据报一旦交给数据链路层，就封装成帧了，MAC帧在传送时使用的都是MAC地址 下面例子是3个局域网用2个路由器R1和R2互连起来，通信路径是：H1-&gt;R1转发-&gt;R2转发-&gt;H2，路由器R1同时连接两个局域网，有两个硬件地址HA3和HA4，R2也有两个硬件地址HA5和HA6 主要有如下几点： IP层的抽象只会看到IP地址和IP数据报，IP数据报的地址始终是IP1和IP2 链路层只看到MAC地址，会在每次转发的时候封装MAC帧，重新设置源和目的MAC地址 IP层的抽象屏蔽了下面链路层复杂的细节 地址解析协议ARP无论网络层使用什么协议，在实际网络的链路上传送数据帧时，最终必须使用硬件地址。所以需要一种方法来完成IP地址到MAC地址的映射，这就是地址解析协议。每台主机都设有一个ARP高速缓存，用来存放本局域网上各主机和路由器的IP地址到MAC地址的映射表，称ARP表。使用ARP动态维护此ARP表 ARP在网络层上工作，原理如下：主机A欲向本局域网上某台主机B发送IP数据报时，先在其ARP高速缓存中查看有无主机B的IP地址。如有，就可以查出其对应的硬件地址，再将此硬件地址写入MAC帧，然后通过局域网将该MAC帧发往此硬件地址。如果没有，就通过使用目的MAC地址为FF-FF-FF-FF-FF-FF的帧封装并广播ARP请求分组，使同一个局域网里的所有主机收到ARP请求，该请求包括源主机IP，源主机MAC地址，目的主机IP，目的主机地址。所有主机都会受到该ARP请求包，当主机B收到该ARP请求后，会检查包中IP地址是否是自己的IP地址，如果是，则先把该ARP数据报的源主机IP和源MAC地址写入自己的ARP缓存列表，如果已存在则覆盖，然后向主机A发出响应ARP分组，分组中包含主机B的IP地址与MAC地址的映射关系，主机A收到后将次映射写入ARP缓存，然后按查询到的硬件地址发送MAC帧。ARP是可以看到IP地址的，所以工作在网络层，NAT路由器看到了端口，所以工作在传输层ARP用于解决同一局域网上的主机或路由器的IP地址和硬件地址的映射关系，如果要找的主机和源主机不在同一局域网，就要通过ARP找到一个位于本局域网上的某个路由器的硬件地址，把分组发送给这个路由器，这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。ARP请求分组是广播发送的，但ARP响应分组是普通的单播 ARP的4种典型情况如下： 发送方是主机，要把IP数据报发送本网络的另一台主机。这时用ARP找到目的主机的硬件地址 发送方是主机，要把IP数据报发送给另一个网络的主机。这时用ARP找到本网络的一个路由器的硬件地址，剩下工作由这个路由器完成 发送方是路由器，要把IP数据报转发给本网络的一台主机。这时用ARP找到目的主机的硬件地址 发送方是路由器，要把IP数据报转发到另一个网络的一台主机。这时用ARP找到本网络上一个路由器的硬件地址，剩下的工作由找到的这个路由器来完成 动态主机配置协议DHCP动态主机配置协议常用于给主机动态分配IP地址，提供即插即用联网的机制，这种机制允许一台计算机加入新的网络和获取IP地址而不用手工参与。DHCP是应用层协议，是基于UDP的 工作原理：使用客户/服务器方式，需要IP地址的主机在启动时向DHCP服务器广播发送发现报文，这时该主机称为DHCP客户。本地网络上所有主机都能收到此广播报文，但只有DHCP服务器才回答此广播报文。DHCP服务器先在其数据库查找该计算机的配置信息，若找到则返回找到的信息，若找不到，则从服务器的IP地址池取一个地址分配给该计算机，DHCP服务器的回答报文称为提供报文 DHCP服务器聚合DHCP客户端交换过程如下： DHCP客户机广播 DHCP发现 消息，试图找到网络中的DHCP服务器，服务器获得一个IP地址 DHCP服务器收到 DHCP发现 消息后，向网络广播 DHCP提供 消息，其中包括提供DHCP客户机的IP地址和相关配置信息 DHCP客户机收到 DHCP提供 消息，如果接收DHCP服务器提供的相关参数，那么通过广播 DHCP请求 消息向DHCP服务器请求提供IP地址 DHCP服务器广播 DHCP确认 消息，将IP地址分配给DHCP客户机 DHCP服务器分配给DHCP客户的IP地址是临时的，客户只能在一段有限时间内使用这个分配的IP地址DHCP是应用层协议，因为它通过客户/服务器方式工作DHCP通过广播方式交互，客户和服务器都没有标识自己身份的IP地址 网际控制报文协议ICMP为了提高IP数据报交付成功的机会，在网络层使用网际控制报文协议让主机或路由器报告差错和异常情况，它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。ICMP报文作为IP层数据报的数据，加上数据报的首部，组成IP数据报发送出去。ICMP是IP层协议 ICMP报文有两种，ICMP差错报告报文和ICMP询问报文 ICMP差错报告报文用于目标主机或到目标主机路径上的路由器向源主机报告差错和异常情况。共有以下5种类型 终点不可达：当路由器或主机不能交付数据报时，向源点发送终点不可达报文 源点抑制：当路由器或主机由于拥塞而丢弃数据报时，向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢 时间超过：当路由器收到生存时间TTL为0的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。终点在预先规定时间内不能收到一个数据报的全部数据报片时，就把已收到数据报片丢弃，向源点发送时间超过报文 参数问题：路由器或目的主机收到的数据报首部有字段值不正确时，就丢弃该数据报并向源点发送参数问题报文 改变路由（重定向）：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器 ICMP询问报文有4种类型：回送请求和回答报文，时间戳请求和回答报文，掩码地址请求和回答报文，路由器询问和通告报文 ICMP两个常见应用是分组网间探测PING和Traceroute（Windows是tracert，用来跟踪分组经过的路由），PING使用了ICMP回送请求和回答报文，Traceroute使用ICMP时间超过报文，PING工作在应用层，直接使用网络层的ICMP，而未使用TCP或UDP，Traceroute工作在网络层 IPv6解决IP地址耗尽的措施有如下三种：采用无类别CIDR；采用NAT方法；采用更大地址空间的IPv6（根本） IPv6特点IPv6特点： 更大地址空间，IPv6地址从32位增大到128位，字节数是IPv4(4字节)的平方(16字节) 扩展的地址层次结构 灵活的首部格式 允许协议继续扩充 支持即插即用 支持资源的预分配 IPv6只有在包的源结点才能分片，是端到端的，传输路径中路由器不能分片，所以一般意义上说，IPv6不允许分片 IPv6首部长度必须是8B的整数倍（IPv4是4B整数倍） 增大了安全性（身份验证和保密功能） IPv6和IPv4不兼容，但它与所有其他因特网协议兼容，包括TCP,UDP,DNS等，只需要在少数地方做修改 IPv6地址IPv6数据报的目的地址可以是以下三种基本类型地址之一： 单播：传统的点对点通信 多播：一点对多点通信 任播：目的站是一组计算机，交付时只交付其中的一台 IPv6通常是表示方法是十六进制，每16位用冒号分隔（IPv4是点分十进制法），如：4BF5:0000:0000:0000:BA5F:039A:000A:2176，对于16位域开头为0的，可以省略，如：4BF5:0:0:0:BA5F:39A:A:2176 路由协议自治系统自治系统（AS)是单一技术管理下的一组路由器，这些路由器用一种AS内部的路由选择协议和共同的度量来确定分组在该AS内的路由，同时还使用一种AS之间的路由选择协议来确定分组在AS之间的路由 一个自治系统内所有网络都由一个行政单位管辖 域内路由与域间路由内部网关协议IGP：在一个自治系统内部使用的路由选择协议，RIP，OSPF等外部网关协议EGP：源站和目的站处于不同自治系统的路由选择协议，如BGP-4 RIP协议基于距离向量路由选择协议，使用UDP，与相邻路由器交换整个路由表 OSPF协议基于链路状态路由算法，使用IP，与全部路由器交换相邻结点链路状态 BGP协议基于路径向量路由选择协议，使用TCP，寻找的并非最佳路由 IP组播组播机制指源计算机一次发送的单个分组可以抵达用一个组地址标识的若干目标主机，并被它们正确接收 组播应用于UDP（TCP要连接，只能一对一发送）。IP组播使用组播组概念，每个组都有一个特别分配的地址，要给该组发送的计算机将使用这个地址作为分组的目标地址，IPv4种，这些地址在D类地址空间中分配。主机使用一个称为IGMP的协议加入组播组。组播需要路由器的支持才能实现，称为组播路由器 IP组播地址IP组播使用D类地址格式，前4位是1110，首部协议字段是2，表示使用IGMP，特点如下： 组播数据报尽最大努力交付 组播地址只用于目的地址，不用于源地址 对组播数据报不产生ICMP差错报文，PING命令后加入组播地址永远不会收到响应 并非所有D类地址都作为组播地址 IGMPIGMP不知道IP组播组包含的成员数，也不知道成员分布在哪些网络，IGMP让连接到本地局域网上的组播路由器知道本局域网上是否有主机参加或退出某个组播组 IGMP应视为TCP/IP的一部分，其工作分为两个阶段 当某台主机加入新的组播组，该主机向组播组的组播地址发送一个IGMP报文声明自己要成为该组成员，本地组播路由器收到IGMP报文后将组成员关系转发给因特网上其他组播路由器 因为组成员关系是动态的，本地组播路由器要周期性探询本地局域网上的主机，以便知道这些主机是否仍继续是组的成员。只要对某个组有一台主机响应，那么组播路由器就认为这个组是活跃的。一个组经过几次探询后仍然没有一台主机响应时，就不再将该组成员关系转发给其他组播路由器 网络层设备路由器路由器是一种具有多个输入/输出端口的专用计算机，其任务是连接不同的网络并完成路由转发。在多个逻辑网络互联时必须使用路由器，路由器也可以作为最基础的包过滤防火墙应用 路由表通常有4项：目的网络IP地址，子网掩码，下一跳IP地址，接口 思维导图]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络层</tag>
        <tag>IPv4</tag>
        <tag>IP</tag>
        <tag>ARP</tag>
        <tag>IPv6</tag>
        <tag>NAT</tag>
        <tag>子网划分与子网掩码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发基础4-执行器和同步器]]></title>
    <url>%2F2019%2F07%2F23%2FJava%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%804-%E6%89%A7%E8%A1%8C%E5%99%A8%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Java并发基础4-执行器和同步器执行器构建一个新线程是有一定代价的，因为涉及与OS的交互。如果程序创建大量生命周期很短的线程，应该使用线程池，一个线程池中包含许多准备运行的空闲线程。将Runnable对象交给线程池，就会有一个线程调用run方法。当run方法退出时，线程不会死亡，而是在池中准备为下一个请求提供服务另一个使用线程池的理由是减少并发线程的数目。创建大量线程会大大降低性能甚至使虚拟机崩溃。如果有一个会创建许多线程的算法，应该使用一个线程数”固定的”线程池限制并发线程的数目 执行器(Executor)类有许多静态工厂方法来构建线程池 方法 描述 static ExecutorService newCachedThreadPool 必要时创建新线程；空闲线程保留60秒 static ExecutorService newFixedThreadPool 包含固定数量的线程；空闲线程会一直保留 static ExecutorService newSingleThreadExecutor 只有一个线程的”池”，该线程顺序执行每一个提交的任务 static ScheduledExecutorService newScheduledThreadPool 用于预定执行而构建的固定线程池，替代java.util.Timer static ScheduledExecutorService newSingleThreadScheduledExecutor 用于预定执行而构建的单线程”池” 线程池newCachedThreadPool方法构建一个线程池，对每个任务如果有空闲线程可用则立即执行，如果没有空闲线程可用，则创建一个新线程；newFixedThreadPool方法构建一个具有固定大小的线程池，如果提交任务数多于空闲线程数，就把得不到服务的任务放置在队列中；newSingleThreadExecutor是一个大小为1的线程池，由一个线程执行提交的任务，一个接着一个；这三个方法都返回实现了ExecutorService接口的ThreadPoolExecutor对象 可以使用下面方法之一将一个Runnable对象或Callable对象提交给ExecutorService 123Future&lt;?&gt; submit(Runnable task);Future&lt;T&gt; submit(Runnable task, T result);Future&lt;T&gt; submit(Callable&lt;T&gt; task); 调用submit方法会返回一个Future对象，可以用来查询该任务的状态第一个submit返回的Future对象可以调用isDone，cancel和isCancelled方法，但get方法在完成时只会简单返回null第二个submit也提交一个Runnable，并且Future的get方法在完成时返回指定的result对象第三个submit提交一个Callable，返回的Future对象将在计算结果准备好的时候得到它 用完一个线程池后，调用shutdown方法，该方法会启动该池的关闭序列。被关闭的执行器不再接受新的任务，所有任务完成后，线程池中的线程死亡。shutdownNow方法会取消尚未开始的所有任务并试图中断正在运行的线程 使用连接池应该做的事： 调用Executors类的静态方法newCachedThreadPool或newFixedThreadPool，得到ExecutorService对象 调用submit提交Runnable或Callable对象 如果想要取消一个任务或提交Callable对象，要保存好submit方法返回的Future对象 当不再提交任何任务时，调用shutdown 预定执行ScheduledExecutorService接口具有为预定执行或重复执行任务而设计的方法，它是一种允许使用线程池机制的java.util.Timer的泛化。Executors类的newScheduledThreadPool和newSingleThreadScheduledExecutor方法返回实现了ScheduledExecutorService接口的对象 ScheduledExecutorService接口继承自ExecutorService接口，且多增加了可以预定Runnable或Callable在初始的延迟后只运行一次，也可以预定一个Runnable对象周期性运行的方法，详见API ExecutorService执行器服务作为线程池使用可以提交任务效率，除此之外，使用执行器可以控制一组相关任务如可以在执行器中使用shutdownNow方法取消所有任务，也可以用使用invokeAny方法提供一个Callable对象的集合，并返回某个已经完成的任务的结果（任意结果，但只有一个，用于搜索问题的任何一种解决方案）invokeAll方法提供一个Callable对象的集合，返回一个Future的List对象，代表所有任务的解决方案 ExecutorService的API如下 Fork-Join框架某些应用可能对每个处理器内核分别使用一个线程，来完成计算密集型任务。java se 7新引入fork-join框架，假设一个处理任务，可以自然地分解为子任务 1234567if (problemSize &lt; threshold) solve problem directlyelse &#123; break proble into subproblems recursively solve each subproblem combine the results&#125; 例如图像处理，可以变换上半部分和下半部分，这些操作可以并行运行（如果有足够多的空闲处理器）一个更简单的例子是数组处理，统计一个数组有多少个元素满足某个特定的属性，可以将数组一分为二，分别对这部分进行统计，结果相加提供一个扩展RecursiveTask&lt;T&gt;的类（计算会生成类型T的结果），或者提供一个扩展RecursiveAction的类（不生成任何结果），再覆盖compute方法来生成并调用子任务，然后合并结果 1234567891011121314class Counter extends RecursiveTask&lt;Integer&gt; &#123; ... protected Integer compute() &#123; if (to - from &lt; THRESHOLD) &#123; solve problem directly &#125; else &#123; int mid = (from + to) / 2; Counter first = new Counter(values, from, mid, filter); Counter second = new Counter(values, mid, to, filter); invokeAll(first, second); return first.join() + second.join(); &#125; &#125;&#125; 后台中，fork-join框架使用一种有效的智能方法来平衡可用线程的工作负载，这种方法称为工作密取，每个工作线程都有一个双端队列来完成任务，一个工作线程将子任务压入其双端队列队头，一个工作线程空闲时，它会从另一个双端队列队尾密取一个任务 同步器倒计时门栓CountDownLatch类让一个线程集等待直到计数变为0，倒计时门栓是一次性的，一旦计数为0，就不能重用 举例来说，假定一个线程集需要一些初始的数据来完成工作，工作器线程被启动并在门外等待。另一个线程准备数据，设置一个计数值为1的门栓，当数据准备好后，调用countDown，所有工作器线程就可以继续运行了。然后设置第二个门栓检查什么时候所有工作器线程完成工作，门栓计数为工作器线程个数 障栅CyclicBarrier类实现一个集结点称为障栅。考虑大量线程运行在一次计算的不同部分的情形，当所有部分准备好时，需要把结果组合在一起，当一个线程完成它的部分任务后，我们让它运行到障栅处，一旦所有线程都到达这个障栅，障栅就撤销，线程可以继续运行 12345678CyclicBarrier barrier = new CyclicBarrier(nthreads);public void run()&#123; doWork(); barrier.await();&#125; 如果任何一个在障栅上等待的线程离开障栅（调用它本身的await导致超时，或者被中断），所有其他线程会的await方法抛出BrokenBarrierException异常 可以提供一个可选的障栅动作，当所有线程到达障栅时会执行这一动作 12Runnable barrierAction = ...CyclicBarrier barrier = new CyclicBarrier(nthreads, barrierAction); 障栅是循环的，可以被重用，Phaser类可以允许改变不同阶段中参与线程的个数 交换器两个线程在同一数据缓冲区的两个实例上工作时，可以使用交换器Exchanger 同步队列是一种生产者消费者线程配对的机制，一个线程调用SynchronousQueue的put方法时，它会阻塞到另一个线程调用take方法位置，反之亦然，与Exchanger不同的是它的数据是单向的，从生产者到消费者，它实现了BlockingQueue接口，但它依然不是一个队列，它的size方法总是返回0]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>执行器</tag>
        <tag>线程池</tag>
        <tag>同步器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发基础3-阻塞队列与线程安全的集合]]></title>
    <url>%2F2019%2F07%2F19%2FJava%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%803-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[Java并发基础3-阻塞队列与线程安全的集合阻塞队列BlockingQueue许多线程问题都可以通过一个或多个队列安全形式化，生产者线程向队列插入元素，消费者线程取出它们，使用队列可以安全从一个线程向另一个线程传递数据。如银行转账，转账线程将转账指令对象插入一个队列中，而不是直接访问银行对象，另一个线程从队列取出指令执行转账，只有该线程可以访问该银行对象的内部，因此不需要同步 当试图往满队列添加元素或从空队列取元素时，阻塞队列会导致线程阻塞，阻塞队列方法如下： 有三类方法，取决于队满队空时的响应方式。如果将队列当做线程管理工具来使用，就要用到put和take；如果要抛出异常，就要用add，remove和element；offer，poll，peek在队满或队空时不会完成任务，而是给出一个错误提示但不抛出异常 offer与poll方法可以带超时参数boolean success = q.offer(x, 100, TimeUtil.MILLISECONDS);，若超时还没插入则返回false java.util.concurrent包提供了阻塞队列的几个变种：默认情况下，LinkedBlockingQueue的容量是没有上边界的，但也可以选择指定其最大容量，LinkedBlockingDeque是双端队列ArrayBlockingQueue在构造时需要指定容量，有一个可选的参数来指定是否需要公平性（公平性指等待最长时间的线程会优先得到处理），公平性会降低性能PriorityBlockingQueue是一个带优先级的队列（不是先进先出），元素会按照他们的优先级顺序被移出，该队列没有上限，队空时取元素会阻塞DelayQueue包含实现Delayed接口的对象Class DelayQueue&lt;E extends Delayed&gt;，实现Delayed接口要实现long getDelay(TimeUnit unit)方法，getDelay方法返回对象的残留延迟，负值表示延迟已经结束，元素只有延迟用完的情况下才能从DelayQueue移除。还必须实现compareTo方法（Delayed接口基础自Comparable）LinkedTransferQueue类实现了TransferQueue接口，可以允许生产者线程等待，直到消费者准备就绪可以接收一个元素，生产者调用q.transfer(item);，会阻塞，直到另一个线程将元素(item)删除 主要在生产者线程中往队列插入元素，消费者线程从队列取元素，不需要关心线程的同步问题，队列本身已经提供了同步机制 线程安全的集合如果多线程要并发修改一个数据结构，如散列表，那么很容易会破坏这个数据结构。可以提供锁来保护共享数据结构，但是Java类库也有提供线程安全的集合实现 高效的映射，集合队列ConcurrentHashMap,ConcurrentSkipListMap,ConcurrentSkipListSet,ConcurrentLinkedQueue都是java.util.concurrent包提供的映射，有序集合队列的高效实现 映射条目的原子更新下面代码不是线程安全的，即使map是线程安全的map 123Long oldValue = map.get(word);Long newValue = oldValue == null ? 1 : oldValue + 1;map.put(word, newValue); 可能会有另一个线程同时更新同一个计数 线程安全的数据结构指如果多个线程修改，内部的结构也不会破坏，不会造成链接丢失，循环等问题 可以使用replace方法更新，它会以原子方式用一个新值替换原值，前提是之前没有其他线程把原值替换成其他值 1234do &#123; oldValue = map.get(word); newValue = oldValue == null ? 1 : oldValue + 1;&#125; while (!map.replace(word, oldValue, newValue); 也可以使用ConcurrentHashMap&lt;String, AtomicLong&gt;或ConcurrentHashMap&lt;String, LongAdder&gt; 12map.putIfAbsent(word, new LongAdder());map.get(word).increment(); Java8也提供了原子更新的方法compute，它提供一个键和计算新值的函数，这个函数接收键和相关联的值（没有则为null），它会计算新值 1map.compute(word, (k, v) -&gt; v == null ? 1 : v + 1); 另外还有computeIfPresent和computeIfAbsent方法 并发散列映射的批操作即使其他线程在处理映射，这些操作也能安全执行，有三种不同的批操作 搜索：为每个键或值提供一个函数，直到函数生成一个非null的结果。然后搜索终止，返回这个函数的结果 归约：组合所有键或值，要使用所提供的一个累加函数 forEach：为所有键或值提供一个函数 每个操作有4个版本 operationKeys：处理键 operationValues：处理值 operation：处理键和值 operationEntries：处理Map.Entry对象 上述操作需要指定一个参数化阈值，如果映射包含元素多于这个阈值，就会并行完成批操作。如果希望批操作在一个线程中运行，可以使用阈值Long.MAX_VALUE，如果希望用尽可能多的线程运行批操作，可以使用阈值1 同步search方法API如下： 对于函数参数，只需要提供lambda函数即可 (k,v) -&gt; {} 并发集视图如果想得到大的线程安全的集而不是映射，但没有ConcurrentHashSet类，可以使用ConcurrentHashMap的静态方法newKeySet，它会生成一个Set（实际上是ConcurrentHashMap&lt;K, Boolean&gt;的一个包装器，所有值为Boolean.TRUE） Callable与FutureRunnable封装一个异步运行的任务，可以把它想象成一个没有参数和返回值的异步方法。而Callable可以有返回值，Callable接口只有一个方法call 123public interface Callable&lt;V&gt; &#123; V call() throws Exception;&#125; Future保存异步计算的结果，可以启动一个计算，把Future对象交给某个线程，Future对象的所有者在结果计算好后就可以获得它 get方法调用被阻塞，直到计算完成（或超时抛出异常），如果计算还在进行，isDone方法返回false，cancel方法取消计算，参数表示如果计算处于运行中，则被中断 使用FutureTask包装器将Callable转换成Future和Runnablee.g. 123456Callable&lt;Integer&gt; myComputation = ...;FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(myComputation);Thread t = new Thread(task);t.start();...Integer result = task.get();]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>阻塞队列</tag>
        <tag>线程安全的集合</tag>
        <tag>Callable与Future</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转Bootstrap04-JS插件]]></title>
    <url>%2F2019%2F07%2F18%2F%E7%8E%A9%E8%BD%ACBootstrap04-JS%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[玩转Bootstrap04-JS插件对JS插件，最重要的是官方文档，各种控件的JS事件 模态弹出框Bootstrap模态弹出框统一称为Modal 1234567891011121314151617181920212223242526272829&lt;button class="btn btn-primary" type="button"&gt;点击我&lt;/button&gt;&lt;div class="modal" id="mymodal"&gt; &lt;div class="modal-dialog"&gt; &lt;div class="modal-content"&gt; &lt;div class="modal-header"&gt; &lt;button type="button" class="close" data-dismiss="modal"&gt;&lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt;&lt;span class="sr-only"&gt;Close&lt;/span&gt;&lt;/button&gt; &lt;h4 class="modal-title"&gt;模态弹出窗标题&lt;/h4&gt; &lt;/div&gt; &lt;div class="modal-body"&gt; &lt;p&gt;模态弹出窗主体内容&lt;/p&gt; &lt;/div&gt; &lt;div class="modal-footer"&gt; &lt;button type="button" class="btn btn-default" data-dismiss="modal"&gt;关闭&lt;/button&gt; &lt;button type="button" class="btn btn-primary"&gt;保存&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;!-- /.modal-content --&gt; &lt;/div&gt;&lt;!-- /.modal-dialog --&gt;&lt;/div&gt;&lt;!-- /.modal --&gt;&lt;script src="http://libs.baidu.com/jquery/1.9.0/jquery.js"&gt;&lt;/script&gt;&lt;!-- 直接引入bootstrap.min.js即可 --&gt;&lt;script src="http://cdn.bootcss.com/bootstrap/2.3.1/js/bootstrap-transition.js"&gt;&lt;/script&gt;&lt;script src="http://cdn.bootcss.com/bootstrap/2.3.1/js/bootstrap-modal.js"&gt;&lt;/script&gt;&lt;script&gt; $(function()&#123; $(".btn").click(function()&#123; $("#mymodal").modal("toggle"); &#125;); &#125;);&lt;/script&gt; 效果如下：点击按钮，弹出框 结构原理bootstrap的模态弹出框，分别运用了”modal”，”modal-dialog”和”modal-content”样式，弹出窗真正内容都放在”modal-content”中，其中又包含3个部分 modal-header：弹出框头部，主要包括标题和关闭按钮（右上角的×） modal-body：弹出框的主要内容 modal-footer：操作按钮 主要结构如上代码所示 可以在最外层的&lt;div class=&quot;modal&quot;&gt;中继续添加类&lt;div class=&quot;modal fade bs-example-modal-lg&quot;&gt;，其中fade表示背景的灰色蒙版是渐变的而不是瞬变的，bs-example-modal-lg是大尺寸模态弹出框，如果小尺寸则用bs-example-modal-sm 触发模态弹出框我主要是用JS触发 123456// 点击类为btn的元素，就会触发id为mymodal的modal事件，使模态弹出框弹出$(function()&#123; $(".btn").click(function()&#123; $("#mymodal").modal(); &#125;);&#125;); 其他还有data-toggle和data-target属性来弹出，略 下拉菜单触发下拉菜单方法有两种，一种是属性声明式用法，另一种是JS方法 属性声明前面章节有代码，下面主要讲JS方法 123$(function()&#123; $(".dropdown-toggle").dropdown();&#125;) 滚动监听器该插件可以自动检测滚动条到达哪个位置，然后在需要高亮的菜单元素上加了一个“active”样式 中文官方文档的滚动监听器 选项卡12345678910111213141516&lt;!-- 选项卡组件（菜单项nav-tabs）--&gt;&lt;ul id="myTab" class="nav nav-tabs" role="tablist"&gt; &lt;li class="active"&gt;&lt;a href="#bulletin" role="tab" data-toggle="tab"&gt;公告&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#rule" role="tab" data-toggle="tab"&gt;规则&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#forum" role="tab" data-toggle="tab"&gt;论坛&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#security" role="tab" data-toggle="tab"&gt;安全&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#welfare" role="tab" data-toggle="tab"&gt;公益&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!-- 选项卡面板 --&gt;&lt;div id="myTabContent" class="tab-content"&gt; &lt;div class="tab-pane active" id="bulletin"&gt;公告内容面板&lt;/div&gt; &lt;div class="tab-pane" id="rule"&gt;规则内容面板&lt;/div&gt; &lt;div class="tab-pane" id="forum"&gt;论坛内容面板&lt;/div&gt; &lt;div class="tab-pane" id="security"&gt;安全内容面板&lt;/div&gt; &lt;div class="tab-pane" id="welfare"&gt;公益内容面板&lt;/div&gt;&lt;/div&gt; 中文官方文档的选项卡 胶囊选项卡只需要修改ul标签的class即可，如下 12345678910111213141516&lt;!-- 选项卡组件（菜单项nav-pills）--&gt;&lt;ul id="myTab" class="nav nav-pills" role="tablist"&gt; &lt;li class="active"&gt;&lt;a href="#bulletin" role="tab" data-toggle="pill"&gt;公告&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#rule" role="tab" data-toggle="pill"&gt;规则&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#forum" role="tab" data-toggle="pill"&gt;论坛&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#security" role="tab" data-toggle="pill"&gt;安全&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#welfare" role="tab" data-toggle="pill"&gt;公益&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!-- 选项卡面板 --&gt;&lt;div id="myTabContent" class="tab-content"&gt; &lt;div class="tab-pane fade in active" id="bulletin"&gt;公告内容面板&lt;/div&gt; &lt;div class="tab-pane fade" id="rule"&gt;规则内容面板&lt;/div&gt; &lt;div class="tab-pane fade" id="forum"&gt;论坛内容面板&lt;/div&gt; &lt;div class="tab-pane fade" id="security"&gt;安全内容面板&lt;/div&gt; &lt;div class="tab-pane fade" id="welfare"&gt;公益内容面板&lt;/div&gt;&lt;/div&gt; 选项卡同理可以添加fade效果，需要在&lt;div class=&quot;tab-pane fade&quot;&gt;添加 12345678910111213141516&lt;!-- 选项卡组件（菜单项nav-tabs）--&gt;&lt;ul id="myTab" class="nav nav-tabs" role="tablist"&gt; &lt;li class="active"&gt;&lt;a href="#bulletin" role="tab" data-toggle="tab"&gt;公告&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#rule" role="tab" data-toggle="tab"&gt;规则&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#forum" role="tab" data-toggle="tab"&gt;论坛&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#security" role="tab" data-toggle="tab"&gt;安全&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#welfare" role="tab" data-toggle="tab"&gt;公益&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!-- 选项卡面板 --&gt;&lt;div id="myTabContent" class="tab-content"&gt; &lt;div class="tab-pane fade in active" id="bulletin"&gt;公告内容面板&lt;/div&gt; &lt;div class="tab-pane fade" id="rule"&gt;规则内容面板&lt;/div&gt; &lt;div class="tab-pane fade" id="forum"&gt;论坛内容面板&lt;/div&gt; &lt;div class="tab-pane fade" id="security"&gt;安全内容面板&lt;/div&gt; &lt;div class="tab-pane fade" id="welfare"&gt;公益内容面板&lt;/div&gt;&lt;/div&gt; 提示框12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;h3&gt;按钮做的提示框&lt;/h3&gt;&lt;button type="button" class="btn btn-default" data-toggle="tooltip" data-placement="left" data-original-title="提示框居左" title=""&gt;提示框居左 &lt;/button&gt;&lt;button type="button" class="btn btn-default" data-toggle="tooltip" data-placement="top" data-original-title="提示框在顶部"&gt; 提示框在顶部&lt;/button&gt;&lt;button type="button" class="btn btn-default" data-toggle="tooltip" data-placement="bottom" data-original-title="提示框在底部"&gt;提示框在底部 &lt;/button&gt;&lt;button type="button" class="btn btn-default" data-toggle="tooltip" data-placement="right" data-original-title="提示框居右"&gt;提示框居右 &lt;/button&gt;&lt;h3&gt;链接制作的提示框&lt;/h3&gt;&lt;a class="btn btn-primary" data-toggle="tooltip" data-placement="left" title="提示框居左"&gt; 提示框居左&lt;/a&gt;&lt;a class="btn btn-primary" data-toggle="tooltip" data-placement="top" title="提示框在顶部"&gt; 提示框在顶部&lt;/a&gt;&lt;a class="btn btn-primary" data-toggle="tooltip" data-placement="bottom" title="提示框在底部"&gt; 提示框在底部&lt;/a&gt;&lt;a class="btn btn-primary" data-toggle="tooltip" data-placement="right" title="提示框在居右"&gt; 提示框居右&lt;/a&gt;&lt;a href="##" class="btn btn-primary" id="myTooltip"&gt; 我是提示框&lt;/a&gt;&lt;a href="##" class="btn btn-primary" id="myTooltip2"&gt; 我是提示框2&lt;/a&gt;&lt;script src="http://libs.baidu.com/jquery/1.9.0/jquery.js"&gt;&lt;/script&gt;&lt;script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;script&gt;$(function()&#123; $('[data-toggle="tooltip"]').tooltip(); $('#myTooltip').tooltip(&#123; title:"我是一个提示框，我在顶部出现", placement:'top' &#125;);&#125;);&lt;/script&gt; 弹出框弹出框的官方文档 它与提示框的区别如下： 提示框 tooltip 的默认触发事件是 hover 和 focus，而弹出框 popover 是 click 提示框 tooltip 只有一个内容(title)，而弹出框不仅可以设置标题（title）还可以设置内容(content) 警告框 警告框 1234&lt;div class="alert alert-success" role="alert"&gt; &lt;button class="close" data-dismiss="alert" type="button" &gt;&amp;times;&lt;/button&gt; &lt;p&gt;恭喜您操作成功！&lt;/p&gt;&lt;/div&gt; 12345&lt;div class="alert alert-warning" role="alert"&gt; &lt;h4&gt;谨防被骗&lt;/h4&gt; &lt;p&gt;请确认您转账的信息是你的亲朋好友，不要轻意相信不认识的人...&lt;/p&gt; &lt;a href="#" class="btn btn-danger" data-dismiss="alert"&gt;关闭&lt;/a&gt;&lt;/div&gt; 点击关闭按钮会隐藏整个警告框 或者使用JS方法触发关闭 1234567891011&lt;div class="alert alert-warning" role="alert" id="myAlert"&gt; &lt;h4&gt;谨防被骗&lt;/h4&gt; &lt;p&gt;请确认您转账的信息是你的亲朋好友，不要轻意相信不认识的人...&lt;/p&gt; &lt;button type="button" class="btn btn-danger" id="close"&gt;关闭&lt;/button&gt;&lt;/div&gt; &lt;script&gt; $(function()&#123; $("#close").on("click",function()&#123; $(this).alert("close"); &#125;);&#125;); 按钮123456789&lt;button class="btn btn-primary" data-loading-text="正在加载中,请稍等..." type="button" id="loaddingBtn"&gt;加载&lt;/button&gt; &lt;script&gt; $(function()&#123; $("#loaddingBtn").click(function () &#123; $(this).button("loading"); &#125;);&#125;); &lt;/script&gt; 模拟单选择按钮1234567891011&lt;div class="btn-group"&gt; &lt;label class="btn btn-primary"&gt; &lt;input type="radio" name="options" id="options1"&gt;男 &lt;/label&gt; &lt;label class="btn btn-primary"&gt; &lt;input type="radio" name="options" id="options2"&gt;女 &lt;/label&gt; &lt;label class="btn btn-primary"&gt; &lt;input type="radio" name="options" id="options3"&gt;未知 &lt;/label&gt;&lt;/div&gt; 模拟复选按钮1234567891011121314&lt;div class="btn-group"&gt; &lt;label class="btn btn-primary"&gt; &lt;input type="checkbox" name="options" id="options1"&gt;电影 &lt;/label&gt; &lt;label class="btn btn-primary"&gt; &lt;input type="checkbox" name="options" id="options2"&gt;音乐 &lt;/label&gt; &lt;label class="btn btn-primary"&gt; &lt;input type="checkbox" name="options" id="options3"&gt;游戏 &lt;/label&gt; &lt;label class="btn btn-primary"&gt; &lt;input type="checkbox" name="options" id="options4"&gt;摄影 &lt;/label&gt;&lt;/div&gt; 按钮状态切换在点击按钮后，按钮的状态为已点击（样式有变化） 123&lt;div class="btn-group" data-toggle="button"&gt; &lt;button type="button" data-toggle="button" class="btn btn-primary"&gt;确认&lt;/button&gt;&lt;/div&gt; JS用法$(&quot;#mybutton&quot;).button(&quot;toggle&quot;)得到焦点$(&quot;#mybutton&quot;).button(&quot;reset&quot;)重新恢复按钮$(&quot;#mybutton&quot;).button(&quot;任意字符参数名&quot;)替换 data-任意字符参数名-text 的属性值为“按钮上显示的文本值” 手风琴效果如下 点击任一标题，下面正文的内容会显示，一次只会显示一个内容，其他的内容会隐藏 1234567891011121314151617181920212223242526&lt;div class="panel-group" id="accordion"&gt; &lt;div class="panel panel-default"&gt; &lt;div class="panel-heading"&gt; &lt;h4 class="panel-title"&gt;&lt;a data-toggle="collapse" data-parent="#accordion" href="#collapseOne"&gt;标题一&lt;/a&gt;&lt;/h4&gt; &lt;/div&gt; &lt;div id="collapseOne" class="panel-collapse collapse in"&gt; &lt;div class="panel-body"&gt;标题一对应的内容&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="panel panel-default"&gt; &lt;div class="panel-heading"&gt; &lt;h4 class="panel-title"&gt;&lt;a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo"&gt;标题二&lt;/a&gt;&lt;/h4&gt; &lt;/div&gt; &lt;div id="collapseTwo" class="panel-collapse collapse"&gt; &lt;div class="panel-body"&gt;标题二对应的内容&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="panel panel-default"&gt; &lt;div class="panel-heading"&gt; &lt;h4 class="panel-title"&gt;&lt;a data-toggle="collapse"data-parent="#accordion"href="#collapseThree"&gt;标题三&lt;/a&gt;&lt;/h4&gt; &lt;/div&gt; &lt;div id="collapseThree" class="panel-collapse collapse"&gt; &lt;div class="panel-body"&gt;标题三对应的内容&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 图片轮播1234567891011121314151617181920212223242526272829303132333435&lt;div id="myCarousel" class="carousel slide"&gt; &lt;ol class="carousel-indicators"&gt; &lt;li data-target="#myCarousel" data-slide-to="0" class="active"&gt;&lt;/li&gt; &lt;li data-target="#myCarousel" data-slide-to="1"&gt;&lt;/li&gt; &lt;li data-target="#myCarousel" data-slide-to="2"&gt;&lt;/li&gt; &lt;/ol&gt; &lt;div class="carousel-inner"&gt; &lt;div class="item active"&gt; &lt;img src="http://images3.c-ctrip.com/rk/201407/ll580x145.jpg" alt=""&gt; &lt;div class="carousel-caption"&gt; &lt;h4&gt;标题一&lt;/h4&gt; &lt;p&gt;图片一内容简介&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;img src="http://images3.c-ctrip.com/dj/201408/zj/zj_580145.jpg" alt=""&gt; &lt;div class="carousel-caption"&gt; &lt;h4&gt;标题二/h4&gt; &lt;p&gt;图片二内容简介&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;img src="http://images3.c-ctrip.com/rk/201403/yfdd580145a.png" alt=""&gt; &lt;div class="carousel-caption"&gt; &lt;h4&gt;标题三&lt;/h4&gt; &lt;p&gt;图片三内容简介&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;a class="left carousel-control" href="#myCarousel" data-slide="prev"&gt;&amp;lsaquo;&lt;/a&gt; &lt;a class="right carousel-control" href="#myCarousel" data-slide="next"&gt;&amp;rsaquo;&lt;/a&gt;&lt;/div&gt;&lt;script&gt;$('.carousel').carousel()&lt;/script&gt;]]></content>
      <categories>
        <category>bootstrap</category>
      </categories>
      <tags>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络2-链路层]]></title>
    <url>%2F2019%2F07%2F18%2F%E7%BD%91%E7%BB%9C2-%E9%93%BE%E8%B7%AF%E5%B1%82%2F</url>
    <content type="text"><![CDATA[网络2-链路层 数据链路层功能 组帧 差错控制检错编码；纠错编码 流量控制与可靠传输机制流量控制，可靠传输与滑动窗口机制；停止-等待协议后退N帧协议（GBN）；选择重传协议（SR） 介质访问控制 信道划分频分多路复用，时分多路复用，波分多路复用，码分多路复用的概念和基本原理 随机访问ALOHA协议，CSMA协议，CSMA/CD协议，CSMA/CA协议 轮询访问：令牌传递协议 局域网局域网的基本概念与体系结构；以太网与IEEE 802.3IEEE 802.11；令牌环网的基本原理 广域网广域网的基本概念；PPP协议；HDLC协议 数据链路层设备网桥的概念及其基本原理；局域网交换机及其工作原理 数据链路层的功能数据链路层主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路 具体功能为： 为网络层提供服务 链路管理 帧定界，帧同步与透明传输 流量控制 差错控制 为网络层提供服务数据链路层可以为网络层提供如下服务： 无确认的无连接服务：适用于以太网 有确认的无连接服务：目的机器收到数据帧必须发回确认；源机器超时未收到确认信号，就重传失去的帧，适用于无线通信 有确认的面向连接服务：建立数据链路，传输帧，释放数据链路 链路管理数据链路层连接的建立，维持和释放过程称为链路管理，主要用于面向连接服务 帧定界，帧同步与透明传输将网络层的分组封装成帧，以帧格式传送。将数据前后分别添加首部尾部就构成了帧。首部尾部要确定帧的界限，称为帧定界。帧同步指接收方能从接收到的二进制比特流中区分帧的起始与终止。透明传输指不管所传数据是怎么样的比特组合，都能在链路上传送，如果在数据中恰好出现与帧定界相同的比特组合，可以采取有效措施解决这个问题 流量控制限制发送方的数据流量，使其发送速率不超过接收方的接收能力，以防止后面发送的帧淹没前面还未被接收的帧的情况。流量控制需要反馈机制使发送方知道什么时候可以发送下一帧 链路层的流量控制主要面向相邻两结点之间，区别于运输层控制源端到目的端 差错控制可以通过循环冗余检验（CRC）发现位错，自动重传请求（ARQ）重传出错的帧。发送方将数据帧附加一定的CRC冗余检错码并发送，接收方检验若发现错误则丢弃，发送方超时重传该数据帧，这种方法称为ARQ法 组帧比特组合成帧发送的目的是为了在出错时只重发出错的帧，而不必重发全部数据，组帧主要解决帧定界，帧同步，透明传输等问题 下面是4种实现组帧的方法 字符计数法帧头部使用计数字段标明帧内字符数，目的结点通过该值得知帧结束的位置，问题是如果计数字段出错，会失去同步 字符填充的首尾定界符法字符填充法使用特定字符定界一帧的开始与结束。信息位的特殊字符添加转移字符区分防止误判 比特填充的首尾标志法允许数据帧包含任意个数比特，允许每个字符编码包含任意个数的比特。它用01111110标志一帧的开始和结束，信息位中出现的比特流01111110为了不被误判，发送方在信息位遇到连续5个1时，会自动在其后插入一个0，接收方做该过程的逆操作 违规编码法物理层进行比特编码时，通常采用违规编码法，如曼彻斯特编码将数据比特1编码成高-低电平对，数据比特0编码成低-高电平对，而高-高电平对和低-低电平对在数据比特中是违规的，可以借用这些违规编码序列来界定帧的起始和终止。局域网IEEE 802标准采用这种方法 差错控制差错由噪声引起，噪声有两大类：信道固有的随机热噪声和外界特定短暂原因造成的冲击噪声，前者可以提高信噪比减少，后者是产生差错的重要原因 可以利用编码技术进行差错控制，主要有自动重传请求ARQ和前向纠错FEC。ARQ方式接收端检测出差错时就设法通知发送端重传，直到接收到正确码字为止。FEC方式接收端不但能发现差错，还能确定二进制数码的错误位置，从而加以纠正。因此差错控制又可分为纠错编码和检错编码 检错编码检错编码采用冗余编码技术，核心思想是在有效数据被发送前，先按某种关系附加一定的冗余位，构成一个符合某一规则的码字后再发送。码字遵从不变的规则，随有效数据的变化而变化。接收端根据收到的码字是否符合原规则来判断是否出错，常见的检错编码有奇偶检验码和循环冗余码 奇偶检验码奇检验码在附加一个检验元后，码长为n的码字中1的个数为奇数，偶检验码在附加一个检验元后，码长为n的码字中1的个数为偶数 循环冗余码CRC给定一个m bit的帧或报文，发送器生成一个r bit的序列，称为帧检验序列，所形成的帧由m+r比特组成，发送方和接收方事先商定一个多项式G(x)，使带检验码的帧刚好被预先确定的G(x)整除，接收方用相同的多项式去除收到的帧，如果无余数就认为无差错。计算过程略 纠错编码纠错编码需要在每个要发送数据块上附加足够冗余信息，使接收方能推导发送方实际发出的应该是什么样的比特串，常见的是海明码 流量控制与可靠传输机制流量控制，可靠传输与滑动窗口机制流量控制涉及对链路上的帧的发送速率的限制，以使接收方有足够缓冲空间来接收每个帧，常见方式有停止-等待协议和滑动窗口协议 停止-等待流量控制基本原理发送方每发送一帧，都要等待接收方的应答信号，之后才发送下一帧，接收方每接收一帧都要反馈一个应答信号，如果接收方不反馈，发送方必须一直等待 滑动窗口流量控制基本原理发送方维持一组连续的允许发送的帧的序号，称为发送窗口，接收方也维持一组连续的允许接收帧的序号，称为接收窗口。发送窗口的大小WT代表在还未收到对方确认信息的情况下发送方最多还可以发送多少个数据帧。接收端设置的接收窗口控制可以接收哪些数据帧和不可以接收哪些数据帧，若接收到的数据帧在窗口之外就丢弃 单帧滑动窗口与停止-等待协议发送方每发送一帧都要等待接收方的应答信号才能发送下一帧 多帧滑动窗口与后退N帧协议（GBN）发送方一次可发送N帧，按序接收，重传从最后一个确认开始 多帧滑动窗口与选择重传协议（SR）发送方一次可发送N帧，可以不按序接收，重传没有确认的帧 介质访问控制当同一信道被多个结点共用时，两对结点之间的通信可能会因为互相干扰而失败，需要采取一定措施，使得两对结点之间的通信不会发生互相干扰的情况 常见介质访问控制方法有信道划分介质访问控制，随机访问介质访问控制，轮询访问介质访问控制，前者是静态划分信道方法，后两者是动态分配信道方法 信道划分介质访问控制采取多路复用可以把多个输入通道的信息整合到一个复用通道中，在接收端把收到的信息分离出来并传送到对应的输出通道，实质是通过分时，分码，分频等方法把原来的一条广播信道，逻辑上分为几条用于两个结点之间通信的互不干扰的子信道，实际上就是把广播信道转变为点对点信道 频分多路复用：多路基带信号调制到不同频率载波上，再叠加成一个复合信号 时分多路复用：物理信道按时间分成若干时间片，轮流分配给多个信号使用 波分多路复用：一根光纤中传输多种不同波长的光信号 码分多路复用：采用不同编码区分各路原始信号 随机访问介质访问控制所有用户都可以随机发送信息，占用信道全部速率，如果2个或多个用户同时发送，会产生帧的冲突，导致所有冲突用户发送失败，为了解决随机接入发送的碰撞，每个用户需要按照一定规则反复重传它的帧，这些规则就是随机访问介质访问控制协议，常见有ALOHA协议，CSMA协议，CSMA/CD协议和CSMA/CA协议等，它们核心都是胜利者通过争用获得信道 ALOHA协议纯ALOHA基本思想：网络中任何一个站点需要发送数据时，可以不进行任何检测就发送，如果一段时间内未收到确认，该站点就认为传输冲突，发送站点等待一段时间后再发送数据，直到发送成功 时隙ALOHA协议把所有各站在时间上同步起来，将时间划分为一段段等长的时隙，规定只能在每个时隙开始时才能发送一个帧 时隙ALOHA效率是纯ALOHA的两倍 CSMA协议ALOHA用户发送数据随意，即使其他站点正在发送也照发不误，如果每个站点在发送前先侦听一下共用信道，发现信道空闲后再发送，就可以提高信道利用率，CSMA就是这样做的根据侦听方式和侦听到信道忙后的处理方式不同，CSMA分为三种 1-坚持CSMA：一个节点要发送数据时，首先侦听信道，如果信道空闲，立即发送数据，如果信道忙，等待并侦听直到信道空闲，如果冲突，则随机等待一段时间后再重新开始侦听 非坚持CSMA：一个节点要发送数据时，首先侦听信道，如果信道空闲，那么立即发送数据，如果信道忙，放弃侦听，等待一个随机实践后再重复上述过程 p-坚持CSMA：用于时分信道，一个节点要发送数据，先侦听信道，如果信道忙，那么等待下一时隙再侦听，如果信道空闲，那么以概率p发送数据，以概率1-p推迟到下一个时隙 CSMA/CD协议是CSMA协议的改进方案，CD指碰撞检测，边发送边侦听，以判断自己在发送数据时其他站点是否也在发送数据 工作流程简单概括为：先听后发，边听边发（区别于CSMA），冲突停发，随机重发 CSMA/CA协议CSMA/CD不适用于无线领域，因此定义了CSMA/CA协议用于无线领域，使用预约信道，ACK帧，RTS/CTS帧三种机制实现碰撞避免 轮询访问介质访问控制轮询访问中，用户不能随机发送信息，而是通过一个集中控制的监控站，以循环方法轮询每个结点，再决定信道的分配，信道是独占的，典型的轮询访问介质访问控制是令牌传递协议，主要用于令牌环局域网 令牌在各节点间以某种固定次序交换，令牌是由一组特殊比特组合而成的帧，环上一个站希望传送帧时，必须等待令牌，一旦收到令牌，站点便可启动发送帧，否则站必须把令牌转发给下一个站 局域网局域网LAN指在一个较小的地理范围内，将各个计算机，外部设备和数据库系统等通过双绞线，同轴电缆等连接介质互相连接起来，组成资源和信息共享的计算机互联网络 局域网特性由拓扑结构，传输介质，介质访问控制方式决定 拓扑结构分为星形结构，环形结构，总线结构，星形和总线形结合的复合型结构传输介质可以用双绞线，铜缆，光纤等，双绞线是主流介质访问控制方法主要有CSMA/CD，令牌总线和令牌环 三种特殊的局域网拓扑实现如下： 以太网（使用最广）：逻辑拓扑是总线形结构，物理拓扑是星形或拓展星形结构 令牌环：逻辑拓扑是环形结构，物理拓扑是星形结构 FDDI：逻辑拓扑是环形结构，物理拓扑是双环结构 以太网与IEEE 802.3IEEE 802.3标准是一种基带总线形的局域网标准，它描述了物理层和数据链路层的MAC子层的实现方法，通常符合802.3标准的局域网简称为以太网以太网逻辑上是总线形拓扑结构，所有计算机共享同一条总线，信息以广播方式发送，使用CSMA/DA方式对总线进行访问控制。以太网采用两种措施简化通信：采用无连接的工作方式，不对发送的数据帧编号，也不要求接收方发送确认，即以太网最大努力交付数据，是不可靠服务，对于差错纠正也由高层完成 计算机与外界局域网连接通过主机箱内插入一块网络接口板（网卡）实现，网卡上装有处理器和存储器，实现与局域网传输介质之间的物理连接和电信号匹配，帧的发送接收，封装拆封，介质访问控制，数据编码与解码，数据缓存等。网卡有唯一代码称为介质访问控制（MAC）地址，网卡工作在物理层，只关注比特 以太网的MAC帧当一台主机向另一台主机发送一个IP数据报，且这两台主机在相同的以太局域网上，发送端的网卡会在一个以太网帧中封装这个IP数据报，并把该帧传递给物理层，接收端的网卡接收到这个帧，提取出IP数据报传递给网络层 每块网卡都有MAC地址，长6字节，由连字符（或冒号）分隔的6个十六进制数表示，如02-60-8c-e4-b1-21（高24位厂商代码，低24位网卡序列号）。以太网总线上使用的是广播通信，因此网卡从网络上每收到一个MAC帧，都用硬件检查MAC帧的MAC地址，如果是发往本站才收下 MAC帧格式如下： 前导码：使接收端和发送端时钟同步，在帧前面插入的8字节可再为两个字段，第一个字段7字节，是前同步码，用于快速实现MAC帧的比特同步，第二个字段是帧开始定界符，表示后面的信息就是MAC帧地址：6字节地址（MAC地址）类型：2字节，指出数据域中携带的数据应交给哪个协议实体处理数据：46~1500字节，包含高层的协议消息，CSMA/CD算法限制，以太网帧必须满足最小长度64字节（MAC帧首位占了18字节），数据较少时加以填充检验码FCS：4字节，从目的地址段到数据端末尾，算法采用32位循环冗余码CRC，不但检验MAC帧数据部分，还检验目的地址，源地址和类型数据，但不检验前导码 IEEE 802.11IEEE 802.11是无线局域网的一系列协议标准，MAC层采用CSMA/CA协议。冲突避免要求每个发送结点在发送帧之前先侦听信道，如果空闲则发送，发送完一帧后必须等待一个短的时间间隔，检查接收站是否发挥帧的确认ACK，如果没有接收到，则发送冲突，重发该帧，直到规定最大重发次数之内发送成功 广域网广域网指覆盖范围很广的长距离网络，是因特网的核心部分，局域网可以通过广域网与另一个相隔很远的局域网通信。广域网不等于互联网，互联网可以连接不同类型的网络（即可以连接局域网，也可以连接广域网），通常使用路由器连接 广域网由结点交换机（不是路由器）及连接这些交换机的链路组成，结点交换机将分组存储并转发 广域网与局域网区别很大，局域网使用的协议主要在数据链路层，而广域网使用协议主要在网络层 广域网中一个重要问题是路由选择和分组转发，PPP协议和HDLC协议是目前最常用的两种广域网数据链路层控制协议 PPP协议PPP是使用串行线路通信的面向字节的协议，该协议应用在直接连接的两个结点的链路上，设计的目的是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机，网桥和路由器之间简单连接的一种共同的解决方案 PPP协议有三个组成部分： 链路控制协议LCP：一种扩展链路控制协议，用于建立，配置，测试和管理数据链路 网络控制协议NCP：PPP协议允许同时采用多种网络层协议，每个不同的网络层协议要用一个相应的NCP配置，为网络层协议建立和配置逻辑连接 一个将IP数据报封装到串行链路的方法：IP数据报在PPP帧中就是其信息部分，这个信息部分的长度受最大传送单元MTU的限制 PPP帧格式如下图所示 前3个字段和最后2个字段与HDLC帧是一样的，首部第一个和尾部第二个字段都是标志字段F(flag)，规定为0x7E，表示一个帧的开始或结束，标志字段是PPP帧的定界符，连续两帧之间只需要用一个标志字段首部的地址字段A规定为0xFF，控制字段C规定为0x03，实际上并没有携带任何信息第四个字段是2字节的协议字段，当协议字段为0x0021时，PPP帧的信息字段就是IP数据报信息字段的长度是可变的，不超过1500字节尾部第一个字段（2字节）是使用CRC的帧检验序列FCS PPP建立，使用，撤销的状态图如下 PPP提供差错检测但不纠错（CRC检验），不可靠的传输协议，不使用序号和确认机制 仅支持点对点 仅支持全双工 PPP两端可以运行不同的网络层协议 PPP是面向字节的，如果信息字段出现和标志字段一样的比特组合，在异步线路，PPP采用字节填充法，同步线路，则采用硬件来完成比特填充 HDLC协议HDLC是面向比特的数据链路层协议，不依赖于任何一个字符编码集，全双工，CRC检验，帧按顺序编号，传输可靠性高 思维导图]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>数据链路层</tag>
        <tag>PPP协议</tag>
        <tag>以太网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发基础2-同步]]></title>
    <url>%2F2019%2F07%2F18%2FJava%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%802-%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[Java并发基础2-同步锁对象有两种机制防止代码块受并发访问的干扰，Java语言提供了一个synchronized的关键字达到这一目的，并且Java5引入了ReentrantLock类 ReentrantLock保护代码块基本结构如下 1234567Lock myLock = new ReentrantLock();myLock.lock();try &#123; critical section&#125; finally &#123; myLock.unlock(); // make sure the lock is unlocked even if an exception is thrown&#125; 锁是可重入的，线程可以重复地获得已经持有的锁，锁保持一个持有计数来跟踪对lock方法的嵌套调用，线程每一次调用lock都要调用unlock来释放锁。由于这个特性，被一个锁保护的代码可以调用另一个使用相同的锁的方法 通过银行对象来描述锁：下面这段代码是一个银行对象，它维护了一个double数组是银行账户，值为账户余额，对余额转账需要同步操作，因此每次转帐前都需要上锁，转账后释放锁，如下 123456789101112131415161718192021222324252627282930public class Bank &#123; private Lock bankLock = new ReentrantLock(); private final double[] accounts; public Bank(int n, double initialBalance) &#123; accounts = new double[n]; Arrays.fill(accounts, initialBalance); &#125; public void transfer(int from, int to, double amount) &#123; bankLock.lock(); try &#123; if (accounts[from] &lt; amount) return; System.out.print(Thread.currentThread()); accounts[from] -= amount; System.out.printf(" %10.2f from %d to %d", amount, from, to); accounts[to] += amount; System.out.printf(" Total Balance: %10.2f%n", getTotalBalance()); &#125; finally &#123; bankLock.unlock(); &#125; &#125; public double getTotalBalance() &#123; double sum = 0; for (double a : accounts) sum += a; return sum; &#125; public int size() &#123; return accounts.length; &#125;&#125; 条件对象通常，线程进入临界区，却发现在某一条件满足后它才能执行。要使用一个条件对象来管理那些已经获得一个锁但是却不能做有用工作的线程 引例：上面的银行对象，假如要避免选择没有足够资金的账户作为转出账户，注意不能使用下面代码，下面代码不是同步的 12if (bank.getBalance(from) &gt;= amount) bank.transfer(from, to, amount) 上面代码当前线程完全有可能通过了if条件，然后被中断，然后在线程再次运行前，账户余额已经低于提款金额，必须确保没有其他线程在本检查余额与转账活动之间修改余额 123456789public void transfer(int from, int to, int amount) &#123; banLock.lock(); try &#123; while (account[from] &lt; amount) &#123; // wait &#125; // transfer funds &#125; finally &#123; banLock.unlock(); &#125;&#125; 但是当账户没有足够余额时，它会一直等直到另一个线程向账户注入资金，但是因为上锁了，其他线程也没有存款操作的机会，所以需要一种机制，当线程获得了锁，又需要满足某一条件时，就让它阻塞并放弃锁，直到该条件满足，这就是条件对象 条件对象是java.util.concurrent.locks.Condition，它的创建可以通过锁对象的newCondition()方法，如下 12345678class bank &#123; private Condition sufficientFunds; ... public Bank() &#123; ... sufficientFunds = bankLock.newCondition(); &#125;&#125; 如果transfer方法发现余额不足，它调用sufficientFunds.await();方法 等待获得锁的线程与调用await方法的线程存在本质上的不同，一旦一个线程调用await方法，它就进入该条件的等待集，当锁可用时，该线程不能马上解除阻塞，相反，它仍处于阻塞状态，直到另一个线程调用同一条件上的signalAll方法为止当另一个线程转账，它应该调用sufficientFunds.signalAll();，这一调用重新激活因为这一条件而等待的所有进程，一旦锁成为可用的，它们中的某个将从await调用返回，获得该锁并从被阻塞的地方继续执行此时，线程应该再次测试该条件，因为无法确保该条件被满足，对await的调用应该是如下形式的，是使用while语句判断的 1while (!(ok to proceed)) condition.await(); 调用signalAll方法的时机是最重要的，稍有不慎就会死锁，经验上讲，在对象的状态有利于等待线程的方向改变时调用signalAll，例如当一个账户余额发生改变时，等待的线程会应该有机会检查余额 12345678910public void transfer(int from, int to, int amount) &#123; banLock.lock(); try &#123; while (account[from] &lt; amount) &#123; sufficientFunds.await(); &#125; // transfer funds sufficientFunds.signalAll(); &#125; finally &#123; banLock.unlock(); &#125;&#125; 对锁和条件对象的总结 锁用来保护代码片段，任何时刻只能有一个线程执行被保护的代码 锁可以管理试图进入被保护代码段的线程 锁可以拥有一个或多个相关的条件对象 每个条件对象管理那些已经进入被保护的代码段但还不能运行的线程 synchronized关键字Java每一个对象都有一个内部锁，如果一个方法用synchronized关键字声明，那么对象的锁将保护整个方法，即要调用该方法，线程必须获得内部的对象锁，也只有方法才能用synchronized关键字声明 123public synchronized void method() &#123; method body&#125; 等价于 1234567public void method() &#123; this.intrinsicLock.lock(); try &#123; method body &#125; finally &#123; this.intrinsicLock.unlock(); &#125;&#125; 内部对象锁只有一个内部条件(Condition)，wait方法添加一个线程到等待集中，notify/notifyAll方法解除等待线程的阻塞状态 synchronized机制由锁来管理那些试图进入synchronized方法的线程，由条件来管理那些调用wait的线程 wait和notifyAll是Object类的final方法（因此Condition的方法才被命名为await和signalAll以免发生冲突） 此时Bank类可以如下实现 123456789101112131415161718192021222324252627282930public class Bank &#123; private final double[] accounts; public Bank(int n, double initialBalance) &#123; accounts = new double[n]; Arrays.fill(accounts, initialBalance); &#125; public synchronized void transfer(int from, int to, double amount) throws InterruptedException &#123; while (accounts[from] &lt; amount) wait(); System.out.print(Thread.currentThread()); accounts[from] -= amount; System.out.printf(" %10.2f from %d to %d", amount, from, to); accounts[to] += amount; System.out.printf(" Total Balance: %10.2f%n", getTotalBalance()); notifyAll(); &#125; public synchronized double getTotalBalance() &#123; double sum = 0; for (double a : accounts) sum += a; return sum; &#125; public int size() &#123; return accounts.length; &#125;&#125; 静态方法声明为synchronized也是合法的，如果调用这种方法，该方法获得相关的类对象的内部锁，当该方法被调用时，xxx.class对象的锁被锁住，没有其他线程可以调用同一个类的这个或任何其他的同步静态方法 内部锁和条件的局限 不能中断一个试图获得锁的线程 试图获得锁时不能设定超时 每个锁仅有单一的条件 对使用Lock/Condition和synchronized的建议 最好既不使用Lock/Condition也不使用synchronized关键字，许多情况下可以使用java.util.concurrent包中的一种机制，它会为你处理所有的加锁 如果synchronized关键字适合你的程序，尽量使用它，减少代码量 如果特别需要Lock/Condition结构提供的独有特性时，才使用Lock/Condition 同步阻塞同步阻塞可以获得锁，语法如下 1234synchronized (obj) // this is the syntax for a synchronized bolck&#123; critical section&#125; 它可以获得obj的锁 监视器概念监视器是面向对象的，有如下特性 监视器是只包含私有域的类 每个监视器类的对象有一个相关的锁 使用该锁对所有方法进行加锁 该锁可以有任意多个相关条件 Java设计者以不是很精确的方式采用了监视器概念，Java的每一个对象有一个内部锁和内部条件，如果一个方法用synchronized关键字声明，那么它表现就像是一个监视器方法，通过调用wait/notifyAll/notify来访问条件变量，然而Java对象仍然不同于监视器，表现为： 域不要求必须是private 方法不要求必须是synchronized 内部锁对客户是可用的 Volatile域有时为了读写一个或两个实例域就使用同步，开销会过大，但不同步的话，使用现代的处理器与编译器，仍然会有很大可能出错： 多处理器的计算机能暂时在寄存器或本地内存缓冲区保存内存的值，结果是，运行在不同处理器上的线程可能在同一内存位置取到不同的值 编译器可以改变指令执行的顺序以使吞吐量最大化，这种顺序上变化不会改变代码语义，但是编译器假定内存的值仅仅在代码中有显式的修改指令时才会改变，然而内存的值可以被另一个线程改变（即指令重排不改变程序执行结果，但可能影响多线程执行结果） 如果使用锁来保护可以被多个线程访问的代码，那么可以不考虑这种问题，编译器被要求通过在必要的时候刷新本地缓存来保持锁的效应，并且不能不正当地重新排序指令 volatile关键字为实例域的同步访问提供了一种免锁机制。如果声明一个域为volatile，那么编译器和虚拟机就知道该域是可能被另一个线程并发更新的 &nbsp; e.g.一个对象有一个布尔标记done，它的值被一个线程设置却被另一个线程查询，那么我们可以使用锁 123private boolean done;public synchronized boolean isDone() &#123; return done; &#125;public synchronized void setDone() &#123; done = true; &#125; 但是如果另一个线程已经对该对象加锁，isDone和setDone方法可能会阻塞，这时可以为这一变量使用独立的Lock，但会带来许多麻烦这时将域声明为volatile是合理的： 123private volatile boolean done'public boolean isDone() &#123; return done; &#125;public void setDone() &#123; done = true; &#125; 要理解volatile，首先要知道Java内存模型 在Java内存模型中，每个线程有它自己的工作内存，它们又共享一个主内存。主内存存储了共享变量(静态变量，堆内存的实例)的”本尊”。而工作内存可以理解为计算机的高速缓存，它存储共享变量的”副本” 在内存模型中，假如线程A从主存读取变量S=0，然后为其赋值S=3，再刷新写回到主存，线程B读取主存数据S，此时线程B可能会出现两种结果，S=3或者S=0（即线程A还没把S写回到主存时，线程B就已经读取主存的S了） 此时就需要用到关键字volatile，它的作用是保证volatile修饰的变量对所有线程的可见性，可见性指当一个线程修改了变量的值，新的值会立刻同步到主内存当中，而其他线程读取这个变量的时候，也会从主内存中拉取最新的变量值volatile可以有这样的特性，得益于Java的先行发生原则，，先行发生原则指两个事件的结果之间的关系，如果一个事件发生在另一个事件之前，结果必须反映，即使这些事件实际上是乱序执行的，在这里，线程A的写操作就先于线程B的读操作的发生 但是，volatile只能保证变量的可见性，并不能保证变量的原子性，如下面例子： 1234567891011121314151617181920212223242526public class VolatileTest &#123; public volatile static int count = 0; public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; Runnable r = () -&gt; &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; for (int j = 0; j &lt; 100; j++) &#123; count++; &#125; &#125;; new Thread(r).start(); &#125; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("count = " + count); &#125;&#125; 理论上，count最后输出的结果是1000，但实际上很难达到1000，这是因为count++并不是原子操作，count++在字节码层面如下： 1234getstatic // 读取静态变量counticonst_1 // 定义常量1iadd // count加1putstatic // 把count结果同步到主内存 可能会发生这种情况：线程A读取静态变量count，此时主内存的count值为0，然后线程A定义常量1的时候，主内存的count被其他线程修改，写为8，当线程A执行putstatic时，它工作内存上的count为1，会覆盖掉主内存的8 还有另一个例子： 1234567891011volatile static int start = 3;volatile static int end = 6;// 线程A执行下面代码while (start &lt; end) &#123; // do something&#125;// 线程B执行下面代码start += 3;end += 3; 假如线程B执行start+=3后，跳由线程A执行，它判断start&lt;end不成立，就会跳出while循环 综上，适用volatile关键字的情况如下： 运行结果不依赖变量当前值（即不能count=count+t，可以count=t)，或者能够确保只有单一的线程修改变量的值 变量不需要与其他状态变量共同参与不变约束（如上面例子） volatile对指令重排也会有影响，在介绍影响之前，先了解内存屏障 内存屏障是一种屏障指令，它使CPU和编译器对屏障指令之前和之后发出的内存操作执行一个排序约束，通常意味着屏障之前发布的操作被保证在屏障之后的操作之前执行，分为四种屏障： LoadLoad屏障：Load1;LoadLoad;Load2，Load2要读取的数据之前，保证Load1要读取的数据读取完毕 StoreStore屏障：Store1;StoreStore;Store2，Store2写入数据前，保证Store1写入操作对其他处理器可见 LoadStore屏障同上 StoreLoad屏障同上 volatile修饰变量后，JVM会做两件事： 每个volatile写操作前插入StoreStore屏障，写操作后插入StoreLoad屏障 每个volatile读操作前插入LoadLoad屏障，读操作后插入LoadStore屏障 &nbsp; Volatile总结 volatile只能保证变量的可见性，并不能保证变量的原子性，可见性的保证是基于CPU的内存屏障指令，称为happens-before 阻止指令重排，编译时编译器遵循内存屏障约束，运行时依靠CPU屏障指令阻止重排 原子性如果仅对变量赋值，不做其他操作，可以对这些共享变量声明为volatile除此之外，java.util.concurrent.atomic包有很多类使用高效的机器级指令(而不是锁)来保证其他操作的原子性，如incrementAndGet和decrementAndGet可以以原子方式将一个整数自增或自减并返回该值，如下： 12public static AtomicLong nextNum = new AtomicLong();long id = nextNum.incrementAndGet(); 还有compareAndSet,updateAndGet,accumulateAndGet方法，查看API文档AtomicInteger等类也同样有，查看API文档，略 线程局部变量有时要避免共享变量，使用ThreadLocal辅助类为各个线程提供各自的实例 e.g. SimpleDateFormat类不是线程安全的，假设有一个静态变量public static final SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);如果两个线程都执行：String dateStamp = dateFormat.format(new Date());可能会破坏dateFormat的内部数据结构，而使用同步开销很大，这时可以为每个线程构造一个实例public static final ThreadLoacl&lt;SimpleDateFormat&gt; dateFormat = ThreadLocal.withInitial(() -&gt; new SimpleDateFormat(&quot;yyyy-MM-dd&quot;));访问具体格式化方法String dateStamp = dateFormat.get().format(new Date()); 锁测试与超时线程调用lock方法来获得另一个线程持有的锁时，会发生阻塞，应该更谨慎的申请锁。tryLock方法试图申请一个锁，在成功后返回true 1234567if (myLock.tryLock()) &#123; // own the lock try &#123; ... &#125; finally &#123; myLock.unlock(); &#125;&#125;else // do something without the lock tryLock可以有超时参数myLock.tryLock(100, TimeUtil.MILLISECONDS); 读写锁Java除了有ReentrantLock类，还有ReentrantReadWriteLock类 构造对象：private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();抽取读锁和写锁：private Lock readLock = rwl.readLock();private Lock writeLock = rwl.writeLock();加锁：readLock.lock(); readLock.unlock(); 弃用stop和suspendstop会终止所有未结束的方法，释放锁，会导致对象处于不一致的状态suspend容易导致死锁，当线程A suspend线程B，线程B持有的锁不会释放，而线程A又试图获得该锁，就会导致死锁]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>同步</tag>
        <tag>锁与条件</tag>
        <tag>Synchronized</tag>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL基本语句]]></title>
    <url>%2F2019%2F07%2F17%2FMySQL%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[MySQL基本语句数据库相关创建数据库1CREATE DATABASE 数据库名; 删除数据库1DROP DATABASE 数据库名; 选择数据库1USE 数据库名; 数据类型数值类型 时间和日期类型 字符串类型 表相关创建表通用语法 1CREATE TABLE table_name (column_name column_type); 例子 1234567CREATE TABLE IF NOT EXISTS `runoob_tbl`( `runoob_id` INT UNSIGNED AUTO_INCREMENT, `runoob_title` VARCHAR(100) NOT NULL, `runoob_author` VARCHAR(40) NOT NULL, `submission_date` DATE, PRIMARY KEY ( `runoob_id` ))ENGINE=InnoDB DEFAULT CHARSET=utf8; AUTO_INCREMENT自增，用于主键，PAIMARY KEY定义主键，多列主键用逗号分隔 删除表1DROP TABLE table_name; ALTER删除表字段1ALTER TABLE testalter_tbl DROP i; 添加字段1ALTER TABLE testalter_tbl ADD i INT; 修改字段修改字段类型及名称, 可以在ALTER命令中使用 MODIFY 或 CHANGE 子句 12ALTER TABLE testalter_tbl MODIFY c CHAR(10);ALTER TABLE testalter_tbl CHANGE i j BIGINT; 修改字段默认值1ALTER TABLE testalter_tbl ALTER i SET DEFAULT 1000; 修改表名1ALTER TABLE testalter_tbl RENAME TO alter_tbl; 数据操作相关插入数据123INSERT INTO table_name ( field1, field2,...fieldN ) VALUES ( value1, value2,...valueN ); 查询数据通用语法 1234SELECT column_name,column_nameFROM table_name[WHERE Clause][LIMIT N][ OFFSET M] LIMIT设定返回的记录数，OFFSET指定查询的数据偏移量，默认为0 LIMIT可以LIMIT m,n，意思是从第m+1条开始，取n条数据 可以在字段之前添加DINSTINCT去重SELECT DISTINCT field FROM table WHERE condition WHEREWHERE常见的用法如下： 123SELECT * FROM table WHERE field = (SELECT field FROM table WHERE condition);SELECT * FROM table WHERE EXISTS(SELECT * FROM table WHERE condition); LIKE子句LIKE子句用于模糊搜索，%表示模糊项，如SELECT * FROM runoob_tbl WHERE runoob_author LIKE &#39;%COM&#39;;会返回所有runoob_author以COM结尾的数据 通用语法 123SELECT field1, field2,...fieldN FROM table_nameWHERE field1 LIKE condition1 [AND [OR]] filed2 = 'somevalue' UNIONUNION用于连接两个以上的SELECT语句的结果组合到一个结果集中，多个SELECT语句会删除重复的数据 通用语法 1234567SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions]UNION [ALL | DISTINCT]SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions]; DISTINCT表示删除结果集中重复的数据，ALL表示包含重复数据 对于联合查询的多张表的列数必须保持一致 推荐：对于每一列的字段类型也要保持一致 对于多个select语句的查询，列名可能不同，要以第一个select语句的列名为准 如果多个select语句查询到相同的记录，就会把重复的记录合并为一条记录 如果不想将相同的查询结果去重，直接在union后加all，当然，这种效率会高一点 排序ORDER BY可以对结果排序 通用语法 12SELECT field1, field2,...fieldN FROM table_name1, table_name2...ORDER BY field1 [ASC [DESC][默认 ASC]], [field2...] [ASC [DESC][默认 ASC]] 默认情况是升序 分组GROUP BY可以对结果集分组，分组列上可以使用COUNT，SUM，AVG等函数 通用语法 1234SELECT column_name, function(column_name)FROM table_nameWHERE column_name operator valueGROUP BY column_name; WHERE语句在GROUP BY语句之前；SQL会在分组之前计算WHERE语句。HAVING语句在GROUP BY语句之后；SQL会在分组之后计算HAVING语句。 连接 INNER JOIN：内连接，获取两个表中字段匹配关系的记录 LEFT JOIN：左连接，获取左表所有记录，即使右表没有对应匹配的记录 RIGHT JOIN：右连接，与上面相反 通用语法 1SELECT a.field, b.field FROM tablea a INNER JOIN tableb b ON [条件]; 正则表达式MySQL的SQL语句支持正则表达式 1SELECT field FROM table WHERE field REGEXP 'regex expression' 更新数据通用语法 12UPDATE table_name SET field1=new-value1, field2=new-value2[WHERE Clause] 删除数据通用语法 1DELETE FROM table_name [WHERE Clause] MySQL函数Runoob中MySQL的函数 视图CREATE VIEW view_name[{column_list}] AS select_statementREPLACE VIEW view_name[{column_list}] AS select_statement e.g. 创建视图 CREATE VIEW test_view_1 AS SELECT name FROM user查询视图 SELECT * FROM test_view_1创建视图并指定视图字段名 CREATE VIEW test_view_2(username) AS SELECT name FROM user]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL基本语句</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类文件结构]]></title>
    <url>%2F2019%2F07%2F17%2F%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[类文件结构将我们编写的程序编译成二进制本地机器码已不再是唯一选择，越来越多程序语言选择了与操作系统和机器指令集无关的，平台中立的格式作为程序编译后的存储格式，各种不同平台的虚拟机与所有平台都统一使用的程序存储格式——字节码，是构成平台无关性的基石。Java虚拟机不和包括Java在内的任何语言绑定，它只与”Class”文件这种特定的二进制文件所关联，Class文件中包含了Java虚拟机指令集和符号表以及若干其他辅助信息，Class文件有许多强制性语法和结构化约束 Class类文件的结构Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何的分隔符，使得整个Class文件存储的内容几乎都是程序运行的必要数据，没有空隙存在，当遇到需要占用8位字节以上空间的数据项时，就会按照高位在前的方式分割成若干个8位字节进行存储 Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表 无符号数属于基本的数据类型，以u1,u2,u4,u8来分别代表1个字节，2个字节，4个字节和8个字节的无符号数，无符号数可以用来描述数字，索引引用，数量值或者按照UTF-8编码构成字符串值 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，整个Class文件本质上就是一张表 魔数域Class文件的版本每个Class文件的头4个字节称为魔数，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件，很多文件存储标准都有用魔数，比如gif或者jpeg，使用魔数而不是扩展名是出于安全方面考虑，文件扩展名可以随意改动。Class文件的魔数值为0xCAFEBABE 紧接着魔数的4个字节存储的Class文件的版本号，第5第6个字节是次版本号，第7第8个字节是主版本号，Java的版本号是从45开始的，JDK1.1之后每个JDK大版本发布主版本号往上加1，高版本JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件 常量池紧接着主次版本号的是常量池入口，常量池可以理解为Class文件中的资源仓库，常量池入口放置一个u2类型的数据代表常量池容量计数值（constant_pool_count），这个容量计数从1开始，e.g.常量池容量为十六进制0x0016（十进制22），代表常量池有21项常量，索引值范围是1——21，索引值置为0代表”不引用任何一个常量池项目” 常量池主要存放两大类常量：字面量和符号引用，字面量指文本字符串，final常量等，对于类内定义的常量，一般在常量池有值，然后字段表对应字段有个属性ConstantValue指向该常量池的常量符号引用属于编译原理的概念，包括 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符 Java代码在Javac编译的时候，不会有链接这一步，而是在虚拟机加载Class文件的时候进行动态链接，也就是说，Class文件中不会保存各个方法，字段的最终内存布局信息，当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析，翻译到具体的内存地址中 常量池中每一项常量都是一个表，常见的如下 这14种表都有一个共同特点：表开始第一位是一个u1类型的tag，代表这个常量属于哪种常量类型 看CONSTANT_Class_info，它有一个tag，一个index，index指向常量池中一个CONSTANT_Utf8_info类型的常量，代表这个类的全限定名 CONSTANT_Utf8_info，有一个tag，一个u2类型length，length个u1类型的bytes，length值就是这个UTF-8编码的字符串长度是多少字节，后面使用UTF-8缩略编码表示的字符串 访问标志在常量池结束后，紧接着的两个字节代表访问标志（access_flags），用于识别一些类或者接口层次的访问信息，包括这个Class是类还是接口，是否为public类型，是否为abstract类型，如果是类，是否被声明为final等 e.g.TestClass是一个普通Java类，不是接口，枚举或者注解，被public修饰但没有abstract和final，所以它的ACC_PUBLIC，ACC_SUPER为真，ACC_FINAL，ACC_INTERFACE，ACC_ABSTRACT，ACC_SYNTHETIC，ACC_ANNOTATION，ACC_ENUM这六个标志为假，access_flags的值为0x0001|0x0020=0x0021 类索引，父类索引与接口索引集合类索引（this_class）和父类索引（super_class）都是u2类型的数据（我感觉可以理解为u2类型的地址），接口索引集合（interfaces）是一组u2类型的数据集合，类索引用于确定这个类的全限定名，父类，接口索引集合同样。类索引，父类索引，接口索引集合都按顺序排列在访问标志之后，类索引和父类索引分别用一个u2类型的索引值表示，它们各自指向一个类型为CONSTANT_Class_info的类描述符，通过CONSTANT_Class_info类型的常量中的索引值就可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串 对于接口索引集合，入口第一项为u2类型的接口计数器，表示接口索引表的容量 字段表集合方法表和字段表之前都会有一个u2类型的计数器保存方法和字段的个数 字段表（field_info）用于描述接口或者类中声明的变量，字段包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量 字段修饰符放在access_flags项目中，它与类的access_flags项目非常类似，都是一个u2数据类型，其中可以设置的标志位和含义见下图 name_index和descriptor_index是对常量池的引用，分别代表字段的简单名称以及字段和方法的描述符（简单名称指没有类型和参数修饰的方法或者字段名称）描述符用来描述字段的数据类型，方法的参数列表和返回值，基本数据类型以及代表无返回值的void类型用一个大写字符表示，对象类型用字符L加对象的全限定名表示 对于数组类型，每一维度用一个前置的”[“字符描述，如一个java.lang.String[][]的数组，，被记录为”[[Ljava/lang/String”，整形数组被记录为”[I”用描述符描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号”()”之内，如方法void inc()的描述符为”()V”，java.lang.String toString()描述符为”()Ljava/lang/String;”，方法int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex)描述符为”([CII[CIII)I” descriptor_index之后跟随一个属性表集合用于存储一些额外的信息（如final static int m=123，可能存在名为ConstantValue的属性，指向常量123） 字段表集合不会列出从超类或者父接口继承而来的字段，但有可能列出原本Java代码之中不存在的字段Java语言中，字段是无法重载的，两个字段的数据类型，修饰符不管是否相同，都必须使用不一样的名称，但对于字节码而言，只要描述符不一致，重名也是合法的 方法表集合Class文件存储格式中对方法的描述与对字段的描述几乎完全一致，依次包括访问标志（access_flags），名称索引（name_index），描述符索引（descriptor_index），属性表集合（attributes）几项，与字段表的区别就是访问标志和属性表集合的可选项 主要是没有了只能访问字段的volatile和transient关键字，增加了只能访问方法的synchronized，native，strictfp和abstract关键字 方法里的代码，经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为”Code”的属性里 属性表集合Class文件，字段表，方法表都可以携带自己的属性表集合 虚拟机能够识别的属性如下： 对于每个属性，它的名称需要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，属性值结构则完全自定义，只需要通过一个u4的长度属性去说明属性值所占用的位数即可 Code属性 attribute_name_index指向CONSTANT_Utf8_info，值为”Code”，attribute_length指示属性值长度，max_stack操作数栈深的最大值，虚拟机根据这个值分配栈帧，max_locals代表局部变量表所需存储空间，code_length和code保存编译后的字节码指令，exception_table_length和exception_table是显式异常处理表集合，如下： 当字节码在第start_pc行到end_pc行之间出现类型为catch_type或者其子类的异常时（catch_type指向CONSTANT_Class_info），则转到第handler_pc行继续处理，catch_type为0时，任意异常都转到handler_pc 编译器使用异常表而不是简单跳转命令来实现Java异常和finally处理机制 Exceptions属性它的作用是列举出方法中可能抛出的受查异常，也就是方法描述时在throws关键字后列举的异常 ConstantValue属性通知虚拟机自动为静态变量赋值，只有被static关键字修饰的变量才可以使用这项属性。非static类型的变量的赋值在实例构造器&lt;init&gt;方法中进行，而类变量可以在类构造器&lt;clinit&gt;方法中或者使用ConstantValue属性。Sun Javac编译器中，如果同时使用final static修饰一个变量，并且这个变量类型是基本类型或者String类型，就生成ConstantValue属性初始化，否则其他静态变量就选择&lt;clinit&gt;初始化 字节码指令Java虚拟机指令由一个字节长度的操作码以及跟随其后的0到多个操作数构成。Java虚拟机采用面向操作数栈而不是寄存器的架构，所以大多数指令都不包含操作数 Java字节码指令限制操作码1个字节，放弃操作数长度对齐 大部分与数据类型相关的字节码指令，操作码助记符都有特殊字符表明，i代表int类型的数据操作，l代表long，s代表short，b代表byte，c代表char，f代表float，d代表double，a代表reference 大多数指令没有支持byte，char和short的，boolean没有任何指令支持，这是因为编译器编译或运行期间将byte和short类型的数据带符号扩展为int，boolean和char零位扩展为int 加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输 将一个局部变量加载到操作栈：iload,iload_&lt;n&gt;,lload,lload_&lt;n&gt;,fload,fload_&lt;n&gt;,dload,dload_&lt;n&gt;,aload,aload_&lt;n&gt; 将一个数值从操作数栈存储到局部变量表：istore,istore_&lt;n&gt;, … 将一个常量加载到操作数栈：bipush,sipush,ldc … 扩充局部变量表的访问索引的指令：wide iload_&lt;n&gt;代表iload_1,iload_2等 运算指令 加法：iadd,ladd,fadd,dadd 减法：isub,lsub… 乘法：imul,lmul… 除法：idiv,ldiv… 求余：irem,lrem… 取反：ineg,lneg… 位移：ishl,ishr,iushr,lshl,lshr,lushr 按位或：ior,lor 按位与：iand,land 按位异或：ixor,lxor 局部变量自增：iinc 比较指令：dcmpg,dcmpl,fcmpg,fcmpl,lcmp 类型转换指令i2b,i2c,i2s等 对象创建与访问指令 创建类实例：new 创建数组指令：newarray,anewarray,multianewarray 访问类字段和实例字段：getfield,putfield,getstatic,putstatic 把一个数组元素加载到操作数栈：baload,caload,saload,iaload,laload,faload,daload,aaload 取数组长度：arraylength 检查类实例类型：instanceof，checkcast 操作数栈管理指令 操作数栈栈顶1个或2个元素出栈：pop,pop2 复制栈顶一个或两个数值并将复制值重新压入栈顶：dup,dup2,dup_x1,dup2_x1,dup_x2,dup2_x2 栈最顶两个元素互换：swap 控制转移指令 条件分支：ifeq,iflt,ifle,ifne,ifgt,ifge… 复合条件分支：tableswitch,lookupswitch 无条件分支：goto,goto_w,jsr,jsr_w,ret 方法调用和返回指令 invokevirtual调用对象实例方法 invokeinterface调用接口方法 invokeespecial调用特殊处理的实例方法如实例初始化方法，私有方法和父类方法 invokestatic invokedynamic：运行时动态解析调用点限定符所引用的方法 异常处理指令athrow显示抛出异常，处理异常（catch）不由字节码实现，而是异常表 同步指令monitorenter和monitorexit对synchronized关键字的支持]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>类文件结构</tag>
        <tag>字节码指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合]]></title>
    <url>%2F2019%2F07%2F16%2FJava%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[Java集合Java集合框架Java集合类库将接口与实现分离，比如队列，队列可以有链式的和顺序的，只要设计好对应接口，具体实现继承该接口即可使用的时候利用多态Queue&lt;XXX&gt; xxQueue = new LinkedListQueue&lt;&gt;(); Java类库会有一组名字以Abstract开头的类，例如AbstractQueue，这些类是为类库实现者设计的，扩展AbstractQueue会比实现Queue接口所有方法要轻松 Collection接口集合类的基本接口是Collection，Collection接口如下： 123456789101112131415161718public interface Collection&lt;E&gt; &#123; boolean add(E element); boolean addAll(Collection&lt;? extends E&gt; c); void clear(); boolean contains(Object o); boolean containsAll(Collection&lt;?&gt; c); boolean equals(Object o); int hashCode(); boolean isEmpty(); Iterator&lt;E&gt; iterator(); boolean remove(Object o); boolean removeAll(Collection&lt;?&gt; c); boolean retainAll(Collection&lt;?&gt; c); int size(); Object[] toArray(); &lt;T&gt; T[] toArray(T[] a); // default method&#125; 迭代器123456public interface Iterator&lt;E&gt; &#123; E next(); boolean hasNext(); void remove(); default void forEachRemaining(Consumer&lt;? super E&gt; action);&#125; 注意迭代器的游标，迭代器的游标是介于两个元素之间，每次next()就穿过一个元素，并返回越过的元素的引用，每次remove()都会删除迭代器穿过的那个元素，不能连续多次remove() 迭代器不能与list的add或remove方法同时使用，否则会报ConcurrentModificationException 1234567891011public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(0); list.add(1); list.add(2); Iterator&lt;Integer&gt; iterator = list.iterator(); System.out.println(iterator.next()); // iterator = null; // 如果不注释这个，会报错 list.add(0); iterator.next();&#125; 从源码上讲原因 基本上ArrayList采用size属性来维护自已的状态，而Iterator采用cursor来来维护自已的状态当size出现变化时，cursor并不一定能够得到同步，除非这种变化是Iterator主动导致的当Iterator.remove方法导致ArrayList列表发生变化时，他会更新cursor来同步这一变化。但其他方式导致的ArrayList变化，Iterator是无法感知的，Iterator只会经常做checkForComodification检查，以防有变。如果有变，则以异常抛出，所以就出现了上面的异常 Collection继承了Iterable接口，因此标准类库中任何集合都可以使用”for each”循环，在Java SE 8中甚至不用写循环，可以调用forEachRemaining方法并提供一个lambda表达式，将对迭代器的每一个元素调用这个lambda表达式直到没有元素为止 iterator.forEachRemaining(element -&gt; do something with element); e.g. 12345678public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(0); list.add(1); list.add(2); Iterator&lt;Integer&gt; iterator = list.iterator(); iterator.forEachRemaining(element -&gt; System.out.println(element));&#125; AbstractCollection抽象类AbstractCollection除了size()和iterator()是抽象的，其他方法都有默认实现，一个具体的集合类可以扩展AbstractCollection，然后提供iterator()和size()方法即可 集合框架中的接口概述Java集合框架为不同类型的集合定义了大量接口，如下图所示： 集合有两个基本接口：Collection和Map，对于Collection的添加元素，使用boolean add(E element);，而对于Map的添加元素，则要使用V put(K key, V value);，从集合获取元素，可以使用迭代器，而从Map读取值则要用get方法V get(K key); Set接口等同于Collection接口，但是其方法更严谨定义，set的add方法不允许增加重复的元素，equals方法只要两个集元素相同就相等，不要求有同样的顺序，hashCode方法定义保证包含相同元素的两个集会得到相同的散列码 List是有序集合，可以使用迭代器顺序访问或整数索引随机访问，List接口定义了随机访问的方法如下 1234void add(int index, E element);void remove(int index);E get(int index);E set(int index, E element); ListIteratorListIterator主要用于可以高效在序列中间插入元素的对象（如链表）ListIterator是Iterator的一个子接口，它定义一个方法用于在迭代器的位置前面增加一个元素，具体其他方法可以见API文档：void add(E element);这个设计不太好，数组支持的有序集合可以快速随机访问，因此适合使用List方法并提供一个整数索引来访问，而链表随机访问很慢，更适合迭代器遍历 RandomAccess为了避免对链表随机访问，Java引入一个RandomAccess接口，它不包含任何方法，可以用来测试特定的集合是否支持高效的随机访问 123456if (c instanceof RandomAccess) &#123; use random access algorithm&#125;else &#123; use sequential access algorithm&#125; 具体的集合下面是Java类库中具体的集合，Map结尾的实现了Map接口，其他实现了Collection接口 链表链表是一种逻辑上顺序，物理存储单元上非连续、非顺序的存储结构，由一系列结点组成，链表插入时间复杂度O(1)，但查找和访问需要O(n)的时间复杂度，不支持随机存取 链表的迭代Java所有链表都是双向的，在集合中，链表的具体实现是LinkedList，链表的遍历可以通过迭代器实现，对于在链表中间插入或删除结点，可以通过概述中提到的Iterator的子接口ListIterator实现，LinkedList有一个listIterator(int index)方法，用于返回其ListIterator对象，ListIterator的API如下 add操作是在游标与越过的元素之间插入，并且插入后游标仍在新插入的元素之后，add只依赖迭代器的位置，可以连续多次add操作remove操作是删除游标越过的元素，不可以连续多次remove，它取决于迭代器的状态set操作是用新元素取代游标越过的元素 1234567891011121314List&lt;Integer&gt; list = new LinkedList&lt;&gt;();list.add(0);list.add(1);list.add(2);ListIterator&lt;Integer&gt; listIterator = list.listIterator(); // | 0 1 2listIterator.next(); // 0 | 1 2listIterator.add(3); // 0 3 | 1 2listIterator.add(4); // 0 3 4 | 1 2listIterator.next(); // 0 3 4 1 | 2listIterator.remove(); // 0 3 4 | 2listIterator.previous(); // 0 3 | 4 2listIterator.remove(); // 0 3 | 2Iterator&lt;Integer&gt; iterator = list.iterator();iterator.forEachRemaining(element -&gt; System.out.print(element + " ")); 列表迭代器还有nextIndex方法和previousIndex方法，它们分别返回下一次调用next和previous时的返回元素的索引，这两个方法是高效的，因为迭代器维护当前位置的计数值，list.listIterator(int n)可以接收一个整型参数n，它返回一个迭代器，指向索引为n的元素的前面的位置 当迭代器发现它的集合被另一个迭代器修改，或者是被该集合自身修改，就会抛出ConcurrentModificationException异常对迭代器的使用应该遵循下面原则：可以根据需要给容器附加许多迭代器，但是这些迭代器只能读取列表。另外，再单独附加一个既能读又能写的迭代器 链表对象Java类库LinkedList的方法除了add,remove,size,clear等链表方法，也支持双端队列的方法如peek,poll,offer,push,pop等，使用这些方法的时候，声明类型必须是LinkedList（或者强制类型转换） Java类库的LinkedList也有get等方法，但是这些方法效率都不高，不符合链表的定义，不建议使用，对链表做如下操作是极其低效的 123for (int i = 0; i &lt; list.size(); i++) &#123; do something with list.get(i);&#125; 建议避免使用以整数索引表示链表中位置的所有方法，如果需要随机访问，最好使用数组或ArrayList，而不要使用链表，使用链表最好使用ListIterator对其操作 数组列表ArrayList内部使用数组实现，支持高效的随机存取 散列集散列集是没有顺序的，支持快速查找元素的数据结构。散列表为每个对象计算一个整数，称为散列码，快速查找元素就是通过散列码实现的 在Java中，散列表用链表数组实现。数组每一项被称为桶(bucket)，它实际是一个链表，如下： 要查找某个元素，就计算它的散列码，然后与桶总数取余，得到的结果就是保存这个元素的桶的索引。如果桶被占满，就是散列冲突，这时就需要用新对象与桶中所有对象比较，查看这个对象是否已经存在 Java集合类库提供了HashSet类，实现基于散列表的集合，使用add方法添加元素，contains快速查看某个元素已经出现在集合中，它只在某个桶中查找元素，而不必查看集合中所有元素 可以初始化其桶数和装填因子，通常桶数为预计元素个数的75%到150%，桶数最好是素数，以防键的集聚。标准类库使用的桶数是2的幂，默认是16；当散列表元素过多，散列表需要再散列，即创建一个桶数更多的表，并将所有元素插入到这个新表。装填因子是0.0 ~ 1.0的浮点数，默认是0.75，指示当表中超过75%的位置都已经填入元素，这个表就会用双倍桶数自动进行再散列，HashSet是通过HashMap实现的，键是HashSet的元素，值是new一个Object对象，contains方法是调用HashMap的containsKey方法，HashSet的构造方法如下，可以指定桶数和装填因子 API文档 树集TreeSet是有序集合，可以以任意顺序将元素插入集合中，对集合遍历时每个值都会自动按照排序后顺序呈现，TreeSet底层原理是红黑树，插入元素比散列表要慢。如果书中包含n个元素，查找新元素的正确位置平均需要lgn次比较 树集比HashSet多了有关排序的方法，如ceiling(返回此set中大于或等于给定元素的最小元素，如果没有这样的元素，则返回null)，first(返回此set中当前的第一个（最低）元素)，floor，last，pollFirst等 树集的元素必须实现Comparator接口，或者构造集时必须提供一个Comparator对象 队列与双端队列Vector所有方法都是同步的，这是与ArrayList主要的区别 队列的接口是Queue 双端队列接口是Deque 与队列的比较 与栈的比较 具体实现的双端队列是ArrayDeque和LinkedList，它们都提供了双端队列，因此也可以把他们当做栈使用 优先级队列优先级队列的元素可以按照任意顺序插入，但总是按照排序的顺序进行检索，无论何时调用remove方法，都会获得当前优先级队列中最小的元素，其实他实现的是堆，可以为其提供Comparator（需要实现public int compare(String o1, String o2)方法） 映射映射用来存放键/值对，Java类库提供了HashMap和TreeMap两种实现，它们都实现了Map接口 散列映射对键进行散列，树映射用键的整体顺序对元素进行排序，并将其组织成搜索树。散列或比较函数只能作用于键。与键关联的值不能进行散列或比较 基本映射操作如果映射没有与给定键对应的值，get方法会返回null，如果想在没有对应值得时候返回默认值，可以使用getOrDefault方法 键是唯一的，对同一键调用两次put方法，第二次的会覆盖第一次的值 迭代处理映射的键值，可以使用forEach方法map.forEach((k, v) -&gt; System.out.println(k + &quot;: &quot; + v)); Map接口 更新映射项更新映射项的一个难点是键第一次出现的时候，如下：map.put(word, map.get(word) + 1);当map不存在关键字word的时候，即第一次插入的时候，get方法就会返回null，从而报空指针错误 可以使用putIfAbsent方法，当键原先存在才会放入一个值12map.putIfAbsent(word, 0);map.put(word, map.get(word) + 1); 使用merge方法会更好 map.merge(word, 1, Integet::sum); 如果关键字word原先不存在，它会把word与1关联，否则使用sum方法组合原值和1 映射视图Map不继承自Collection接口，即在集合框架中，映射不是一个集合（虽然在其他数据结构中映射是一个键/值对集合），可以得到映射的视图，视图是实现了Collection接口或某个子接口的对象 有3种视图，键集，值集合（不是一个集）以及键/值对集，下面方法会返回这三个视图 123Set&lt;V&gt; keySet();Collection&lt;V&gt; values();Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(); keySet不是HashSet或者TreeSet，而是实现了Set接口(AbstractSet)的另外对象 entrySetentrySet()的元素是Map.Entry类，该类API如下 迭代Map对map的迭代，可以使用entrySet，也可以使用forEach，如下： 1234567for (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123; // do something with entry.getKey() + entry.getValue();&#125;map.forEach((k, v) -&gt; &#123; // do something with k, v&#125;); 弱散列映射WeakHashMap中当对键的唯一引用来自散列条目时，它就会与垃圾回收器协同工作一起删除键/值对。它使用弱引用保存键 链接散列集与映射LinkedHashSet与LinkedHashMap类记住插入元素项的顺序，内部是由双向链表实现 枚举集与映射EnumSet是枚举类型元素集的高效实现，内部用位序列实现，它没有公共构造器，可以使用静态工厂方法构造集 12345enum Weekday &#123; MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAT, SUNDAY &#125;;EnumSet&lt;Weekday&gt; always = EnumSet.allOf(Weekday.class);EnumSet&lt;Weekday&gt; never = EnumSet.noneOf(Weekday.class);EnumSet&lt;Weekday&gt; workday = EnumSet.range(Weekday.MONDAY, Weekday.FRIDAY);EnumSet&lt;Weekday&gt; mwf = EnumSet.of(Weekday.MONDAY, Weekday.WEDNESDAY, Weekday.FRIDAY); 可以使用Set接口方法来修改EnumSet EnumMap键类型为枚举类型，可以直接高效用一个值数组实现，使用时需要在构造器指定键类型EnumMap&lt;Weekday, Employee&gt; personInCharge = new EnumMap&lt;&gt;(Weekday.class); 标识散列映射IdentityHashMap键的散列值不是用HashCode函数计算，而是用System.identityHashCode方法计算，这是Object.hashCode方法根据对象内存地址计算散列码的方式，对两个对象进行比较，IdentityHashMap类使用==，而不是用equals，即不同的键对象，即使内容相同，也是不同的对象 视图与包装器轻量级集合包装器Arrays类的静态方法asList将返回一个包装了普通Java数组的List包装器。这个方法可以将数组传递给一个期望得到列表或集合参数的方法 123String[] cards = new String[100];...List&lt;String&gt; cardList = Arrays.asList(cards); 返回的对象不是ArrayList，它是一个视图对象，带有访问底层数组的get和set方法。改变数组大小的所有方法（如迭代器相关的add和remove方法）都会抛出不支持操作异常，asList不支持基本类型到包装类型的转换 asList方法可以接收可变数目参数List&lt;String&gt; names = Arrays.asList(&quot;Amy&quot;, &quot;Bob&quot;, &quot;Carl&quot;); 子范围可以为很多集合建立子范围视图，调用subList方法List group2 = list1.subList(10, 20); // 10 ~ 19子范围可以任意操作，操作都会自动反应到整个列表，例如可以删除整个子范围group2.clear(); 对于有序集和映射，可以使用排序顺序而不是元素位置建立子范围SortedSet有三个方法 123SortedSet&lt;E&gt; subSet(E from, E to);SortedSet&lt;E&gt; headSet(K to);SortedSet&lt;E&gt; tailSet(E from); SortedMap同理 不可修改的视图可以使用如下方法获得不可修改视图 12345678Collections.unmodifiableCollectionCollections.unmodifiableListCollections.unmodifiableSetCollections.unmodifiableSortedSetCollections.unmodifiableNavigableSetCollections.unmodifiableMapCollections.unmodifiableSortedMapCollections.unmodifiableNavigableMap 同步视图JAVA集合类库也提供了视图机制确保常规集合的线程安全，而不是实现线程安全的集合类，如Collections类的静态synchronizedMap方法可以将任何一个映射表转换成具有相同同步访问方法的Map 算法排序与混排Collections类的sort方法可以对实现了List接口的集合进行排序，该方法假定列表元素实现了Comparable接口 如果想采用其他方式对列表进行排序，可以使用List接口的sort方法并传入Comparator对象 e.g.对工资进行排序staff.sort(Comparator.comparingDouble(Employee::getSalary)); 降序对列表排序staff.sort(Comparator.reverseOrder());staff.sort(Comparator.comparingDouble(Employee::getSalary).reversed()); 混排的话，调用Collections的shuffle方法，传入list对象即可 二分查找Collections.binarySearch，第一个参数为列表，第二个参数为待查找元素，第三个可选参数Comparator。返回负数表示找不到，但可以利用返回值计算应该将element插入到集合哪个位置，插入位置是-i-1，i是binarySearch的返回结果，if(i&lt;0) c.add(-i-1,element); 简单算法常见简单算法如下，他们都是Collections类提供的静态方法，具体参数查看API文档 12345678910111213minmaxcopy // 第一个参数是to，第二个是fromfill // 填充列表所有值为某个值addAllreplaceAllindexOfSubListlastIndexOfSubListswapreverserotate // 第二个参数为int d，将索引i的条目移到(i+d)%l.size()frequency // 返回与对象o相同的元素个数disjoint // 如果两个列表没有共同元素返回true 数组与集合的转换数组-&gt;集合123String[] values = ...;HashSet&lt;String&gt; staff = new HashSet&lt;&gt;(Arrays.asList(values));` 集合-&gt;数组Object[] values = staff.toArray();String[] values = staff.toArray(new String[0]); 第二个方法可以提供一个所需类型的长度为0的数组，创建所需类型的数组类型 遗留的集合Hashtable它与Hashmap作用一样，但它是同步的 枚举Enumeration接口对元素序列遍历，有hasMoreElements方法和nextElement方法，它与Iterator接口类似 栈栈Stack类扩展为Vector类 位集BitSet类存放一个位序列，它实际上不是一个集，称为位向量或者位数组更合适，位集将位包装在字节里，使用位集要比使用Boolean对象的ArrayList要更高效]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Collection</tag>
        <tag>Collections</tag>
        <tag>遗留集合</tag>
        <tag>LinkedList</tag>
        <tag>迭代器</tag>
        <tag>Map</tag>
        <tag>List</tag>
        <tag>Set</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络01-体系结构&物理层]]></title>
    <url>%2F2019%2F07%2F15%2F%E7%BD%91%E7%BB%9C1-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%26%E7%89%A9%E7%90%86%E5%B1%82%2F</url>
    <content type="text"><![CDATA[计算机网络01-体系结构&amp;物理层计算机网络体系结构 计算机网络概述计算机网络的概念，组成与功能；计算机网络的分类计算机网络的标准化工作及相关组织 计算机网络体系结构与参考模型计算机网络分层结构；计算机网络协议，接口，服务等概念ISO/OSI参考模型和TCP/IP模型 概述概念计算机网络是一个将分散的，具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统 组成1）由组成部分看，网络由硬件，软件，协议3部分组成，硬件由主机（端系统），通信链路（双绞线，光纤），交换设备（路由器，交换机）和通信处理机（网卡）等组成。软件主要包括各种实现资源共享的软件和工具软件 2）由工作方式看，网络分为边缘部分和核心部分，边缘部分是所有连接到因特网上的主机组成，核心是大量网络和连接网络的路由器组成 3）由功能组成看，网络由通信子网和资源子网组成，通信子网由各种传输介质，通信设备和相应的网络介质组成，资源子网是实现资源共享功能的设备及其软件的集合 功能 数据通信（最基本最重要） 资源共享 分布式处理 提高可靠性 负载均衡 分类按分布范围分类 广域网(WAN)：几十千米到几千千米 城域网(MAN)：5 ~ 50km 局域网(LAN)：几十米到几千米，局域网使用广播技术，广域网使用交换技术 个人区域网(PAN)：约10m 按传播技术分类 广播式网络：一台计算机共享通信信道发送报文分组，所有其他计算机都会收听到，通过检查目的地址确定是否接收该分组，广播式网络不需要网络层，不存在路由选择问题，LAN基本属于广播式 点对点网络：每条物理线路连接一对计算机，可以有中间结点接收存储和转发，WAN基本属于点对点 按拓扑网络分类 星形网络：每个终端单独线路连接中央设备 总线形网络 环形网络 网状型网络：多用于广域网 按使用者分类 公用网 专用网 按交换技术分类 电路交换网络：源结点和目的结点建立专用通路 报文交换网络：整个报文一次发送，又称存储-转发网络，整个报文先传送到相邻结点，通过查找转发表转发到下一个结点 分组交换网络：将数据分成较短的固定长度的数据块，加上目的地址，源地址等辅助信息，存储-转发方式传输，当今主流 按传输介质分类 有线网络 无线网络 标准化工作及相关组织因特网所有标准都以RFC（Request For Comments，请求评论）形式在因特网发布，RFC要上升为因特网正式标准要经过4个阶段 因特网草案：这个阶段还不是RFC文档 建议标准：正式成为RFC文档 草案标准 因特网标准 负责制定，实施相关网络标准的标准化组织主要有如下几个 ISO（国际标准化组织）：OSI参考模型等 ITU（国际电信联盟） IEEE（国际电气电子工程师协会）：802标准等 计算机网络的性能标准 带宽：网络的通信线路所能传送数据的能力，比特/秒 时延：数据(分组或报文)从网络一端传送到另一端所需时间，分为发送时延，传播时延，处理时延和排队时延 发送时延：结点将分组所有比特推向链路所需时间，即发送分组第一个比特开始，到该分组最后一个比特发送完毕所需时间，发送时延=分组长度/信道宽度 传播时延：电磁波在信道传播一定距离所需时间，即一个比特从链路一端到另一端所需时间，传播时延=信道长度/电磁波在信道上传播速率 处理时延：数据在交换结点为存储转发而进行一些必要的处理所花费时间 排队时延：分组在进入路由器后先在队列中排队等待处理，确定转发端口后还要在输出队列中排队等待转发 时延带宽积：发送端连续发送数据且发送的第一个比特即将到达终点，发送端已经发出的比特数，时延带宽积=传播时延*信道宽度 往返时延：从发送端发送数据到发送端接收到接收端确认的时延 吞吐量：单位时间内通过某个网络的数据量 速率：连接到计算机网络上的主机在数字信道上传送数据的速率 计算机网络体系结构与参考模型计算机网络分层结构计算机网络体系结构的各个层次中，每个报文都分为两部分：一是数据部分，即SDU，二是控制信息部分，即PCI，它们共同组成PDU SDU服务数据单元：为完成用户所要求的功能而应传送的数据，第n层服务的服务数据单元记为n-SDU PCI协议控制信息：控制协议操作的信息，n-PCI PDU协议数据单元：对等层次之间传送的数据单位成为该层的PDU，n-PDU，物理层的PDU成为比特，链路层的PDU称为帧，网络层的PDU称为分组，传输层的PDU称为报文 各层传输数据时，把从n+1层收到的PDU作为第n层的SDU，加上第n层的PCI，就变成了第n层的PDU，然后作为SDU发给第n-1层，接收方作相反处理即可 层次结构含义包括以下方面： 第n层实体不仅要使用第n-1层的服务来实现自身定义的功能，还要向第n+1层提供本层的服务，该服务是第n层及其下面各层提供的服务综合 最底层只提供服务，是整个层次结构的基础，中间各层既是下一层的服务使用者，也是上一层的服务提供者，最高层面向用户提供服务 上一层只能通过相邻层间的接口使用下一层的服务，而不能调用其它层的服务，下一层所提供的服务实现细节对上一层透明 两台主机通信，对等层在逻辑上有一条直接信道，表现为不经过下层就把信息传递到对方 协议，接口和服务的概念协议：规则的集合，明确规定所交换的数据的格式和有关的同步问题，协议是水平的，是控制对等实体之间通信的规则，本层服务用户只能看见服务而无法看见下面的协议 接口：同一结点相邻两层交换信息的连接点，典型的接口同一结点相邻两层的实体通过服务访问点（SAP）进行交互，服务通过SAP提供给上层使用，第n层SAP就是n+1层可以访问第n层服务的地方 服务：指下层为紧邻的上层提供的功能调用，它是垂直的，服务原语：请求，指示，响应，证实 分层参考模型 OSI体系低三层为通信子网，高三层为资源子网表示层采用标准的编码形式使不同表示方法的数据和信息之间能互相交换，同时提供数据压缩，加密和解密功能会话层提供有序传输数据服务，负责建立，管理和终止进程间会话，可以使用校验点使会话在通信失效时从校验点恢复通信，实现数据同步 OSI参考模型在网络层支持无连接和面向连接的通信，但在传输层仅有面向连接的通信。而TCP/IP模型在网际层仅有无连接的通信模式，传输层支持无连接和面向连接两种 思维导图 物理层 通信基础信道，信号，带宽，码元，波特，速率，信源与信宿等基本概念奈奎斯特定理与香农定理；编码与调制电路交换，报文交换与分组交换；数据报与虚电路 传输介质双绞线，同轴电缆，光纤与无线传输介质；物理层接口的特性 物理层设备中继器；集线器 通信基础基本概念 数据，信号与码元：数据是传送信息的实体。信号是数据的电气或电磁表现，分为模拟信号和数字信号，数据传输分为串行和并行传输，远距离通信串行（经济）。码元是指用一个固定时长的信号波形（数字脉冲）表示一位k进制数字，代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为k进制码元，该时长称为码元宽度 信源，信道与信宿：信源是产生和发送数据的源头，信宿是接收数据的终点，信道是信号的传输媒介。可分为单工通信（一个方向的通信），半双工通信（通信双方都可以发送或接收信息，但任一方不能同时发送和接收），全双工通信 速率，波特与带宽：速率分为码元传输速率（单位时间内数字通信系统传输的码元个数，单位是波特）和信息传输速率（单位时间内数字通信系统传输的二进制码元个数，b/s） 波特和比特的区别：若一个码元携带n比特的信息，则M波特率的码元传输速率所对应的信息传输速率为Mn比特/秒 带宽原来指信号具有的频带宽度，单位是Hz，现在是网络通信线路所能传输数据的能力（最高数据率），单位是b/s 奈奎斯特定理与香农定理奈奎斯特定理奈氏准则：在理想低通（没有噪声，带宽有限）的信道中，极限码元传输率为2W波特，W是理想低通信道的带宽，单位为Hz，V表示每个码元离散电平的数目，极限数据率为： 理想低通信道的极限数据传输率=2Wlog2(V) (b/s) 可以得出如下结论： 任何信道中，码元传输速率有上限，若超过此上限，会有严重的码间串扰问题，接收端无法正确识别码元 信道的频带越宽（通过的信号高频分量越多），就可用更高的速率进行码元的有效传输 奈氏准则给出码元传输速率的限制，但未对信息传输速率给出限制，即未对一个码元可以对应多少个二进制位给出限制 要提高数据传输速率，设法对每个码元携带更多个比特的信息量，需要采用多元制的调制方法 香农定理香农定理给出了带宽受限且有高斯白噪音干扰的信道的极限数据传输率，当用此速率传输，可以做到不产生误差 信道的极限数据传输率=Wlog2(1+S/N) (b/s) W为信道的带宽，S为信道所传输信号的平均功率，N为信道内部的高斯噪声功率，S为信噪比，即信号的平均功率与噪声的平均功率之比可以得出如下结论： 信道的带宽或信道中的信噪比越大，信息的极限传输速率越高 对一定的传输带宽和一定的信噪比，信息传输速率的上限是确定的 只要信息的传输速率低于信道的极限传输速率，就能找到某种方法实现无差错的传输 香农定理得出的是极限信息传输速率，实际信道的传输速率要低很多 编码与调制数据变换为模拟信号称为调制，数据变换为数字信号称为编码 数字数据编码为数字信号 非归零编码（NRZ）：两个电压来代表两个二进制数字，如低电平表示0，高电平表示1，没有检错功能，无法判断一个码元的开始和结束 曼彻斯特编码：一个码元分成两个相等的间隔，前一个间隔为高电平而后一个间隔为低电平表示码元1，码元0的表示相反。特点是每个码元中间的电平跳变可作为时钟信号也可作为数据信号，所占频带宽度是原始基带宽度的2倍，以太网使用的编码方式就是它 差分曼彻斯特编码：用于局域网传输，若码元为1，则前半个码元的电平与上一个码元的后半个码元的电平相同；若码元为0，则相反。特点是每个码元中间都有一次电平的跳转，可以实现自同步，抗干扰性好 4B/5B编码：将欲发送数据流的每4位作为一组，按照4B/5B编码规则将其转换成相应的5位码。5位码16种组合对应16种不同的4位码，其他16位作为控制码或保留 数字数据调制为模拟信号幅移键控，频移键控，相移键控，正交振幅调制… 模拟数据编码为数字信号典型例子是音频信号编码的脉码调制，包括采样，量化，编码 模拟数据调制为模拟信号可以使用频分复用技术 电路交换，报文交换与分组交换电路交换数据传输前，两个节点之间必须先建立一条专用的物理通信路径，这一路径可能经过许多中间结点，在整个数据传输期间一直被独占，直到通信结束，分为3个阶段：连接建立，数据传输和连接释放 优点：通信时延小，有序传输，没有冲突，适用范围广，实时性强，控制简单缺点：建立连接时间长，线路独占，灵活性差，难以规格化 报文交换交换的单位是报文，携带目的地址，源地址等信息，在交换结点采用存储转发的传输方式 优点：无需建立连接，动态分配线路，提高线路可靠性，提高线路利用率，提供多目标服务缺点：转发时延，对报文大小没有限制因此网络结点要有较大的缓存空间 分组交换也采用存储转发方式，但解决了报文交换中大报文传输的问题，分组限制每次传送的数据块大小的上限，把大数据块划分为合理的小数据块，加上必要的控制信息构成分组 优点：无建立时延，线路利用率高，简化存储管理，加速传输，减少出错概率和重发数据量缺点：存在传输时延，需要传输额外的信息量，可能出现失序，丢失或重复分组 数据报与虚电路分组交换根据其通信子网向端点系统提供的服务，可以进一步分为面向连接的虚电路方式和无连接的数据报方式，这两种方式都由网络层提供 数据报发送一个报文，拆分为若干带有序号的数据单元，在网络层加上地址等信息后形成数据报分组（即网络层PDU），不同分组可以走不同路径，也可按不同顺序到达目的结点 特点：无连接，网络尽最大努力交付但不保证，网络具有冗余路径对故障适应能力强，不独占链路资源利用率高 虚电路虚电路方式试图将数据报方式与电路交换方式结合起来，分组发送前要求在发送方和接收方建立一条逻辑上相连的虚电路，虚电路是固定的，通信过程分为虚电路建立，数据传输与虚电路释放虚电路方式中，端系统每次建立虚电路，选择一个未用过的虚电路号分配给该虚电路，以区别于本系统其他虚电路，传送数据时除了分组号等信息，还要有它要通过的虚电路号。虚电路网络中每个结点维护一张虚电路表 特点： 虚电路的建立和释放需要时间开销 路由选择体现在虚电路建立阶段，连接建立后就确定了传输路径 提供可靠的通信功能，每个分组正确有序到达，且有流量控制 当网络某个结点或某条链路出故障时，所有经过该节点或该链路的虚电路将遭到破坏 分组首部不包含目的地址，而包含虚电路标识符，相对数据报方式开销小 传输介质双绞线，同轴电缆，光纤与无线传输介质（无线电波，微波，红外线，激光） 物理层接口的特性：机械特性，电气特性，功能特性，规程特性 物理层设备中继器又称转发器，将信号整形并放大再转发出去，以消除信号经长段电缆后，因噪声或其他原因造成的失真和衰减，使信号波形和强度达到所需要的要求，进而扩大网络传输的距离 集线器(Hub)多端口的中继器，一个端口接收到数据信号后，整形放大，转发到其他所有处于工作状态的端口，若同时多个端口输入，则输出会冲突 思维导图]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络分层</tag>
        <tag>物理层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转Bootstrap03-导航条,分页导航和其他内置组件]]></title>
    <url>%2F2019%2F07%2F14%2F%E7%8E%A9%E8%BD%ACBootstrap03-%E5%AF%BC%E8%88%AA%E6%9D%A1%2C%E5%88%86%E9%A1%B5%E5%AF%BC%E8%88%AA%E5%92%8C%E5%85%B6%E4%BB%96%E5%86%85%E7%BD%AE%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[玩转Bootstrap03-导航条,分页导航和其他内置组件导航条基础导航条在导航条(navbar)中有一个背景色、而且导航条可以是纯链接（类似导航），也可以是表单，还有就是表单和导航一起结合等多种形式 第一步：首先在制作导航的列表&lt;ul class=”nav”&gt;基础上添加类名“navbar-nav”第二步：在列表外部添加一个容器（div），并且使用类名“navbar”和“navbar-default” 123456789&lt;div class="navbar navbar-default" role="navigation"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href="##"&gt;网站首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;系列教程&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;名师介绍&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;成功案例&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;关于我们&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 为导航条添加标题、二级菜单及状态123456789101112131415161718192021222324252627282930313233&lt;!--加入导航条标题--&gt;&lt;div class="navbar navbar-default" role="navigation"&gt; &lt;div class="navbar-header"&gt; &lt;a href="##" class="navbar-brand"&gt;慕课网&lt;/a&gt; &lt;/div&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href="##"&gt;网站首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;系列教程&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;名师介绍&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;成功案例&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;关于我们&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;!--导航条状态及二级菜单--&gt;&lt;div class="navbar navbar-default" role="navigation"&gt; &lt;div class="navbar-header"&gt; &lt;a href="##" class="navbar-brand"&gt;慕课网&lt;/a&gt; &lt;/div&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href="##"&gt;网站首页&lt;/a&gt;&lt;/li&gt; &lt;li class="dropdown"&gt; &lt;a href="##" data-toggle="dropdown" class="dropdown-toggle"&gt;系列教程&lt;span class="caret"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class="dropdown-menu"&gt; &lt;li&gt;&lt;a href="##"&gt;CSS3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;JavaScript&lt;/a&gt;&lt;/li&gt; &lt;li class="disabled"&gt;&lt;a href="##"&gt;PHP&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;名师介绍&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;成功案例&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;关于我们&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 带表单的导航条1234567891011121314151617181920212223242526&lt;!--代码--&gt;&lt;div class="navbar navbar-default" role="navigation"&gt; &lt;div class="navbar-header"&gt; &lt;a href="##" class="navbar-brand"&gt;慕课网&lt;/a&gt; &lt;/div&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href="##"&gt;网站首页&lt;/a&gt;&lt;/li&gt; &lt;li class="dropdown"&gt; &lt;a href="##" data-toggle="dropdown" class="dropdown-toggle"&gt;系列教程&lt;span class="caret"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class="dropdown-menu"&gt; &lt;li&gt;&lt;a href="##"&gt;CSS3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;JavaScript&lt;/a&gt;&lt;/li&gt; &lt;li class="disabled"&gt;&lt;a href="##"&gt;PHP&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;名师介绍&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;成功案例&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;关于我们&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;form action="##" class="navbar-form navbar-left" rol="search"&gt; &lt;div class="form-group"&gt; &lt;input type="text" class="form-control" placeholder="请输入关键词" /&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-default"&gt;搜索&lt;/button&gt; &lt;/form&gt;&lt;/div&gt; 导航条的按钮，文本和链接 导航条中的按钮navbar-btn 导航条中的文本navbar-text 导航条中的普通链接navbar-link 这三种样式在框架中使用时受到一定的限制，需要和navbar-brand、navbar-nav配合起来使用，而且对数量也有一定的限制，一般情况在使用一到两个不会有问题，超过两个就会有问题 12345678910&lt;div class="navbar navbar-default" role="navigation"&gt; &lt;div class="navbar-header"&gt; &lt;a href="##" class="navbar-brand"&gt;慕课网&lt;/a&gt; &lt;/div&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li&gt;&lt;a href="##" class="navbar-text"&gt;Navbar Text&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##" class="navbar-text"&gt;Navbar Text&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##" class="navbar-text"&gt;Navbar Text&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 固定导航条很多情况之一，设计师希望导航条固定在浏览器顶部或底部，这种固定式导航条的应用在移动端开发中更为常见。Bootstrap框架提供了两种固定导航条的方式 .navbar-fixed-top：导航条固定在浏览器窗口顶部 .navbar-fixed-bottom：导航条固定在浏览器窗口底部 123456789101112&lt;div class="navbar navbar-default navbar-fixed-bottom" role="navigation"&gt; &lt;div class="navbar-header"&gt; &lt;a href="##" class="navbar-brand"&gt;慕课网&lt;/a&gt; &lt;/div&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href="##"&gt;网站首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;系列教程&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;名师介绍&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;成功案例&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;关于我们&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 响应式导航条对不同屏幕的设备要有不同的适应屏幕的导航条 保证在窄屏时需要折叠的内容必须包裹在带一个div内，并且为这个div加入collapse、navbar-collapse两个类名。最后为这个div添加一个class类名或者id名。 保证在窄屏时要显示的图标样式（固定写法）： 123456&lt;button class="navbar-toggle" type="button" data-toggle="collapse"&gt; &lt;span class="sr-only"&gt;Toggle Navigation&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt;&lt;/button&gt; 并为button添加data-target=”.类名/#id名”，究竞是类名还是id名呢？由需要折叠的div来决定 e.g. 123456789101112131415161718192021222324&lt;!--代码--&gt;&lt;div class="navbar navbar-default" role="navigation"&gt; &lt;div class="navbar-header"&gt; &lt;!-- .navbar-toggle样式用于toggle收缩的内容，即nav-collapse collapse样式所在元素 --&gt; &lt;button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".navbar-responsive-collapse"&gt; &lt;span class="sr-only"&gt;Toggle Navigation&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;/button&gt; &lt;!-- 确保无论是宽屏还是窄屏，navbar-brand都显示 --&gt; &lt;a href="##" class="navbar-brand"&gt;慕课网&lt;/a&gt; &lt;/div&gt; &lt;!-- 屏幕宽度小于768px时，div.navbar-responsive-collapse容器里的内容都会隐藏，显示icon-bar图标，当点击icon-bar图标时，再展开。屏幕大于768px时，默认显示。 --&gt; &lt;div class="collapse navbar-collapse navbar-responsive-collapse"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href="##"&gt;网站首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;系列教程&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;名师介绍&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;成功案例&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;关于我们&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 反色导航条反色导航条其实是Bootstrap框架为大家提供的第二种风格的导航条，与默认的导航条相比，使用方法并无区别，只是将navbar-deafult类名换成navbar-inverse。其变化只是导航条的背景色和文本做了修改 1234567891011&lt;!--代码--&gt;&lt;div class="navbar navbar-inverse" role="navigation"&gt; &lt;div class="navbar-header"&gt; &lt;a href="##" class="navbar-brand"&gt;慕课网&lt;/a&gt; &lt;/div&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href=""&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;教程&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;关于我们&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 分页导航（带页码的分页导航）1234567891011121314151617181920212223242526272829&lt;!--代码--&gt;&lt;ul class="pagination pagination-lg"&gt; &lt;li&gt;&lt;a href="#"&gt;&amp;laquo;第一页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;11&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;12&lt;/a&gt;&lt;/li&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;13&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;14&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;15&lt;/a&gt;&lt;/li&gt; &lt;li class="disabled"&gt;&lt;a href="#"&gt;最后一页&amp;raquo;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; &lt;ul class="pagination pagination"&gt; &lt;li&gt;&lt;a href="#"&gt;&amp;laquo;第一页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;11&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;12&lt;/a&gt;&lt;/li&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;13&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;14&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;15&lt;/a&gt;&lt;/li&gt; &lt;li class="disabled"&gt;&lt;a href="#"&gt;最后一页&amp;raquo;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; &lt;ul class="pagination pagination-sm"&gt; &lt;li&gt;&lt;a href="#"&gt;&amp;laquo;第一页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;11&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;12&lt;/a&gt;&lt;/li&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;13&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;14&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;15&lt;/a&gt;&lt;/li&gt; &lt;li class="disabled"&gt;&lt;a href="#"&gt;最后一页&amp;raquo;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 翻页分页导航这种分页导航是看不到具体的页码，只会提供一个“上一页”和“下一页”的按钮 123456789101112131415&lt;!--代码--&gt;&lt;ul class="pager"&gt; &lt;li&gt;&lt;a href="#"&gt;&amp;laquo;上一页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;下一页&amp;raquo;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; &lt;!--左右对齐--&gt;&lt;ul class="pager"&gt; &lt;li class="previous"&gt;&lt;a href="#"&gt;&amp;laquo;上一页&lt;/a&gt;&lt;/li&gt; &lt;li class="next"&gt;&lt;a href="#"&gt;下一页&amp;raquo;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; &lt;!--禁止状态--&gt;&lt;ul class="pager"&gt; &lt;li class="disabled"&gt;&lt;span&gt;&amp;laquo;上一页&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;下一页&amp;raquo;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 标签在一些Web页面中常常会添加一个标签用来告诉用户一些额外的信息，比如说在导航上添加了一个新导航项，可能就会加一个“new”标签，来告诉用户。这是新添加的导航项 123456789&lt;!--代码--&gt;&lt;h3&gt;Example heading &lt;span class="label label-default"&gt;New&lt;/span&gt;&lt;/h3&gt; &lt;!--代码--&gt;&lt;span class="label label-default"&gt;默认标签&lt;/span&gt;&lt;span class="label label-primary"&gt;主要标签&lt;/span&gt;&lt;span class="label label-success"&gt;成功标签&lt;/span&gt;&lt;span class="label label-info"&gt;信息标签&lt;/span&gt;&lt;span class="label label-warning"&gt;警告标签&lt;/span&gt;&lt;span class="label label-danger"&gt;错误标签&lt;/span&gt; 徽章徽章效果和前面介绍的标签效果是极其的相似。也是用来做一些提示信息使用。常出现的是一些系统发出的信息，比如你登录你的twitter后，如果你信息没有看，系统会告诉你有多少信息未读 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!--代码--&gt;&lt;a href="#"&gt;Inbox &lt;span class="badge"&gt;42&lt;/span&gt;&lt;/a&gt; &lt;!--navbar-default导航条勋章--&gt;&lt;div class="navbar navbar-default" role="navigation"&gt; &lt;div class="navbar-header"&gt; &lt;a href="##" class="navbar-brand"&gt;慕课网&lt;/a&gt; &lt;/div&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href="##"&gt;网站首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;系列教程&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;名师介绍&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;成功案例&lt;span class="badge"&gt;23&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;关于我们&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;!--nav-pills导航条勋章--&gt;&lt;ul class="nav nav-pills"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;Home &lt;span class="badge"&gt;42&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Profile&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Messages &lt;span class="badge"&gt;3&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt; &lt;ul class="nav nav-pills nav-stacked" style="max-width: 260px;"&gt; &lt;li class="active"&gt; &lt;a href="#"&gt; &lt;span class="badge pull-right"&gt;42&lt;/span&gt; Home &lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Profile&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt; &lt;span class="badge pull-right"&gt;3&lt;/span&gt; Messages &lt;/a&gt; &lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;!--按钮勋章--&gt;&lt;button class="btn btn-primary" type="button"&gt; Messages &lt;span class="badge"&gt;4&lt;/span&gt;&lt;/button&gt; 其他内置组件缩略图缩略图在网站中最常用的地方就是产品列表页面，一行显示几张图片，有的在图片底下（左侧或右侧）带有标题、描述等信息。Bootstrap框架将这一部独立成一个模块组件。并通过“thumbnail”样式配合bootstrap的网格系统来实现。可以将产品列表页变得更好看 123456789101112131415161718192021222324&lt;div class="container"&gt; &lt;div class="row"&gt; &lt;div class="col-xs-6 col-md-3"&gt; &lt;a href="#" class="thumbnail"&gt; &lt;img alt="100%x180" src="http://img.mukewang.com/5434eba100014fe906000338.png" style="height: 180px; width: 100%; display: block;" &gt; &lt;/a&gt; &lt;/div&gt; &lt;div class="col-xs-6 col-md-3"&gt; &lt;a href="#" class="thumbnail"&gt; &lt;img alt="100%x180" src="http://img.mukewang.com/5434eba100014fe906000338.png" style="height: 180px; width: 100%; display: block;"&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class="col-xs-6 col-md-3"&gt; &lt;a href="#" class="thumbnail"&gt; &lt;img alt="100%x180" src="http://img.mukewang.com/5434eba100014fe906000338.png" style="height: 180px; width: 100%; display: block;"&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class="col-xs-6 col-md-3"&gt; &lt;a href="#" class="thumbnail"&gt; &lt;img alt="100%x180" src="http://img.mukewang.com/5434eba100014fe906000338.png" style="height: 180px; width: 100%; display: block;"&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 还可以让缩略图配合标题，描述内容，按钮等使用在仅有缩略图的基础上，添加了一个div名为“caption“的容器，在这个容器中放置其他内容，比如说标题，文本描述，按钮等 123456789101112131415161718&lt;div class="container"&gt; &lt;div class="row"&gt; &lt;div class="col-xs-6 col-md-3"&gt; &lt;a href="#" class="thumbnail"&gt; &lt;img src="http://a.hiphotos.baidu.com/image/w%3D400/sign=c56d7638b0b7d0a27bc9059dfbee760d/3b292df5e0fe9925d46873da36a85edf8cb171d7.jpg" style="height: 180px; width: 100%; display: block;" alt=""&gt; &lt;/a&gt; &lt;div class="caption"&gt; &lt;h3&gt;Bootstrap框架系列教程&lt;/h3&gt; &lt;p&gt;Bootstrap框架是一个优秀的前端框，就算您是一位后端程序员或者你是一位不懂设计的前端人员，你也能依赖于Bootstrap制作做优美的网站...&lt;/p&gt; &lt;p&gt; &lt;a href="##" class="btn btn-primary"&gt;开始学习&lt;/a&gt; &lt;a href="##" class="btn btn-info"&gt;正在学习&lt;/a&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; … &lt;/div&gt;&lt;/div&gt; 警示框12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;h2&gt;默认警示框&lt;/h2&gt;&lt;div class="alert alert-success" role="alert"&gt;恭喜您操作成功！&lt;/div&gt;&lt;div class="alert alert-info" role="alert"&gt;请输入正确的密码&lt;/div&gt;&lt;div class="alert alert-warning" role="alert"&gt;您已操作失败两次，还有最后一次机会&lt;/div&gt;&lt;div class="alert alert-danger" role="alert"&gt;对不起，您输入的密码有误&lt;/div&gt; &lt;h2&gt;可关闭的警示框&lt;/h2&gt;&lt;div class="alert alert-success alert-dismissable" role="alert"&gt; &lt;button class="close" type="button" data-dismiss="alert"&gt;&amp;times;&lt;/button&gt; 恭喜您操作成功！&lt;/div&gt;&lt;div class="alert alert-info alert-dismissable" role="alert"&gt; &lt;button class="close" type="button" data-dismiss="alert"&gt;&amp;times;&lt;/button&gt; 请输入正确的密码&lt;/div&gt;&lt;div class="alert alert-warning alert-dismissable" role="alert"&gt; &lt;button class="close" type="button" data-dismiss="alert"&gt;&amp;times;&lt;/button&gt; 您已操作失败两次，还有最后一次机会&lt;/div&gt;&lt;div class="alert alert-danger alert-dismissable" role="alert"&gt; &lt;button class="close" type="button" data-dismiss="alert"&gt;&amp;times;&lt;/button&gt; 对不起，您输入的密码有误&lt;/div&gt;&lt;h2&gt;警示框的链接&lt;/h2&gt;&lt;div class="alert alert-success" role="alert"&gt; &lt;strong&gt;Well done!&lt;/strong&gt; You successfully read &lt;a href="#" class="alert-link"&gt;this important alert message&lt;/a&gt; .&lt;/div&gt;&lt;div class="alert alert-info" role="alert"&gt; &lt;strong&gt;Heads up!&lt;/strong&gt; This &lt;a href="#" class="alert-link"&gt;alert needs your attention&lt;/a&gt; , but it's not super important.&lt;/div&gt;&lt;div class="alert alert-warning" role="alert"&gt; &lt;strong&gt;Warning!&lt;/strong&gt; Better check yourself, you're &lt;a href="#" class="alert-link"&gt;not looking too good&lt;/a&gt; .&lt;/div&gt;&lt;div class="alert alert-danger" role="alert"&gt; &lt;strong&gt;Oh snap!&lt;/strong&gt; &lt;a href="#" class="alert-link"&gt;Change a few things up&lt;/a&gt; and try submitting again.&lt;/div&gt; 进度条基本样式1234&lt;div class="progress"&gt; &lt;div class="progress-bar" style="width:40%"&gt; &lt;/div&gt;&lt;/div&gt; 彩色进度条123456789101112&lt;div class="progress"&gt; &lt;div class="progress-bar progress-bar-success" style="width:40%"&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class="progress"&gt; &lt;div class="progress-bar progress-bar-info" style="width:60%"&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class="progress"&gt; &lt;div class="progress-bar progress-bar-warning" style="width:80%"&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class="progress"&gt; &lt;div class="progress-bar progress-bar-danger" style="width:50%"&gt;&lt;/div&gt;&lt;/div&gt; 条纹进度条使用Bootstrap框架中的条纹进度条只需要在进度条的容器“progress”基础上增加类名“progress-striped” 123456789101112&lt;div class="progress progress-striped"&gt; &lt;div class="progress-bar progress-bar-success" style="width:40%"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="progress progress-striped"&gt; &lt;div class="progress-bar progress-bar-info" style="width:60%"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="progress progress-striped"&gt; &lt;div class="progress-bar progress-bar-warning" style="width:80%"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="progress progress-striped"&gt; &lt;div class="progress-bar progress-bar-danger" style="width:50%"&gt;&lt;/div&gt;&lt;/div&gt; 动态条纹进度条在进度条“progress progress-striped”两个类的基础上再加入“active”类名 123456789101112&lt;div class="progress progress-striped active"&gt; &lt;div class="progress-bar progress-bar-success" style="width:40%"&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class="progress progress-striped active"&gt; &lt;div class="progress-bar progress-bar-info" style="width:60%"&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class="progress progress-striped active"&gt; &lt;div class="progress-bar progress-bar-warning" style="width:80%"&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class="progress progress-striped active"&gt; &lt;div class="progress-bar progress-bar-danger" style="width:50%"&gt;&lt;/div&gt;&lt;/div&gt; 层叠进度条Bootstrap框架除了提供上述几种进度条之外，还提供了一种层叠进度条，层叠进度条，可以将不同状态的进度条放置在一起，按水平方式排列。具体使用如下 123456&lt;div class="progress"&gt; &lt;div class="progress-bar progress-bar-success" style="width:20%"&gt;&lt;/div&gt; &lt;div class="progress-bar progress-bar-info" style="width:10%"&gt;&lt;/div&gt; &lt;div class="progress-bar progress-bar-warning" style="width:30%"&gt;&lt;/div&gt; &lt;div class="progress-bar progress-bar-danger" style="width:15%"&gt;&lt;/div&gt;&lt;/div&gt; 带Label的进度条有很多时候是需要在进度条中直接用相关的数值向用户传递完成的进度值 123&lt;div class="progress"&gt; &lt;div class="progress-bar progress-bar-success" role="progressbar" aria-valuenow="20" aria-valuemin="0" aria-valuemax="100" style="width:20%"&gt;20%&lt;/div&gt;&lt;/div&gt; 媒体对象默认媒体对象媒体对象一般是成组出现，而一组媒体对象常常包括以下几个部分： 媒体对像的容器：常使用“media”类名表示，用来容纳媒体对象的所有内容 媒体对像的对象：常使用“media-object”表示，就是媒体对象中的对象，常常是图片 媒体对象的主体：常使用“media-body”表示，就是媒体对像中的主体内容，可以是任何元素，常常是图片侧边内容 媒体对象的标题：常使用“media-heading”表示，就是用来描述对象的一个标题，此部分可选 123456789&lt;div class="media"&gt; &lt;a class="pull-left" href="#"&gt; &lt;img class="media-object" src="http://img.mukewang.com/52e1d29d000161fe06000338-300-170.jpg" alt="..."&gt; &lt;/a&gt; &lt;div class="media-body"&gt; &lt;h4 class="media-heading"&gt;系列：十天精通CSS3&lt;/h4&gt; &lt;div&gt;全方位深刻详解CSS3模块知识，经典案例分析，代码同步调试，让网页穿上绚丽装备！&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 媒体对象的嵌套 如上图评论系统，是由3个媒体对象嵌套而成，在Bootstrap框架中的媒体对象也具备这样的功能，只需要将另一个媒体对象结构放置在媒体对象的主体内“media-body”，如下所示： 123456789101112131415161718192021222324252627&lt;div class="media"&gt; &lt;a class="pull-left" href="#"&gt; &lt;img class="media-object" src="http://a.disquscdn.com/uploads/users/3740/2069/avatar92.jpg?1406972031" alt="..."&gt; &lt;/a&gt; &lt;div class="media-body"&gt; &lt;h4 class="media-heading"&gt;我是大漠&lt;/h4&gt; &lt;div&gt;我是W3cplus站长大漠，我在写Bootstrap框中的媒体对象测试用例&lt;/div&gt; &lt;div class="media"&gt; &lt;a class="pull-left" href="#"&gt; &lt;img class="media-object" src="http://tp2.sinaimg.cn/3306361973/50/22875318196/0" alt="..."&gt; &lt;/a&gt; &lt;div class="media-body"&gt; &lt;h4 class="media-heading"&gt;慕课网&lt;/h4&gt; &lt;div&gt;大漠写的《玩转Bootstrap》系列教程即将会在慕课网上发布&lt;/div&gt; &lt;div class="media"&gt; &lt;a class="pull-left" href="#"&gt; &lt;img class="media-object" src="http://tp4.sinaimg.cn/1167075935/50/22838101204/1" alt="..."&gt; &lt;/a&gt; &lt;div class="media-body"&gt; &lt;h4 class="media-heading"&gt;W3cplus&lt;/h4&gt; &lt;div&gt;W3cplus站上还有很多教程....&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 媒体对象列表 如上评论系统所示，Bootstrap也支持媒体对象列表，Bootstrap框架提供了一个列表展示的效果，在写结构的时候可以使用ul，并且在ul上添加类名“media-list”，而在li上使用“media” 12345678910111213&lt;ul class="media-list"&gt; &lt;li class="media"&gt; &lt;a class="pull-left" href="#"&gt; &lt;img class="media-object" src=" " alt="..."&gt; &lt;/a&gt; &lt;div class="media-body"&gt; &lt;h4 class="media-heading"&gt;Media Header&lt;/h4&gt; &lt;div&gt;…&lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class="media"&gt;…&lt;/li&gt; &lt;li class="media"&gt;…&lt;/li&gt;&lt;/ul&gt; 列表组列表组是Bootstrap框架新增的一个组件，可以用来制作列表清单、垂直导航等效果，也可以配合其他的组件制作出更漂亮的组件 基础列表组1234567&lt;ul class="list-group"&gt; &lt;li class="list-group-item"&gt;揭开CSS3的面纱&lt;/li&gt; &lt;li class="list-group-item"&gt;CSS3选择器&lt;/li&gt; &lt;li class="list-group-item"&gt;CSS3边框&lt;/li&gt; &lt;li class="list-group-item"&gt;CSS3背景&lt;/li&gt; &lt;li class="list-group-item"&gt;CSS3文本&lt;/li&gt;&lt;/ul&gt; 带徽章的列表组带徽章的列表组其实就是将Bootstrap框架中的徽章组件和基础列表组结合在一起的一个效果。具体做法很简单，只需要在“list-group-item”中添加徽章组件“badge” 1234567891011121314151617&lt;ul class="list-group"&gt; &lt;li class="list-group-item"&gt; &lt;span class="badge"&gt;13&lt;/span&gt;揭开CSS3的面 &lt;/li&gt; &lt;li class="list-group-item"&gt; &lt;span class="badge"&gt;456&lt;/span&gt;CSS3选择器 &lt;/li&gt; &lt;li class="list-group-item"&gt; &lt;span class="badge"&gt;892&lt;/span&gt;CSS3边框 &lt;/li&gt; &lt;li class="list-group-item"&gt; &lt;span class="badge"&gt;90&lt;/span&gt;CSS3背景 &lt;/li&gt; &lt;li class="list-group-item"&gt; &lt;span class="badge"&gt;1290&lt;/span&gt;CSS3文本 &lt;/li&gt;&lt;/ul&gt; 带链接的列表组很多时候，都希望在列表项的任何区域都具备可点击，这个时候只需要将ul.list-group使用div.list-group来替换，而li.list-group-item直接用a.list-group-item来替换 123456789101112131415161718192021222324&lt;h3&gt;带链接的列表组1&lt;/h3&gt;&lt;ul class="list-group"&gt; &lt;li class="list-group-item"&gt; &lt;a href="##"&gt;揭开CSS3的面&lt;/a&gt; &lt;/li&gt; &lt;li class="list-group-item"&gt; &lt;a href="##"&gt;CSS3选择器&lt;/a&gt; &lt;/li&gt; &lt;li class="list-group-item"&gt; &lt;a href="##"&gt;CSS3边框&lt;/a&gt; &lt;/li&gt; &lt;li class="list-group-item"&gt; &lt;a href="##"&gt;CSS3背景&lt;/a&gt; &lt;/li&gt; &lt;li class="list-group-item"&gt; &lt;a href="##"&gt;CSS3文本&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;带链接的列表组2&lt;/h3&gt;&lt;div class="list-group"&gt; &lt;a href="##" class="list-group-item"&gt;图解CSS3&lt;/a&gt; &lt;a href="##" class="list-group-item"&gt;&lt;span class="badge"&gt;220&lt;/span&gt;Sass教程&lt;/a&gt; &lt;a href="##" class="list-group-item"&gt;玩转Bootstrap&lt;/a&gt;&lt;/div&gt; 自定义列表组 list-group-item-heading：用来定义列表项头部样式 list-group-item-text：用来定义列表项主要内容 12345678910&lt;div class="list-group"&gt; &lt;a href="##" class="list-group-item"&gt; &lt;h4 class="list-group-item-heading"&gt;图解CSS3&lt;/h4&gt; &lt;p class="list-group-item-text"&gt;详细讲解了选择器、边框、背景、文本、颜色、盒模型、伸缩布局盒模型、多列布局、渐变、过渡、动画、媒体、响应Web设计、Web字体等主题下涵盖的所有CSS3新特性...&lt;/p&gt; &lt;/a&gt; &lt;a href="##" class="list-group-item"&gt; &lt;h4 class="list-group-item-heading"&gt;Sass中国&lt;/h4&gt; &lt;p class="list-group-item-text"&gt;致力于为中国开发者提供最全面，最具影响力，最前沿的Sass相关技术与教程...&lt;/p&gt; &lt;/a&gt;&lt;/div&gt; 列表项的状态设置 active：表示当前状态 disabled：表示禁用状态 123456&lt;div class="list-group"&gt; &lt;a href="##" class="list-group-item active"&gt;&lt;span class="badge"&gt;5902&lt;/span&gt;图解CSS3&lt;/a&gt; &lt;a href="##" class="list-group-item"&gt;&lt;span class="badge"&gt;15902&lt;/span&gt;W3cplus&lt;/a&gt; &lt;a href="##" class="list-group-item"&gt;&lt;span class="badge"&gt;59020&lt;/span&gt;慕课网&lt;/a&gt; &lt;a href="##" class="list-group-item disabled"&gt;&lt;span class="badge"&gt;0&lt;/span&gt;Sass中国&lt;/a&gt;&lt;/div&gt; 多彩列表组 list-group-item-success：成功，背景色绿色 list-group-item-info：信息，背景色蓝色 list-group-item-warning：警告，背景色为黄色 list-group-item-danger：错误，背景色为红色 1234567&lt;div class="list-group"&gt; &lt;a href="##" class="list-group-item active"&gt;&lt;span class="badge"&gt;5902&lt;/span&gt;图解CSS3&lt;/a&gt; &lt;a href="##" class="list-group-item list-group-item-success"&gt;&lt;span class="badge"&gt;15902&lt;/span&gt;W3cplus&lt;/a&gt; &lt;a href="##" class="list-group-item list-group-item-info"&gt;&lt;span class="badge"&gt;59020&lt;/span&gt;慕课网&lt;/a&gt; &lt;a href="##" class="list-group-item list-group-item-warning"&gt;&lt;span class="badge"&gt;0&lt;/span&gt;Sass中国&lt;/a&gt; &lt;a href="##" class="list-group-item list-group-item-danger"&gt;&lt;span class="badge"&gt;10&lt;/span&gt;Mobile教程&lt;/a&gt;&lt;/div&gt; 面板面板（Panels）是Bootstrap框架新增的一个组件，其主要作用就是用来处理一些其他组件无法完成的功能 基础面板基础面板非常简单，就是一个div容器运用了“panel”样式，产生一个具有边框的文本显示块。由于“panel”不控制主题颜色，所以在“panel”的基础上增加一个控制颜色的主题“panel-default”，另外在里面添加了一个“div.panel-body”来放置面板主体内容： 123&lt;div class="panel panel-default"&gt; &lt;div class="panel-body"&gt;我是一个基础面板，带有默认主题样式风格&lt;/div&gt;&lt;/div&gt; 带有头和尾的面板 panel-heading：用来设置面板头部样式 panel-footer：用来设置面板尾部样式 12345&lt;div class="panel panel-default"&gt; &lt;div class="panel-heading"&gt;图解CSS3&lt;/div&gt; &lt;div class="panel-body"&gt;…&lt;/div&gt; &lt;div class="panel-footer"&gt;作者：大漠&lt;/div&gt;&lt;/div&gt; 彩色面板 panel-primary：重点蓝 panel-success：成功绿 panel-info:信息蓝 panel-warning：警告黄 panel-danger：危险红 使用方法就很简单了，只需要在panel的类名基础上增加自己需要的类名： 12345678910&lt;div class="panel panel-default"&gt; &lt;div class="panel-heading"&gt;图解CSS3&lt;/div&gt; &lt;div class="panel-body"&gt;…&lt;/div&gt; &lt;div class="panel-footer"&gt;作者：大漠&lt;/div&gt;&lt;/div&gt;&lt;div class="panel panel-primary"&gt;…&lt;/div&gt;&lt;div class="panel panel-success"&gt;…&lt;/div&gt;&lt;div class="panel panel-info"&gt;…&lt;/div&gt;&lt;div class="panel panel-warning"&gt;…&lt;/div&gt;&lt;div class="panel panel-danger"&gt;…&lt;/div&gt; 面板中嵌套表格一般情况下可以把面板理解为一个区域，在使用面板的时候，都会在panel-body放置需要的内容，可能是图片、表格或者列表等。来看看面板中嵌套表格和列表组的一个效果。首先来看嵌套表格的效果 如果表格和面板边缘不需要有任何的间距，可以把table放在panel-body外面 123456&lt;div class="panel panel-default"&gt; &lt;div class="panel-heading"&gt;图解CSS3&lt;/div&gt; &lt;div class="panel-body"&gt;…&lt;/div&gt; &lt;table class="table table-bordered"&gt;…&lt;/table&gt; &lt;div class="panel-footer"&gt;作者：大漠&lt;/div&gt;&lt;/div&gt; 面板中嵌套列表组12345678910&lt;div class="panel panel-default"&gt; &lt;div class="panel-heading"&gt;图解CSS3&lt;/div&gt; &lt;div class="panel-body"&gt;…&lt;/div&gt; &lt;ul class="list-group"&gt; &lt;li class="list-group-item"&gt;我是列表项&lt;/li&gt; &lt;li class="list-group-item"&gt;我是列表项&lt;/li&gt; &lt;li class="list-group-item"&gt;我是列表项&lt;/li&gt; &lt;/ul&gt; &lt;div class="panel-footer"&gt;作者：大漠&lt;/div&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>bootstrap</category>
      </categories>
      <tags>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转Bootstrap02-菜单,按钮及导航&网格系统]]></title>
    <url>%2F2019%2F06%2F27%2F%E7%8E%A9%E8%BD%ACBootstrap02-%E8%8F%9C%E5%8D%95%2C%E6%8C%89%E9%92%AE%E5%8F%8A%E5%AF%BC%E8%88%AA%26%E7%BD%91%E6%A0%BC%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[玩转Bootstrap02-菜单,按钮及导航&amp;网格系统网格系统网格系统的实现原理非常简单，仅仅是通过定义容器大小，平分12份（24或32），再调整内外边距，最后结合媒体查询即可制作强大的响应式网格系统 工作原理 数据行(.row)必须包含在容器(.container)中，以便赋予合适的对齐方式和内距，如： 123&lt;div class="container"&gt;&lt;div class="row"&gt;&lt;/div&gt;&lt;/div&gt; 在行(.row)中可以添加列(.column)，但列数之和不能超过平分的总列数，比如12。如： 12345&lt;div class="container"&gt;&lt;div class="row"&gt; &lt;div class="col-md-4"&gt;&lt;/div&gt; &lt;div class="col-md-8"&gt;&lt;/div&gt;&lt;/div&gt; 具体内容应当放置在列容器内，且只有列才可以作为行容器的直接子元素 通过设置内距(padding)从而创建列与列之间的间距。然后通过为第一列和最后一列设置负值的外距(margin)来抵消内距的影响 列偏移有的时候，我们不希望相邻的两个列紧靠在一起，但又不想使用margin或者其他的技术手段来。这个时候就可以使用列偏移（offset）功能来实现。使用列偏移也非常简单，只需要在列元素上添加类名“col-md-offset-*”(其中星号代表要偏移的列组合数)，那么具有这个类名的列就会向右偏移。例如，你在列元素上添加“col-md-offset-4”，表示该列向右移动4个列的宽度。 123456789101112&lt;div class="container"&gt;&lt;h4&gt;列向右移动四列的间距&lt;/h4&gt; &lt;div class="row"&gt; &lt;div class="col-md-4"&gt;.col-md-4&lt;/div&gt; &lt;div class="col-md-2 col-md-offset-4"&gt;列向右移动四列的间距&lt;/div&gt; &lt;div class="col-md-2"&gt;.col-md-3&lt;/div&gt; &lt;/div&gt; &lt;div class="row"&gt; &lt;div class="col-md-4"&gt;.col-md-4&lt;/div&gt; &lt;div class="col-md-4 col-md-offset-4"&gt;列向右移动四列的间距&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 列排序列排序其实就是改变列的方向，就是改变左右浮动，并且设置浮动的距离。在Bootstrap框架的网格系统中是通过添加类名“col-md-push-”和“col-md-pull-” (其中星号代表移动的列组合数)。 “col-md-4”居左，“col-md-8”居右，如果要互换位置，需要将“col-md-4”向右移动８个列的距离，也就是8个offset ,也就是在“”添加类名“col-md-push-8”，调用其样式。也要将“col-md-8”向左移动４个列的距离，也就是4个offset，在“”上添加类名“col-md-pull-4”： .col-md-4 .col-md-8 列的嵌套Bootstrap框架的网格系统还支持列的嵌套。你可以在一个列中添加一个或者多个行（row）容器，然后在这个行容器中插入列（像前面介绍的一样使用列）。但在列容器中的行容器（row），宽度为100%时，就是当前外部列的宽度。来看一个简单示例： 1234567891011121314151617181920212223&lt;div class="container"&gt; &lt;div class="row"&gt; &lt;div class="col-md-8"&gt; 我的里面嵌套了一个网格 &lt;div class="row"&gt; &lt;div class="col-md-6"&gt;col-md-6&lt;/div&gt; &lt;div class="col-md-6"&gt;col-md-6&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="col-md-4"&gt;col-md-4&lt;/div&gt; &lt;/div&gt; &lt;div class="row"&gt; &lt;div class="col-md-4"&gt;.col-md-4&lt;/div&gt; &lt;div class="col-md-8"&gt; 我的里面嵌套了一个网格 &lt;div class="row"&gt; &lt;div class="col-md-4"&gt;col-md-4&lt;/div&gt; &lt;div class="col-md-4"&gt;col-md-4&lt;/div&gt; &lt;div class="col-md-4"&gt;col-md-4&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 菜单，按钮及导航下拉菜单基本用法 &lt;div class=&quot;dropdown&quot;&gt;作为容器包裹整个下拉菜单元素 使用了一个按钮做为父菜单，并且定义类名“dropdown-toggle”和自定义“data-toggle”属性，且值必须和最外容器类名一致，此示例为:data-toggle=&quot;dropdown&quot; 下拉菜单项使用一个ul列表，并且定义一个类名为“dropdown-menu”，此示例为:&lt;ul class=&quot;dropdown-menu&quot;&gt; 123456789101112&lt;div class="dropdown"&gt; &lt;button class="btn btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown"&gt; 选择你喜欢的水果 &lt;span class="caret"&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class="dropdown-menu" role="menu" aria-labelledby="dropdownMenu1"&gt; &lt;li role="presentation"&gt;&lt;a role="menuitem" tabindex="-1" href="#"&gt;苹果&lt;/a&gt;&lt;/li&gt; &lt;li role="presentation"&gt;&lt;a role="menuitem" tabindex="-1" href="#"&gt;香蕉&lt;/a&gt;&lt;/li&gt; &lt;li role="presentation"&gt;&lt;a role="menuitem" tabindex="-1" href="#"&gt;梨&lt;/a&gt;&lt;/li&gt; &lt;li role="presentation"&gt;&lt;a role="menuitem" tabindex="-1" href="#"&gt;桃&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 下拉分割线在Bootstrap框架中的下拉菜单还提供了下拉分隔线，假设下拉菜单有两个组，那么组与组之间可以通过添加一个空的，并且给这个添加类名“divider”来实现添加下拉分隔线的功能 123456789101112 &lt;div class="dropdown"&gt; &lt;button class="btn btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown"&gt; 下拉菜单 &lt;span class="caret"&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class="dropdown-menu" role="menu" aria-labelledby="dropdownMenu1"&gt; &lt;li role="presentation"&gt;&lt;a role="menuitem" tabindex="-1" href="#"&gt;下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;li role="presentation"&gt;&lt;a role="menuitem" tabindex="-1" href="#"&gt;下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;li role="presentation" class="divider"&gt;&lt;/li&gt; &lt;li role="presentation"&gt;&lt;a role="menuitem" tabindex="-1" href="#"&gt;下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 菜单标题可以添加下拉菜单标题 1234567891011121314151617&lt;div class="dropdown"&gt; &lt;button class="btn btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown"&gt; 下拉菜单 &lt;span class="caret"&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class="dropdown-menu" role="menu" aria-labelledby="dropdownMenu1"&gt; &lt;li role="presentation" class="dropdown-header"&gt;第一部分菜单头部&lt;/li&gt; &lt;li role="presentation"&gt;&lt;a role="menuitem" tabindex="-1" href="#"&gt;下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;li role="presentation"&gt;&lt;a role="menuitem" tabindex="-1" href="#"&gt;下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;li role="presentation"&gt;&lt;a role="menuitem" tabindex="-1" href="#"&gt;下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;li role="presentation" class="divider"&gt;&lt;/li&gt; &lt;li role="presentation" class="dropdown-header"&gt;第二部分菜单头部&lt;/li&gt; &lt;li role="presentation"&gt;&lt;a role="menuitem" tabindex="-1" href="#"&gt;下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;li role="presentation"&gt;&lt;a role="menuitem" tabindex="-1" href="#"&gt;下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;li role="presentation"&gt;&lt;a role="menuitem" tabindex="-1" href="#"&gt;下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 对齐方式Bootstrap框架中下拉菜单默认是左对齐，如果你想让下拉菜单相对于父容器右对齐时，可以在&lt;ul&gt;的类“dropdown-menu”上添加一个“pull-right”或者“dropdown-menu-right”类名 12345678910111213 &lt;div class="dropdown"&gt; &lt;button class="btn btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown"&gt; 下拉菜单 &lt;span class="caret"&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class="dropdown-menu pull-right" role="menu" aria-labelledby="dropdownMenu1"&gt; &lt;li role="presentation"&gt;&lt;a role="menuitem" tabindex="-1" href="#"&gt;下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;li role="presentation"&gt;&lt;a role="menuitem" tabindex="-1" href="#"&gt;下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;li role="presentation"&gt;&lt;a role="menuitem" tabindex="-1" href="#"&gt;下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;li role="presentation" class="divider"&gt;&lt;/li&gt; &lt;li role="presentation"&gt;&lt;a role="menuitem" tabindex="-1" href="#"&gt;下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 菜单项状态默认有悬浮（:hover）和焦点（:focus）状态，还有当前状态（.active）和禁用状态（.disabled），只要在对应菜单项上添加对应类名即可 123456789101112&lt;div class="dropdown"&gt; &lt;button class="btn btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown"&gt; 下拉菜单 &lt;span class="caret"&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class="dropdown-menu" role="menu" aria-labelledby="dropdownMenu1"&gt; &lt;li role="presentation"&gt;&lt;a role="menuitem" tabindex="-1" href="#"&gt;苹果&lt;/a&gt;&lt;/li&gt; &lt;li role="presentation" class="active"&gt;&lt;a role="menuitem" tabindex="-1" href="#"&gt;香蕉&lt;/a&gt;&lt;/li&gt; &lt;li role="presentation"&gt;&lt;a role="menuitem" tabindex="-1" href="#"&gt;梨&lt;/a&gt;&lt;/li&gt; &lt;li role="presentation" class="disabled"&gt;&lt;a role="menuitem" tabindex="-1" href="#"&gt;桃&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 按钮按钮组使用一个名为“btn-group”的容器，把多个按钮放到这个容器中即可 1234567891011&lt;div class="btn-group"&gt; &lt;button type="button" class="btn btn-default"&gt;&lt;span class="glyphicon glyphicon-step-backward"&gt;&lt;/span&gt;&lt;/button&gt; &lt;button type="button" class="btn btn-default"&gt;&lt;span class="glyphicon glyphicon-fast-backward"&gt;&lt;/span&gt;&lt;/button&gt; &lt;button type="button" class="btn btn-default"&gt;&lt;span class="glyphicon glyphicon-backward"&gt;&lt;/span&gt;&lt;/button&gt; &lt;button type="button" class="btn btn-default"&gt;&lt;span class="glyphicon glyphicon-play"&gt;&lt;/span&gt;&lt;/button&gt; &lt;button type="button" class="btn btn-default"&gt;&lt;span class="glyphicon glyphicon-pause"&gt;&lt;/span&gt;&lt;/button&gt; &lt;button type="button" class="btn btn-default"&gt;&lt;span class="glyphicon glyphicon-stop"&gt;&lt;/span&gt;&lt;/button&gt; &lt;button type="button" class="btn btn-default"&gt;&lt;span class="glyphicon glyphicon-forward "&gt;&lt;/span&gt;&lt;/button&gt; &lt;button type="button" class="btn btn-default"&gt;&lt;span class="glyphicon glyphicon-fast-forward"&gt;&lt;/span&gt;&lt;/button&gt; &lt;button type="button" class="btn btn-default"&gt;&lt;span class="glyphicon glyphicon-step-forward"&gt;&lt;/span&gt;&lt;/button&gt;&lt;/div&gt; 按钮工具栏1234567891011121314&lt;div class="btn-toolbar"&gt; &lt;div class="btn-group"&gt; … &lt;/div&gt; &lt;div class="btn-group"&gt; … &lt;/div&gt; &lt;div class="btn-group"&gt; … &lt;/div&gt; &lt;div class="btn-group"&gt; … &lt;/div&gt;&lt;/div&gt; 嵌套分组很多时候，我们常把下拉菜单和普通的按钮组排列在一起，实现类似于导航菜单的效果。如下所示： 使用的时候，只需要把当初制作下拉菜单的“dropdown”的容器换成“btn-group”，并且和普通的按钮放在同一级。如下所示： 123456789101112131415&lt;div class="btn-group"&gt; &lt;button class="btn btn-default" type="button"&gt;首页&lt;/button&gt; &lt;button class="btn btn-default" type="button"&gt;产品展示&lt;/button&gt; &lt;button class="btn btn-default" type="button"&gt;案例分析&lt;/button&gt; &lt;button class="btn btn-default" type="button"&gt;联系我们&lt;/button&gt; &lt;div class="btn-group"&gt; &lt;button class="btn btn-default dropdown-toggle" data-toggle="dropdown" type="button"&gt;关于我们&lt;span class="caret"&gt;&lt;/span&gt;&lt;/button&gt; &lt;ul class="dropdown-menu"&gt; &lt;li&gt;&lt;a href="##"&gt;公司简介&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;企业文化&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;组织结构&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;客服服务&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 垂直分组前面看到的示例，按钮组都是水平显示的。但在实际运用当中，总会碰到垂直显示的效果。在Bootstrap框架中也提供了这样的风格。我们只需要把水平分组的“btn-group”类名换成“btn-group-vertical”即可。如下所示： 123456789101112131415&lt;div class="btn-group-vertical"&gt; &lt;button class="btn btn-default" type="button"&gt;首页&lt;/button&gt; &lt;button class="btn btn-default" type="button"&gt;产品展示&lt;/button&gt; &lt;button class="btn btn-default" type="button"&gt;案例分析&lt;/button&gt; &lt;button class="btn btn-default" type="button"&gt;联系我们&lt;/button&gt; &lt;div class="btn-group"&gt; &lt;button class="btn btn-default dropdown-toggle" data-toggle="dropdown" type="button"&gt;关于我们&lt;span class="caret"&gt;&lt;/span&gt;&lt;/button&gt; &lt;ul class="dropdown-menu"&gt; &lt;li&gt;&lt;a href="##"&gt;公司简介&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;企业文化&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;组织结构&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;客服服务&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 等分按钮等分按钮的效果在移动端上特别的实用。整个按钮组宽度是容器的100%，而按钮组里面的每个按钮平分整个容器宽度。例如，如果你按钮组里面有五个按钮，那么每个按钮是20%的宽度，如果有四个按钮，那么每个按钮是25%宽度，以此类推。 等分按钮也常被称为是自适应分组按钮，其实现方法也非常的简单，只需要在按钮组“btn-group”上追加一个“btn-group-justified”类名，如下所示： 12345678&lt;div class="btn-wrap"&gt; &lt;div class="btn-group btn-group-justified"&gt; &lt;a class="btn btn-default" href="#"&gt;首页&lt;/a&gt; &lt;a class="btn btn-default" href="#"&gt;产品展示&lt;/a&gt; &lt;a class="btn btn-default" href="#"&gt;案例分析&lt;/a&gt; &lt;a class="btn btn-default" href="#"&gt;联系我们&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; 按钮下拉菜单按钮下拉菜单仅从外观上看和上一节介绍的下拉菜单效果基本上是一样的。不同的是在普通的下拉菜单的基础上封装了按钮（.btn）样式效果。简单点说就是点击一个按钮，会显示隐藏的下拉菜单。 按钮下拉菜单其实就是普通的下拉菜单，只不过把“”标签元素换成了“”标签元素。唯一不同的是外部容器“div.dropdown”换成了“div.btn-group”。如下所示： 123456789&lt;div class="btn-group"&gt; &lt;button class="btn btn-default dropdown-toggle" data-toggle="dropdown" type="button"&gt;按钮下拉菜单&lt;span class="caret"&gt;&lt;/span&gt;&lt;/button&gt; &lt;ul class="dropdown-menu"&gt; &lt;li&gt;&lt;a href="##"&gt;按钮下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;按钮下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;按钮下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;按钮下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 按钮的向下向上三角形按钮的向下三角形，我们是通过在标签中添加一个“”标签元素，并且命名为“caret”: 123456789&lt;div class="btn-group"&gt; &lt;button class="btn btn-default dropdown-toggle" data-toggle="dropdown" type="button"&gt;按钮下拉菜单&lt;span class="caret"&gt;&lt;/span&gt;&lt;/button&gt; &lt;ul class="dropdown-menu"&gt; &lt;li&gt;&lt;a href="##"&gt;按钮下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;按钮下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;按钮下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;按钮下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 有的时候我们的下拉菜单会向上弹起（接下来一个小节会介绍），这个时候我们的三角方向需要朝上显示，实现方法：需要在“.btn-group”类上追加“dropup”类名（这也是做向上弹起下拉菜单要用的类名）。 123&lt;div class="btn-group dropup"&gt; &lt;!-- 其他同上 --&gt;&lt;/div&gt; 效果如下 导航基础样式Bootstrap框架中制作导航条主要通过“.nav”样式。默认的“.nav”样式不提供默认的导航样式，必须附加另外一个样式才会有效，比如“nav-tabs”、“nav-pills”之类 标签形tab导航标签形导航又称选项卡导航，在很多内容分块显示的时候，使用这种选项卡来分组十分合适 标签形导航通过”nav-tabs”样式实现 1234567&lt;ul class="nav nav-tabs"&gt; &lt;li&gt;&lt;a href="##"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;CSS3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;Sass&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;jQuery&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;Responsive&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 如果想加上当前选中行的效果，只需要在对应的&lt;li&gt;添加类名class=&quot;active&quot;即可 1234&lt;ul class="nav nav-tabs"&gt; &lt;li class="active"&gt;&lt;a href="##"&gt;Home&lt;/a&gt;&lt;/li&gt; …&lt;/ul&gt; 除了当前项之外，有的选项卡还带有禁用状态，实现这样的效果，只需要在标签项上添加“class=”disabled””即可 胶囊形pills导航胶囊形（pills）导航听起来有点别扭，因为其外形看起来有点像胶囊形状。但其更像我们平时看到的大众形导航。当前项高亮显示，并带有圆角效果。其实现方法和“nav-tabs”类似，同样的结构，只需要把类名“nav-tabs”换成“nav-pills”即可 1234567&lt;ul class="nav nav-pills"&gt; &lt;li class="active"&gt;&lt;a href="##"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;CSS3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;Sass&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;jQuery&lt;/a&gt;&lt;/li&gt; &lt;li class="disabled"&gt;&lt;a href="##"&gt;Responsive&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 垂直堆叠的导航在实际运用当中，除了水平导航之外，还有垂直导航，就类似前面介绍的垂直排列按钮一样。制作垂直堆叠导航只需要在“nav-pills”的基础上添加一个“nav-stacked”类名即可 1234567&lt;ul class="nav nav-pills nav-stacked"&gt; &lt;li class="active"&gt;&lt;a href="##"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;CSS3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;Sass&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;jQuery&lt;/a&gt;&lt;/li&gt; &lt;li class="disabled"&gt;&lt;a href="##"&gt;Responsive&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 自适应导航自适应导航指的是导航占据容器全部宽度，而且菜单项可以像表格的单元格一样自适应宽度。自适应导航和前面使用“btn-group-justified”制作的自适应按钮组是一样的。只不过在制作自适应导航时更换了另一个类名“nav-justified”。当然他需要和“nav-tabs”或者“nav-pills”配合在一起使用 1234567&lt;ul class="nav nav-tabs nav-justified"&gt; &lt;li class="active"&gt;&lt;a href="##"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;CSS3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;Sass&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;jQuery&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;Responsive&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 二级导航只需要将li当作父容器，使用类名“dropdown”，同时在li中嵌套另一个列表ul，使用前面介绍下拉菜单的方法就可以 12345678910111213&lt;ul class="nav nav-pills"&gt; &lt;li class="active"&gt;&lt;a href="##"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li class="dropdown"&gt; &lt;a href="##" class="dropdown-toggle" data-toggle="dropdown"&gt;教程&lt;span class="caret"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class="dropdown-menu"&gt; &lt;li&gt;&lt;a href="##"&gt;CSS3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;Sass&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;jQuery&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;Responsive&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="##"&gt;关于我们&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 面包屑式导航面包屑(Breadcrumb)一般用于导航，主要是起的作用是告诉用户现在所处页面的位置（当前位置）。在Bootstrap框架中面包屑也是一个独立模块组件 12345&lt;ol class="breadcrumb"&gt; &lt;li&gt;&lt;a href="#"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;我的书&lt;/a&gt;&lt;/li&gt; &lt;li class="active"&gt;《图解CSS3》&lt;/li&gt;&lt;/ol&gt;]]></content>
      <categories>
        <category>bootstrap</category>
      </categories>
      <tags>
        <tag>bootstrap</tag>
        <tag>网格系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL锁]]></title>
    <url>%2F2019%2F06%2F27%2FMySQL%E9%94%81%2F</url>
    <content type="text"><![CDATA[MySQL锁开发多用户，数据库驱动的应用时，最大的一个难点是：一方面要最大程度利用数据库的并发访问，另一方面保证每个用户能以一致的方式读取和修改数据，为此有了锁的机制 什么是锁锁是数据库系统区别文件系统的一个关键特性。锁机制用于管理对共享资源的并发访问。InnoDB引擎提供一致性的非锁定读，行锁级支持 lock与latchlatch一般称为闩锁（轻量级的锁），其要求锁定时间必须非常短，若持续时间长，则性能会非常差，InnoDB中，latch可以分为mutex（互斥量）和rwlock（读写锁），其目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测机制 lock的对象是事务，用来锁定的是数据库中的对象，如表，页，行，并且一般lock的对象仅在事务commit或rollback后进行释放（不同事务隔离级别释放的时间不同），lock是有死锁机制的 可以通过SHOW ENGINE INNODB MUTEX查看latch的信息 InnoDB存储引擎的锁锁的类型InnoDB存储引擎实现了如下两种标准的行级锁 共享锁（S Lock）：允许事务读一行数据 排他锁（X Lock）：允许事务删除或更新一行数据 如果一个事务T1获得行r的共享锁，那么另外的事务T2可以立即获得行r的共享锁，称为锁兼容。但若有其他事务T3想获得行r的排他锁，必须等待事务T1,T2释放行r的共享锁，称为锁不兼容 此外，InnoDB存储引擎支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一种额外的锁方式，称为意向锁，意向锁是将锁定的对象分为多个层次，如下图 若将上锁对象看作一棵树，那么对最下层即最细粒度的对象上锁，首先要对粗粒度的对象上锁，如：要对页上记录r进行上X锁，那么首先分别对数据库A，表，页上意向锁IX，最后对记录r上X锁，若其中任一部分导致等待，那么该操作需要等待粗粒度锁的完成（比如对记录r加X锁之前，表已存在S锁，那么事务对记录r在表1上加上IX锁，由于不兼容，事务需要等待表锁操作完成） InnoDB的意向锁是表级的锁，设计目的主要是为了在一个事务中揭示下一行将被请求的锁类型，支持如下两个意向锁 意向共享锁（IS Lock）：事务想要获得一张表中某几行的共享锁 意向排他锁（IX Lock）：事务想要获得一张表中某几行的排他锁 意向锁不会阻塞除全表扫以外的任何请求，兼容性如下 可以通过SHOW ENGINE INNODB STATUS查看当前锁请求的信息 一致性非锁定读一致性非锁定读指InnoDB存储引擎通过行多版本控制的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行DELETE或UPDATE操作，这时读操作不会因此去等待行上锁的释放，相反，InnoDB存储引擎会去读取行的一个快照数据 非锁定读不需要等待访问行上X锁的释放，快照数据是该行的之前版本的数据，它是undo段完成的，没有额外的开销 非锁定读机制极大提高数据库的并发性，是InnoDB默认的读取方式，非锁定读不会占用和等待表上的锁 READ COMMITTED 和 REPEATABLE READ下，InnoDB使用非锁定的一致性读，它们的区别在于快照数据的定义，READ COMMITTED事务隔离级别下，对于快照数据，非一致性锁定读总是读取被锁定行的最新一份快照数据，而在REPEATABLE READ事务隔离级别下，对于快照数据，非一致性读总是读取本事务开始时的行数据版本 如下例子 在READ COMMITTED和REPEATABLE READ事务隔离级别下，第二次执行SELECT的结果都是能够查询到该行，因为会话B此时还没有COMMIT，当会话B COMMIT后再查询一次，在READ COMMITTED事务隔离级别下就查询不到id=1的行数据了，因为它的数据快照是最新一份快照数据，而在REPEATABLE READ下仍然能读取到id=1的数据行，因为它的数据快照是事务开始时候的行数据版本 对一致性非锁定读的大概总结一致性非锁定读：读取数据时读取的是undo段的快照数据（即以前的数据），使得读数据时不占用S锁和不等待X锁，极大提高并发性要注意的是快照数据到底是什么，READ COMMITTED事务隔离级别下，快照数据是被锁定行的最新一份快照数据，REPEATABLE READ事务隔离级别下，快照数据是读取本事务开始时的行数据版本 一致性锁定读某些情况下，用户需要显式地对数据库读取操作加锁以保证数据逻辑的一致性 SELECT ... FOR UPDATE;：对读取的行记录加一个X锁SELECT ... LOCK IN SHARE MODE;：对读取的行记录加一个S锁 对于一致性非锁定读，即使读取的行已被执行了SELECT ... FOR UPDATE;，也是可以读取的上述两个语句必须用在一个事务中 自增长与锁自增长属性一般是主键方式，InnoDB存储引擎的内存结构中，对每个含有自增长值的表都有一个自增长计数器。当对含有自增长的计数器的表进行插入操作时，这个计数器会被初始化，执行如下语句来得到计数器的值SELECT MAX(auto_inc_col) FROM t FOR UPADATE;。插入操作会依据这个自增长的计数器值加1赋予自增长列。这种方式叫做AUTO-INC Locking，这种锁是一种特殊的表锁机制，锁不在事务完成后释放，而是对自增长值插入的SQL语句后立即释放，AUTO-INC Locking对有自增长值的列的并发插入性能较差，事务必须等待前一个插入的完成 MySQL 5.1.22版本开始，InnoDB提供一种轻量级互斥量的自增长实现机制，InnoDB提供一个参数innodb_autoinc_lock_mode控制自增长的模式，该参数的默认值为1，在此之前先对自增长的插入进行分类 参数innodb_autoinc_lock_mode以及各个设置下对自增的影响，有3个值可以设置，分别为0,1,2 简单来说，0就是使用AUTO-INC Locking，1就是对不同的插入类型有不同用法，2就是只用互斥量（性能最高，但是会有并发的问题） InnoDB存储引擎自增长值必须是索引，同时必须是索引的第一个列，否则会抛出异常 外键和锁外键主要用于引用完整性的约束检查，InnoDB对于一个外键列，如果没有显式地对这个列加索引，InnoDB会自动对其加一个索引，这样可以避免表锁 对于外键的插入和更新，首先需要查询父表的记录，即SELECT父表，但是对于父表的SELECT操作，不是使用一致性非锁定读的方式，因为这样会发生数据不一致的情况，因此这时使用的是SELECT ... LOCK IN SHARE MODE方式，主动对父表加S锁，这时如果父表已经加X锁，子表的操作会被阻塞 锁的算法行锁的3种算法InnoDB有3种行锁的算法，分别是： Record Lock：单个行记录上的锁 Gap Lock：间隙锁，锁定一个范围，但不包括记录本身 Next-Key Lock：Gap Lock + Record Lock，锁定一个范围且包括记录本身 Record Lock总是锁住索引记录，如果InnoDB存储引擎表在建立的时候没有设置任何一个索引，这时就会使用隐式的主键进行锁定 Next-Key Lock是结合了Record Lock和Gap Lock的一种锁定算法，如果一个索引有10,11,13和20这四个值，那么该索引可能被Next-Key Locking的区别为：(-∞,10],(10,11],(11,13],(13,20],(20,+∞) 这种锁用于解决Phantom Problem（后面会讲） 当查询的索引含有唯一属性时，InnoDB存储引擎会对Next-Key Lock进行优化，将其降级为Record Lock，即仅锁住索引本身，而不是范围，如下： 1234CREATE TABLE t (a INT PRIMARY KEY);INSERT INTO t SELECT 1;INSERT INTO t SELECT 2;INSERT INTO t SELECT 5; 接着执行下图的SQL语句 会话A首先会对a=5进行X锁定，a是主键且唯一，所以锁定的仅仅是5这个值，而不是(2.5]这个范围，这样会话B插入4就不会阻塞，可以立即插入并返回 如果是辅助索引，则情况完全不同，如下面例子： 123456CREATE TABLE z (a INT, b INT, PRIMARY KEY(a), KEY(b));INSERT INTO z SELECT 1,1;INSERT INTO z SELECT 3,1;INSERT INTO z SELECT 5,3;INSERT INTO z SELECT 7,6;INSERT INTO z SELECT 10,8; 当在会话A执行下面SQL语句SELECT * FROM z WHERE b=3 FOR UPDATE，需要对2个索引分别加锁，对于聚集索引，其仅加上列5的锁，而对于辅助索引，加上的是Next-Key Lock，会加上(1,3]的锁，特别需要注意的是，InnoDB还会对辅助索引的下一个键值加上gap lock，即还有一个辅助索引范围(3,6)的锁，即辅助索引的(1,6)都被锁住了，因此，若在新会话B中运行下面的SQL语句，都会被阻塞，要不被阻塞，插入必须聚集索引所在列不为5，且辅助索引所在列不在(1,6)才行 123SELECT * FROM z WHERE a=5 LOCK IN SHARE MODE;INSERT INTO z SELECT 4,2;INSERT INTO z SELECT 6,5; Gap Lock可以通过下面两种方式关闭，关闭后除了外键约束和唯一性检查需要Gap Lock，其他情况仅使用Record Lock锁定 事务隔离级别设置为READ COMMITTED 参数innodb_locks_unsafe_for_binlog设置为1 解决Phantom Proplem在默认事务隔离级别(REPEATABLE READ)下，InnoDB采用Next-Key Locking机制避免Phantom Proplem(幻读)，幻读指同一事务下，连续执行两次相同的SQL语句可能导致不同的结果，第二次的SQL语句可能会返回之前不存在的行（事务A第一次查询得到一行记录，事务B提交后，事务A第二次查询得到两行记录），如下例子： 表t创建语句：CREATE TABLE z (a INT, PRIMARY KEY(a));，且由1,2,5这三个值组成，如果事务T1执行SELECT * FROM t WHERE a&gt;2 FOR UPDATE;，会返回5这一个结果，当另一个事务T2插入了4这个值，事务T1再次执行上述SQL语句，会得到结果4,5，这违反了事务的隔离性，出现了幻读的现象 上述的Next-Key Locking算法避免幻读的出现，对于SELECT * FROM t WHERE a&gt;2 FOR UPDATE;，锁定不只是5这个值，而是对(2,+∞)这个范围加了X锁，任何对于这个范围的插入都是不允许的，从而避免了幻读 对行锁算法的总结看书的时候看的我有点晕，然后我去看了下博客，大致懂了 先看下面例子 对于t1表，有id自增主索引，且有10,20,30,40这4个值 对记录存在且主键精确匹配SELECT id FROM t1 WHERE id=20 FOR UPDATE，只会对20上锁，即Record Lock对记录不存在且主键精确匹配SELECT id FROM t1 WHERE id=18 FOR UPDATE，会上gap lock，对(10,20)上锁对主键范围匹配SELECT id FROM t1 WHERE id&lt;30 AND id&gt;10 FOR UPDATE，会上Next-Key Lock，对(10,30]上锁，锁上界不锁下届对非UNIQUE的索引上锁，只会使用Next-Key Lock 场景 锁类型 使用unique index精确匹配(=)，且记录存在 Record Lock 使用unique index精确匹配(=), 且记录不存在 Gap Lock 使用unique index范围匹配(&lt;和&gt;) Next-Key Lock，锁上界不锁下界 非unique Next-Key Lock 操作 锁类型 SELECT … FROM 快照读, 不加锁, SERIALIZABLE隔离级别除外. SELECT … FROM … LOCK IN SHARE MODE 共享的Next-Key Lock SELECT … FROM … FOR UPDATE 排他的Next-Key Lock UPDATE … WHERE … 排他的Next-Key Lock DELETE FROM … WHERE … 排他的Next-Key Lock INSERT Record Lock 不同SQL语句的加锁规则 锁问题脏读脏数据和脏页不同，脏页是指缓冲池已经被修改的页，但还没刷新到磁盘，脏数据指事务对缓冲池中行记录的修改，并且还没有被提交，读取脏数据是不允许的，如果一个事务可以读取到另外一个事务还没提交的数据，违反了数据库的隔离性 脏读就是在不同事务下，当前事务可以读取到另外事务未提交的数据，也就是脏数据，当事务隔离级别为READ UNCOMMITTED，就会出现脏读的情况 不可重复读不可重复读指一个事务内多次读取同一数据集合。在这个事务还没有结束时，另外一个事务也访问了该同一数据集合，并做了一些DML操作。因此，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据可能是不一样的 一般来说，不可重复读是可以接受的，因为其读到的是已经提交的数据，READ COMMITTED允许出现不可重复读的现象 InnoDB使用Next-Key Lock避免不可重复读 幻读，脏读和不可重复读脏读:事务T1正在读数据库内容,而T2修改了数据库内容还没有提交,接着T1读到了T2未提交的数据,就叫脏读 不可重复读:在一个事务里面读取了两次某个数据，读出来的数据不一致的现象,T1正在读数据库内容,而T2 update数据库后提交了,T1又读了一次数据库内容,这时出现两个内容不同的结果,这叫不可重复读,主要针对update而言 幻读:T1正在读数据库内容,而T2 insert数据库后提交了,T1又读了一次数据库内容,这时T1看到内容出现了多一条数据,这叫幻读,幻读出现的前提是并发的事务中有事务发生了插入、删除操作 丢失更新一个事务的更新操作会被另一个事务的更新操作所覆盖，从而导致数据不一致的现象，称为丢失更新 例如： 事务T1将行记录r更新为v1，但事务未提交 与此同时，事务T2,将行记录r更新为v2，事务T2未提交 事务T1提交 事务T2提交 当前数据库任意隔离级别都不会导致丢失更新问题，即使是READ UNCOMMITTED的事务隔离级别，对于行的DML操作，需要对行或其他粗粒度级别对象加锁，上述步骤2种事务T2并不能对行记录r进行更新操作，它会被阻塞 但是有一种逻辑上的丢失更新问题，这种问题并不是数据本身的问题，如下： 事务T1查询一行数据，放入本地内存，并显示给一个终端用户User1 事务T2也查询该行数据，并将取得数据显示给终端用户User2 User1修改了这行记录，更新数据库并提交 User2修改了这行记录，更新数据库并提交 这会导致User1的修改更新操作丢失了，这是一个很严重的问题，如果银行一个用户账户有10000元，他同时打开两个客户端查询余额，第一个客户端转账9000元出去并提交，第二个客户端再转账1元出去并提交，这时用户的余额会变成9999元，那9000元还转出去了，钱变多了，账不平 要避免上述丢失更新发生，可以让事务在这种情况下的操作变成串行化，即在上述4个步骤的第1步中，对用户读取的记录加上一个排他X锁。同样，在步骤2的操作过程中，用户读取也需要加一个排他X锁，这样，步骤2就必须等待步骤1和步骤3完成，最后完成步骤4 阻塞不同锁之间的兼容关系，有些时刻一个事务的锁要等待另一个事务的锁释放它占用的资源，这就是阻塞 InnoDB参数innodb_lock_wait_timeout用来控制等待的时间，innodb_rollback_on_timeout用来设定是否在等待超时时对进行中的事务进行回滚操作，默认是OFF，innodb_lock_wait_timeout可以在MySQL运行时修改，innodb_rollback_on_timeout不可以 默认情况下InnoDB不会回滚阻塞超时引发的错误异常，需要用户判断是否需要COMMIT还是ROLLBACK 死锁死锁指两个或两个以上的事务在执行过程中，因争夺资源而造成的一种互相等待的现象。 解决死锁最简单的一种方法是超时，即当两个事务互相等待时，当一个等待时间超过设置的某一阈值，其中一个事务回滚，另一个等待的事务就能继续进行。参数innodb_lock_wait_timeout设置超时时间 超时机制带来的问题是：如果超时的事务所占权重比较大（如更新了很多行，占用了较多的undo log），回滚这个事务的时间相对另一个事务所占用时间可能就很多 当前数据库普遍采用wait-for graph（等待图）的方式进行死锁检测，InnoDB也采用这种方式。wait-for graph要求数据库保存以下两种信息：锁的信息链表和事务等待链表通过上述链表可以构造出一张图，而在这个图中若存在回路，就代表存在死锁，因此资源间相互发生等待。图中事务T1指向T2边定义为：事务T1等待事务T2所占用的资源如下例子 画出的wait-for graph如下 可以看到t1和t2是回路，存在死锁，回滚undo量最小的事务，采用深度优先算法 死锁的例子 死锁会报1213错误提示，而且它会回滚事务，因此并不需要我们主动去回滚]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>InnoDB</tag>
        <tag>MySQL锁</tag>
        <tag>脏读</tag>
        <tag>幻读</tag>
        <tag>不可重复读</tag>
        <tag>丢失更新</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL事务]]></title>
    <url>%2F2019%2F06%2F26%2FMySQL%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[MySQL事务 认识事务概述事务符合ACID特性 原子性(atomicity)：整个事务操作为原子操作 一致性(consistency)：指事务将数据库从一种状态转变为下一种一致的状态。事务开始之前和事务结束之后，数据库的完整性约束都没有被破坏 隔离性(isolation)：要求每个读写事务的对象对其他事务的操作对象能相互分离，即事务提交前对其他事务都不可见（并发控制，可串行化，锁等） 持久性(durability)：事务一旦提交，其结果就是永久性的。即使发生宕机等故障，数据库也能将数据恢复 事务指一些操作要么都做，要么都不做 对一致性和原子性理解的一个小例子比如有A有500块存款，B有500块存款，A转200给B，则一致性操作如下：A-200;B+200如果这两条操作都执行完毕，那同时它也是原子性的如果操作变为A-200;B+100，且都完成了，那这个操作是原子性的，但不是一致性的 原子性关注状态，要么全部成功，要么全部失败，不存在部分成功的状态。而一致性关注数据的可见性，中间状态的数据对外部不可见，只有最初状态和最终状态的数据对外可见 分类InnoDB存储引擎不原生支持嵌套事务，但可以用带保存点的扁平事务来模拟 扁平事务扁平事务所有操作都处于同一层次，由BEGIN WORK开始，COMMIT WORK或ROLLBACK WORK结束，期间操作是原子性的 扁平事务主要限制是不能提交或回滚事务的某一部分，或分几个步骤提交 带有保存点的扁平事务允许在事务执行过程中回滚到同一事务中较早的一个状态，某些事务可能在执行过程中出现的错误并不会导致所有操作都无效，放弃整个事务不合乎要求，保存点用来通知系统应该记住事务当前的状态，以便之后发生错误时，事务能回到保存点当时的状态 扁平事务隐式地设置了一个事务开始时的保存点，用SAVE WORK函数来建立保存点，保存点在事务内部是递增的，如下： 链事务保存点是易失的，当系统崩溃时，保存点都会消失，恢复时事务要从开始处重新执行，链事务可视为保存点模式的一种变种链事务思想：提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传给下一个要开始的事务，提交事务操作和开始下一个事务操作合并为一个原子操作，意味下一个事务可以看到上一个事务的结果，他们好像在同一个事务中进行一样 链事务只能回滚到最近一个的保存点，而带保存点的扁平事务可以回滚到任意正确的保存点，链事务COMMIT后释放当前事务所持有的所，而带保存点的扁平事务不影响锁 嵌套事务由一个顶层事务控制着各个层次的子事务 嵌套事务是由若干事务组成的一棵树，子树既可以是嵌套事务，也可以是扁平事务 处在叶节点的事务是扁平事务，但是每个事务从根到叶距离可以不同 位于根节点的事务为顶层事务，其他为子事务 子事务既可以提交也可以回滚，但是它的提交不会立即生效，除非其父事务已经提交（可以一直回溯到顶层事务的提交） 树种任意一个事务的回滚会引起它的所有子事务一同回滚，子事务只有ACI特性，没有D特性 分布式事务分布式环境下的扁平事务 事务的实现redo log保证事务的原子性和持久性，undo log来保证事务的一致性 redo恢复提交事务修改的页操作，undo回滚行记录到某个特定版本，redo通常是物理日志，记录的是页的物理修改操作，undo是逻辑日志，根据每行记录进行记录 不详述 事务控制语句 隐式提交的SQL语句以下语句会产生一个隐式的提交操作，即执行完这些语句后，会有一个隐式的COMMIT操作 DDL语句：ALTER TABLE,CREATE DATABASE, CREATE TABLE, CREATE INDEX, DROP DATABASE… 隐式修改MySQL架构的操作：CREATE USER, DROP USER, GRANT, RENAME USER, SET PASSWORD… 管理语句：CACHE INDEX, CHECK TABLE… 事务的隔离级别ISO和ANSI SQL标准制定了四种事务隔离级别的标准，但很少有厂商遵循，如Oracle就不支持READ UNCOMMITTED和REPEATABLE READ READ UNCOMMITTED：称为浏览访问，仅仅针对事务而言 READ COMMITTED：称为游标稳定 REPEATABLE READ：2.9999°的隔离，没有幻读的保护 SERIALIZABLE：称为隔离，或3°的隔离 InnoDB存储引擎默认支持的隔离级别是REPEATABLE READ，但与标准不同的是，InnoDB在REPEATABLE READ事务级别下，使用Next-Key Lock锁的算法，避免幻读的产生，即已经达到了SQL标准的SERIALIZABLE隔离级别 隔离级别越低，事务请求的锁越少或保持的锁的时间越短 即使是READ COMMITTED，对DML操作，都会对行或其他粗粒度对象加锁 READ UNCOMMITTED：读取未提交，允许读取尚未提交的数据，可能出现脏读，幻读，不可重复读READ COMMITTED：读取已提交，允许读取并发事务已经提交的数据，可以阻止脏读，可能出现幻读，不可重复读REPEATABLE READ：可重读，对同一字段的多次读取结果都是一致的，可以阻止脏读和不可重复读，幻读仍有可能发生，InnoDB的话不会发生幻读，通过Next-Key Lock算法SERIALIZABLE：可串行化，对读也加锁，完全服从ACID隔离级别，可以防止脏读，不可重复读，幻读 事务隔离级别 脏读 不可重复读 幻读 加锁读 READ UNCOMMITTED √ √ √ × READ COMMITTED × √ √ × REPEATABLE READ × × √ × SERIALIZABLE × × × √ 分布式事务常见于银行的转账，InnoDB存储引擎提供对XA事务的支持，并通过XA事务支持分布式事务的实现。分布式事务指允许多个独立的事务资源参与到一个全局的事务中。事务资源通常是关系型数据库系统。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚。在使用分布式事务时，InnoDB引擎的事务隔离级别必须设置为SERIALIZABLE XA事务允许不同数据库之间的分布式事务，XA事务由一个或多个资源管理器，一个事务管理器以及一个应用程序组成 资源管理器：提供访问事务资源的方法，通常一个数据库就是一个资源管理器 事务管理器：协调参与全局事务的各个事务，需要和参与全局事务的所有资源管理器进行通信，一般为连接数据库的客户端 应用程序：定义事务的边界，指定全局事务的操作 分布式事务采用两段式提交，第一阶段，所有参与全局事务的节点都开始准备（PREPARE），告诉事务管理器他们准备好提交了，第二阶段，事务管理器告诉资源管理器执行ROLLBACK还是COMMIT，如果任何一个节点显示不能提交，则所有节点都被告知需要回滚。它与本地事务不同的是，分布式事务需要多一次的PREPARE操作，待收到所有节点同意信息后再进行COMMIT或是ROLLBACK操作 MySQL定义的XA操作如下 在XA START和XA END之间是一些SQL语句]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>InnoDB</tag>
        <tag>MySQL事务</tag>
        <tag>事务隔离级别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转Bootstrap01-排版&表单]]></title>
    <url>%2F2019%2F06%2F25%2F%E7%8E%A9%E8%BD%ACBootStrap01-%E6%8E%92%E7%89%88%26%E8%A1%A8%E5%8D%95%2F</url>
    <content type="text"><![CDATA[玩转Bootstrap01-排版&amp;表单strater template 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;Bootstrap 101 Template&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;link href="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css" rel="stylesheet"&gt; &lt;!-- HTML5 shim 和 Respond.js 是为了让 IE8 支持 HTML5 元素和媒体查询（media queries）功能 --&gt; &lt;!-- 警告：通过 file:// 协议（就是直接将 html 页面拖拽到浏览器中）访问页面时 Respond.js 不起作用 --&gt; &lt;!--[if lt IE 9]&gt; &lt;script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;你好，世界！&lt;/h1&gt; &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt; &lt;script src="https://cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"&gt;&lt;/script&gt; &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt; &lt;script src="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 排版标题BootStrap定义标题和普通HTML页面一样，都是&lt;h1&gt; ~ &lt;h6&gt;，它定义了 .h1 ~ .h6 6个类名，可以让非标题元素使用和标题同样的样式 BootStrap可以在&lt;h1&gt; ~ &lt;h6&gt;内添加&lt;small&gt;标签添加副标题&lt;h2&gt;Bootstrap标题二&lt;small&gt;我是副标题&lt;/small&gt;&lt;/h2&gt; 段落Bootstrap的全局文本样式在&lt;body&gt;元素中定义，所以web页面中文本（包括段落p元素）如果没有重置都会有这样的样式效果 强调内容使用.lead定义了强调内容，使用的时候只需要指定class=&quot;lead&quot;即可 12&lt;p&gt;我是一个普通的段落，我不需要强调显示&lt;/p&gt;&lt;p class="lead"&gt;这部分内容需要特别的强调，我和别人长得不一样&lt;/p&gt; 粗体使用&lt;strong&gt;或&lt;b&gt;标签让文本加粗 1&lt;p&gt;我在学习&lt;strong&gt;Bootstrap&lt;/strong&gt;，我要掌握&lt;strong&gt;Bootstrap&lt;/strong&gt;的所有知识。&lt;/p&gt; 斜体使用&lt;em&gt;或&lt;i&gt;让文本斜体 1&lt;p&gt;我正在学习&lt;em&gt;Bootstrap&lt;/em&gt;。我发现&lt;em&gt;Bootstrap&lt;/em&gt;真的好强大。&lt;/p&gt; 强调相关的类 .text-muted：提示，使用浅灰色（#999） .text-primary：主要，使用蓝色（#428bca） .text-success：成功，使用浅绿色(#3c763d) .text-info：通知信息，使用浅蓝色（#31708f） .text-warning：警告，使用黄色（#8a6d3b） .text-danger：危险，使用褐色（#a94442） 123456&lt;div class="text-muted"&gt;.text-muted 效果&lt;/div&gt;&lt;div class="text-primary"&gt;.text-primary效果&lt;/div&gt;&lt;div class="text-success"&gt;.text-success效果&lt;/div&gt;&lt;div class="text-info"&gt;.text-info效果&lt;/div&gt;&lt;div class="text-warning"&gt;.text-warning效果&lt;/div&gt;&lt;div class="text-danger"&gt;.text-danger效果&lt;/div&gt; 文本对齐风格 .text-left：左对齐 .text-center：居中对齐 .text-right：右对齐 .text-justify：两端对齐 1234&lt;p class="text-left"&gt;我居左&lt;/p&gt;&lt;p class="text-center"&gt;我居中&lt;/p&gt;&lt;p class="text-right"&gt;我居右&lt;/p&gt;&lt;p class="text-justify"&gt;我两端对齐&lt;/p&gt; 列表无序列表和有序列表这两个与平常的HTML是一致的 去点列表可以为列表添加class=&quot;list-unstyled&quot;去掉列表项前的点 12345678910111213141516171819202122232425262728293031&lt;ul&gt; &lt;li&gt; 项目列表 &lt;ul&gt; &lt;li&gt;带有项目符号&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; 项目列表 &lt;ul class="list-unstyled"&gt; &lt;li&gt;不带项目符号&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;项目列表&lt;/li&gt;&lt;/ul&gt;&lt;!--有序列表去序号--&gt;&lt;ol&gt; &lt;li&gt; 项目列表 &lt;ol&gt; &lt;li&gt;带有项目编号&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt; 项目列表 &lt;ol class="list-unstyled"&gt; &lt;li&gt;不带项目编号&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt;项目列表&lt;/li&gt;&lt;/ol&gt; 内联列表添加类名class=&quot;.list-inline&quot;实现内联列表，也就是把垂直列表转换为水平列表，而且去掉项目符号，保持水平显示 1234567&lt;ul class="list-inline"&gt; &lt;li&gt;W3cplus&lt;/li&gt; &lt;li&gt;Blog&lt;/li&gt; &lt;li&gt;CSS3&lt;/li&gt; &lt;li&gt;jQuery&lt;/li&gt; &lt;li&gt;PHP&lt;/li&gt;&lt;/ul&gt; 效果如下 定义列表使用方法同HTML一样，都是&lt;dl&gt;和&lt;dt&gt;和&lt;dd&gt;的结合 水平定义列表在定义列表&lt;dl&gt;上添加class=&quot;dl-horizontal&quot; 代码 &lt;code&gt;：一般是针对于单个单词或单个句子的代码 &lt;pre&gt;：一般是针对于多行代码（也就是成块的代码） &lt;kbd&gt;:一般是表示用户要通过键盘输入的内容 当&lt;pre&gt;代码的内容太长，可以通过为其添加类class=&quot;pre-scrollable&quot;来限制代码块高度为340px，多出来的则用滚动条 表格bootstrap的表格使用应该如下 123&lt;table class="table"&gt;…&lt;/table&gt; BootStrap提供了多种不同样式的表格，如下 .table：基础表格 .table-striped：斑马线表格 .table-bordered：带边框的表格 .table-hover：鼠标悬停高亮的表格 .table-condensed：紧凑型表格 .table-responsive：响应式表格，即当浏览器可视区域小于768px时，表格底部就会出现水平滚动条，主要用于兼容其他设备 &lt;table class=&quot;table table-xxx&quot;&gt;即可指定除基础表格以外的表格 表格行的类可以为&lt;tr class=&quot;xxx&quot;&gt;指定表格行的类，Bootstrap提供了如下5种，主要是背景颜色的区别 表单表单常见元素有：文本输入框，下拉选择框，单选按钮，复选按钮，文本域和按钮等 水平表单bootstrap默认是垂直显示风格水平表单即标签居左，表单控件居右的风格 在Bootstrap框架中要实现水平表单效果，必须满足以下两个条件： 在元素是使用类名“form-horizontal”。 配合Bootstrap框架的网格系统。（网格布局会在以后的章节中详细讲解） 12345678910111213141516171819202122232425262728&lt;form class="form-horizontal" role="form"&gt; &lt;div class="form-group"&gt; &lt;label for="inputEmail3" class="col-sm-2 control-label"&gt;邮箱&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input type="email" class="form-control" id="inputEmail3" placeholder="请输入您的邮箱地址"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="inputPassword3" class="col-sm-2 control-label"&gt;密码&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input type="password" class="form-control" id="inputPassword3" placeholder="请输入您的邮箱密码"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;div class="col-sm-offset-2 col-sm-10"&gt; &lt;div class="checkbox"&gt; &lt;label&gt; &lt;input type="checkbox"&gt; 记住密码 &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;div class="col-sm-offset-2 col-sm-10"&gt; &lt;button type="submit" class="btn btn-default"&gt;进入邮箱&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; 内联表单 要实现内联表单，只需在&lt;form&gt;元素添加class=&quot;form-inline&quot;即可，表单控件设置为内联块元素，如下 1234567891011121314151617&lt;form class="form-inline" role="form"&gt; &lt;div class="form-group"&gt; &lt;!-- 这里的class="sr-only"会把label隐藏 --&gt; &lt;label class="sr-only" for="exampleInputEmail2"&gt;邮箱&lt;/label&gt; &lt;input type="email" class="form-control" id="exampleInputEmail2" placeholder="请输入你的邮箱地址"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label class="sr-only" for="exampleInputPassword2"&gt;密码&lt;/label&gt; &lt;input type="password" class="form-control" id="exampleInputPassword2" placeholder="请输入你的邮箱密码"&gt; &lt;/div&gt; &lt;div class="checkbox"&gt; &lt;label&gt; &lt;input type="checkbox"&gt; 记住密码 &lt;/label&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-default"&gt;进入邮箱&lt;/button&gt;&lt;/form&gt; 表单控件输入框input单行输入框，就是input的type属性为text，其他输入框如密码，邮箱只是把type属性改一下即可 bootstrap为&lt;input&gt;添加类class=&quot;form-control&quot;，使其有比较好的样式 123456&lt;form role="form"&gt; &lt;div class="form-group"&gt; &lt;input type="email" class="form-control" placeholder="Enter email"&gt; &lt;/div&gt;&lt;/form&gt; 下拉选择框select1234567891011121314151617181920212223242526&lt;body&gt;&lt;form role="form"&gt; &lt;!-- 下拉选择框 --&gt; &lt;div class="form-group"&gt; &lt;select class="form-control"&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;!-- 多行选择 --&gt; &lt;div class="form-group"&gt; &lt;select multiple class="form-control"&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt; &lt;/select&gt; &lt;/div&gt;&lt;/form&gt; 文本域textarea文本域和原始使用方法一样，设置rows可定义其高度，设置cols可以设置其宽度。但如果textarea元素中添加了类名“form-control”类名，则无需设置cols属性。因为Bootstrap框架中的“form-control”样式的表单控件宽度为100%或auto 12345&lt;form role="form"&gt; &lt;div class="form-group"&gt; &lt;textarea class="form-control" rows="3"&gt;&lt;/textarea&gt; &lt;/div&gt;&lt;/form&gt; 复选框checkbox和单选择按钮radio123456789101112131415161718192021&lt;form role="form"&gt; &lt;h3&gt;案例1&lt;/h3&gt; &lt;div class="checkbox"&gt; &lt;label&gt; &lt;input type="checkbox" value=""&gt; 记住密码 &lt;/label&gt; &lt;/div&gt; &lt;div class="radio"&gt; &lt;label&gt; &lt;input type="radio" name="optionsRadios" id="optionsRadios1" value="love" checked&gt; 喜欢 &lt;/label&gt; &lt;/div&gt; &lt;div class="radio"&gt; &lt;label&gt; &lt;input type="radio" name="optionsRadios" id="optionsRadios2" value="hate"&gt; 不喜欢 &lt;/label&gt; &lt;/div&gt;&lt;/form&gt; 不管是checkbox还是radio都使用label包起来了 checkbox连同label标签放置在一个名为“.checkbox”的容器内 radio连同label标签放置在一个名为“.radio”的容器内 在Bootstrap框架中，主要借助“.checkbox”和“.radio”样式，来处理复选框、单选按钮与标签的对齐方式。 复选框和单选按钮水平排列 如果checkbox需要水平排列，只需要在label标签上添加类名“checkbox-inline” 如果radio需要水平排列，只需要在label标签上添加类名“radio-inline” 123456789101112131415161718192021222324&lt;form role="form"&gt; &lt;div class="form-group"&gt; &lt;label class="checkbox-inline"&gt; &lt;input type="checkbox" value="option1"&gt;游戏 &lt;/label&gt; &lt;label class="checkbox-inline"&gt; &lt;input type="checkbox" value="option2"&gt;摄影 &lt;/label&gt; &lt;label class="checkbox-inline"&gt; &lt;input type="checkbox" value="option3"&gt;旅游 &lt;/label&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label class="radio-inline"&gt; &lt;input type="radio" value="option1" name="sex"&gt;男性 &lt;/label&gt; &lt;label class="radio-inline"&gt; &lt;input type="radio" value="option2" name="sex"&gt;女性 &lt;/label&gt; &lt;label class="radio-inline"&gt; &lt;input type="radio" value="option3" name="sex"&gt;中性 &lt;/label&gt; &lt;/div&gt;&lt;/form&gt; 表单控件大小可以通过设置控件的height，line-height，padding和font-size等属性来实现控件的高度设置 Bootstrap框架还提供了两个不同的类名，用来控制表单控件的高度。这两个类名是： input-sm:让控件比正常大小更小 input-lg:让控件比正常大小更大 1234567891011121314&lt;form role="form"&gt; &lt;div class="form-group"&gt; &lt;label class="control-label"&gt;控件变大&lt;/label&gt; &lt;input class="form-control input-lg" type="text" placeholder="添加.input-lg，控件变大"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label class="control-label"&gt;正常大小&lt;/label&gt; &lt;input class="form-control" type="text" placeholder="正常大小"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label class="control-label"&gt;控件变小&lt;/label&gt; &lt;input class="form-control input-sm" type="text" placeholder="添加.input-sm，控件变小"&gt; &lt;/div&gt; &lt;/form&gt; 要控制表单控件宽度，要借助bootstrap的网格系统 1234567891011121314151617181920212223242526&lt;form role="form" class="form-horizontal"&gt; &lt;div class="form-group"&gt; &lt;div class="col-xs-4"&gt; &lt;input class="form-control input-lg" type="text" placeholder=".col-xs-4"&gt; &lt;/div&gt; &lt;div class="col-xs-4"&gt; &lt;input class="form-control input-lg" type="text" placeholder=".col-xs-4"&gt; &lt;/div&gt; &lt;div class="col-xs-4"&gt; &lt;input class="form-control input-lg" type="text" placeholder=".col-xs-4"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;div class="col-xs-6"&gt;&lt;input class="form-control" type="text" placeholder=".col-xs-6"&gt;&lt;/div&gt; &lt;div class="col-xs-6"&gt;&lt;input class="form-control" type="text" placeholder=".col-xs-6"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;div class="col-xs-5"&gt; &lt;input class="form-control input-sm" type="text" placeholder=".col-xs-5"&gt; &lt;/div&gt; &lt;div class="col-xs-7"&gt; &lt;input class="form-control input-sm" type="text" placeholder=".col-xs-7"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; 表单控件状态焦点状态焦点状态通过伪类:focus实现，要表单在焦点状态下有样式效果，必须为控件添加类form-control 禁用状态禁用状态要在相应表单控件添加属性disabled，bootstrap只是添加了一些样式风格 12345678910&lt;form role="form" class="form-horizontal"&gt; &lt;div class="form-group"&gt; &lt;div class="col-xs-6"&gt; &lt;input class="form-control input-lg" type="text" placeholder="不是焦点状态下效果"&gt; &lt;/div&gt; &lt;div class="col-xs-6"&gt; &lt;input class="form-control input-lg" id="disabledInput" type="text" placeholder="表单已被禁用，不可输入" disabled&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; 验证状态123456789101112131415161718&lt;form role="form"&gt; &lt;div class="form-group has-success has-feedback"&gt; &lt;label class="control-label" for="inputSuccess1"&gt;成功状态&lt;/label&gt; &lt;input type="text" class="form-control" id="inputSuccess1" placeholder="成功状态" &gt; &lt;span class="glyphicon glyphicon-ok form-control-feedback"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class="form-group has-warning has-feedback"&gt; &lt;label class="control-label" for="inputWarning1"&gt;警告状态&lt;/label&gt; &lt;input type="text" class="form-control" id="inputWarning1" placeholder="警告状态"&gt; &lt;span class="glyphicon glyphicon-warning-sign form-control-feedback"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class="form-group has-error has-feedback"&gt; &lt;label class="control-label" for="inputError1"&gt;错误状态&lt;/label&gt; &lt;input type="text" class="form-control" id="inputError1" placeholder="错误状态"&gt; &lt;span class="glyphicon glyphicon-remove form-control-feedback"&gt;&lt;/span&gt; &lt;/div&gt;&lt;/form&gt; 类has-xxx只是颜色的变化，类has-feedback可以把后面的icon显示出来 表单提示信息平常在制作表单验证时，要提供不同的提示信息。在Bootstrap框架中也提供了这样的效果。使用了一个”help-block”样式，将提示信息以块状显示，并且显示在控件底部 1234567891011121314151617181920&lt;form role="form"&gt; &lt;div class="form-group has-success has-feedback"&gt; &lt;label class="control-label" for="inputSuccess1"&gt;成功状态&lt;/label&gt; &lt;input type="text" class="form-control" id="inputSuccess1" placeholder="成功状态" &gt; &lt;span class="help-block"&gt;你输入的信息是正确的&lt;/span&gt; &lt;span class="glyphicon glyphicon-ok form-control-feedback"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class="form-group has-warning has-feedback"&gt; &lt;label class="control-label" for="inputWarning1"&gt;警告状态&lt;/label&gt; &lt;input type="text" class="form-control" id="inputWarning1" placeholder="警告状态"&gt; &lt;span class="help-block"&gt;请输入正确信息&lt;/span&gt; &lt;span class="glyphicon glyphicon-warning-sign form-control-feedback"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class="form-group has-error has-feedback"&gt; &lt;label class="control-label" for="inputError1"&gt;错误状态&lt;/label&gt; &lt;input type="text" class="form-control" id="inputError1" placeholder="错误状态"&gt; &lt;span class="glyphicon glyphicon-remove form-control-feedback"&gt;&lt;/span&gt; &lt;/div&gt;&lt;/form&gt; 按钮 input[type=“submit”] input[type=“button”] input[type=“reset”] &lt;button&gt; 12345678&lt;button class="btn" type="button"&gt;基础按钮.btn&lt;/button&gt; &lt;button class="btn btn-default" type="button"&gt;默认按钮.btn-default&lt;/button&gt; &lt;button class="btn btn-primary" type="button"&gt;主要按钮.btn-primary&lt;/button&gt; &lt;button class="btn btn-success" type="button"&gt;成功按钮.btn-success&lt;/button&gt; &lt;button class="btn btn-info" type="button"&gt;信息按钮.btn-info&lt;/button&gt; &lt;button class="btn btn-warning" type="button"&gt;警告按钮.btn-warning&lt;/button&gt; &lt;button class="btn btn-danger" type="button"&gt;危险按钮.btn-danger&lt;/button&gt; &lt;button class="btn btn-link" type="button"&gt;链接按钮.btn-link&lt;/button&gt; 对&lt;span&gt;,&lt;div&gt;,&lt;input type=&quot;xxx&quot;&gt;，只要指定对应的class是上述的class之一，均可以作为按钮使用 12345&lt;button class="btn btn-default" type="button"&gt;button标签按钮&lt;/button&gt; &lt;input type="submit" class="btn btn-default" value="input标签按钮"/&gt;&lt;a href="##" class="btn btn-default"&gt;a标签按钮&lt;/a&gt;&lt;span class="btn btn-default"&gt;span标签按钮&lt;/span&gt; &lt;div class="btn btn-default"&gt;div标签按钮&lt;/div&gt; 按钮大小123&lt;button class="btn btn-primary btn-lg" type="button"&gt;大型按钮.btn-lg&lt;/button&gt; &lt;button class="btn btn-primary" type="button"&gt;正常按钮&lt;/button&gt;&lt;button class="btn btn-primary btn-sm" type="button"&gt;小型按钮.btn-sm&lt;/button&gt; 块状按钮宽度充满整个父容器的按钮，不需要padding和margin值，称为块状按钮，添加类btn-block即可 1234&lt;button class="btn btn-primary btn-lg btn-block" type="button"&gt;大型按钮.btn-lg&lt;/button&gt;&lt;button class="btn btn-primary btn-block" type="button"&gt;正常按钮&lt;/button&gt;&lt;button class="btn btn-primary btn-sm btn-block" type="button"&gt;小型按钮.btn-sm&lt;/button&gt;&lt;button class="btn btn-primary btn-xs btn-block" type="button"&gt;超小型按钮.btn-xs&lt;/button&gt; 按钮状态活动状态活动状态包括悬浮（:hover），点击（:active），焦点（:focus）3种，bootstrap只为其添加了样式 禁用状态bootstrap有两种方式实现禁用状态 方法1：在标签中添加disabled属性方法2：在元素标签中添加类名“disabled” “.disabled”样式不会禁止按钮的默认行为，比如说提交和重置行为等。如果想要让这样的禁用按钮也能禁止按钮的默认行为，则需要通过JavaScript这样的语言来处理。对于标签也存在类似问题，如果通过类名“.disable”来禁用按钮，其链接行为是无法禁止。而在元素标签中添加“disabled”属性的方法是可以禁止元素的默认行为的。 12&lt;button class="btn btn-primary btn-block" type="button" disabled="disabled"&gt;通过disabled属性禁用按钮&lt;/button&gt; &lt;button class="btn btn-primary btn-block disabled" type="button"&gt;通过添加类名disabled禁用按钮&lt;/button&gt; 图像bootstrap提供如下几种图像类 img-responsive：响应式图片，主要针对于响应式设计 img-rounded：圆角图片 img-circle：圆形图片 img-thumbnail：缩略图片 1234567891011121314151617181920212223242526&lt;div class="container"&gt; &lt;div class="row"&gt; &lt;div class="col-sm-4"&gt; &lt;img alt="140x140" src="http://placehold.it/140x140"&gt; &lt;div&gt;默认图片&lt;/div&gt; &lt;/div&gt; &lt;div class="col-sm-4"&gt; &lt;img class="img-rounded" alt="140x140" src="http://placehold.it/140x140"&gt; &lt;div&gt;圆角图片&lt;/div&gt; &lt;/div&gt; &lt;div class="col-sm-4"&gt; &lt;img class="img-circle" alt="140x140" src="http://placehold.it/140x140"&gt; &lt;div&gt;圆形图片&lt;/div&gt; &lt;/div&gt; &lt;div class="row"&gt; &lt;div class="col-sm-6"&gt; &lt;img class="img-thumbnail" alt="140x140" src="http://placehold.it/140x140"&gt; &lt;div&gt;缩略图&lt;/div&gt; &lt;/div&gt; &lt;div class="col-sm-6"&gt; &lt;img class="img-responsive" alt="140x140" src="http://placehold.it/140x140" /&gt; &lt;div&gt;响应式图片&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 图标bootstrap提供了近200个不同的icon图片，由glyphicons.com网站提供并免费授权给bootstrap框架使用 1234&lt;span class="glyphicon glyphicon-search"&gt;&lt;/span&gt;&lt;span class="glyphicon glyphicon-asterisk"&gt;&lt;/span&gt;&lt;span class="glyphicon glyphicon-plus"&gt;&lt;/span&gt;&lt;span class="glyphicon glyphicon-cloud"&gt;&lt;/span&gt; runoob的glyphicons的图标索引中文官网的glyphicons的图标索引 可以在button内部使用这些图标 123&lt;button type="button" class="btn btn-default btn-xs"&gt; &lt;span class="glyphicon glyphicon-user"&gt;&lt;/span&gt; User&lt;/button&gt;]]></content>
      <categories>
        <category>bootstrap</category>
      </categories>
      <tags>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery]]></title>
    <url>%2F2019%2F06%2F23%2FjQuery%2F</url>
    <content type="text"><![CDATA[jQuery简介jQuery是一个JS函数库，包含以下功能 HTML元素选取和操作 CSS操作 HTML事件函数 JS特效和动画 HTML DOM遍历和修改 AJAX Utilities CDN引用jQuery 1234&lt;head&gt;&lt;script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"&gt;&lt;/script&gt;&lt;/head&gt; jQuery语法$(selector).action() e.g. $(this).hide()：隐藏当前元素$(&quot;p&quot;).hide()：隐藏所有&lt;p&gt;元素$(&quot;p.test&quot;).hide()：隐藏所有&lt;p class=&quot;test&quot;&gt;的元素$(&quot;#test&quot;).hide()：隐藏所有id=&quot;test&quot;元素 文档就绪事件12345$(document).ready(function()&#123; // 开始写 jQuery 代码... &#125;); 当文档完全加载完成后再运行jQuery代码，等价于下面的代码 12345$(function()&#123; // 开始写 jQuery 代码... &#125;); jQuery选择器 元素选择器：$(&quot;p&quot;) #id选择器：$(&quot;#yourID&quot;) .class选择器：$(&quot;.yourClass&quot;) jQuery事件 e.g. 123$("p").click(function()&#123; // 动作触发后执行的代码!!&#125;); jQuery效果隐藏/显示hide() &amp; show()12$(selector).hide(speed,callback);$(selector).show(speed,callback); 两个参数都是可选的，第一个参数是隐藏/显示的速度，可以取”slow”,”fast”或毫秒，第二个参数callback是隐藏或显示完成后执行的函数名称 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt;$(document).ready(function()&#123; $("#hide").click(function()&#123; $("p").hide(); &#125;); $("#show").click(function()&#123; $("p").show(); &#125;);&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;如果你点击“隐藏” 按钮，我将会消失。&lt;/p&gt;&lt;button id="hide"&gt;隐藏&lt;/button&gt;&lt;button id="show"&gt;显示&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; toggle()toggle()方法显示被隐藏的元素，隐藏已显示的元素 1$(selector).toggle(speed,callback); 淡入淡出fadeTo()允许渐变为给定的不透明度，参数speed为必需的，为渐变速度，参数opacity为透明度，也是必需的（值介于0与1之间） 1234$(selector).fadeIn(speed,callback); // 淡入已隐藏元素$(selector).fadeOut(speed,callback);$(selector).fadeToggle(speed,callback);$(selector).fadeTo(speed,opacity,callback); 滑动123$(selector).slideDown(speed,callback); // 向下滑动$(selector).slideUp(speed,callback); // 向上滑动$(selector).slideToggle(speed,callback); 动画1$(selector).animate(&#123;params&#125;,speed,callback); 必需参数params定义形成动画的CSS属性 e.g. 1234// div元素右移250像素$("button").click(function()&#123; $("div").animate(&#123;left:'250px'&#125;);&#125;); 停止动画1$(selector).stop(stopAll,goToEnd); 可选的 stopAll 参数规定是否应该清除动画队列。默认是 false，即仅停止活动的动画，允许任何排入队列的动画向后执行可选的 goToEnd 参数规定是否立即完成当前动画。默认是 false 链123$("#p1").css("color","red") .slideUp(2000) .slideDown(2000); 可以在相同元素依次运行多条jQuery命令 jQuery HTML捕获获得内容-text(),html(),val() text()：设置或返回所选元素的文本内容 html()：设置或返回所选元素的内容（包括HTML标记） val()：设置或返回表单字段的值 获取属性-attr()e.g. 1234// 获取链接中href属性的值$("button").click(function()&#123; alert($("#yourAnchorID").attr("href"));&#125;); 设置设置内容同样使用text(),html(),val() 1234567891011$(document).ready(function()&#123; $("#btn1").click(function()&#123; $("#test1").text("Hello world!"); &#125;); $("#btn2").click(function()&#123; $("#test2").html("&lt;b&gt;Hello world!&lt;/b&gt;"); &#125;); $("#btn3").click(function()&#123; $("#一个输入框的ID").val("改变的输入框内的值"); &#125;);&#125;); 可以通过回调函数设置 1234567891011$("#btn1").click(function()&#123; $("#test1").text(function(i,origText)&#123; return "旧文本: " + origText + " 新文本: Hello world! (index: " + i + ")"; &#125;);&#125;); $("#btn2").click(function()&#123; $("#test2").html(function(i,origText)&#123; return "旧 html: " + origText + " 新 html: Hello &lt;b&gt;world!&lt;/b&gt; (index: " + i + ")"; &#125;);&#125;); 设置属性同样通过attr()设置 123456$("button").click(function()&#123; $("#yourAnchorID").attr(&#123; "href" : "http://www.runoob.com/jquery", "title" : "jQuery 教程" &#125;);&#125;); attr同样有回调函数，回调函数有两个参数：被选元素列表中当前元素的下标，以及原始（旧的）值。然后以函数新值返回您希望使用的字符串 12345$("button").click(function()&#123; $("#yourAnchorID").attr("href", function(i,origValue)&#123; return origValue + "/jquery"; &#125;);&#125;); 添加元素 append() - 在被选元素的结尾插入内容 prepend() - 在被选元素的开头插入内容 after() - 在被选元素之后插入内容 before() - 在被选元素之前插入内容 e.g. 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt;$(document).ready(function()&#123; $("#btn1").click(function()&#123; $("p").append(" &lt;b&gt;追加文本&lt;/b&gt;。"); &#125;); $("#btn2").click(function()&#123; $("ol").append("&lt;li&gt;追加列表项&lt;/li&gt;"); &#125;);&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;这是一个段落。&lt;/p&gt;&lt;p&gt;这是另外一个段落。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;List item 1&lt;/li&gt;&lt;li&gt;List item 2&lt;/li&gt;&lt;li&gt;List item 3&lt;/li&gt;&lt;/ol&gt;&lt;button id="btn1"&gt;添加文本&lt;/button&gt;&lt;button id="btn2"&gt;添加列表项&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 删除元素 remove() - 删除被选元素（及其子元素） empty() - 从被选元素中删除子元素 jQuery remove() 方法也可接受一个参数，允许您对被删元素进行过滤$(&quot;p&quot;).remove(&quot;.italic&quot;);删除 class=”italic” 的所有 元素 CSS类 addClass() - 向被选元素添加一个或多个类 removeClass() - 从被选元素删除一个或多个类 toggleClass() - 对被选元素进行添加/删除类的切换操作 css() - 设置或返回样式属性 可以指定多个类，也可以选取多个元素，对多个类，用空格分隔，对多个元素，用逗号分隔 12345678910// 多个元素$("button").click(function()&#123; $("h1,h2,p").addClass("blue"); $("div").addClass("important");&#125;);// 多个类，分别为important和blue$("button").click(function()&#123; $("body div:first").addClass("important blue");&#125;); css()方法设置或返回被选元素的一个或多个样式属性 返回指定CSS属性的值$(&quot;p&quot;).css(&quot;background-color&quot;); 设置指定CSS属性的值$(&quot;p&quot;).css(&quot;background-color&quot;,&quot;yellow&quot;); 设置多个CSS属性$(&quot;p&quot;).css({&quot;background-color&quot;:&quot;yellow&quot;,&quot;font-size&quot;:&quot;200%&quot;}); 尺寸 width() height() innerWidth() innerHeight() outerWidth() outerHeight() jQuery遍历祖先 parent()：直接父元素 parents()：所有祖先元素，可以通过参数过滤 parentsUntil()：通过参数选出参数与调用者之间的所有祖先元素 后代 children()：直接子元素，同样可以过滤 find()：一路向下直到最后一个后代，同样可以过滤 同胞 siblings()：所有同胞，可以过滤 next()：下一个同胞，只会返回一个元素 nextAll()：所有跟随的同胞 nextUntil()：给定参数之间的所有跟随同胞 prev()：同上，区别是往前找同胞 prevAll()：同上，区别是往前找同胞 prevUntil()：同上，区别是往前找同胞 过滤 first()：返回被选元素的首个元素 last()：返回被选元素的最后一个元素 eq()：返回被选元素中带有指定索引号的元素 filter()：匹配这个标准的元素会被返回 not()：不匹配这个标准的元素会被返回 e.g. 1234567891011$(document).ready(function()&#123; $("div p").first();&#125;);$(document).ready(function()&#123; $("p").eq(1); // 注意索引号是从0开始，它选取第二个&lt;p&gt;元素&#125;);$(document).ready(function()&#123; $("p").filter(".url");&#125;); // 返回带有类名"url"的所有&lt;p&gt;元素 jQuery Ajaxload()方法load方法从服务器加载数据，并把返回的数据放入被选元素中 1$(selector).load(URL,data,callback); 必需的 URL 参数规定您希望加载的 URL可选的 data 参数规定与请求一同发送的查询字符串键/值对集合可选的 callback 参数是 load() 方法完成后所执行的函数名称 get()和post()方法1$.get(URL,callback); 必需的 URL 参数规定您希望请求的 URL可选的 callback 参数是请求成功后所执行的函数名 1$.post(URL,data,callback); 必需的 URL 参数规定您希望请求的 URL可选的 data 参数规定连同请求发送的数据可选的 callback 参数是请求成功后所执行的函数名 e.g. 12345678910$("button").click(function()&#123; $.post("/try/ajax/demo_test_post.php", &#123; name:"菜鸟教程", url:"http://www.runoob.com" &#125;, function(data,status)&#123; alert("数据: \n" + data + "\n状态: " + status); &#125;);&#125;);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2019%2F06%2F23%2F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[排序要求：熟记各个排序的排序过程，能写出代码 插入排序插入排序的基本思想是每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成 关键字：记录后移，相对有序 直接插入排序假定L[1]是一个已经排好序的子序列，将L[2]…L[n]依次插入到已排好序的子序列即可。需要进行的操作就是在已排序子序列有k-1个元素的时候(k初始为2)，判断L[k-1]&lt;L[k]，如果是，令L[0]=L[k]，从L[k-1]开始进行记录后移(L[k-1]移到L[k]，依次类推)，直到L[t]&gt;L[0]，就把L[0]插入到L[t+1]即可 1234567891011void InsertSort(ElemType A[], int n) &#123; int i, j; // i: 待排元素 for (i = 2; i &lt;= n; i++) if (A[i].key &lt; A[i - 1].key) &#123; A[0] = A[i]; // 0号哨兵 for (int j = i - 1; A[0].key &lt; A[j].key; --j) A[j + 1] = A[j]; // 记录后移 A[j + 1] = A[0]; &#125;&#125; 评价平均时间复杂度O(n^2)，最差时间复杂度也是O(n^2)，最好是O(n)，稳定，适用于顺序存储和链式存储的线性表 折半插入排序对数据量比较少的排序表往往有更好的性能它把比较和移动分离，先折半查找出元素待插入位置，然后统一地移动待插入位置之后的所有元素 12345678910111213141516171819void InsertSort(ElemType A[], int n) &#123; int i, j, low, high, mid; for (i = 2; i &lt;= n; i++) &#123; A[0] = A[i]; // 哨兵 low = 1; high = i - 1; while (low &lt;= high) &#123; mid = (low + high) / 2; if (A[mid].key &lt; A[0].key) low = mid + 1; else high = mid - 1; &#125; // high此时为有序序列中A[i].key的直接前驱 for (j = i - 1; j &gt;= high + 1; j--) &#123; A[j + 1] = A[j]; &#125; A[high + 1] = A[0]; &#125;&#125; 评价时间复杂度仍为O(n^2)，稳定 希尔排序基本思想：将待排序列表分割为若干形如L[i, i+d, i+2d, …, i+kd]的特殊子表，然后分别进行直接插入排序，当整个表中元素已”基本有序”的时候，再对全体记录进行一次直接插入排序 实际上，希尔排序就是把每个间隔dk的序列进行插入排序，排完之后dk=dk/2，然后继续排序，依次循环直至dk=1时整个序列都是有序的 1234567891011void ShellSort(ElemType A[], int n) &#123; for (int dk = n / 2; dk &gt;= 1; dk = dk / 2) &#123; for (int i = dk + 1; i &lt;= n; ++i) if (A[i].key &lt; A[i - dk].key) &#123; // 判断是否需要把A[i]插入到有序增量子表 A[0] = A[i]; // 0号元素作暂存 for (j = i - dk; j &gt; 0 &amp;&amp; A[0].key &lt; A[j].key; j -= dk) A[j + dk] = A[j]; A[j + dk] = A[0]; &#125; &#125;&#125; 评价算法平均时间复杂度O(n^1.3)，最坏情况是O(n^2)，是不稳定的排序算法 交换排序交换是指根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置 关键字：最终位置 冒泡排序基本思想：假设待排序表长为n，从后往前（或从前往后）两两比较相邻元素的值，若为逆序（A[i-1]&gt;A[i]），则交换它们，直到序列比较完毕，称为一趟冒泡，结果是将最小的元素交换到待排序列的第一个位置（关键字最小的元素如气泡一样逐渐往上漂浮直到水面）。下一趟冒泡，最小元素就不再参与比较 注意冒泡排序是与插入排序不同的，插入排序是把待排序的记录插入到前面的有序区，此时整个序列分为三部分：有序区，待插入记录，无序区，插排的操作是比较，记录后移，插入到对应位置，i为待插入记录，i之前为有序区，i之后为无序区而冒泡排序则是把最小的元素往前冒泡（与前面的元素交换），直到冒泡到第0个位置，然后次小元素，以此类推冒泡排序产生的有序子序列是全局有序的，对应所有元素的关键字的位置必定是全局位置，这一点与插入排序不同 123456789101112void BubbleSort(ElemType A[], int n) &#123; for (int i = 0; i &lt; n - 1; i++) &#123; Status flag = FALSE; for (int j = n - 1; j &gt; i; j--) &#123; if (A[j - 1].key &gt; A[j].key) &#123; swap(A[j - 1], A[j]); flag = TRUE; &#125; &#125; if (flag == FALSE) return; &#125;&#125; 评价平均与最坏时间复杂度都是O(n^2)，空间复杂度是O(1)，是稳定的排序算法 快速排序快排是对冒泡排序的一种改进，基本思想是基于分治法，在待排序表L[1..n]中任取一个元素pivot作为基准，通过一趟排序将待排序表划分为独立的两部分L[1…k-1]和L[k+1…n]，其中L[1…k-1]所有元素都小于pivot，L[k+1…n]所有元素都大于pivot，此时pivot就已经在其最终位置k上了，这个过程为一趟快速排序，而后分别递归地对两个子表重复上述过程，直到每部分内只有一个元素或空为止，即所有元素都放在其最终位置上 对快排过程的理解最好是基于思想看代码，它总有一个位置的元素是暂时无用的，例如排序开始前的low，第一次把A[low]=A[high]之后的high，第一次把A[high]=A[low]之后的low，直到high==low，此时low就是pivot的位置 1234567891011121314151617181920212223void QuickSort(ElemType A[], int low, int high)&#123; if (low &lt; high) &#123; int pivotpos = Partition(A, low, high); QuickSort(A, low, pivotpos - 1); QuickSort(A, pivotpos + 1, high); &#125;&#125;int Partition(ElemType A[], int low, int high)&#123; ElemType pivot = A[low]; while (low &lt; high) &#123; while (low &lt; high &amp;&amp; A[high] &gt;= pivot) --high; A[low] = A[high]; while (low &lt; high &amp;&amp; A[low] &lt;= pivot) ++low; A[high] = A[low]; &#125; A[low] = pivot; return low;&#125; 评价空间上平均O(log2(n))，最坏O(n)时间上平均O(log2(n))，最坏情况O(n^2) 是不稳定的排序算法 选择排序选择排序的基本思想是：每一趟（如第i趟）在后面n-i+1个待排序元素中选取关键字最小的元素，作为有序子序列的第i个元素，直到第n-1趟做完，待排序元素只剩下一个，就不用再选了 简单选择排序12345678910void SelectSort(ElemType A[], int n)&#123; for (i = 0; i &lt; n - 1; i++) &#123; min = i; for (j = i + 1; j &lt; n; j++) if (A[j] &lt;A[min]) min = j; if (min != i) swap(A[i], A[min]); &#125;&#125; 评价简单选择排序是不稳定的排序方法，空间效率O(1)，时间效率O(n^2) 堆排序堆是一棵完全二叉树，它的定义如下：n个关键字序列L[1…n]称为堆，当且仅当该序列满足：L[i]&lt;=L[2i]且L[i]&lt;=L[2i+1]（称为小顶堆）或L[i]&gt;=L[2i]且L[i]&gt;=L[2i+1]（称为大顶堆） 大顶堆最大元素在根结点，且对任一非根结点，它的值小于等于其双亲结点值，小顶堆则相反 建立大顶堆算法如下： 12345678910111213141516171819void BuildMaxHeap(ElemType A[], int len) &#123; for (int i = len/2; i &gt; 0; i--) // 从i=[n/2] -- 1反复调整堆 AdjustDown(A, i, len);&#125;void AdjustDown(ElemType A[], int k, int len) &#123; // 下沉元素A[k] A[0] = A[k]; for (int i = k*2; i &lt;= len; i *= 2) &#123; if (i &lt; len &amp;&amp; A[i] &lt; A[i+1]) // 找出其较大的子结点，通过交换来向下筛 i++; if (A[0] &gt;= A[i]) break; else &#123; A[k] = A[i]; k = i; &#125; &#125; A[k] = A[0];&#125; 建堆的时间复杂度是O(n)，n为数组的长度 下面是堆排序算法 1234567void HeapSort(ElemType A[], int len) &#123; BuildMaxHeap(A, len); for (int i = len; i &gt; 1; i--) &#123; swap(A[i], A[1]); AdjustDown(A, 1, i-1); &#125;&#125; 堆也支持删除和插入操作，删除堆顶元素时，只需要把堆的最后一个元素与堆顶交换，然后对根结点下沉操作。插入元素时，先插入到堆的末端，然后对这个新结点上浮，上浮代码如下： 1234567891011void AdjustUp(ElemType A[], int k) &#123; // A[k]上浮 A[0] = A[k]; int i = k/2; while (i &gt; 0 &amp;&amp; A[i] &lt; A[0]) &#123; A[k] = A[i]; k = i; i = k/2; &#125; A[k] = A[0];&#125; 评价堆排序空间复杂度O(1)，时间复杂度O(nlogn)（建堆O(n)，每次调整O(h)），是不稳定的排序算法 归并排序和基数排序归并排序归并指将两个或以上的有序表组合成一个新的有序表 空间复杂度O(n)，因为新建了一个辅助数组时间复杂度O(nlogn) 基数排序 基数排序采用多关键字的思想，借助分配和收集两种操作对单逻辑关键字进行排序，分为最高位优先(MSD)排序和最低位优先(LSD)排序 结点aj由d元组(kj(d-1),kj(d-2),…,kj(0))组成，r为基数（对于十进制，r=10） 空间复杂度O(r)时间复杂度O(d*(n+r)) 内部排序的算法比较 外部排序的概念将待排序记录存储在外存上，排序时再把数据一部分一部分调入内存进行排序，需要多次内存外存的交换，对外存文件的记录排序后结果仍然被放到原有文件中，这样的排序称为外部排序]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>插入排序</tag>
        <tag>希尔排序</tag>
        <tag>基数排序</tag>
        <tag>快速排序</tag>
        <tag>堆排序</tag>
        <tag>归并排序</tag>
        <tag>选择排序</tag>
        <tag>冒泡排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC04-AJAX&JSON处理,拦截器]]></title>
    <url>%2F2019%2F06%2F15%2FSpringMVC04-AJAX%26JSON%E5%A4%84%E7%90%86%2C%E6%8B%A6%E6%88%AA%E5%99%A8%2F</url>
    <content type="text"><![CDATA[SpringMVC04-AJAX&amp;JSON处理,拦截器源码 AJAX&amp;JSON处理AJAX处理可以去看AJAX那篇BLOG，只需要通过HttpServletResponse对象实例发送非视图的响应回去即可 SpringMVC处理JSON数据一定要知道：服务器和客户端传递的是JSON串，而不是JSON对象！！！ 如果用到JSON，最好还是去 学一下Fastjson 导入JAR包 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.58&lt;/version&gt;&lt;/dependency&gt; 发送和接收JSON前端接收JSON很简单，通过 var text = xmlHttp.responseText; // 返回的是一个json字符串 接收JSON字符串，然后调用eval方法即可得到JSON对象 var user = eval(&quot;(&quot; + text + &quot;)&quot;);，需要注意，如果发送的是GET请求，浏览器会下载该JSON格式，如果发送的是POST请求，它才能正常执行，我也不清楚为什么 服务器通过@ResponseBody注解，返回对象即可，转换器会把该对象转换成JSON对象，同理，对于前端传来的JSON串，也会解析成对应参数 12345678910111213141516171819202122232425262728&lt;!-- 摘自https://www.w3cschool.cn/fastjson/fastjson-httpmessageconverter.html --&gt;&lt;!-- JSON配置，配置json转换器 --&gt;&lt;bean id="fastJsonConfig" class="com.alibaba.fastjson.support.config.FastJsonConfig"&gt; &lt;!-- Default charset --&gt; &lt;property name="charset" value="UTF-8" /&gt; &lt;!-- Default dateFormat --&gt; &lt;property name="dateFormat" value="yyyy-MM-dd HH:mm:ss" /&gt; &lt;!-- Class Level SerializeFilter --&gt;&lt;/bean&gt;&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;bean class="com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter"&gt; &lt;!-- MediaTypes --&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;application/json&lt;/value&gt; &lt;value&gt;text/plain&lt;/value&gt; &lt;value&gt;application/x-www-form-urlencoded&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- FastJsonConfig --&gt; &lt;property name="fastJsonConfig" ref="fastJsonConfig" /&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt;&lt;mvc:default-servlet-handler /&gt; 一定要注意，前端发送过来的并不是JSON对象，而是JSON字符串，即要通过 var jsonStr = JSON.stringify(json) 转换为JSON字符串，然后添加请求头 xmlHttp.setRequestHeader(&quot;Content-Type&quot;, &quot;application/json&quot;); 注意发送JSON串时，请求头是application/json，然后 xmlHttp.send(jsonStr); 直接发送该字符串；前端接收服务器传来的JSON串时，要调用eval方法执行该串转为JSON对象 123456789101112131415161718192021222324252627282930313233&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type="text/javascript" &gt; function createXMLHttpRequest() // 略 window.onload = function (ev) &#123; var btn = document.getElementById("btn"); btn.onclick = function (ev1) var json = &#123;"name":"zhangsan","id":18,"password":"123456"&#125;; var jsonStr = JSON.stringify(json); var xmlHttp = createXMLHttpRequest(); xmlHttp.open("POST", "/jsontest.do", true); xmlHttp.setRequestHeader("Content-Type", "application/json"); xmlHttp.send(jsonStr); // 直接发送 xmlHttp.onreadystatechange = function () &#123; // xmlHttp的任意一种状态变化都会调用本方法 if (xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200) &#123; // 状态码200表示服务器已成功处理了请求 var text = xmlHttp.responseText; // 返回的是一个json字符串 var user = eval("(" + text + ")"); // eval函数是用JavaScript执行其参数的内容，需要注意的是要加圆括号括起来 var s = user.id + ", " + user.name + ", " + user.password; var h1 = document.getElementById("h1"); h1.innerText = s; &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button id="btn"&gt;click here&lt;/button&gt;&lt;h1 id="h1"&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 服务器对应方法添加@ResponseBody注解，以及接收的参数添加@RequestBody注解即可，如下，转换器把前端发送过来的JSON串转换为user对象，然后把user对象经转换器转换为JSON串发送回前端 12345678// testjson测试客户端发送JSON数据到服务器接收// 接收前端传来的JSON参数，并原样返回给前端@RequestMapping("/jsontest")@ResponseBodypublic User jsontest(HttpServletRequest request, HttpServletResponse response, @RequestBody User user) throws IOException &#123; // 此时服务器会把json串转换为user对象 return user; // 直接返回user对象即可，转换器会自动转换为JSON串&#125; 拦截器java里的拦截器是动态拦截Action调用的对象。它提供了一种机制可以使开发者可以定义在一个action执行的前后执行的代码，也可以在一个action执行前阻止其执行，同时也提供了一种可以提取action中可重用部分的方式。在AOP（Aspect-Oriented Programming）中拦截器用于在某个方法或字段被访问之前，进行拦截然后在之前或之后加入某些操作。 实现 实现HandlerInterceptor接口 1234567891011121314151617181920212223public class MyInterceptor implements HandlerInterceptor &#123; // 在请求处理的方法之前执行 // 如果返回true，执行下一个拦截器，返回false，不执行下一个拦截器，如果返回false，使用HttpServletRequest或HttpServletResponse转发或重定向，如下注释 @Override public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123; System.out.println("--------处理前-------"); return true; //httpServletResponse.sendRedirect(httpServletRequest.getContextPath()+"/index.jsp"); //return false; &#125; // 在请求处理的方法之后执行 @Override public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123; System.out.println("--------处理后-------"); &#125; // 在DispatcherServlet处理后执行---清理工作 @Override public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123; &#125;&#125; 配置拦截器，在Spring配置文件中配置 123456789101112&lt;!-- 拦截器的配置 --&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!-- mapping拦截某一路径，比如/admin/* --&gt; &lt;!-- /**表示该路径下所有路径及其子路径 如果是/admin/*，拦截的是/admin/add,/admin/list，而/admin/user/add之类的孙子路径不能拦截 --&gt; &lt;!-- &lt;mvc:mapping path="/**"/&gt; --&gt; &lt;mvc:mapping path="/admin/*" /&gt; &lt;bean class="com.mkl.interceptor.MyInterceptor" /&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 被拦截Controller的编写 123456789@Controller@RequestMapping("/admin")public class InterceptorController &#123; @RequestMapping("/interceptor") public String hello() &#123; System.out.println("hello controller"); return "index"; &#125;&#125; 当访问http://localhost:8080/admin/interceptor.do的时候，控制台输出如下 拦截器应用-登陆拦截器先说功能：index.do转交给login.jsp，通过login.jsp输入用户名密码点击submit登录，点击submit后交由login.do处理，如果用户名密码均为admin，则进入登录成功页面，否则重定向回index.do拦截器的任务是：当session没有用户对象时，就拦截除了index.do的请求，当有用户对象，就不拦截，注意，因为login.do负责验证用户名密码，并为session添加user对象的任务，所以拦截器不应该对其进行拦截，如果拦截了，那么只要提交表单，交由login.do处理时，还没进入login.do的代码段，就会被拦截器重定位回index.do LoginInterceptor 123456789101112131415161718192021222324252627282930313233343536public class LoginInterceptor implements HandlerInterceptor &#123; public void setAllowedPass(List&lt;String&gt; allowedPass) &#123; this.allowedPass = allowedPass; &#125; private List&lt;String&gt; allowedPass; @Override public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123; String url = httpServletRequest.getRequestURL().toString(); User user = (User) httpServletRequest.getSession().getAttribute("user"); // 当session中的user属性不为空，表示有用户对象，此时不拦截 if (user != null) &#123; return true; &#125; // 有些内容不登录是看不到的，就需要拦截器拦截，只有用户登录了，才能进入这些页面，否则就重定向回登录页面 for (String temp : allowedPass) &#123; if (url.endsWith(temp)) &#123; return true; &#125; &#125; httpServletResponse.sendRedirect("/index.do"); return false; &#125; @Override public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123; &#125;&#125; LoginController 1234567891011121314151617181920212223242526272829@Controllerpublic class LoginController &#123; @RequestMapping("/index") public String index() &#123; // 跳转到login.jsp,login.jsp表单交由login.do处理 return "login"; &#125; @RequestMapping("/login") public String login(User user, HttpSession session) &#123; if ("admin".equals(user.getName()) &amp;&amp; "admin".equals(user.getPwd())) &#123; session.setAttribute("user", user); return "redirect:/success.do"; &#125; return "redirect:/index.do"; &#125; @RequestMapping("/success") public String success() &#123; return "loginsuccess"; &#125; // 用于测试拦截器，如果拦截器生效，输入http://localhost:8080/add.do并不会转发到index.jsp，而是重定向回index.do，且控制台不会输出add @RequestMapping("/add") public String add() &#123; return "index"; &#125;&#125; 登录拦截器的编写 123456789101112&lt;!-- 登陆拦截器 --&gt;&lt;mvc:interceptor&gt; &lt;mvc:mapping path="/**" /&gt; &lt;bean class="com.mkl.interceptor.LoginInterceptor" &gt; &lt;property name="allowedPass"&gt; &lt;list&gt; &lt;value&gt;index.do&lt;/value&gt; &lt;value&gt;login.do&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/mvc:interceptor&gt; login.jsp 12345678910111213&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="login.do" method="post"&gt; name:&lt;input type="text" name="name" /&gt; password:&lt;input type="password" name="pwd" /&gt; &lt;input type="submit" value="submit"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; loginsuccess.jsp略，只有一个登录成功的标志]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>拦截器</tag>
        <tag>AJAX</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX]]></title>
    <url>%2F2019%2F06%2F15%2Fajax%2F</url>
    <content type="text"><![CDATA[Ajax源码地址 简介是什么ajax全称asynchronnous javascript and xml：异步的js和xml它能使用js异步访问服务器使用ajax局部刷新，服务器不用再响应整个页面，而只是数据，可以响应text纯文本，xml和json 异步交互和同步交互同步：发一个请求，就要等待服务器的响应结束，然后才能发第二个请求；且他刷新的是整个页面，即服务器响应的是整个html页面异步：发一个请求后无需等待服务器响应，然后就可以发第二个请求；他可以使用js接收服务器的响应，然后用js来局部刷新，即服务器可以只响应xml或json ajax应用场景 百度搜索框输入内容，会有下拉框联想词显示，这个是ajax的作用 用户注册时，检验用户名是否被注册过，这个也是ajax的作用 优缺点优点 异步交互，增强用户体验 性能：因为服务器无需再响应整个页面，只需响应部分页面 缺点 ajax不能应用在所有场景 ajax无端增多了对服务器的访问次数，为服务器带来了压力 ajax发送异步请求四步操作 第一步，得到XMLHttpRequest对象ajax最重要的对象：XMLHttpRequest，第一步就是得到这个对象 大多数浏览器都支持var xmlHttp = new XMLHttpRequest(); IE6.0：var xmlHttp = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); IE5.5及更早版本的IE：var xmlHttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); 编写创建XMLHttpRequest对象的函数 123456789101112131415function createXMLHttpRequest() &#123; try &#123; return new XMLHttpRequest(); &#125; catch (e) &#123; try &#123; return new ActiveXObject("Msxml2.XMLHTTP"); &#125; catch (e) &#123; try &#123; new ActiveXObject("Microsoft.XMLHTTP"); &#125; catch (e) &#123; throw e; &#125; &#125; &#125;&#125; 第二步，打开与服务器的连接xmlHttp.open();用于打开与服务器的连接，需要三个参数： 请求方式：GET或POST 请求的URL：指定服务器端资源，例如：/day23_1/Aservlet 请求是否为异步：如果为true就发送异步请求 如：xmlHttp.open(&quot;GET&quot;, &quot;/day23_1/AServlet&quot;, true); 第三步，发送请求xmlHttp.send(null);用于发送请求，如果不添加null，可能部分浏览器无法发送参数其实就是请求体内容，如果是GET，就要给出null，如果是POST，就是请求参数，如xmlHttp.send(&quot;username=zhangSan&amp;password=123&quot;); 第四步，处理响应在xmlHttp对象的onreadystatechange事件上注册监听器 xmlHttp对象一共有5个状态 0状态：刚创建，还没有调用open方法 1状态：请求已开始，open()方法已调用，send()方法还没有调用 2状态：请求发送完成，调用完send()方法 3状态：服务器已经开始响应，但响应是否结束未知 4状态：服务器响应结束，通常只关心这个状态 得到xmlHttp对象的状态：var state = xmlHttp.readyState; // 可能是0,1,2,3,4,得到服务器响应的状态码var status = xmlHttp.status; // 如200,404,500得到服务器响应的文本格式的内容var content = xmlHttp.responseText;得到服务器响应的xml响应的内容var content = xmlHttp.responseXML; // 它是Document对象 综上，处理响应可以通过监听器实现，如下： 12345xmlHttp.onreadystatechange = function() &#123; // xmlHttp的任意一种状态变化都会调用本方法 if (xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200) &#123; // 状态码200表示服务器已成功处理了请求 var text = xmlHttp.responseText; // 处理响应 &#125; Ajax案例第一例：Hello World主要实现的功能是ajax发送一个异步GET请求到服务器的/hello.do，然后服务器返回字符串（而不是view）给前端，并显示在h1上 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type="text/javascript"&gt; function createXMLHttpRequest() &#123; try &#123; return new XMLHttpRequest(); &#125; catch (e) &#123; try &#123; return new ActiveXObject("Msxml2.XMLHTTP"); &#125; catch (e) &#123; try &#123; new ActiveXObject("Microsoft.XMLHTTP"); &#125; catch (e) &#123; throw e; &#125; &#125; &#125; &#125; window.onload = function (ev) &#123; var btn = document.getElementById("btn"); btn.onclick = function (ev1) &#123; var xmlHttp = createXMLHttpRequest(); xmlHttp.open("GET", "/hello.do", true); xmlHttp.send(null); xmlHttp.onreadystatechange = function () &#123; // xmlHttp的任意一种状态变化都会调用本方法 if (xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200) &#123; // 状态码200表示服务器已成功处理了请求 var text = xmlHttp.responseText; var h1 = document.getElementById("h1"); h1.innerText = text; &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id="btn"&gt;点击这里&lt;/button&gt; &lt;h1 id="h1"&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 12345@RequestMapping("/hello")public void hello(HttpServletResponse response) throws IOException &#123; response.getWriter().print("Hello, Ajax!!"); System.out.println("Hello Ajax!!");&#125; 第二例：发送POST请求 open：xmlHttp.open(&quot;POST&quot;, ...) 添加一步：设置Content-Type请求头，xmlHttp.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;); send：xmlHttp.send(&quot;username=zhangsan&amp;password=123&quot;); 主要实现的功能是，前端发送带参数的POST请求，服务器通过方法的参数得到这个参数，并输出到前端 1234567891011121314151617181920212223242526272829&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type="text/javascript"&gt; // createXMLHttpRequest()方法同上，略 window.onload = function (ev) &#123; var btn = document.getElementById("btn"); btn.onclick = function (ev1) &#123; var xmlHttp = createXMLHttpRequest(); xmlHttp.open("POST", "/post.do", true); xmlHttp.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"); xmlHttp.send("name=zhangsan&amp;password=123456"); xmlHttp.onreadystatechange = function () &#123; // xmlHttp的任意一种状态变化都会调用本方法 if (xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200) &#123; // 状态码200表示服务器已成功处理了请求 var text = xmlHttp.responseText; var h1 = document.getElementById("h1"); h1.innerText = text; &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button id="btn"&gt;点击这里&lt;/button&gt;&lt;h1 id="h1"&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 12345678// 处理POST请求，前端发来带参数的POST请求，负责处理该参数@RequestMapping("/post")public void post(HttpServletRequest request, HttpServletResponse response, User user) throws IOException &#123; response.setContentType("text/html;charset=utf-8"); // 处理响应编码问题 request.setCharacterEncoding("utf-8"); // 处理请求编码问题 System.out.println(user); response.getWriter().print("Post：" + user);&#125; 第三例：用户名是否被注册主要实现的功能是：当用户输入用户名，然后输入密码的时候，用户名输入框失去焦点，触发事件发送一个POST请求到服务器，返回判断该用户名是否被注册的消息（这里为了方便，只判断了用户名是否为admin） 12345678910111213141516171819202122232425262728293031323334&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type="text/javascript"&gt; // createXMLHttpRequest()方法同上，略 window.onload = function (ev) &#123; // 获取文本框，为它的失去焦点事件注册监听 var userEle = document.getElementById("usernameEle"); userEle.onblur = function (ev1) &#123; var xmlHttp = createXMLHttpRequest(); xmlHttp.open("POST", "/validate.do", true); xmlHttp.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"); xmlHttp.send("name=" + userEle.value); xmlHttp.onreadystatechange = function () &#123; // xmlHttp的任意一种状态变化都会调用本方法 if (xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200) &#123; // 状态码200表示服务器已成功处理了请求 var text = xmlHttp.responseText; var errorSpan = document.getElementById("errorSpan"); if (text == "1") errorSpan.innerText = "用户名已被注册！"; else errorSpan.innerText = "恭喜你，该用户名可用！" &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="" method="post"&gt; 用户名:&lt;input type="text" name="name" id="usernameEle" /&gt;&lt;span id="errorSpan"&gt;&lt;/span&gt;&lt;br/&gt; 密 码:&lt;input type="password" name="password"/&gt;&lt;br/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 123456789@RequestMapping("/validate")public void validate(HttpServletRequest request, HttpServletResponse response, User user) throws IOException &#123; response.setContentType("text/html;charset=utf-8"); // 处理响应编码问题 request.setCharacterEncoding("utf-8"); // 处理请求编码问题 String name = user.getName(); if (name.equalsIgnoreCase("admin")) &#123; response.getWriter().print("1"); &#125; else response.getWriter().print("0");&#125; 第四例：响应内容为XML如果需要响应XML的内容（即XML格式的字符串），服务器端需要设置响应头ContentType的值为：text/xml;charset=utf-8，response.setContentType(&quot;text/xml;charset=utf-8&quot;);，在前端中，XML被解析为document对象，可以分别读取它的节点属性等 主要实现的是点击按钮，服务器发送一个XML对象给前端，前端通过DOM处理得到各个节点和属性并输出 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type="text/javascript"&gt; // createXMLHttpRequest()方法同上，略 window.onload = function (ev) &#123; var btn = document.getElementById("btn"); btn.onclick = function (ev1) &#123; var xmlHttp = createXMLHttpRequest(); xmlHttp.open("GET", "/xml.do", true); xmlHttp.send(null); xmlHttp.onreadystatechange = function () &#123; // xmlHttp的任意一种状态变化都会调用本方法 if (xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200) &#123; // 状态码200表示服务器已成功处理了请求 var doc = xmlHttp.responseXML; // 这次获取的是responseXML，是一个document对象 var ele = doc.getElementsByTagName("student")[0]; var number = ele.getAttribute("number"); var name, age, gender; if (window.addEventListener) &#123; // 其他浏览器的支持 name = ele.getElementsByTagName("name")[0].textContent; age = ele.getElementsByTagName("age")[0].textContent; gender = ele.getElementsByTagName("gender")[0].textContent; &#125; else &#123; // IE的支持 name = ele.getElementsByTagName("name")[0].text; age = ele.getElementsByTagName("age")[0].text; gender = ele.getElementsByTagName("gender")[0].text; &#125; var text = number + ", " + name + ", " + age + ", " + gender; var h1 = document.getElementById("h1"); h1.innerText = text; &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button id="btn"&gt;点击这里&lt;/button&gt;&lt;h1 id="h1"&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314@RequestMapping("/xml")public void xml(HttpServletRequest request, HttpServletResponse response, User user) throws IOException &#123; response.setContentType("text/html;charset=utf-8"); // 处理响应编码问题 request.setCharacterEncoding("utf-8"); // 处理请求编码问题 String xml = "&lt;students&gt;" + "&lt;student number='ITCAST_1001'&gt;" + "&lt;name&gt;zhangsan&lt;/name&gt;" + "&lt;age&gt;18&lt;/age&gt;" + "&lt;gender&gt;male&lt;/gender&gt;" + "&lt;/student&gt;" + "&lt;/students&gt;"; response.setContentType("text/xml;charset=utf-8"); response.getWriter().print(xml);&#125; 第五例：省市联动主要实现的功能是选择省份后，市的下拉栏才出现，省份和城市用XML文件保存，需要使用JAVA来处理XML文件，并且要注意中文编码的问题使用一个Servlet来处理当页面加载完，从服务器获取并显示所有的省份，另外一个Servlet处理当选择省份后，下拉框出现对应的市 需要使用dom4j处理XML对象，导入jar包dom4j和jaxen 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;jaxen&lt;/groupId&gt; &lt;artifactId&gt;jaxen&lt;/artifactId&gt; &lt;version&gt;1.2.0&lt;/version&gt; &lt;type&gt;bundle&lt;/type&gt;&lt;/dependency&gt; 注意解决中文编码问题的办法：前端两次encodeURI，后端一次URLDecoder.decode(String, String) 保存省份和市的china.xml如下，这里为了方便，省略了很多 123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;china&gt; &lt;province name="广东"&gt; &lt;city&gt;广州&lt;/city&gt; &lt;city&gt;深圳&lt;/city&gt; &lt;city&gt;佛山&lt;/city&gt; &lt;/province&gt; &lt;province name="北京"&gt; &lt;city&gt;朝阳区&lt;/city&gt; &lt;city&gt;东城区&lt;/city&gt; &lt;city&gt;西城区&lt;/city&gt; &lt;/province&gt; &lt;province name="天津"&gt; &lt;city&gt;和平区&lt;/city&gt; &lt;city&gt;河东区&lt;/city&gt; &lt;city&gt;河西区&lt;/city&gt; &lt;/province&gt;&lt;/china&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type="text/javascript"&gt; // createXMLHttpRequest()方法，略 // 在文档加载完毕后发送请求得到所有省份名称，显示在&lt;select name="province"&gt; // 选择新的省份时，发送请求，得到xml文档，即&lt;province&gt;元素 // 解析xml文档，得到其中所有&lt;city&gt;，再得到每个&lt;city&gt;元素的内容，即市名，使用市名生成&lt;option&gt;，插入到&lt;select&gt; window.onload = function (ev) &#123; var province = document.getElementById("p"); var xmlHttp = createXMLHttpRequest(); xmlHttp.open("GET", "/province.do", true); xmlHttp.send(null); xmlHttp.onreadystatechange = function () &#123; // xmlHttp的任意一种状态变化都会调用本方法 if (xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200) &#123; // 状态码200表示服务器已成功处理了请求 var text = xmlHttp.responseText; var arr = text.split(","); for (var i = 0; i &lt; arr.length; i++) &#123; var op = document.createElement("option"); op.value = arr[i]; // value是该option选择后的标识符，相当于键值的键，textNode的值为值 var textNode = document.createTextNode(arr[i]); op.appendChild(textNode); province.appendChild(op); &#125; &#125; &#125;; // 选择省份后显示对应的市 province.onchange = function (ev) &#123; var xmlHttp = createXMLHttpRequest(); xmlHttp.open("POST", "/city.do", true); xmlHttp.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"); var pname = province.value; // 这是省份对应的名称，如广东，北京等 pname = encodeURI(pname); // 中文编码问题，前端两次encode，服务器一次decode pname = encodeURI(pname); xmlHttp.send("pname=" + pname); xmlHttp.onreadystatechange = function () &#123; // xmlHttp的任意一种状态变化都会调用本方法 if (xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200) &#123; // 状态码200表示服务器已成功处理了请求 // 把select的所有option移除，除了 ===请选择=== 这个 var citySelect = document.getElementById("c"); var optionList = citySelect.getElementsByTagName("option"); while (optionList.length &gt; 1) &#123; citySelect.removeChild(optionList[1]); &#125; var doc = xmlHttp.responseXML; // 获取XML对象 var cityList = doc.getElementsByTagName("city"); // 获取city标签 for (var i = 0; i &lt; cityList.length; i++) &#123; var cityEle = cityList[i]; if (window.addEventListener) &#123; // 其他浏览器的支持 var cityName = cityEle.textContent; &#125; else &#123; // IE的支持 var cityName = cityEle.text; &#125; var op = document.createElement("option"); op.value = cityName; var textNode = document.createTextNode(cityName); op.appendChild(textNode); citySelect.appendChild(op); &#125; &#125; &#125; &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;select name="province" id="p"&gt; &lt;option&gt;===请选择省===&lt;/option&gt; &lt;/select&gt; &lt;select name="city" id="c"&gt; &lt;option&gt;===请选择市===&lt;/option&gt; &lt;/select&gt; &lt;h1 id="h1" &gt; &lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// DOM4J处理XML文件主要步骤是先获得SAXReader对象，再通过InputStream读取xml文件，然后通过reader.read(inputStream)构建Document对象// 然后Element root = document.getRootElement()获得根节点，得到根节点之后就可以继续获得下属节点或属性等// 响应所有省份名称，使用逗号分隔@RequestMapping("/province")public void province(HttpServletRequest request, HttpServletResponse response) throws DocumentException, IOException &#123; response.setContentType("text/html;charset=utf-8"); // 处理响应编码问题 request.setCharacterEncoding("utf-8"); // 处理请求编码问题 SAXReader reader = new SAXReader(); InputStream inputStream = this .getClass().getResourceAsStream("/china.xml"); Document doc = reader.read(inputStream); Element root = doc.getRootElement(); // 获取根节点 List&lt;Element&gt; arrList = root.elements(); // 获取所有根节点的下属节点 List&lt;String&gt; attrList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; arrList.size(); i++) &#123; attrList.add(arrList.get(i).attributeValue("name")); // 获取属性name的值 &#125; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; arrList.size(); i++) &#123; sb.append(attrList.get(i)); if (i &lt; arrList.size() - 1) &#123; sb.append(","); &#125; &#125; response.getWriter().print(sb);&#125;// 获取省份名称，加载该省对应的&lt;province&gt;元素，把元素转换为字符串发送给客户端@RequestMapping("/city")public void city(HttpServletRequest request, HttpServletResponse response, String pname) throws IOException, DocumentException &#123; response.setContentType("text/html;charset=utf-8"); // 处理响应编码问题 request.setCharacterEncoding("utf-8"); // 处理请求编码问题 pname = URLDecoder.decode(pname, "utf-8"); // 中文编码问题，前端两次encode，服务器一次decode SAXReader reader = new SAXReader(); InputStream inputStream = this .getClass().getResourceAsStream("/china.xml"); Document doc = reader.read(inputStream); Element root = doc.getRootElement(); // 获取根节点 Iterator&lt;Element&gt; it = root.elementIterator(); while (it.hasNext()) &#123; Element province = it.next(); if (province.attribute("name").getValue().equals(pname)) &#123; String xmlStr = province.asXML(); // 返回的内容为xml时，一定要添加下面的内容，然后在前端获取时var doc = xmlHttp.responseXML; response.setContentType("text/xml;charset=utf-8"); response.getWriter().print(xmlStr); &#125; &#125;&#125; XStream是一个把JavaBean序列化为XML的小工具 使用XStream首先要添加依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;xpp3&lt;/groupId&gt; &lt;artifactId&gt;xpp3_min&lt;/artifactId&gt; &lt;version&gt;1.1.4c&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;xstream&lt;/groupId&gt; &lt;artifactId&gt;xstream&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt;&lt;/dependency&gt; 然后添加测试类Province和City和XStreamUtils 1234567891011121314151617181920212223242526272829303132333435363738394041424344// com.mkl.xstream.Province.javapublic class Province &#123; private String name; private List&lt;City&gt; cities = new ArrayList&lt;&gt;(); public void addCity(City city) &#123; cities.add(city); &#125; //getter, setter, constructor&#125;// com.mkl.xstream.City.javapublic class City &#123; private String name; private String description; //getter, setter, constructor&#125;// com.mkl.xstream.XStreamUtils.javapublic class XStreamUtils &#123; public List&lt;Province&gt; getProvinceList() &#123; Province p1 = new Province(); p1.setName("北京"); p1.addCity(new City("东城区", "DongChengQu")); p1.addCity(new City("朝阳区", "ChaoYangQu")); Province p2 = new Province(); p2.setName("广东"); p2.addCity(new City("广州市", "GuangZhou")); p2.addCity(new City("深圳市", "ShenZhen")); List&lt;Province&gt; provinceList = new ArrayList&lt;&gt;(); provinceList.add(p1); provinceList.add(p2); return provinceList; &#125;&#125; 测试方法和输出结果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public class TestXStream &#123; // 不使用别名，父标签为&lt;list&gt; // 对应的标签分别是&lt;com.mkl.xstream.Province&gt;, &lt;com.mkl.xstream.City&gt; @Test public void testXStream() &#123; XStreamUtils xStreamUtils = new XStreamUtils(); List&lt;Province&gt; provinceList = xStreamUtils.getProvinceList(); XStream xStream = new XStream(); String s = xStream.toXML(provinceList); System.out.println(s); &#125; // 对应输出结果如下，父标签是&lt;list&gt;，子标签为类的全限定名，它准确的通过对应的类和标签把所有的属性都列了出来 // 包括父标签使用的是&lt;list&gt;标签，集合属性也使用了标签&lt;cities&gt;，并在该标签的子标签列出对应集合的元素/*&lt;list&gt; &lt;com.mkl.xstream.Province&gt; &lt;name&gt;北京&lt;/name&gt; &lt;cities&gt; &lt;com.mkl.xstream.City&gt; &lt;name&gt;东城区&lt;/name&gt; &lt;description&gt;DongChengQu&lt;/description&gt; &lt;/com.mkl.xstream.City&gt; &lt;com.mkl.xstream.City&gt; &lt;name&gt;朝阳区&lt;/name&gt; &lt;description&gt;ChaoYangQu&lt;/description&gt; &lt;/com.mkl.xstream.City&gt; &lt;/cities&gt; &lt;/com.mkl.xstream.Province&gt; &lt;com.mkl.xstream.Province&gt; &lt;name&gt;广东&lt;/name&gt; &lt;cities&gt; &lt;com.mkl.xstream.City&gt; &lt;name&gt;广州市&lt;/name&gt; &lt;description&gt;GuangZhou&lt;/description&gt; &lt;/com.mkl.xstream.City&gt; &lt;com.mkl.xstream.City&gt; &lt;name&gt;深圳市&lt;/name&gt; &lt;description&gt;ShenZhen&lt;/description&gt; &lt;/com.mkl.xstream.City&gt; &lt;/cities&gt; &lt;/com.mkl.xstream.Province&gt;&lt;/list&gt;*/ // 使用别名 // 希望&lt;list&gt;为&lt;china&gt;, &lt;com.mkl.xstream.Province&gt;为&lt;province&gt;, &lt;com.mkl.xstream.City&gt;为&lt;city&gt; // 默认bean的属性会生成子标签，现在希望对应bean的属性可以生成标签的属性 // 把无用的Collection类型的属性如&lt;cities&gt;属性也删除 // 把不想要的City类的description属性也去除 @Test public void testXStreamNice() &#123; XStreamUtils xStreamUtils = new XStreamUtils(); List&lt;Province&gt; provinceList = xStreamUtils.getProvinceList(); XStream xStream = new XStream(); // 设置别名 xStream.alias("china", List.class); xStream.alias("province", Province.class); xStream.alias("city", City.class); // 把Province类型的name属性，生成&lt;province&gt;元素的属性 xStream.useAttributeFor(Province.class, "name"); // 去除&lt;cities&gt;这样的Collection类型的属性 xStream.addImplicitCollection(Province.class, "cities"); // 让City类的description属性不生成标签 xStream.omitField(City.class, "description"); String s = xStream.toXML(provinceList); System.out.println(s); &#125;/*&lt;china&gt; &lt;province name="北京"&gt; &lt;city&gt; &lt;name&gt;东城区&lt;/name&gt; &lt;/city&gt; &lt;city&gt; &lt;name&gt;朝阳区&lt;/name&gt; &lt;/city&gt; &lt;/province&gt; &lt;province name="广东"&gt; &lt;city&gt; &lt;name&gt;广州市&lt;/name&gt; &lt;/city&gt; &lt;city&gt; &lt;name&gt;深圳市&lt;/name&gt; &lt;/city&gt; &lt;/province&gt;&lt;/china&gt;*/&#125; JSONJSON是JS提供的一种数据交换格式 语法简介JSON的语法如下 括号{}指对象属性名必须要用双引号括起来属性值： null 数值 字符串 数组：使用[]括起来 boolean值：true和false 一个简单的应用JSON的例子var person = {&quot;name&quot;:&quot;zhangsan&quot;, &quot;age&quot;:18, &quot;gender&quot;:&quot;male&quot;} 服务器发送JSON数据，前端处理整合MVC的例子在SpringMVC04-AJAX&amp;JSON处理,拦截器这篇BLOG 需要注意的是，JSON也是JavaScript的一种类型，而服务器只能发送字符串回去，因此前端需要把该字符串解析为JSON对象，JavaScript有一个方法eval，可以使用JavaScript执行其方法体内的参数，使用如下：var s = eval(&quot;(&quot; + yourJSONString + &quot;)&quot;)，此时s就是一个JSON对象 一个hellojson的例子如下，点击按钮，服务器发送JSON格式的字符串到前端，前端对其解析处理得到JSON对象并输出该JSON格式的值 123456@RequestMapping("hellojson")public void hellojson(HttpServletResponse response) throws IOException &#123; String str = "&#123;\"name\":\"zhangsan\",\"age\":18,\"gender\":\"male\"&#125;"; // &#123;"name":"zhangsan","age":18,"gender":"male"&#125; response.getWriter().print(str); System.out.println(str);&#125; 1234567891011121314151617181920212223242526272829&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type="text/javascript" &gt; // createXMLHttpRequest()，略 window.onload = function (ev) &#123; var btn = document.getElementById("btn"); btn.onclick = function (ev1) &#123; var xmlHttp = createXMLHttpRequest(); xmlHttp.open("GET", "/hellojson.do", true); xmlHttp.send(null); xmlHttp.onreadystatechange = function () &#123; // xmlHttp的任意一种状态变化都会调用本方法 if (xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200) &#123; // 状态码200表示服务器已成功处理了请求 var text = xmlHttp.responseText; // 返回的是一个json字符串 var person = eval("(" + text + ")"); // eval函数是用JavaScript执行其参数的内容，需要注意的是要加圆括号括起来 var s = person.name + ", " + person.age + ", " + person.gender; var h1 = document.getElementById("h1"); h1.innerText = s; &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id="btn"&gt;click here&lt;/button&gt; &lt;h1 id="h1"&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 如果是前端发送JSON，服务器处理，要发送的是JSON串，则要设置方法为POST，请求头为xmlHttp.setRequestHeader(&quot;Content-Type&quot;, &quot;application/json&quot;);，然后直接发送该JSON串 xmlHttp.send(jsonStr);，详情见SpringMVC04-AJAX%JSON处理那篇BLOG JSON与XML比较可读性：XML比JSON更好解析难度：JSON本身就是JS对象，肯定比XML好流行度：XML已经流行多年，但AJAX领域中，JSON更受欢迎 javabean转换为json字符串：json-libjson-lib是过时的东西，最好使用fastjsonjson-lib可以把javabean转换为json字符串 maven依赖 123456&lt;dependency&gt; &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt; &lt;artifactId&gt;json-lib&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;classifier&gt;jdk15&lt;/classifier&gt; &lt;/dependency&gt; 核心类 JSONObject –&gt; Map –&gt; toString()方法转换为JSON串 –&gt; JSONObject.fromObject()方法传入已有Object JSONArray –&gt; List –&gt; toString()方法转换为JSON串 –&gt; JSONArray.fromObject()方法传入已有List JSONObject12345678910111213// mapJSONObject map = new JSONObject();map.put("name", "zhangsan");map.put("age", 23);map.put("gender", "male");String s = map.toString();System.out.println(s);// 当已经有一个bean时，可以通过fromObject()方法转换City city = new City("guangzhou", "gz");JSONObject map = JSONObject.fromObject(city);String s = map.toString();System.out.println(s); JSONArray1234567891011121314// mapCity sz = new City("shenzhen", "sz");City gz = new City("guangzhou", "gz");JSONArray list = new JSONArray();list.add(gz);list.add(sz);System.out.println(list.toString());// 原来就有一个list的情况List&lt;City&gt; cityList = new ArrayList&lt;&gt;();cityList.add(gz);cityList.add(sz);JSONArray list = JSONArray.fromObject(cityList);System.out.println(list.toString()); javabean转换为json字符串：fastjsonfastjson可以把javabean转换为json字符串，是阿里巴巴开发的json工具库 maven依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.58&lt;/version&gt;&lt;/dependency&gt; w3cschool的fastjson文档 打包AJAX以后使用AJAX的时候，最好先打包，如果不会，看这个视频：打包AJAX]]></content>
      <categories>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>ajax</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM整合]]></title>
    <url>%2F2019%2F06%2F12%2FSSM%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[SSM整合jar包导入略 web.xml主要配置Spring配置文件，SpringMVC和字符编码过滤器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;/WEB-INF/index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!--配置spring的字符编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 加载spring的过滤器 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--配置springmvc的核心过滤器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; springmvc.xml是MVC的配置文件，基于注解开发的话主要配置解析器和拦截器，如果需要json或其他处理要填写相关配置，如下 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;!-- SpringMVC注解开发 --&gt; &lt;!-- 配置view resolver --&gt; &lt;bean id="jspViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt; &lt;context:component-scan base-package="com.mkl.Controller" /&gt; &lt;!-- 拦截器的配置 --&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!-- mapping拦截某一路径，比如/admin/* --&gt; &lt;!-- /**表示该路径下所有路径及其子路径 如果是/admin/*，拦截的是/admin/add,/admin/list，而/admin/user/add之类的孙子路径不能拦截 --&gt; &lt;!-- &lt;mvc:mapping path="/**"/&gt; --&gt; &lt;mvc:mapping path="/admin/*" /&gt; &lt;bean class="com.mkl.interceptor.MyInterceptor" /&gt; &lt;/mvc:interceptor&gt; &lt;!-- 其他拦截器如登陆拦截器 --&gt; &lt;/mvc:interceptors&gt;&lt;/beans&gt; spring-*.xml其他spring-*.xml略，主要是mybatis的配置 spring-dao.xml具体配置去看Spring05-整合MyBatis]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC03-数据处理,乱码,Restful和文件上传]]></title>
    <url>%2F2019%2F06%2F12%2FSpringMVC03-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%2C%E4%B9%B1%E7%A0%81%2CRestful%E5%92%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[SpringMVC03-数据处理,乱码,Restful和文件上传源码 数据处理 DataController.java 12345678910@Controllerpublic class DataController &#123; // @RequestParam为提交的域名称 @RequestMapping("/data") public String data(@RequestParam("uname") String name) &#123; System.out.println(name); return "index"; &#125;&#125; URL输入时添加参数uname 控制台输出 对象数据的处理主要是表单域名和对象属性名一致，方法参数使用对象即可，如下 创建实体类User(id, name, pwd)，略 Controller如下 12345@RequestMapping("/user")public String user(User user) &#123; System.out.println(user); return "index";&#125; 网址输入http://localhost:8080/user.do?name=zs&amp;pwd=1234，一般是提交表单输入的 控制台输出User{id=0, name=&#39;zs&#39;, pwd=&#39;1234&#39;} 数据显示到UI层通过ModelAndView略 通过ModelMap只需要在对应方法上添加参数ModelMap即可，如下 1.Controller 123456@RequestMapping("/user")public String user(User user, ModelMap modelMap) &#123; modelMap.addAttribute("user", user); System.out.println(user); return "user";&#125; 编写user.jsp文件，略 网址输入http://localhost:8080/user.do?name=zs&amp;pwd=1234 网址输出Hello, User{id=0, name=&#39;zs&#39;, pwd=&#39;1234&#39;} 乱码及RESTful乱码的解决对POST方法中文出现乱码的情况，通过过滤器CharacterEncodingFilter来解决 web.xml添加如下配置 12345678910111213&lt;!--配置spring的字符编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 对于请求或响应编码问题，可以如下方法解决 1234567@RequestMapping("/foo") public void foo(HttpServletRequest request, HttpServletResponse response, User user) throws IOException &#123; response.setContentType("text/html;charset=utf-8"); // 处理响应编码问题 request.setCharacterEncoding("utf-8"); // 处理请求编码问题 System.out.println(user); response.getWriter().print(user); &#125; RESTful风格RESTful风格的URL：轻量级，安全，效率高，编写如下： 1234567@RequestMapping("/&#123;name&#125;/&#123;id&#125;/restful")public String restful(@PathVariable String name, @PathVariable int id, ModelMap modelMap) &#123; System.out.println(id + name); modelMap.addAttribute("name", name); modelMap.addAttribute("id", id); return "/data";&#125; data.jsp 12345678910&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;%@ page isELIgnored="false"%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; Hello, this is data page， $&#123;name&#125;, $&#123;id&#125;&lt;/body&gt;&lt;/html&gt; 在网址输入http://localhost:8080/mkl/1/restful.do，可以输出Hello, this is data page， mkl, 1 它是根据URL路径的uname，uid设置方法的属性name和id，然后通过ModelMap传给转发的页面data.jsp的 文件上传 导入相关jar包commons-fileupload,commons-io 12345678910&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 配置springmvc配置文件，配置解析器 12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="defaultEncoding" value="utf-8"/&gt; &lt;property name="maxUploadSize" value="10485760000"/&gt; &lt;property name="maxInMemorySize" value="40960"/&gt; &lt;/bean&gt; &lt;!-- 还有一个InternalResourceViewResolver，略 --&gt;&lt;/beans&gt; 编写Controller 12345678910111213141516171819202122@Controllerpublic class FileUploadController &#123; @RequestMapping("/file") public String file() &#123; return "fileupload"; &#125; @RequestMapping("/upload") public String fileupload(@RequestParam("file") CommonsMultipartFile file, HttpServletRequest req) throws IOException &#123; String path = req.getRealPath("/WEB-INF"); OutputStream os = new FileOutputStream(new File(path, file.getOriginalFilename())); InputStream is = file.getInputStream(); int len = 0; byte[] buffer = new byte[400]; while((len = is.read(buffer)) != -1) os.write(buffer, 0, len); os.close(); is.close(); return "index"; &#125;&#125; fileupload.jsp 1234567891011&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="upload.do" method="post" enctype="multipart/form-data"&gt; file:&lt;input type="file" name="file"&gt;&lt;input type="submit" value="上传"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 工作流程是这样的：输入http://localhost:8080/file.do，他会转交给fileupload.jsp处理，然后上传文件，点击上传后，交由upload.do处理，即交给Controller的fileupload方法处理，他得到一个CommonsMultipartFile，通过Java IO把它写进tomcat路径的WEB-INF下，然后页面跳转到index]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>MVC</tag>
        <tag>RESTful</tag>
        <tag>MVC文件上传</tag>
        <tag>MVC表单数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC02-使用注解开发和结果跳转方式]]></title>
    <url>%2F2019%2F06%2F12%2FSpringMVC02-%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%E5%92%8C%E7%BB%93%E6%9E%9C%E8%B7%B3%E8%BD%AC%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[SpringMVC02-使用注解开发和结果跳转方式源码 DispatcherServlet的初始化参数You can customize individual DispatcherServlet instances by adding Servlet initialization parameters ( init-param elements) to the Servlet declaration in the web.xml file. See the following table for the list of supported parameters. Parameter Explanation contextClass Class that implements ConfigurableWebApplicationContext, to be instantiated and locally configured by this Servlet. By default, XmlWebApplicationContext is used. contextConfigLocation String that is passed to the context instance (specified by contextClass) to indicate where context(s) can be found. The string consists potentially of multiple strings (using a comma as a delimiter) to support multiple contexts. In case of multiple context locations with beans that are defined twice, the latest location takes precedence. namespace Namespace of the WebApplicationContext. Defaults to [servlet-name]-servlet. View Resolver官网Spring 4.3.24的View Resolver 使用注解开发Spring MVC的DEMO 导入jar包 web.xml配置 123456789101112131415161718192021&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- MVC配置文件所在位置 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; Controller 123456789101112@Controllerpublic class HelloController2 &#123; @RequestMapping("/hello") public ModelAndView hello(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) &#123; ModelAndView mv = new ModelAndView(); // 封装要显示到视图的数据 mv.addObject("msg", "hello springmvc annotation"); // 封装视图名称 mv.setViewName("hello"); return mv; &#125;&#125; mvc.xml 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 配置view resolver --&gt; &lt;bean id="jspViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt; &lt;context:component-scan base-package="com.mkl.Controller" /&gt;&lt;/beans&gt; 结果跳转方式ModelAndViewController返回一个ModelAndView对象，通过视图解析器的前缀+viewName+后缀返回View对象，如上代码所示 Servlet API不需要配置视图解析器，Controller代码如下 12345678@Controllerpublic class HelloController2 &#123; // 使用这种方式输出结果不需要视图解析器 @RequestMapping("/hello2") public void hello2(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws IOException &#123; httpServletResponse.getWriter().write("Hello Spring MVC with servlet api"); &#125;&#125; 通过HttpServletResponse对象的实例方法实现输出或重定向，或通过HttpServletRequest实现转发 通过Spring MVC提供转发和重定向转发的URL是不变的，重定向是会变化的，注意重定向需要指定后缀，它不会经解析器解析 同样不需要视图解析器 12345678910111213@Controllerpublic class HelloController2 &#123; // 通过Spring MVC转发和重定向 @RequestMapping("/hello3") public String hello3() &#123; //转发 //return "index.jsp"; //等价于return "forward:index.jsp"; //重定向 return "redirect:index.jsp"; &#125;&#125; 通过Spring MVC加视图解析器1234567891011@Controllerpublic class HelloController2 &#123; // 通过Spring MVC加上视图解析器实现转发 @RequestMapping("/hello4") public String hello4() &#123; //转发 return "index"; //重定向，重定向是用不到视图解析器的 //return "redirect:hello.do"; &#125;&#125;]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>MVC</tag>
        <tag>Controller</tag>
        <tag>RequestMapping</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC01-HelloSpringMVC]]></title>
    <url>%2F2019%2F06%2F11%2FSpringMVC01-HelloSpringMVC%2F</url>
    <content type="text"><![CDATA[SpringMVC01-HelloSpringMVC源码 概述mvc框架可以做如下事情： 将URL映射到java类或java类的方法 封装用户提交的数据 处理请求-调用相关的业务处理-封装响应的数据 将响应的数据进行渲染，jsp，html，freemarker等 SpringMVC是一个轻量级的，基于请求响应的mvc框架 对上图的解释： 请求第一站是DispatcherServlet，它是一个前端控制器，负责将请求委托给应用程序的其他组件来执行实际的处理DispatcherServlet的任务是将请求发送给SpringMVC控制器(Controller)，应用程序有多个控制器，所以DispatcherServlet会查询一个或多个处理器映射(handler mapping)来确定请求的下一站在哪里，处理器映射根据URL信息决策一旦选择了合适的控制器，DispatcherServlet就会将请求发送给选中的controller，到了controller，请求会卸下负载（用户提交的信息）并等待控制器处理这些信息，实际上controller会把业务逻辑委托给一个或多个service对象处理控制器完成逻辑后，会产生一些信息，这些信息需要返回给用户并在浏览器上显示，这些信息就是model，但信息一般需要格式化，比如HTML，所以，信息需要发送给一个view，通常是JSP控制器最后一件事就是模型数据打包，并标示出用于渲染输出的视图名，然后将请求连同模型和视图名发送回DispatcherServlet（这样controller就不会与特定的view相耦合）传递回DispatcherServlet的视图名不直接表示某个特定的JSP（甚至不是JSP），它只是一个逻辑名，用于查找产生结果的真正视图，DispatcherServlet使用视图解析器（view resolver）将逻辑视图名匹配为一个特定的视图实现最后，DispatcherServlet把模型数据交付给view，view通过响应对象传递给客户端即可 Hello Spring MVCHello Spring MVC是完全不使用注解开发的，主要是了解上述MVC框架的工作流程，实际开发最好不采用下述方法 导入相关jar包，pom.xml关键依赖如下 123456789101112131415161718192021222324&lt;!-- 省略了Spring相关的依赖包，关键是mvc包和servlet包，具体依赖见源码 --&gt;&lt;dependencies&gt; &lt;!-- 3.Spring web依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0-alpha-1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置web.xml文件-配置分发器 123456789101112&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 编写springmvc-serlvet.xml（它的名字必须为web.xml的&lt;serlvet-name&gt;的值加上-servlet） 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 配置handler mapping --&gt; &lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping" /&gt; &lt;!-- 配置handler adapter --&gt; &lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter" /&gt; &lt;!-- 配置view resolver --&gt; &lt;bean id="jspViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt; &lt;!-- 配置请求和处理器 --&gt; &lt;bean name="/hello.do" class="com.mkl.Controller.HelloController" /&gt;&lt;/beans&gt; 编写HelloController.java，注意导入的javax包和Controller为org.springframework.web.servlet.mvc.Controller，默认导入的不是那个Controller 1234567891011121314151617181920// HelloController.javapackage com.mkl.Controller;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class HelloController implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; ModelAndView mv = new ModelAndView(); // 封装要显示到视图的数据 mv.addObject(&quot;msg&quot;, &quot;hello springmvc&quot;); // 封装视图名称 mv.setViewName(&quot;hello&quot;); return mv; &#125;&#125; 编写视图hello.jsp，记得开启EL表达式 12345678910&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;%@ page isELIgnored="false"%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 配置TOMCAT 运行TOMCAT，浏览器输入http://localhost:8080/hello.do ，即可看到hello springmvc 工作流程简要介绍 在web.xml配置了分发器，通过servlet-name指定对应的xxx-servlet.xml，url-pattern表示该servlet处理所有.do的网址，然后当用户输入xxx/hello.do，由springmvc-mapping.xml的bean知该URL对应的Controller为HelloController，转而交给该Controller处理，该Controller处理完后返回一个ModelAndView对象，指定了View的逻辑名与一个键值对数据，view resolver通过为该View的逻辑名添加前缀和后缀得出其物理名，把模型返回给View处理，然后View返回给用户]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring05-整合MyBatis]]></title>
    <url>%2F2019%2F06%2F10%2FSpring05-%E6%95%B4%E5%90%88MyBatis%2F</url>
    <content type="text"><![CDATA[Spring05-整合MyBatis源代码在这 步骤 导入相关jar包 编写配置文件 实现 导入jar包主要是spring相关的包加上mybatis加上mysql-connector-java加上mybatis-spring 123456789101112131415161718&lt;dependencies&gt; &lt;!-- spring相关依赖，略 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 编写配置文件mybatis-conf.xml如下： 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name="com.mkl.mybatis" /&gt; &lt;/typeAliases&gt; &lt;!-- 对数据源的配置已经由bean实现 &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://127.0.0.1:3306/yourDBName?useUnicode=true&amp;amp;serverTimezone=UTC&amp;amp;characterEncoding=utf8"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="123456"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; --&gt; &lt;mappers&gt; &lt;mapper resource="com/mkl/mybatis/entity/UserMapper.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 事实上，甚至不需要这个mybatis-conf.xml，任何配置都可以在bean中实现，只要为对应SqlSessionFactory配置property即可 spring-mybatis.xml配置文件如下： 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://127.0.0.1:3306/sampledb?useUnicode=true&amp;amp;serverTimezone=UTC&amp;amp;characterEncoding=utf8" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="123456" /&gt; &lt;/bean&gt; &lt;!-- 配置SqlSessionFactory --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;property name="configLocation" value="classpath:mybatis-conf.xml" /&gt; &lt;/bean&gt; &lt;!-- 配置SqlSession --&gt; &lt;bean id="sqlSessionTemplate" class="org.mybatis.spring.SqlSessionTemplate"&gt; &lt;constructor-arg index="0" ref="sqlSessionFactory" /&gt; &lt;/bean&gt; &lt;!-- 配置DAO --&gt; &lt;bean id="userDao" class="com.mkl.mybatis.dao.UserDaoI" &gt; &lt;property name="sqlSession" ref="sqlSessionTemplate" /&gt; &lt;/bean&gt;&lt;/beans&gt; 在这个spring配置文件中，主要配置了数据源，并通过这个数据源配置了SqlSessionFactory，通过把这个sqlSessionFactory作为参数，构造器注入创建SqlSessionTemplate对象，作为SqlSession UserMapper.xml如下 12345678910&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.mkl.mybatis.UserMapper"&gt; &lt;select id="selectUser" resultType="com.mkl.mybatis.entity.User"&gt; SELECT * FROM user &lt;/select&gt;&lt;/mapper&gt; 实现User是一个实体类，主要有id，name和password三个属性，UserDaoI如下 12345678910111213public class UserDaoI implements UserDao &#123; private SqlSessionTemplate sqlSession; @Override public List&lt;User&gt; selectUser() &#123; return sqlSession.selectList("com.mkl.mybatis.UserMapper.selectUser"); &#125; public void setSqlSession(SqlSessionTemplate sqlSession) &#123; this.sqlSession = sqlSession; &#125;&#125; 测试类只要获得这个Dao对象并调用其方法即可 注解实现声明式事务事务：方法要么全成功，要么全失败 主要是配置spring配置文件，如下 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://127.0.0.1:3306/sampledb?useUnicode=true&amp;amp;serverTimezone=UTC&amp;amp;characterEncoding=utf8" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="123456" /&gt; &lt;/bean&gt; &lt;!-- 其他配置如SqlSessionFactory，略 --&gt; &lt;!-- 声明式事务配置 --&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- 配置事务通知 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="txManager" &gt; &lt;tx:attributes&gt; &lt;tx:method name="insert*" propagation="REQUIRED" /&gt; &lt;tx:method name="delete*" propagation="REQUIRED" /&gt; &lt;tx:method name="update*" propagation="REQUIRED" /&gt; &lt;tx:method name="add*" propagation="REQUIRED" /&gt; &lt;tx:method name="*" propagation="REQUIRED" /&gt; &lt;tx:method name="get*" read-only="true" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 这里的execution表达式其实不应该写dao，而应该写service --&gt; &lt;aop:config&gt; &lt;aop:pointcut id="pointcut" expression="execution(* com.mkl.mybatis.dao.daoImpl.*.*(..))" /&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="pointcut" /&gt; &lt;/aop:config&gt;&lt;/beans&gt; 注意&lt;beans&gt;标签的属性要加入xmlns:tx，xsi:schemaLocation也要加入相应值，详情看上面 这样，对execution(* com.mkl.mybatis.dao.daoImpl.*.*(..))里的所有方法，都是一个事务，方法体内的SQL语句执行要么全部执行，要么全部不执行 通过Dao继承SqlSessionDaoSupport整合这种方法可以不用定义SqlSessionTemplate的bean，在Dao中不需要设置SqlSession属性，只要继承SqlSessionDaoSupport父类，并在对应类bean中设置sqlSessionFactory属性，然后调用getSession()方法即可 1234567public class UserDaoI2 extends SqlSessionDaoSupport implements UserDao &#123; @Override public List&lt;User&gt; selectUser() &#123; return getSqlSession().selectList("com.mkl.mybatis.UserMapper.selectUser"); &#125;&#125; 通过接口的实现继承父类SqlSessionDaoSupport，然后调用getSqlSession()方法获取SqlSession对象，注意此时的bean要传入SqlSessionFactory参数，如下 123&lt;bean id="userDao2" class="com.mkl.mybatis.dao.daoImpl.UserDaoI2" &gt; &lt;property name="sqlSessionFactory" ref="sqlSessionFactory" /&gt;&lt;/bean&gt; mapper注入（最好用这个）编写mapper，然后编写接口，接口名必须与mapper名一致，且接口方法和mapper对应sql语句的id一致，且mapper和接口在同一目录下 UserMapper.xml 123456789101112&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.mkl.mybatis.mapper.UserMapper"&gt; &lt;select id="selectAll" resultType="User" &gt; SELECT * FROM user; &lt;/select&gt; &lt;select id="selectById" resultType="User" parameterType="int"&gt; SELECT * FROM user WHERE id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; UserMapper.java 123456public interface UserMapper &#123; List&lt;User&gt; selectAll(); User selectById(int id);&#125; UserServiceImpl 1234567891011121314151617// spring配置文件开启自动扫描，它自动装配了UserMapper@Service("userService")public class UserServiceImpl implements UserService &#123; @Autowired private UserMapper userMapper; @Override public List&lt;User&gt; selectAll() &#123; return userMapper.selectAll(); &#125; @Override public User selectById(int id) &#123; return userMapper.selectById(id); &#125;&#125; Spring配置文件启用mybatis的接口代理开发模式（接口和Xml配置必须同名，并且在同一目录下） 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:property-placeholder location="db.properties" /&gt; &lt;context:component-scan base-package="com.mkl.mybatis.service" /&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driverClassName&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;/bean&gt; &lt;!-- 配置SqlSessionFactory --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;property name="typeAliasesPackage" value="com.mkl.mybatis" /&gt; &lt;property name="mapperLocations" value="com/mkl/mybatis/entity/UserMapper.xml" /&gt; &lt;/bean&gt; &lt;!-- 配置SqlSession --&gt; &lt;bean id="sqlSessionTemplate" class="org.mybatis.spring.SqlSessionTemplate"&gt; &lt;constructor-arg index="0" ref="sqlSessionFactory" /&gt; &lt;/bean&gt; &lt;!-- 启用mybatis的接口代理开发模式（接口和Xml配置必须同名，并且在同一目录下） --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.mkl.mybatis.mapper"/&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试类只需获得service对象，并调用其方法即可]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring整合MyBatis</tag>
        <tag>声明式事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发基础1-线程]]></title>
    <url>%2F2019%2F06%2F06%2FJava%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%801-%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Java并发基础1-线程启动一个线程 实现Runnable接口，可以使用lambda表达式Runnable r = () -&gt; { task code }; 由Runnable创建一个Thread对象Thread t = new Thread(r); 启动线程t.start(); 也可以通过构建一个Thread类的子类来定义一个线程，然后构造该子类的对象，并调用start()方法，不过这种方法不推荐，应该将要并行运行的任务与运行机制解耦合 不要调用Thread类或Runnable对象的run方法，直接调用run方法，只会执行同一个线程的任务，而不会启动新线程。应该调用Thread.start方法，这个方法将创建一个run方法的新线程 中断线程当线程的run方法执行方法体中最后一条语句后，并经由执行return语句返回后，或者出现了在方法中没有捕获的异常时，线程将终止 可以使用interrupt方法，请求终止线程，线程中断状态被置位，每个线程都应该时不时检查这个标志，以判断线程是否被中断可以使用Thread.currentThread().isInterrupted()来判断线程是否被中断如果线程被阻塞(调用sleep或wait)，就无法检测中断状态。这是产生InterruptedException异常的地方注意有个静态方法interrupted，它检测当前线程是否被中断，调用它会清除该线程的中断状态，isInterrupted是一个实例方法，它检验线程被中断，它不会改变中断状态 中断线程不等于终止线程，但普遍的情况下，线程将简单地将中断作为一个终止的请求。这种线程的Run方法有如下形式： 12345678910111213Runnable r = () -&gt; &#123; try &#123; ... while (!Thread.currentThread().isInterrupted() &amp;&amp; more work to do) &#123; do more work &#125; &#125; catch (InterruptedException e) &#123; // thread was interrupted during sleep or wait &#125; finally &#123; cleanup,if required &#125; // exiting the run method terminates the thread&#125; 如果每次工作迭代之后都调用sleep方法，isInterrupted检测既没有必要也没有用处。如果在中断状态被置位时调用sleep方法，它不会休眠，相反，它会清除这一状态并抛出InterruptedException。因此，如果循环调用了sleep，不会检测中断状态。相反，要如下所示捕获InterruptedException异常： 12345678910111213Runnable r = () -&gt; &#123; try &#123; ... while (more work to do) &#123; do more work Thread.sleep(delay); &#125; &#125; catch (InterruptedException e) &#123; // thread was interrupted during sleep &#125; finally &#123; cleanup,if required &#125;&#125; catch语句块不要忽略，不要空着不写，有两种更好的选择第一种是catch子句中设置中断状态 12345void mySubTask() &#123; ... try &#123; sleep(delay); &#125; catch (InterruptedException e) &#123; Thread.currentThread().interrupt(); &#125;&#125; 第二种更好的选择是抛出错误，不采用try 12345void mySubTask() throws InterruptedException &#123; ... sleep(delay); ...&#125; 线程状态线程有如下6种状态 New Runnable Blocked Waiting Timed waiting(计时等待) Terminated 可以采用getState方法确定一个线程当前状态 新创建线程当用new操作符创建一个新线程时，如new Thread(r)，该线程还没有开始运行，他的状态是new 可运行线程一旦调用start方法，线程就处于Runnable状态。一个可运行的线程可能正在运行也可能没有运行，这取决于操作系统给线程提供运行的时间 被阻塞线程和等待线程当线程处于被阻塞或等待状态时，它暂时不活动。它不运行任何代码且消耗最少的资源。直到线程调度器重新激活它 当一个线程试图获取一个内部的对象锁，而该锁被其他线程持有，则该线程进入阻塞状态 当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态 有几个方法有一个超时参数。调用它们导致线程进入计时等待状态 sleep()与wait()的区别sleep一般用于当前线程休眠，或者轮循暂停操作，wait则多用于多线程之间的通信 sleep()方法是Thread类里面的，主要的意义就是让当前线程停止执行，让出cpu给其他的线程，但是不会释放对象锁资源以及监控的状态，当指定的时间到了之后又会自动恢复运行状态，sleep必须捕获异常wait()方法是Object类里面的，主要的意义就是让线程放弃当前的对象的锁，进入等待此对象的等待锁定池，只有针对此对象调动notify方法后本线程才能够进入对象锁定池准备获取对象锁进入运行状态，wait不用捕获异常wait() method causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object. In other words, this method behaves exactly as if it simply performs the call wait(0). 被终止的线程线程因如下两个原因之一被终止 因为run方法正常退出而自然死亡 因为一个没有捕获的异常终止了run方法而意外死亡 joinjoin()方法是Thread类中一个实例方法，该方法的定义是等待该线程终止，它可以传入参数void join(long millis)，表示等待指定的线程死亡或者经过指定的毫秒数 join的一个例子T1,T2,T3三个线程，保证T2在T1执行后再执行，T3再T2执行后再执行 1234567891011121314151617181920212223242526public static void main(String[] args) throws Exception &#123; Thread t1 = new Thread(() -&gt; &#123; System.out.println("T1 is running"); &#125;); Thread t2 = new Thread(() -&gt; &#123; try &#123; t1.join(); &#125; catch (InterruptedException e) &#123; t1.interrupt(); &#125; finally &#123; System.out.println("T2 is running"); &#125; &#125;); Thread t3 = new Thread(() -&gt; &#123; try &#123; t2.join(); &#125; catch (InterruptedException e) &#123; t2.interrupt(); &#125; finally &#123; System.out.println("T3 is running"); &#125; &#125;); t1.start(); t2.start(); t3.start();&#125; 线程属性线程优先级每个线程可以有一个优先级,但优先级依赖于宿主机平台的线程实现机制,相关方法如下 方法或属性 解释 void setPriority(int newPrority) Changes the priority of this thread. static int MIN_PRIORITY 线程的最小优先级,值为1 static int NORM_PRIORITY 线程的默认优先级,默认为5 static int MAX_PRIORITY 线程的最高优先级,为10 static void yield() 导致当前执行的线程处于让步状态,如果其他可运行线程具有至少与此线程同样高的优先级,则这些线程接下来会被调度 守护线程可以通过调用t.setDaemon(true)将线程设置为守护线程,守护线程的作用是为其他线程提供服务,当只剩下守护线程时,虚拟机就退出了,守护线程不应该访问固有资源,例如文件,数据库,因为守护线程会在任何时候发生中断 未捕获异常处理器线程的run方法不能抛出任何受查异常，但是，非受查异常会导致线程终止，这种情况下线程就死亡了，当一个线程由于非受查异常而死亡，在死亡前，异常会被传递到一个用于未捕获异常的处理器，该处理器必须属于一个实现Thread.UncaughtExceptionHandler接口的类，这个接口只有一个方法void uncaughtException(Thread t, Throwable e)可以用setUncaughtExceptionHandler方法为所有线程安装一个处理器，也可以用Thread类的静态方法setDefaultUncaughtExceptionHandler为所有线程安装一个默认的处理器]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis从入门到秃头]]></title>
    <url>%2F2019%2F06%2F06%2FMyBatis%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%A7%83%E5%A4%B4%2F</url>
    <content type="text"><![CDATA[MyBatis从入门到秃头源码地址 入门MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录 安装要使用MyBatis，只需将mybatis-x.x.x.jar文件置于classpath中即可。 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;x.x.x&lt;/version&gt;&lt;/dependency&gt; 从0构造一个MyBatis应用数据库MySQL账户root，密码123456数据库名sampledb，表名person，有id，name，age三列 步骤： 配置mybatis的conf.xml：配置数据库信息和需要加载的映射文件 配置映射文件xxMapper.xml，增删改查标签 在测试类中拿到SqlSession对象进行数据操作，session.selectOne(&quot;需要查询的namespace.id&quot;,&quot;SQL的参数值&quot;) 目录树： 123456789101112131415161718// Person.javapackage com.mkl.entity;public class Person &#123; private int id; private String name; private int age; public Person() &#123; &#125; // constructor, setter and getter @Override public String toString() &#123; return this.id + "," + this.name + "," + this.age; &#125;&#125; 12345678910&lt;!-- personMapper.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.mkl.entity.personMapper"&gt; &lt;select id="queryPersonById" resultType="com.mkl.entity.Person" parameterType="int"&gt; select * from person where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 1234567891011121314151617181920212223242526&lt;!-- conf.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;typeAlias type="com.mkl.entity.Person" alias="Person" /&gt; &lt;/typeAliases&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt; &lt;!-- ?useUnicode=true&amp;amp;characterEncoding=utf8为了支持中文数据的写入 --&gt; &lt;property name="url" value="jdbc:mysql://127.0.0.1:3306/sampledb?useUnicode=true&amp;amp;serverTimezone=UTC&amp;amp;characterEncoding=utf8" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="123456" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="com/mkl/entity/personMapper.xml" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; 123456789101112131415// TestMybatis.javapublic class TestMybatis extends UnitTestBase &#123; @Test public void testMybatis() throws IOException &#123; Reader reader = Resources.getResourceAsReader("conf.xml"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader); SqlSession session = sessionFactory.openSession(); // 通过mapper的namespace+对应查询语句的id选择唯一的查询语句 String statement = "com.mkl.entity.personMapper.queryPersonById"; Person person = session.selectOne(statement, 1); System.out.println(person); session.close(); &#125;&#125; 配置文件解析环境配置的官方文档 多个environment 可以在conf.xml中配置多个environment，比如开发环境的environment，测试环境的environment，部署上线环境的environment，每个environment的数据库参数都不一样 除了在&lt;environments&gt;中设置default的environment，还可以SqlSessionFactoryBuilder().build(reader, &quot;xxx&quot;)，为build方法传入第二个字符串参数，指定选择哪个environment 数据源类型通过&lt;environment&gt;的子标签&lt;dataSource type=&quot;xxx&quot;&gt;指定数据源，有如下几种： POOLED：MyBatis创建一个数据库连接池，连接池中的一个连接用于数据库操作，一旦操作完成，MyBatis将此连接返回给连接池，开发和测试的时候经常使用这种方式 UNPOOLED：传统JDBC模式，为每一个数据库操作创建一个新的连接，在使用完毕后关闭它（创建Connection对象非常耗时） JNDI：从应用服务器（TOMCAT）中内置的配置好的数据源（数据库连接池）获取数据库连接，一般生产环境优先使用该方式 事务提交方式通过&lt;environment&gt;的子标签&lt;transactionManager type=&quot;xxx&quot; /&gt;指定事务提交方式，有如下两种 JDBC：使用JDBC的事务管理机制,就是利用java.sql.Connection对象完成对事务的提交 MANAGED：使用MANAGED的事务管理机制，这种机制mybatis自身不会去实现事务管理，而是让程序的容器（Spring）来实现对事务的管理 SQL语句传入多个参数12345678910&lt;!-- personMapper.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.mkl.entity.personMapper"&gt; &lt;select id="queryPersonById" resultType="com.mkl.entity.Person" parameterType="int"&gt; select * from person where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 如上mapper，MyBaits规定一个增删改查标签只能有一个resultType和一个parameterType，即只能有一个输入参数和一个输出参数，但逻辑上是可以传入多个参数的，如下 1234&lt;!-- personMapper.xml --&gt;&lt;insert id="addPerson" parameterType="com.mkl.entity.Person" &gt; INSERT INTO person(id, name, age) VALUES (#&#123;id&#125;, #&#123;name&#125;, #&#123;age&#125;)&lt;/insert&gt; 只要传入对象参数即可，注意当参数类型是对象的时候，#{xxx}的xxx必须要和对象的属性名一致 然后构造一个Person对象，调用session.insert(statement, person)即可完成多参数的插入 多个对象的返回时，resultType为这多个对象的共同类型，只要session.selectList(statement);即可返回包含这多个对象的List类型 XML映射文件XML映射文件官方文档 所有&lt;insert&gt;,&lt;delete&gt;,&lt;update&gt;,&lt;select&gt;的属性在官方文档都有详细说明，值得注意的是在&lt;insert&gt;和&lt;update&gt;中有useGeneratedKeys和keyProperty属性，它们的作用是：如果你的数据库支持自动生成主键的字段（比如 MySQL 和 SQL Server），那么你可以设置 useGeneratedKeys=”true”，然后再把 keyProperty 设置到目标属性上就 OK 了。例如，如果 Author 表已经对 id 使用了自动生成的列类型，那么语句可以修改为： 12345&lt;insert id="insertAuthor" useGeneratedKeys="true" keyProperty="id"&gt; insert into Author (username,password,email,bio) values (#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)&lt;/insert&gt; 不用自己显式的为id设置值 在底层，SqlSession接口的insert和update和delete的实现其实都是调用了update方法，即调用java的insert和delete方法和调用update方法是一样的，只要确保XML的SQL语句不一样即可 XML配置优化MyBatis配置官方文档 MyBatis的配置文件包含各种设置和属性，如下： 配置config.properties文件properties属性 新建.properties文件，如下 12345# db.propertiesjdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://127.0.0.1:3306/sampledb?useUnicode=true&amp;serverTimezone=UTC&amp;characterEncoding=utf8jdbc.username=rootjdbc.password=123456 然后修改MyBatis的配置文件conf.xml 1234567891011&lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;" /&gt; &lt;!-- ?useUnicode=true&amp;amp;characterEncoding=utf8为了支持中文数据的写入 --&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;/dataSource&gt;&lt;/environment&gt; 指定别名类型别名是为 Java 类型设置一个短的名字。 它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余，可以使得 mapper 映射文件中的 resultType 和 parameterType 直接饮用别名即可 12345678&lt;typeAliases&gt; &lt;typeAlias alias="Author" type="domain.blog.Author"/&gt; &lt;typeAlias alias="Blog" type="domain.blog.Blog"/&gt; &lt;typeAlias alias="Comment" type="domain.blog.Comment"/&gt; &lt;typeAlias alias="Post" type="domain.blog.Post"/&gt; &lt;typeAlias alias="Section" type="domain.blog.Section"/&gt; &lt;typeAlias alias="Tag" type="domain.blog.Tag"/&gt;&lt;/typeAliases&gt; 也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如： 123&lt;typeAliases&gt; &lt;package name="domain.blog"/&gt;&lt;/typeAliases&gt; 每一个在包 domain.blog 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 domain.blog.Author 的别名为 author；若有注解，则别名为其注解值。见下面的例子： 1234@Alias("author")public class Author &#123; ...&#125; 它内建了部分Java类型的别名，详情可以去看官方文档 解决属性名和列名不一致当Java实体类的属性名和数据库中列名不一致的时候，查询时MyBatis无法通过setter为实体类对应属性设置值，同理，增改时无法通过getter获取实体类属性对数据库修改列，解决方法如下： 为列名指定别名，别名和Java实体类属性名一致 123456&lt;mapper namespace="com.mkl.entity.personMapper"&gt; &lt;!-- 为name设置别名name1，name1和实体类的属性名一致，name为数据库的列名 --&gt; &lt;select id="queryPersonById" resultType="com.mkl.entity.Person"&gt; SELECT id, name name1, age FROM person WHERE id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 设置结果映射类型 1234567891011121314&lt;mapper namespace="com.mkl.entity.personMapper"&gt; &lt;select id="queryPersonById" resultMap="PersonMap"&gt; SELECT id, name, age FROM person WHERE id = #&#123;id&#125; &lt;/select&gt; &lt;!-- resultMap的type与实体类名一致 --&gt; &lt;!-- column为数据库列名，property为实体类属性名 --&gt; &lt;resultMap id="PersonMap" type="Person" &gt; &lt;result column="id" property="id" /&gt; &lt;result column="name" property="name1" /&gt; &lt;result column="age" property="age" /&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 注意自增主键要设置的标签不是&lt;result&gt;而是&lt;id&gt;，官方文档在这里 分页MySQL的分页语句SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset LIMIT子句可以被用于指定 SELECT 语句返回的记录数。需注意以下几点： 第一个参数指定第一个返回记录行的偏移量 第二个参数指定返回记录行的最大数目 如果只给定一个参数：它表示返回最大的记录行数目 第二个参数为 -1 表示检索从某一个偏移量到记录集的结束所有的记录行 初始记录行的偏移量是0(而不是 1) 需要注意分页的原理是先读取前面offset条记录，然后抛弃前offset条，读后面rows条想要的，所以offset越大，偏移量越大，性能就越差因此需要对分页进行优化，但这个内容不是MyBatis相关的，所以就不赘述，分页优化看这篇就够了 MyBatis分页的Map实现首先在mapper中设置分页的SQL语句，注意指定的parameterType为Map，然后传入SQL参数为#{startIndex}, #{pageSize} 123&lt;select id="queryPage" parameterType="Map" resultMap="PersonMap"&gt; SELECT * FROM person LIMIT #&#123;startIndex&#125;, #&#123;pageSize&#125;&lt;/select&gt; 然后为session.selectList(statement, map)传入statement，map，代码如下（该代码应该在Dao中）： 123456789101112public List&lt;Person&gt; queryPersonPage(int currentPage, int pageSize) throws IOException &#123; SqlSession session = MyBatisUtil.getSqlSession(); // 获取SqlSession String statement = "com.mkl.entity.personMapper.queryPage"; Map&lt;String ,Integer&gt; map = new HashMap&lt;String, Integer&gt;(); // startIndex为MySQL分页的偏移量，currentPage是第几页，pageSize是每页的size，也是返回记录行的最大数目 // 基于它们的定义，currentPage和startIndex的关系为startIndex = (currentPage - 1) * pageSize map.put("startIndex", (currentPage - 1) * pageSize); map.put("pageSize", pageSize); List&lt;Person&gt; list = session.selectList(statement, map); session.close(); return list;&#125; MyBatis分页的RowBounds实现用RowBounds实现，不需要在SQL语句中加入LIMIT关键字，也不需要指定Map，只需要在session.selectList(statement, null, rowBounds)传入rowBounds参数即可，RowBounds对象构造器有两个参数，第一个是offset，第二个是limit 123&lt;select id="queryPageRowBounds" resultMap="PersonMap"&gt; SELECT * FROM person&lt;/select&gt; 12345678public List&lt;Person&gt; queryPersonPageRowBounds(int currentPage, int pageSize) throws IOException &#123; SqlSession session = MyBatisUtil.getSqlSession(); // 获取SqlSession String statement = "com.mkl.entity.personMapper.queryPageRowBounds"; RowBounds rowBounds = new RowBounds((currentPage - 1) * pageSize, pageSize); List&lt;Person&gt; list = session.selectList(statement, null, rowBounds); session.close(); return list;&#125; 使用注解实现MyBatis使用MyBtis可以在接口中通过注解实现SQL语句，这样不需要mapper.xml的编写面向接口编程好处：扩展性好，分层开发中，上层不用管具体的实现，大家都遵循共同的标准，规范性更好 编写Dao接口 12345678public interface PersonDao &#123; @Select("SELECT * FROM person") public List&lt;Person&gt; getList(); @Insert("INSERT INTO user(id, name, age) VALUES(#&#123;id&#125;, #&#123;name&#125;, #&#123;age&#125;)") public int insert(Person person);&#125; 然后在核心配置文件中导入该接口，注意使用的是全限定类名，而不是路径 123&lt;mapper&gt; &lt;mapper class="com.mkl.dao.PersonDao"&lt;/mapper&gt; 然后在service层得到SqlSession对象，通过session.getMapper(PersonDao.class)得到动态代理的PersonDao接口的实现类，通过调用其方法即可执行对应SQL语句 12345SqlSession session = MyBatisUtil.getSqlSession(); PersonDao personDao = session.getMapper(PersonDao.class); List&lt;Person&gt; list = personDao.getList(); for (Person person : list) System.out.println(person); 关于联表的处理多对一关系的处理一个老师对应多个学生，就学生而言（学生设置外键为老师的id），对象关系是多对一的多对一有两种处理方式，一种是按结果嵌套处理，另一种是按查询嵌套处理 假设我们有一个学生表，有id，name，外键tid为老师的id，一个老师表，有id，name，下面以这个假设为前提就这两种处理进行说明 按结果嵌套处理 首先创建实体类，Student有属性id,name和teacher，Teacher有属性id和name 123456789public class Student &#123; private int id; private String name; // 这是多对一关系的实现，多个学生对应一个老师 private Teacher teacher; // getter setter constructor toString&#125; 创建StudentMapper.xml，SQL语句使用常用的联表查询语句，注意返回类型是一个resultMap，在该resultMap里有一个&lt;association&gt;子标签关联实体类Teacher，如下： 123456789101112131415&lt;mapper namespace="com.mkl.entity.StudentMapper"&gt; &lt;select id="getStudents" resultMap="StudentTeacher"&gt; SELECT s.id sid, s.name sname, s.tid stid, t.id tid, t.name tname FROM student s, teacher t WHERE s.tid = t.id &lt;/select&gt; &lt;resultMap id="StudentTeacher" type="Student" &gt; &lt;id column="sid" property="id" /&gt; &lt;result column="sname" property="name" /&gt; &lt;!-- javaType要用全类名或别名，表示对应实体类，property表示Student类的teacher属性 --&gt; &lt;association property="teacher" javaType="Teacher" &gt; &lt;id column="tid" property="id" /&gt; &lt;result column="tname" property="name" /&gt; &lt;/association&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 在MyBatis核心配置文件配置好mapper，然后获取SqlSession查询即可 按查询嵌套处理按查询嵌套处理的过程是先查询Student表，再通过Student表的tid查询Teacher表，把对应Teacher实例赋值给Student的teacher属性 实体类同上，StudentMapper.xml先查询Student表 1234567891011121314&lt;mapper namespace="com.mkl.entity.StudentMapper"&gt; &lt;select id="getStudents2" resultMap="StudentTeacher2"&gt; SELECT * FROM student &lt;/select&gt; &lt;resultMap id="StudentTeacher2" type="Student" &gt; &lt;!-- 按查询嵌套的处理过程是：先SELECT从数据库取出数据，然后对应id和name赋值给Student实体类 tid则作为参数传给&lt;association&gt;的select属性的SQL语句，查出对应的Teacher赋值给Student的teacher属性 --&gt; &lt;association property="teacher" column="tid" javaType="Teacher" select="com.mkl.entity.TeacherMapper.getTeachers" /&gt; &lt;/resultMap&gt;&lt;/mapper&gt; TeacherMapper.xml如下 12345&lt;mapper namespace="com.mkl.entity.TeacherMapper"&gt; &lt;select id="getTeachers" resultType="Teacher" &gt; SELECT * FROM teacher WHERE id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 一对多关系的处理一个老师对应多个学生，就老师而言（实体类不是学生设置老师，而是老师设置学生的集合），数据关系是一对多的 不需要修改数据库表，修改实体类，把学生类的tid删除，然后为老师类添加List属性，List指定类型为Student 按结果嵌套处理 修改相关实体类，修改规则如上所述 mapper编写如下，按id联表查找出一个老师的所有列，返回类型是resultMap，Map指定collection子标签，collection指定studentList的实体类属性 1234567891011&lt;select id="getTeacher" resultMap="TeacherStudent"&gt; SELECT s.id sid, s.name sname, s.tid stid, t.id tid, t.name tname FROM student s, teacher t WHERE s.tid = t.id AND t.id = #&#123;id&#125;&lt;/select&gt;&lt;resultMap id="TeacherStudent" type="Teacher" &gt; &lt;id column="tid" property="id" /&gt; &lt;result column="tname" property="name" /&gt; &lt;collection property="studentList" ofType="Student"&gt; &lt;id column="sid" property="id" /&gt; &lt;result column="sname" property="name" /&gt; &lt;/collection&gt;&lt;/resultMap&gt; 获取SqlSession对象，selectOne方法获取Teacher对象即可 按查询嵌套处理 TeacherMapper 123456789101112&lt;!--先找出Teacher表，然后根据Teacher表的id作为参数传入到select子标签去查Student表根据select标签的SQL语句，Student表找出tid为id的Student，并构造出Student对象作为studentList的一份子--&gt;&lt;select id="getTeacher2" resultMap="TeacherStudent2" &gt; SELECT * FROM teacher WHERE id = #&#123;id&#125;&lt;/select&gt;&lt;resultMap id="TeacherStudent2" type="Teacher"&gt; &lt;collection property="studentList" javaType="ArrayList" ofType="Student" column="id" select="com.mkl.entity.StudentMapper.getStudents3" /&gt;&lt;/resultMap&gt; StudentMapper 123&lt;select id=&quot;getStudents3&quot; resultType=&quot;Student&quot;&gt; SELECT * FROM student WHERE tid = #&#123;id&#125;&lt;/select&gt; 获取SqlSession对象，selectOne方法获取Teacher对象即可 动态SQL动态SQL指根据不同的查询条件生成不同的SQL语句MyBatis使用了OGNL表达式来实现动态SQL官方文档简单又易懂，稍微看一下就会用了呢需要注意的是，对动态SQL传入参数的时候，要用Map来传参，例子如下 123456789101112&lt;select id="getStudentsByObject" resultType="Student"&gt; SELECT * FROM student &lt;where&gt; &lt;if test="id != null"&gt; id = #&#123;id&#125; &lt;/if&gt; &lt;if test="name != null"&gt; AND name = #&#123;name&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 1234567891011121314151617181920// StudentDao的方法public List&lt;Student&gt; getStudentsByObject(Map&lt;String, Object&gt; map) throws IOException &#123; SqlSession session = MyBatisUtil.getSqlSession(); String statement; statement = "com.mkl.entity.StudentMapper.getStudentsByObject"; List&lt;Student&gt; students = session.selectList(statement, map); session.close(); return students;&#125;// 单元测试的代码StudentDao studentDao = new StudentDao();// List&lt;Student&gt; students = studentDao.getStudentsByObject(null);Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();// 使用map传参map.put("name", "zs");List&lt;Student&gt; students = studentDao.getStudentsByObject(map);for (Student s : students) System.out.println(s); Mybatis注意事项 Maven导入包 1234567891011&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt; 配置conf.xml时要指定serverTimezone，分隔符要用&amp;amp;代替 IDEA查找接口实现类的时候，可以通过在接口的源码界面ctrl+alt+B查找]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java异常]]></title>
    <url>%2F2019%2F05%2F22%2FJava%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[Java异常异常分类 Error类层次结构描述了Java运行时系统的内部错误和资源耗尽错误，应用程序不应该抛出这种类型的对象 Exception分为RuntimeException和IOException，RuntimeException是程序错误导致的异常，有下面几种情况 错误的类型转换 数组访问越界 访问null指针 不是派生于RuntimeException的有 试图在文件尾部后读取数据 试图打开一个不存在的文件 试图根据给定的字符串查找Class对象，而这个字符串表示的类并不存在 Java语言规范将派生于Error或RuntimeException类的所有异常称为非受查异常，所有其他异常称为受查异常，一个方法必须声明所有可能抛出的受查异常，非受查异常要么不可控制（Error），要么避免发生（RuntimeException），编译器会核实是否为所有受查异常提供了异常处理器 声明受查异常e.g.public FileInputStream(String name) throws FileNotFoundException，这个声明表示这个构造器将根据给定的String参数产生一个FileInputStream对象，但也有可能抛出一个FileNotFoundException异常，抛出异常后，运行时系统就会开始搜索异常处理器，以便知道如何处理FileNotFoundException对象 自己编写方法时，不必将所有可能抛出的异常都进行声明，什么时候需要在方法中throws子句声明异常，什么异常必须使用throws子句声明，需要记住遇到下面4种情况应该抛出异常 调用一个抛出受查异常的方法，例如FileInputStream构造器 程序运行过程中发现错误，并且利用throw语句抛出一个受查异常（注意不是方法中的throws） 程序出现错误，比如a[-1]=0会抛出一个ArrayIndexOutOfBoundsException这样的非受查异常 Java虚拟机和运行时库出现的内部错误 不需要声明Java的内部错误，即Error继承的错误，也不应该声明RuntimeException继承的非受查异常 1234class MyAnimation &#123; ... void drawImage(int i) throws ArrayIndexOutOfBoundsException // bad style&#125; 抛出异常语法：throw new IOException(); e.g. 12345678String readData(Scanner in) throws EOFException &#123; ... while(...) &#123; if (!in.hasNext()) &#123; throw new EOFException(); &#125; &#125;&#125; 步骤： 找到一个合适的异常类 创建这个类的一个对象 throw语句抛出 捕获异常try，catch，finally语句，不多说了 如果超类没有抛出任何异常，子类也不能抛出任何异常，如果编写一个覆盖超类的方法，这个方法又没有抛出异常，就必须捕获方法代码种出现的每一个受查异常]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring04-AspectJ]]></title>
    <url>%2F2019%2F05%2F22%2FSpring04-AspectJ%2F</url>
    <content type="text"><![CDATA[Spring04-AspectJ源代码在这 @AspectJ的风格类似于纯Java注解的普通Java类 Spring可以使用AspectJ来做切入点解析 AOP的运行时仍旧是纯的Spring AOP，对AspectJ的编译器或者织入无依赖性 Enabling @AspectJ Support对@AspectJ支持可以使用XML或Java风格的配置 Java注解方式1234@Configuration@EnableAspectJAutoProxypublic class AppConfig &#123;&#125; XML配置1&lt;aop:aspectj-autoproxy /&gt; Declaring an aspect@AspectJ切面使用@Aspect注解配置，拥有@Aspect的任何bean将被Spring自动识别并应用，用@Aspect注解的类可以有方法和字段，他们也可能包括切入点（pointcut），通知（advice）和引入（introduction）声明，@Aspect注解不能通过类路径自动检测发现，需要配合使用@Component注释或者在xml配置bean一个类中的@Aspect注解标识它为一个切面，并且将自己从自动代理中排除（假如切面类和业务类在同一包下，或者相同包的不同子包中，切入点的声明只声明了它们的基本包，声明了@Aspect的切面不会代理它自己，即检测到自己不会调用通知方法） 定义一个切面模板如下： 123&lt;bean id="myAspect" class="org.xyz.NotVeryUsefulAspect"&gt; &lt;!-- configure properties of aspect here as normal --&gt;&lt;/bean&gt; 1234567package org.xyz;import org.aspectj.lang.annotation.Aspect;@Aspectpublic class NotVeryUsefulAspect &#123;&#125; Declaring a pointcut一个切入点通过一个普通的方法定义来提供，并且切入点表达式使用@Pointcut注解，方法返回类型必须是void 下面定义一个名为anyOldTransfer，这个切入点将匹配任何名为”transfer”的方法的执行 12@Pointcut("execution(* transfer(..))")// the pointcut expressionprivate void anyOldTransfer() &#123;&#125;// the pointcut signature Supported Pointcut Designators execution - for matching method execution join points, this is the primary pointcut designator you will use when working with Spring AOP（匹配方法执行的切入点） within - limits matching to join points within certain types (simply the execution of a method declared within a matching type when using Spring AOP)（限定匹配特定类型的切入点） this - limits matching to join points (the execution of methods when using Spring AOP) where the bean reference (Spring AOP proxy) is an instance of the given type（匹配特定切入点的bean引用是指定类型的实例的限制） target - limits matching to join points (the execution of methods when using Spring AOP) where the target object (application object being proxied) is an instance of the given type args - limits matching to join points (the execution of methods when using Spring AOP) where the arguments are instances of the given types @target - limits matching to join points (the execution of methods when using Spring AOP) where the class of the executing object has an annotation of the given type @args - limits matching to join points (the execution of methods when using Spring AOP) where the runtime type of the actual arguments passed have annotations of the given type(s) @within - limits matching to join points within types that have the given annotation (the execution of methods declared in types with the given annotation when using Spring AOP) @annotation - limits matching to join points where the subject of the join point (method being executed in Spring AOP) has the given annotation e.g. 123456789101112@Component@Aspectpublic class MoocAspect &#123; // 当检测到biz这个包里任何以Biz结尾的类的任何方法时，都会匹配当前这个切入点 @Pointcut("execution(* com.mkl.aop.aspectj.biz.*Biz.*(..))") public void pointcut() &#123;&#125; // 检测到biz这个包的任何类都会匹配到这个切入点 @Pointcut("within(com.mkl.aop.aspectj.biz.*)") public void bizPointcut() &#123;&#125;&#125; Combining pointcut expressions切入点表达式可以通过&amp;&amp;，||和!进行组合，也可以通过名字引用切入点表达式，通过组合，可以建立更加复杂的切入点表达式 12345678@Pointcut("execution(public * *(..))")private void anyPublicOperation() &#123;&#125;@Pointcut("within(com.xyz.someapp.trading..*)")private void inTrading() &#123;&#125;@Pointcut("anyPublicOperation() &amp;&amp; inTrading()")private void tradingOperation() &#123;&#125; 定义良好的pointcutsAspectJ是编译器的AOP，检查代码并匹配连接点与切入点的代价是昂贵的 一个好的切入点应该包括以下几点 选择特定类型的连接点，如：execution,get,set,call,handler 确定连接点范围，如：within,withincode 匹配上下文信息，如：this,target,@annotation Before adviceBefore advice is declared in an aspect using the @Before annotation: 123456789@Aspectpublic class BeforeExample &#123; @Before("com.xyz.myapp.SystemArchitecture.dataAccessOperation()") public void doAccessCheck() &#123; // ... &#125;&#125; If using an in-place pointcut expression we could rewrite the above example as: 123456789@Aspectpublic class BeforeExample &#123; @Before("execution(* com.xyz.myapp.dao.*.*(..))") public void doAccessCheck() &#123; // ... &#125;&#125; Before Advice的小DEMO12345678&lt;!-- spring-aop-aspectj.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans ...&gt; &lt;context:component-scan base-package="com.mkl.aop.aspectj" /&gt; &lt;aop:aspectj-autoproxy /&gt;&lt;/beans&gt; 12345678910111213141516171819202122232425262728293031323334// MoocBiz.java@Servicepublic class MoocBiz &#123; public String save(String arg) &#123; System.out.println("MoocBiz save: " + arg); return "Save success"; &#125;&#125;// MoocAspect.java@Component@Aspectpublic class MoocAspect &#123; @Pointcut("execution(* com.mkl.aop.aspectj.biz.*Biz.*(..))") public void pointcut() &#123;&#125;// @Before("execution(* com.mkl.aop.aspectj.biz.*Biz.*(..))") @Before("com.mkl.aop.aspectj.MoocAspect.pointcut()") public void before() &#123; System.out.println("Before"); &#125;&#125;// 单元测试方法@Testpublic void test() &#123; MoocBiz biz = super.getBean("moocBiz"); biz.save("This is test");&#125;// 输出：// Before// MoocBiz save: This is test After returning advice123456789@Aspectpublic class AfterReturningExample &#123; @AfterReturning("com.xyz.myapp.SystemArchitecture.dataAccessOperation()") public void doAccessCheck() &#123; // ... &#125;&#125; 有时候需要在通知体内得到返回的实际值，可以使用@AfterReturning绑定返回值的形式，这里的返回值指的是连接点指定的方法，即被通知的方法的返回值，把该返回值作为参数传递给通知 1234567891011@Aspectpublic class AfterReturningExample &#123; @AfterReturning( pointcut="com.xyz.myapp.SystemArchitecture.dataAccessOperation()", returning="retVal") public void doAccessCheck(Object retVal) &#123; // ... &#125;&#125; AfterReturning的小DEMO大部分和Before advice的一样 12345678910111213141516171819202122232425@Servicepublic class MoocBiz &#123; public String save(String arg) &#123; System.out.println("MoocBiz save: " + arg); return "Save success"; &#125;&#125;@Component@Aspectpublic class MoocAspect &#123; @Pointcut("execution(* com.mkl.aop.aspectj.biz.*Biz.*(..))") public void pointcut() &#123;&#125; @AfterReturning(pointcut = "com.mkl.aop.aspectj.MoocAspect.pointcut()", returning = "returnValue") public void afterReturning(Object returnValue) &#123; System.out.println("AfterReturning : " + returnValue); &#125;&#125;// 输出结果：（Save success是MoocBiz的save方法的返回值）// MoocBiz save: This is test// AfterReturning : Save success After throwing advice123456789@Aspectpublic class AfterThrowingExample &#123; @AfterThrowing("com.xyz.myapp.SystemArchitecture.dataAccessOperation()") public void doRecoveryActions() &#123; // ... &#125;&#125; Often you want the advice to run only when exceptions of a given type are thrown, and you also often need access to the thrown exception in the advice body. Use the throwing attribute to both restrict matching (if desired, use Throwable as the exception type otherwise) and bind the thrown exception to an advice parameter. 123456789101112@Aspectpublic class AfterThrowingExample &#123; // The name used in the throwing attribute must correspond to the name of a parameter in the advice method. @AfterThrowing( pointcut="com.xyz.myapp.SystemArchitecture.dataAccessOperation()", throwing="ex") public void doRecoveryActions(DataAccessException ex) &#123; // ... &#125;&#125; After throwing advice的小DEMO12345678910111213141516171819202122232425262728@Servicepublic class MoocBiz &#123; public String save(String arg) &#123; System.out.println("MoocBiz save: " + arg); throw new RuntimeException("Save failed!");// return "Save success"; &#125;&#125;@Component@Aspectpublic class MoocAspect &#123; @AfterThrowing(pointcut = "com.mkl.aop.aspectj.MoocAspect.pointcut()", throwing = "e") public void afterThrowing(RuntimeException e) &#123; System.out.println("AfterThrowing： " + e.getMessage()); &#125;&#125;@Testpublic void test() &#123; MoocBiz biz = super.getBean("moocBiz"); biz.save("This is test");&#125;// MoocBiz save: This is test// AfterThrowing： Save failed! After (finally) advice最终通知必须准备处理正常和异常两种返回情况，它通常用于释放资源 123456789@Aspectpublic class AfterFinallyExample &#123; @After("com.xyz.myapp.SystemArchitecture.dataAccessOperation()") public void doReleaseLock() &#123; // ... &#125;&#125; Around advice环绕通知使用@Around注解来声明，通知方法的第一个参数必须是ProceedingJoinPoint类型，在通知内部调用ProceedingJoinPoint的proceed()方法会导致执行真正的方法，传入一个Object[]对象，数组中的值将被作为参数传递给该方法，Object retVal是真正方法的返回值 123456789101112@Aspectpublic class AroundExample &#123; @Around("com.xyz.myapp.SystemArchitecture.businessService()") public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable &#123; // start stopwatch Object retVal = pjp.proceed(); // stop stopwatch return retVal; &#125;&#125; Advice扩展给advice传递参数1234567891011121314@Before("com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp; args(account,..)")public void validateAccount(Account account) &#123; // ...&#125;// 也可以先给pointcut传递参数，再通过pointcut把参数传递给advice@Pointcut("com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp; args(account,..)")private void accountDataAccessOperation(Account account) &#123;&#125;@Before("accountDataAccessOperation(account)")public void validateAccount(Account account) &#123; // ...&#125; 前两种方法是把切入点的方法的参数通过args(..)，作为参数传递给通知，让通知可以得到被通知的方法的参数 第三种方法是，首先定义一个注解 12345@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface Auditable &#123; AuditCode value();&#125; 然后在advice中引用这个注解 12345@Before("com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; @annotation(auditable)")public void audit(Auditable auditable) &#123; AuditCode code = auditable.value(); // ...&#125; 具体流程是：首先按上面的模板定义一个注解MyAnnotation，然后在切入点的方法中使用这个注解并传入参数，然后在advice添加@Before(&quot;xxx &amp;&amp; @annotation(myAnnotation)&quot;)，然后给advice添加参数public void advice(MyAnnotation myAnnotation)，注解的value就可以通过该参数传递给通知了（注解的value在切入点方法中定义，在通知中使用） 使用注解的DEMO123456789101112131415161718192021222324252627282930313233343536373839404142@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface MoocMethod &#123; String value();&#125;@Component@Aspectpublic class MoocAspect &#123; @Pointcut("execution(* com.mkl.aop.aspectj.biz.*Biz.*(..))") public void pointcut() &#123;&#125; @Before("pointcut() &amp;&amp; @annotation(moocMethod)") public void beforeWithAnnotation(MoocMethod moocMethod) &#123; System.out.println("BeforeWithParam: " + moocMethod.value()); &#125;&#125;@Servicepublic class MoocBiz &#123; @MoocMethod("MoocBiz save MoocMethod.") public String save(String arg) &#123; System.out.println("MoocBiz save: " + arg);// throw new RuntimeException("Save failed!"); return "Save success"; &#125;&#125;@Testpublic void test() &#123; MoocBiz biz = super.getBean("moocBiz"); biz.save("This is test");&#125;// 输出结果/*BeforeWithParam: MoocBiz save MoocMethod.MoocBiz save: This is test*/ 其他的Advice扩展比如对泛型的处理，通过argNames决定参数名称，都可以去看Spring-5.0.14官方文档 Introductions允许一个切面声明一个通知对象实现指定接口，并提供一个接口实现类来代表这些对象 introduction使用@DeclareParents进行注解，这个注解用来定义匹配的类型拥有一个新的parent e.g.给定一个接口UsageTracked，并且该接口拥有DefaultUsageTracked的实现，接下来的切面声明了所有的service包下的类的实现都实现了UsageTracked接口 123456789101112@Aspectpublic class UsageTracking &#123; @DeclareParents(value="com.xzy.myapp.service.*+", defaultImpl=DefaultUsageTracked.class) public static UsageTracked mixin; @Before("com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; this(usageTracked)") public void recordUsage(UsageTracked usageTracked) &#123; usageTracked.incrementUseCount(); &#125;&#125; 切面实例化模型“perthis”切面通过指定@Aspect注解perthis子句实现每个独立的service对象执行时都会创建一个切面实例service对象的每个方法在第一次执行的时候创建切面实例，切面在service对象失效的同时失效 1234567891011@Aspect("perthis(com.xyz.myapp.SystemArchitecture.businessService())")public class MyAspect &#123; private int someState; @Before(com.xyz.myapp.SystemArchitecture.businessService()) public void recordServiceUsage() &#123; // ... &#125;&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>AOP</tag>
        <tag>切面</tag>
        <tag>切入点</tag>
        <tag>通知</tag>
        <tag>AspectJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring03-AOP基本概念]]></title>
    <url>%2F2019%2F05%2F21%2FSpring03-AOP%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[Spring03-AOP基本概念源代码在这 基本概念什么是AOP？AOP：Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术主要功能：日志记录，性能统计，安全控制，事务管理，异常处理等等 AOP实现方式 预编译：AspectJ 运行期动态代理（JDK动态代理，CGLib动态代理）：SpringAOP，JbossAOP AOP几个相关概念 名称 说明 切面Aspect 一个关注点的模块化，这个关注点可能会横切多个对象 连接点Joinpoint 程序执行过程中的某个特定的点（比如某个类的方法） 通知Advice 在切面的某个特定的连接点上执行的动作（比如上述方法执行时额外执行的切面的动作） 切入点Pointcut 匹配连接点的断言，在AOP中通知和一个切入点表达式关联（如何在切面中去匹配一个连接点） 引入Introduction 在不修改类代码前提下，为类添加新的方法和属性 目标对象Target Object 被一个或者多个切面所通知的对象 AOP代理AOP Proxy AOP框架创建的对象，用来实现切面契约（包括通知方法执行等功能） 织入Weaving 把切面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象，分为：编译时织入，类加载时织入，执行时织入 通知Advice的类型 名称 说明 前置通知 在某连接点之前执行的通知，但不能阻止连接点前的执行（除非它抛出异常） 返回后通知 在某连接点正常完成后执行的通知 抛出异常后通知 在方法抛出异常退出时执行的通知 后通知 当某连接点退出的时候执行的通知（不论是正常返回还是异常退出） 环绕通知 包围一个连接点的通知 Spring框架中AOP的用途 提供了声明式的企业服务，特别是EJB的代替服务的声明 允许用户定制自己的方面，以完成OOP与AOP的互补使用 Spring的AOP的实现 纯Java实现，无需特殊的编译过程，不需要控制类加载器层次 目前只支持方法执行连接点（通知Spring Bean的方法执行） 不是为了提供最完整的AOP实现，而是侧重于提供一种AOP实现和Spring IoC容器之间的整合，用于帮助解决企业应用中常见的问题 Spring AOP不会与AspectJ竞争，从而提供综合全面的AOP解决方案 有接口和无接口的Spring AOP实现区别 Spring AOP默认使用标准的JavaSE动态代理作为AOP代理，使得任何接口都可以被代理 Spring AOP中也可以使用CGLIB代理（如果一个业务对象并没有实现一个接口） Schema-base的AOP实现官方文档的schema-based AOP support 看官方文档写的挺全的，也不难懂 schema-defined aspects只支持singleton model Declaring an aspect基于使用配置的AOP实现Spring所有的切面和通知器都必须放在一个&lt;aop:config&gt;内（可以配置多个），每个&lt;aop:config&gt;可以包含pointcut，advisor和aspect元素（它们必须按照这个顺序进行声明） 12345678910&lt;!-- 把下面的bean作为一个AOP声明 --&gt;&lt;aop:config&gt; &lt;aop:aspect id="myASpect" ref="aBean"&gt; ... &lt;/aop::aspect&gt;&lt;/aop:config&gt;&lt;bean id="aBean" class="..."&gt; ...&lt;/bean&gt; Declaring a pointcut官方文档里面上一节AspectJ support的切入点基本包括了所有的切入点表达式 A named pointcut can be declared inside an aop:config element, enabling the pointcut definition to be shared across several aspects and advisors. 123456&lt;aop:config&gt; &lt;aop:pointcut id="businessService" expression="execution(* com.xyz.myapp.service.*.*(..))"/&gt;&lt;/aop:config&gt; Declaring a pointcut inside an aspect is very similar to declaring a top-level pointcut: 123456789101112&lt;aop:config&gt; &lt;aop:aspect id="myAspect" ref="aBean"&gt; &lt;aop:pointcut id="businessService" expression="execution(* com.xyz.myapp.service.*.*(..))"/&gt; ... &lt;/aop:aspect&gt;&lt;/aop:config&gt; Declaring advice可以在&lt;aop:before&gt;中指定pointcut-ref，该ref为aop:pointcut的id，method为&lt;aop:aspect&gt;指定的bean的方法 Before advice123456789&lt;aop:aspect id="beforeExample" ref="aBean"&gt; &lt;aop:before pointcut-ref="dataAccessOperation" method="doAccessCheck"/&gt; ...&lt;/aop:aspect&gt; 也可以直接在&lt;aop:before&gt;中直接指定pointcut 123456789&lt;aop:aspect id=&quot;beforeExample&quot; ref=&quot;aBean&quot;&gt; &lt;aop:before pointcut=&quot;execution(* com.xyz.myapp.dao.*.*(..))&quot; method=&quot;doAccessCheck&quot;/&gt; ...&lt;/aop:aspect&gt; After returning advice123456789&lt;aop:aspect id="afterReturningExample" ref="aBean"&gt; &lt;aop:after-returning pointcut-ref="dataAccessOperation" method="doAccessCheck"/&gt; ...&lt;/aop:aspect&gt; Just as in the @AspectJ style, it is possible to get hold of the return value within the advice body. Use the returning attribute to specify the name of the parameter to which the return value should be passed: 12345678910&lt;aop:aspect id="afterReturningExample" ref="aBean"&gt; &lt;aop:after-returning pointcut-ref="dataAccessOperation" returning="retVal" method="doAccessCheck"/&gt; ...&lt;/aop:aspect&gt; The doAccessCheck method must declare a parameter named retVal. The type of this parameter constrains matching in the same way as described for @AfterReturning. For example, the method signature may be declared as: public void doAccessCheck(Object retVal) {... After throwing advice123456789&lt;aop:aspect id="afterThrowingExample" ref="aBean"&gt; &lt;aop:after-throwing pointcut-ref="dataAccessOperation" method="doRecoveryActions"/&gt; ...&lt;/aop:aspect&gt; Just as in the @AspectJ style, it is possible to get hold of the thrown exception within the advice body. Use the throwing attribute to specify the name of the parameter to which the exception should be passed: 12345678910&lt;aop:aspect id="afterThrowingExample" ref="aBean"&gt; &lt;aop:after-throwing pointcut-ref="dataAccessOperation" throwing="dataAccessEx" method="doRecoveryActions"/&gt; ...&lt;/aop:aspect&gt; The doRecoveryActions method must declare a parameter named dataAccessEx. The type of this parameter constrains matching in the same way as described for @AfterThrowing. For example, the method signature may be declared as: public void doRecoveryActions(DataAccessException dataAccessEx) {... After (finally) adviceAfter (finally) advice runs however a matched method execution exits. It is declared using the after element: 123456789&lt;aop:aspect id="afterFinallyExample" ref="aBean"&gt; &lt;aop:after pointcut-ref="dataAccessOperation" method="doReleaseLock"/&gt; ...&lt;/aop:aspect&gt; Around adviceIt has the opportunity to do work both before and after the method executes, and to determine when, how, and even if, the method actually gets to execute at all. Around advice is often used if you need to share state before and after a method execution in a thread-safe manner (starting and stopping a timer for example). Always use the least powerful form of advice that meets your requirements; don’t use around advice if simple before advice would do. Around advice is declared using the aop:around element. The first parameter of the advice method must be of type ProceedingJoinPoint. Within the body of the advice, calling proceed() on the ProceedingJoinPoint causes the underlying method to execute. The proceed method may also be calling passing in an Object[] - the values in the array will be used as the arguments to the method execution when it proceeds. 123456789&lt;aop:aspect id="aroundExample" ref="aBean"&gt; &lt;aop:around pointcut-ref="businessService" method="doBasicProfiling"/&gt; ...&lt;/aop:aspect&gt; 123456public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable &#123; // start stopwatch Object retVal = pjp.proceed(); // stop stopwatch return retVal;&#125; Advice parametersAdvice可以传入参数，如下面例子，指定切面为MoocAspect，切入点为* com.mkl.aop.schema.advice.biz.AspectBiz.init(String, int)，注意表达式pointcut=&quot;execution(* com.mkl.aop.schema.advice.biz.AspectBiz.init(String, int)) and args(bizName, times)&quot;，表示指定切入点，并且把切入点的参数作为通知的参数传入给通知，切面的通知方法aroundInit除了一个ProceedingJoinPoint参数，还要有一个String bizName，int times参数，通知的参数名必须要和表达式的args里面的参数名一致 执行AspectInit的init方法的时候，会有MoocAspect切面的通知来临，并把init方法的参数传递给该通知作为该通知的参数，需要注意配置的时候，切入点的args(arg1, arg2, …)的arg1,arg2,…必须要和切面对应通知方法的参数名对应起来 1234567&lt;bean id="moocAspect" class="com.mkl.aop.schema.advice.MoocAspect" /&gt;&lt;bean id="aspectBiz" class="com.mkl.aop.schema.advice.biz.AspectBiz" /&gt;&lt;aop:config&gt; &lt;aop:aspect id="moocAspectAOP" ref="moocAspect"&gt; &lt;aop:around method="aroundInit" pointcut="execution(* com.mkl.aop.schema.advice.biz.AspectBiz.init(String, int)) and args(bizName, times)" /&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 123456789101112131415161718192021222324252627public class AspectBiz &#123; public void init(String bizName, int times) &#123; System.out.println("AspectBiz init: " + bizName + " " + times); &#125;&#125;public class MoocAspect &#123; public Object aroundInit(ProceedingJoinPoint pjp, String bizName, int times) throws Throwable &#123; System.out.println(bizName + " " + times + " before"); Object retVal = pjp.proceed(); System.out.println(bizName + " " + times + " after"); return retVal; &#125;&#125;// 单元测试方法@Testpublic void testInit() &#123; AspectBiz biz = super.getBean("aspectBiz"); biz.init("moocService", 3);&#125;/*moocService 3 beforeAspectBiz init: moocService 3moocService 3 after*/ 一个切面，切入点和通知整合的schema-based AOP的例子123456789101112&lt;aop:config&gt; &lt;aop:aspect id="moocAspectAOP" ref="moocAspect"&gt; &lt;aop:pointcut id="moocPointcut" expression="execution(* com.mkl.aop.schema.advice.biz.*Biz.*(..))" /&gt; &lt;aop:before method="before" pointcut-ref="moocPointcut" /&gt; &lt;aop:after-returning method="afterReturning" pointcut-ref="moocPointcut" /&gt; &lt;aop:after-throwing method="afterThrowing" pointcut-ref="moocPointcut" /&gt; &lt;aop:after method="after" pointcut-ref="moocPointcut" /&gt; &lt;aop:around method="around" pointcut-ref="moocPointcut" /&gt; &lt;aop:around method="aroundInit" pointcut="execution(* com.mkl.aop.schema.advice.biz.AspectBiz.init(String, int)) and args(bizName, times)" /&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; Introductions简介允许一个切面声明一个实现指定接口的通知对象，并且提供了一个接口实现类来代表这些对象 An introduction is made using the aop:declare-parents element inside an aop:aspect This element is used to declare that matching types have a new parent (hence the name).（此元素用于声明匹配类型具有新父级） 看一个例子，下面xml中types-matching就是匹配的类型，即上文中实现指定接口的通知对象，implement-interface就是指定接口，default-impl就是接口的实现类，它把匹配到的类型声明一个新的父级，该父级就是接口Fit，可以通过强制转换调用父级的方法 123456789&lt;bean id="moocAspect" class="com.mkl.aop.schema.advice.MoocAspect" /&gt;&lt;bean id="aspectBiz" class="com.mkl.aop.schema.advice.biz.AspectBiz" /&gt;&lt;aop:config&gt; &lt;aop:aspect id="moocAspectAOP" ref="moocAspect"&gt; &lt;aop:declare-parents types-matching="com.mkl.aop.schema.advice.biz.*(+)" implement-interface="com.mkl.aop.schema.advice.Fit" default-impl="com.mkl.aop.schema.advice.FitImpl" /&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 1234567891011121314151617181920212223242526// AspectBiz.java不重要，随意// Fit.javapublic interface Fit &#123; void filter();&#125;// FitImpl.javapublic class FitImpl implements Fit &#123; @Override public void filter() &#123; System.out.println("FitImpl filter"); &#125;&#125;// 单元测试方法@Testpublic void testFit() &#123; Fit fit = (Fit) super.getBean("aspectBiz"); fit.filter();&#125;// 输出：// FitImpl filter Advisorsadvisor就像一个小的自包含的方面，只有一个advice 切面自身通过一个bean表示，并且必须实现某个advice接口，同时，advisor也可以很好的利用AspectJ的切入点表达式 Spring通过配置文件中&lt;aop:advisor&gt;元素支持advisor实际使用，大多数情况下它会和transactional advice配合使用 为了定义一个advisor的优先级以便让advice可以有序，可以使用order属性来定义advisor的顺序，它的语法如下： 12345678910111213141516&lt;aop:config&gt; &lt;aop:pointcut id="businessService" expression="execution(* com.xyz.myapp.service.*.*(..))"/&gt; &lt;aop:advisor pointcut-ref="businessService" advice-ref="tx-advice"/&gt;&lt;/aop:config&gt;&lt;tx:advice id="tx-advice"&gt; &lt;tx:attributes&gt; &lt;tx:method name="*" propagation="REQUIRED"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 常见问题1.面向切面编写时报下面错误java.lang.NoClassDefFoundError: org/aspectj/weaver/reflect/ReflectionWorld$ReflectionWorldException原因：缺少aspectjweaver.jar这个包解决：maven查找该包导入]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>AOP</tag>
        <tag>切面</tag>
        <tag>切入点</tag>
        <tag>通知</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring02-Bean装配]]></title>
    <url>%2F2019%2F05%2F20%2FSpring02-Bean%E8%A3%85%E9%85%8D%2F</url>
    <content type="text"><![CDATA[Spring02-Bean装配源代码在这 Classpath扫描与组件的注解配置Spring注解Spring3.0开始，Spring JavaConfig提供了很多特性，包括使用java而不是XML定义bean，比如@Configuration,@Bean,@Import,@DependsOn等 @Component是一个通用注解，可用于任何bean，下面三个都是Component的子注解 @Repository通常用于注解DAO类，即持久层 @Service通常用于注解Service类，即服务层 @Controller通常用于注解Controller类，即控制层（MVC） 类的自动检测及Bean的注册Spring可以自动检测类并注册Bean到ApplicationContext中，首先类必须要有注解，比如@Service,@Repository,@Controller,@Component，然后@Autowired注册到成员或方法中(比如一个类注解了@Repository，另外一个类注解了@Service，且它有个成员变量的类型是注解了@Repository的类的类型，给该成员或该成员的setter添加@Autowired即可自动装配) XML的Spring配置标签&lt;context:component-scan base-package=&quot;org.example&quot;&gt;的作用是组件扫描，扫描到类上哪些注解注解了@Service,@Repository,@Controller,@Component，然后把它注册到IOC容器中去，它有一个属性base-package，是扫描该包下的所有类 &lt;context:component-scan base-package=&quot;org.example&quot;&gt;包含&lt;context:annotation-config /&gt;，前者作用如上所述，后者是完成了bean的注册后，去处理基于bean的方法或成员变量的注解(@Autowired)，前者包含了后者的全部功能，使用了前者后就不再使用后者 使用过滤器进行自定义的扫描默认情况下，类被自动发现并注册bean的条件是：使用@Service,@Repository,@Controller,@Component注解或者使用@Component的自定义注解可以通过过滤器修改上面的行为，如下面例子的XML配置的意思是包含正则表达式为.Stub.Repository的类，排除注解为org.springframework.stereotype.Repository的类 123456789&lt;!-- The following example shows the configuration ignoring all @Repository annotations and using "stub" repositories instead. --&gt;&lt;beans&gt; &lt;context:component-scan base-package="org.example"&gt; &lt;context:include-filter type="regex" expression=".*Stub.*Repository" /&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Repository" /&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; type的类型有下面 上面XML配置文件等价于 1234567@Configuration@ComponentScan(basePackages = "org.example", includeFilters = @Filter(type = FilterType.REGEX, pattern = ".*Stub.*Repository"), excludeFilters = @Filter(Repository.class))public class AppConfig &#123; ...&#125; You can also disable the default filters by setting useDefaultFilters=false on the annotation or providing use-default-filters=”false” as an attribute of the element. This will in effect disable automatic detection of classes annotated with @Component, @Repository, @Service, @Controller, or @Configuration. 定义Bean扫描过程中组件被自动检测，如果没有显式指定Bean名称，则由BeanNameGenerator生成(@Service,@Repository,@Controller,@Component都有个name属性用于显式设置Bean Name)，使用默认生成的BeanName是把第一个字母小写后的类名 可以自定义bean命名策略，实现BeanNameGenerator接口，并包含一个无参数构造器 1234&lt;beans&gt; &lt;context:component-scan base-package="org.example" name-generator="org.example.MyNameGenerator" /&gt;&lt;/beans&gt; 作用域类加注解@Scope(“xxx”)，xxx为bean的作用域（prototype，singleton等），默认的作用域为singleton 自定义scpoe，实现ScopeMetadataResolver接口，提供无参构造器 1234&lt;beans&gt; &lt;context:component-scan base-package="org.example" scope-resolver="org.example.MyScopeResolver" /&gt;&lt;/beans&gt; 几个小DEMO最简单的注解DEMO1234567891011&lt;!-- spring配置文件：spring-beanannotation.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:component-scan base-package="com.mkl.beanannotation" /&gt;&lt;/beans&gt; 123456789101112/* BeanAnnotation.java */package com.mkl.beanannotation;import org.springframework.stereotype.Component;@Componentpublic class BeanAnnotation &#123; public void say(String arg) &#123; System.out.println("BeanAnnotation: " + arg); &#125;&#125; 单元测试略，通过配置文件的&lt;context:component-scan base-package=&quot;com.mkl.beanannotation&quot; /&gt;，实现了IOC容器的自动扫描，扫描到BeanAnnotation的@Component注解，并注册入IOC容器，默认名为beanAnnotation 作用域的DEMO12345678910111213/* BeanAnnotation.java */package com.mkl.beanannotation;import org.springframework.stereotype.Component;@Component@Scope("prototype")public class BeanAnnotation &#123; public void myHashCode() &#123; System.out.println("BeanAnnotation: " + this.hashCode()); &#125;&#125; 1234567891011121314151617/* TestBeanAnnotation.java 单元测试类 */@RunWith(BlockJUnit4ClassRunner.class)public class TestBeanAnnotation extends UnitTestBase &#123; public TestBeanAnnotation() &#123; super("classpath*:spring-beanannotation.xml"); &#125; @Test public void testScope() &#123; BeanAnnotation bean = super.getBean("bean"); bean.myHashCode(); BeanAnnotation bean2 = super.getBean("bean"); bean2.myHashCode(); &#125;&#125; AutowiredRequired适用于Bean属性的setter方法，它表示受影响的bean属性必须在配置时被填充，通过在bean定义或通过自动装配一个明确的属性值 Autowired注解beanAutowired可用于成员，setter和构造器，完成自动装配，它比@Required使用范围更广，用的更多 默认情况下，如果找不到合适的bean导致autowiring失败抛出异常，可以通过autowire的属性避免，@Autowired(required=false)每个类的构造器都可以有@Autowired，但只能有一个构造器被标记为required=true@Autowired的必要属性，建议使用@Required注解 小DEMO通过注解实现的自动注入，在IOC容器中扫描出注解了那4个bean注解的类，注册入IOC容器，然后根据@Autowired把injectionDAO注入到injectionService中去 12345678910111213141516171819202122232425262728// InjectionService接口只有save方法，略@Servicepublic class InjectionServiceImpl implements InjectionService &#123; //@Autowired private InjectionDAO injectionDAO; @Autowired public InjectionServiceImpl(InjectionDAO injectionDAO) &#123; this.injectionDAO = injectionDAO; &#125; public InjectionDAO getInjectionDAO() &#123; return injectionDAO; &#125; //@Autowired public void setInjectionDAO(InjectionDAO injectionDAO) &#123; this.injectionDAO = injectionDAO; &#125; public void save(String args) &#123; System.out.println(&quot;Service接收参数：&quot; + args); args = args + &quot;:&quot; + this.hashCode(); injectionDAO.save(args); &#125;&#125; 12345678// InjectionDAO只有save方法，略@Repositorypublic class InjectionDAOImpl implements InjectionDAO &#123; public void save(String args) &#123; System.out.println("保存数据：" + args); &#125;&#125; Autowired注解众所周知的解析依赖性接口比如：BeanFactory,ApplicationContext,Environment,ResourceLoader,ApplicationEventPublisher,and MessageSource，可以实现它们的自动装配 1234567public class MovieRecommender &#123; @Autowired private ApplicationContext context; ...&#125; AutoWired注解需要该类型的数组的字段或方法可以通过添加注解给需要该类型的数组的字段或方法，以提供ApplicationContext中的所有特定类型的bean 123456private Set&lt;MovieCatalog&gt; movieCatalogs;@Autowiredpublic void setMovieCatalogs(Set&lt;MovieCatalog&gt; movieCatalogs) &#123; this.movieCatalogs = movieCatalogs;&#125; 1234567private Map&lt;String, MovieCatalog&gt; movieCatalogs;@Autowiredpublic void setMovieCatalogs(Map&lt;String, MovieCatalog&gt; movieCatalogs) &#123; this.movieCatalogs = movieCatalogs;&#125;// 用map的话，key必须是String，为bean的ID 如果希望数组有序（map，set无序，Order不会有效），可以让bean实现org.springframework.core.Ordered接口或使用@Order注解 小DEMO12// BeanInterfacepublic interface BeanInterface &#123; &#125; 1234// BeanImplOne@Order(value = 1)@Componentpublic class BeanImplOne implements BeanInterface &#123; &#125; 1234// BeanImplTwo@Order(2)@Componentpublic class BeanImplTwo implements BeanInterface &#123; &#125; 1234567891011121314151617181920212223242526272829// BeanInvoker@Componentpublic class BeanInvoker &#123; @Autowired private List&lt;BeanInterface&gt; list; @Autowired private Map&lt;String, BeanInterface&gt; map; public void say() &#123; if (null != list &amp;&amp; 0 != list.size()) &#123; System.out.println("list..."); for (BeanInterface bean : list) &#123; System.out.println(bean.getClass().getName()); &#125; &#125; else &#123; System.out.println("list null"); &#125; if (null != map &amp;&amp; 0 != map.size()) &#123; System.out.println("map..."); for (Map.Entry&lt;String, BeanInterface&gt; entry : map.entrySet()) &#123; System.out.println(entry.getKey() + " " + entry.getValue().getClass().getName()); &#125; &#125; else &#123; System.out.println("map null"); &#125; &#125;&#125; 12345678910111213141516// 单元测试@Testpublic void testMultiBean() &#123; BeanInvoker invoker = super.getBean("beanInvoker"); invoker.say();&#125;/** 输出结果：* list...* com.mkl.beanannotation.multibean.BeanImplOne* com.mkl.beanannotation.multibean.BeanImplTwo* map...* beanImplOne com.mkl.beanannotation.multibean.BeanImplOne* beanImplTwo com.mkl.beanannotation.multibean.BeanImplTwo*/ Autowired不能用在哪@Autowired由Spring BeanPostProcessor处理，所以不能在自己的BeanPostProcessor或BeanFactoryPostProcessor类型应用这些注解，这些类型必须通过XML或者Spring的@Bean注解加载 Qualifier注解 按类型自动装配可能多个bean实例的情况，可以使用Spring的@Qualifier注解缩小范围（或指定唯一），也可以用于指定单独的构造器参数或方法参数 可用于注解集合类型变量 1234567public class MovieRecommender &#123; // 当IOC容器中有多个MovieCatalog，自动装载使用ID为main的那一个 @Autowired @Qualifier("main") private MovieCatalog movieCatalog;&#125; 1234567891011public class MovieRecommender &#123; private MovieCatalog movieCatalog; private CustomerPreferenceDao customerPreferenceDao; // 当IOC容器中有多个MovieCatalog，自动装载使用ID为main的那一个 @Autowired public void prepare(@Qualifier("main")MovieCatalog movieCatalog, CustomerPreferenceDao customerPreferenceDao) &#123; this.movieCatalog = movieCatalog; this.customerPreferenceDao = customerPreferenceDao; &#125;&#125; Qualifier的XML实现： 123&lt;bean class="xxx"&gt; &lt;qualifier value="main" /&gt;&lt;/bean&gt; Resource注解 如果通过名字进行注解注入，主要使用的不是@Autowired（即使技术上能够通过@Qualifier指定bean的名字）代替方式是JSR-250@Resource注解，它是通过其独特的名称来定义来识别特定的目标（这是一个与所声明的类型无关的匹配过程） 因语义差异，集合或Map类型的bean无法通过@Autowired来注入，因为没有类型匹配到这样的bean，为这些bean使用@Resource注解，通过唯一名称引用集合或Map的bean 与Qualifiers的区别 @Autowired适用于fields，constructors，multi-argument methods这些允许在参数级别使用@Qualifier注解缩小范围的情况 @Resource适用于成员变量，只有一个参数的setter方法，所以在目标是构造器或一个多参数方法时，最好方式是使用qualifiers Qualifiers的小DEMO1234567891011121314151617181920// BeanInvoker,其他类同上@Componentpublic class BeanInvoker &#123; ... // 通过@Qualifier("beanName")指定beanInterface的bean @Autowired @Qualifier("beanImplOne") private BeanInterface beanInterface; public void say() &#123; ... if (null != beanInterface) System.out.println(beanInterface.getClass().getName()); else System.out.println("beanInterface null"); &#125;&#125; 基于Java容器的注解Bean注解与Configuration注解@Bean标识一个用于配置和初始化一个由SpringIoC容器管理的新对象的方法，类似于XML配置文件的&lt;bean/&gt; 可以在Spring的@Component注解的类中使用@Bean注解任何方法（仅仅是可以） 上一点中，通常使用的是@Configuration 12345678@Configurationpublic class AppConfig &#123; @Bean public MyService myService() &#123; return new MyServiceImpl(); &#125;&#125; 相当于 123&lt;beans&gt; &lt;bean id="myService" class="com.xxx.MyServiceImpl" /&gt;&lt;/beans&gt; Bean注解支持自定义的Bean name，@Bean(name = &quot;myFoo&quot;)，如果不指定，默认是该注解对应方法的方法名它支持init-method和destroy-method 12345678910111213public class Foo &#123; public void init() &#123; ... &#125;&#125;public class Bar &#123; public void cleanup() &#123; ... &#125;&#125;@Configurationpublic class AppConfig &#123; @Bean(initMethod = "init") public Foo foo() &#123; return new Foo(); &#125; @Bean(destroyMethod = "cleanup") public Bar bar() &#123; return new Bar(); &#125;&#125; 一个使用Bean注解与Configuraion注解的小DEMO12345678910111213141516171819202122232425public interface Store &#123;&#125;public class StringStore implements Store &#123; public void init() &#123; System.out.println("init Store"); &#125; public void destroy() &#123; System.out.println("destroy Store"); &#125;&#125;@Configurationpublic class StoreConfig &#123; @Bean(initMethod = "init", destroyMethod = "destroy") public Store stringStore() &#123; return new StringStore(); &#125;&#125;// 单元测试类里的单元测试方法@Testpublic void test() &#123; Store store = super.getBean("stringStore"); System.out.println(store.getClass().getName());&#125; 它与上面的@Component主要区别是不用每个Bean都添加@Component，但是要有一个AppConfig来为每个Bean配置一个方法，并加上@Bean注解 ImportResource注解与Value注解实现对资源文件引入可以通过xml中&lt;beans&gt;的子标签property-placeholder location=&quot;xxx&quot;来指定资源文件，然后在&lt;bean&gt;中使用该资源文件的内容，如下图，在properties-config.xml中引用了jdbc.properties，然后在&lt;bean&gt;中通过{jdbc.url}等引用其值 使用注解也可以把资源文件的值赋给Java类，看下图（注意引入的资源是properties-config.xml，在properties-config.xml中，仍然存在&lt;context:property-placeholder location=&quot;classpath:xxxx.properties&quot; /&gt; 通过类配置@ImportResource，属性配置@Value(“${jdbc.url}”)实现同样的效果 引入资源文件的小DEMO资源文件，IDEA右键resources，new一个Resource Bundle，资源文件如下 12345# config.propertiespassword=rooturl=127.0.0.1jdbc.username=root# 需要注意username输出的是系统用户的名字，而不是这里的key，所以为了避免重名，最好对key加前缀 123456&lt;!-- config.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans ...&gt; &lt;context:property-placeholder location="config.properties" /&gt;&lt;/beans&gt; 1234567public class MyDriverManager &#123; public MyDriverManager(String url, String userName, String password) &#123; System.out.println("url:" + url); System.out.println("userName:" + userName); System.out.println("password:" + password); &#125;&#125; 123456789101112131415161718@Configuration@ImportResource("classpath:config.xml")public class StoreConfig &#123; @Value("$&#123;url&#125;") private String url; @Value("$&#123;jdbc.username&#125;") private String userName; @Value("$&#123;password&#125;") private String password; @Bean public MyDriverManager myDriverManager() &#123; return new MyDriverManager(url, userName, password); &#125;&#125; 123456789101112// 单元测试类里的单元测试方法@Testpublic void testMyDriverManager() &#123; MyDriverManager myDriverManager = super.getBean("myDriverManager"); System.out.println(myDriverManager.getClass().getName());&#125;/* 输出结果url:127.0.0.1userName:rootpassword:rootcom.mkl.beanannotation.javabased.MyDriverManager*/ Scope注解@Scope除了可以给@Component和其子注解注明范围以外，还可以给@Bean注明，@Bean默认也是单例，可以通过@Scope(“prototype”)来注明范围为prototype（每次请求创建一个新对象） 基于泛型的自动装配12345678910111213@Configurationpublic class MyConfiguration @Bean public StringStore stringStore() &#123; return new StringStore(); &#125; @Bean public IntegerStore integerStore() &#123; return new IntegerStore(); &#125;&#125; 12345678910@Autowiredprivate Store&lt;String&gt; s1; // &lt;String&gt; qualifier, injects the stringStore bean@Autowiredprivate Store&lt;Integer&gt; s2; // &lt;Integer&gt; qualifier, injects the integerStore bean// Inject all Store beans as long as they have an &lt;Integer&gt; generic// Store&lt;String&gt; beans will not appear in this list@Autowiredprivate List&lt;Store&lt;Integer&gt;&gt; s; 基于泛型的自动装配的小DEMO1234567891011121314151617181920212223242526272829303132333435363738394041public class IntegerStore implements Store&lt;Integer&gt; &#123; &#125;public class StringStore implements Store&lt;String&gt; &#123; &#125;public class TestStore &#123; &#125;@Configurationpublic class StoreConfig &#123; @Autowired private Store&lt;String&gt; s1; @Autowired private Store&lt;Integer&gt; s2; @Bean public StringStore stringStore() &#123; return new StringStore(); &#125; @Bean public IntegerStore integerStore() &#123; return new IntegerStore(); &#125; @Bean(name = "GenericTestStore") public TestStore testStore() &#123; System.out.println("s1: " + s1.getClass().getName()); System.out.println("s2: " + s2.getClass().getName()); return new TestStore(); &#125;&#125;@Testpublic void testG() &#123; TestStore store = super.getBean("GenericTestStore");&#125;// 输出结果：// s1: com.mkl.beanannotation.javabased.StringStore// s2: com.mkl.beanannotation.javabased.IntegerStore Spring对JSR的支持Resource注解Spring支持使用JSR-250@Resource注解的变量或setter方法，@Resource有一个name属性，并且默认Spring解释该值作为被注入bean的名称如果没有显式地指出@Resource的name，默认的名称是从属性名或者setter方法得出注解提供的名字被解析为一个bean的名称，这是由ApplicationContext中的CommonAnnotationBeanPostProcessor发现并处理的 123456789public class SimpleMovieLister &#123; private MovieFinder movieFinder; @Resource(name="myMovieFinder") public void setMovieFinder(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125;&#125; 123456789public class SimpleMovieLister &#123; private MovieFinder movieFinder; @Resource public void setMovieFinder(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125;&#125; PostConstruct注解和PreDestroy注解CommonAnnotationBeanPostProcessor发现并处理的，它不仅能识别@Resource，还支持初始化回调和销毁回调 123456789101112public class CachingMovieLister &#123; @PostConstruct public void populateMovieCache() &#123; // populates the movie cache upon initialization... &#125; @PreDestroy public void clearMovieCache() &#123; // clears the movie cache upon destruction... &#125;&#125; JSR-330标准的注解mavaen导入JSR-330支持 12345&lt;dependency&gt; &lt;groupId&gt;javax.inject&lt;/groupId&gt; &lt;artifactId&gt;javax.inject&lt;/artifactId&gt; &lt;version&gt;1&lt;/version&gt;&lt;/dependency&gt; JSR330中与Spring注解类似的注解（部分）]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring注解</tag>
        <tag>AutoWired</tag>
        <tag>Qualifier</tag>
        <tag>Resource</tag>
        <tag>Component</tag>
        <tag>Configuration</tag>
        <tag>ImportResource</tag>
        <tag>PostConstruc</tag>
        <tag>PreDestroy</tag>
        <tag>JSR330</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM性能调优]]></title>
    <url>%2F2019%2F05%2F18%2FJVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%2F</url>
    <content type="text"><![CDATA[JVM性能调优JVM参数 -Xmx：堆最大内存数 -Xms：堆初始化大小 -Xmn：堆新生代初始及最大大小 -Xss：线程栈大小 -XX:PermSize,-XX:MaxPermSize：方法区大小，永久代大小，JDK1.7之前适用 -XX:MaxDirectMemorySize：直接内存，默认大小与-Xmx大小一样 -XX:SurvivorRatio=n：Survivor与Eden大小的比例为2:n，n默认是8 -XX：NewRatio=n：年轻代(eden+2*survivor)和年老代比值为1:n -XX:+HeapDumpOnOutOfMemoryError：虚拟机出现内存溢出异常时Dump出当前内存堆转快照 Full GC对整个堆进行整理，包括年轻代，老年代，永久代，JVM调优要减少Full GC次数 导致Full GC原因 老年代被写满 持久代空间不足 System.gc()调用 CMS GC时出现promotion failed和concurrent mode failure 统计得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间 Minor GC年轻代的GC叫minor GC，老年代的GC叫Full GC 导致Minor GC原因 Eden区满，触发新生代Minor GC将Eden和非空闲Survivor存活的对象复制到另一个空闲Survivor中 当Survivor区满，通过Minor GC将对象复制到老年代 JVM性能调优方法和步骤 监控GC状态：使用各种JVM工具，查看当前日志，分析当前JVM参数设置，堆内存快照和GC日志，根据实际各区域划分和GC执行时间，判断是否进行优化 生成堆的dump文件 分析dump文件：用Visual VM等待工具 分析结果，判断是否需要优化：如果系统没有超时日志出现，GC频率不高耗时不高，没有必要进行优化 调整GC类型和内存分配 不断分析调整 JVM调优参数参考 针对JVM设置，一般可以通过-Xms -Xmx限定最小，最大值，防止垃圾收集器在最小最大之间收缩堆而产生额外的时间，通常把最大最小值设为相同的值 年轻代和老年代根据默认比例（1：2）分配堆内存，同样的，对于年轻代为了防止堆收缩，-XX:newSize,-XX:MaxNewSize设为相同大小 如果应用存在大量临时对象，应选择更大的年轻代，如果存在相对较多的持久对象，应选择年老代 配置较好的机器上（多核，大内存），可以为年老代选择并行收集算法：XX:+UseParallelOldGC 线程堆栈设置：默认1M，建议256K]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM参数</tag>
        <tag>FullGC与MinorGC</tag>
        <tag>JVM调优</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垃圾收集器与内存分配策略]]></title>
    <url>%2F2019%2F05%2F18%2F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[垃圾收集器与内存分配策略概述GC（Garbage Collection）考虑三个问题：哪些内存需要回收？什么时候回收？如何回收？ 程序计数器，虚拟机栈，本地方法栈随线程而生，随线程而灭，其中栈帧需要的内存是随着方法的进入和退出而有条不紊地执行者出栈和入栈操作，每一个栈帧分配多少内存是在类结构确定下来的时候就已知的，因此这几个区域的内存分配和回收都具备确定性，不需要过多考虑回收的问题。而方法区和堆的内存不一样，一个接口多个实现类需要的内存可能不一样，一个方法中多个分支需要的内存也可能不一样，只有在程序运行期间才知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器关注的是这部分的内存 GC分代分代的垃圾回收策略，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。在Java程序运行过程中，会产生大量的对象，其中有些对象是与业务信息有关的，比如Http请求的Session对象，Socket连接，它们的生命周期比较长，但是有些对象，主要是程序运行过程生成的，比如String对象，不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间，花费时间相对会比较长，但实际上，对长周期对象而言，这种遍历是没有效果的，因为可能进行了很多次遍历后他们依旧存在，因此分代垃圾回收采用分治的思想，把不同生命周期的对象放在不同代上，不同代采用适合它们的垃圾回收方式进行回收 GC分代分为年轻代，年老代和持久代，持久代一般在方法区，保存Java类的类信息，所有新生成的对象都是放在年轻代的，年轻代分为1个Eden区，2个Survivor区，年轻代经历N此垃圾回收后仍然存活的对象，会放到年老代 对象已死吗引用计数算法给对象添加一个引用计数器，每当一个地方引用它时，计数器就加1，当引用失效时，计数器就减1，任何时刻计数器为0的对象就是不可能再被使用的 它实现简单，判定效率也很高，但是很难解决对象之间相互循环引用的问题 如下： 1234567891011121314151617181920212223public class ReferenceCountingGC &#123; public Object instance = null; private static final int _1MB = 1024 * 1024; // 占点内存，以便GC日志看清是否被回收 private byte[] bigSize = new byte[2 * _1MB]; public static void main(String[] args) &#123; ReferenceCountingGC objA = new ReferenceCountingGC(); ReferenceCountingGC objB = new ReferenceCountingGC(); objA.instance = objB; // objA.instance引用了objB这片内存 objB.instance = objA; // objB.instance引用了objA这片内存 objA = null; // 令objA引用null objB = null; // 令objB引用null // 此时，新创建的2个ReferenceCountingGC实例因为互相引用，其引用计数值仍为1，但没有其他引用引用它们，即它们是不可达的 System.gc(); &#125;&#125; 对象objA和objB都有字段instance，赋值令objA.instance = objB及objB.instance = objA;，除此之外这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但因为它们之间互相引用对方，导致它们的引用计数都不为0，引用计数法无法通知GC收集器回收它们 可达性分析算法Java的主流实现就是可达性分析算法，这个算法基本思想是通过一系列称为”GC Roots”的对象作为起始点，从这些节点开始往下搜索。搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（图论知识来说，就是从GC Roots到这个对象不可达），证明此对象是不可用的 Java中，GC Roots对象包括下面几种 虚拟机栈（栈帧的本地变量表）中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈JNI（Native方法）引用的对象 再谈引用在JDK 1.2之前，Java引用的定义很传统：如果reference类型的数据中存储的数值代表另外一块内存的起始地址，就称这块内存代表一个引用，在1.2之后，Java对引用的概念进行了扩充，将引用分为强引用，软引用，弱引用，虚引用4种 强引用：程序代码之中普遍存在的，类似Object obj = new Object()的引用，只要强引用还存在，垃圾收集器就永远不会回收被引用的对象 软引用：描述一些还有用但并非必需的对象，对于软引用关联的对象，在系统将要发生内存溢出溢出之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收完还没有足够的内存，才会抛出内存溢出异常。JDK 1.2后提供了SoftReference类实现软引用 弱引用：也是描述非必需对象的，强度比软引用更弱，只能生存到下次垃圾回收发生之前，WeakReference类实现弱引用 虚引用：最弱的引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通知虚引用来取得一个对象实例，为一个对象设置虚引用的唯一目的是能在这个对象被收集器回收时收到一个系统通知，PhantomReference类实现虚引用 生存还是死亡可达性分析算法中不可达的对象，并不一定真的会死亡，要真正宣告一个对象死亡，至少经历两次标记过程，如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法，当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用，虚拟机将这两种情况视为”没有必要执行” 如果这个对象被判定为有必要执行finalize()方法，那么这个对象就会被放置在一个叫F-Queue的队列中，并在稍后由一个虚拟机自动建立的，低优先级的Finalizer线程去执行它，”执行”指虚拟机会触发这个方法，但不承诺会等待它运行结束，原因是：如果一个对象在finalize()方法执行缓慢，或者发生死循环，很可能导致F-Queue队列的其他对象永久处于等待，甚至整个内存回收系统崩溃。稍后GC对F-Queue中的对象进行第二次小规模的标记，对象如果在finalize()方法中重新与引用链上的任何一个对象关联（this赋值给某个类变量或者对象的成员变量），那么第二次标记时它将被移除出”即将回收”的集合，finalize()方法只会被调用一次，它是C/C++的一种妥协，尽量不要使用它，用try-finally或者其他方法会更好 回收方法区堆中，尤其是新生代中，常规应用一次垃圾收集一般可以回收70%——95%的空间，而永久代（方法区）的垃圾收集效率远低于此 永久代的垃圾收集主要回收两部分：废弃常量和无用的类，回收废弃常量和回收Java堆中的对象非常类似，常量池中字面量回收为例，假如字符串”abc”已经进入常量池，但是没有任何String对象引用常量池的”abc”，也没有其他地方引用这个字面量，如果这时发生内存回收，且必要的话，”abc”就会被系统清理出常量池，常量池其他类，接口，方法，字段的符号引用也与此类似 判断类是否为无用的类，要满足下面三个条件 该类所有实例已经被回收，Java堆中不存在该类任何实例 加载该类的ClassLoader已经被回收 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法 垃圾回收算法标记-清除算法首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象，标记过程前面有说。主要两个不足：标记和清除的效率都不高，标记清除后会产生大量不连续内存碎片，导致分配较大对象时无法得到足够的内存而触发另一次垃圾收集动作 复制算法为了解决效率问题，它将可用内存按容量划分为大小相等的两块，每次只使用其中一块，当一块内存用完，就将还存活的对象复制到另外一块上，然后把已使用的内存空间一次清理掉，这样使得每次都是对整个半区进行内存回收，内存分配时也不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，但代价是内存缩小为原来一半 现在商业虚拟机都采用这种收集算法回收新生代，实际应用并不需要1：1比例划分空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor，新建的对象都被分配到Eden区，经过第一次Minor GC后仍存活就放到Survivor区，当回收时，将Eden和Survivor中还存活的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才使用的过Survivor空间，HotSpot虚拟机默认Eden和Survivor大小比例是8：1，也就是每次新生代中可用的内存空间为整个新生代容量的90%(80%+10%)，没办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够时，需要依赖其他内存呢（老年代）进行分配担保 标记-整理算法复制收集算法在对象存活率比较高时要进行较多的复制操作，效率会变低，在老年代中，对象存活率会很高，不适合复制收集算法根据老年代的特点，可以使用标记-整理算法，标记过程与标记-清除算法的标记过程一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉端边界以外的内存 分代收集算法根据对象存活周期不同将内存划分为几块，一般是把Java堆分为新生代和老年代，新生代采用复制算法，老年代采用标记-清理或标记-整理算法 HotSpot的算法实现枚举根节点可达性分析中从GC Roots节点找引用链这个操作为例，可作为GC Roots的节点主要在全局性的引用（常量或类静态属性）与执行上下文（栈帧的本地变量表）中，现在很多应用仅仅方法区都有数百兆，如果逐个检查这里面的引用，那么必然消耗很多时间 另外，可达性分析对执行时间的敏感还体现在GC停顿上，因为这项工作必须在一个能确保一致性的快照中进行，一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上，不可能出现分析过程对象引用还在不断变化的情况 目前主流Java虚拟机使用的都是准确式GC，当执行系统停顿下来，并不需要一个不漏地检查完所有执行上下文和全局引用位置，而是有办法得知哪些地方存放对象引用，HotSpot中，使用一组OopMap数据结构达到这个目的，在类加载完成时，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，JIT编译过程中，也会特定位置记录下栈和寄存器哪些位置是引用，这样GC扫描时就可以得知这些信息了 安全点OopMap协助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个很现实的问题是，可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，就会需要大量额外的空间，GC的空间成本就会很高 实际上HotSpot只会在特定的位置记录这些信息，这些位置称为安全点，程序执行并非在所有地方都能停顿下来开始GC，只会在安全点才暂停，安全点的选择是以程序”是否具有让程序长时间执行的特征”为标准，例如方法调用，循环跳转，异常跳转等，具有这些功能的指令才会产生Safepoint Safepoint需要考虑的另一个问题是GC发生时所有线程都”跑”到最近安全点再停顿，主流的是主动式中断，思想是：当GC需要中断线程的时候，不直接对线程操作，仅仅简单设置一个标志，各个线程执行时主动轮询这个标志，发现中断标志为真时就自己中断挂起，轮询标志的地方和安全点是重合的 安全区域Safepoint机制保证程序执行时，在不太长时间内就会遇到可进入GC的Safepoint，但是程序不执行时，即没有分配CPU时间时（Sleep或Blocked）状态，这时线程无法响应JVM中断请求，”走”到安全的地方去中断挂起，就需要安全区域(Safe Region)来解决 安全区域指在一段代码片段里，引用关系不会发生变化。在这个区域任意地方开始的GC都是安全的，线程执行到Safe Region的代码时，首先标识自己已经进入Safe Region，这样当这段时间JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了，在线程离开Safe Region，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成，那程序就继续执行，否则它必须等待直到收到可以安全离开Safe Region的信号为止 垃圾收集器 上图展示了7种用于不同分代的垃圾收集器，如果两个收集器之间存在连线，表示它们可以搭配使用，虚拟机所处的区域表示它是新生代收集器还是老年代收集器 Serial收集器 单线程，垃圾收集时必须暂停其他所有工作线程直到收集结束，它是虚拟机运行在Client模式下的默认新生代收集器 ParNew收集器Serial的多线程版本，多条线程进行垃圾收集 左边是ParNew新生代收集器，右边是Serial Old老年代收集器 Parallel Scavenge收集器 它也是新生代收集器，也是使用复制算法的收集器，也是多线程收集器，与ParNew的主要区别是它的关注点不是缩短垃圾收集时用户线程的停顿时间，而是达到一个可控制的吞吐量，即CPU用于运行用户代码的时间与CPU总消耗时间的比值，吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间) 停顿时间越短越适合与用户交互的程序，良好的响应速度能提升用户体验，而提高吞吐量可以高效地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务 Serial Old收集器Serial收集器的老年代版本，使用标记-整理算法 Parallel Old收集器Parallel Scavenge收集器的老年代版本 CMS收集器CMS收集器是一种以获取最短回收停顿时间为目标的收集器，尤其重视响应速度，希望停顿时间最短，基于”标记-清除”算法实现，分为4个步骤 初始标记 并发标记 重新标记 并发清除 初始标记和重新标记需要”Stop The World”，初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记就是进行GC Roots Tracing的过程，重新标记是为了修正并发标记期间因用户程序继续运作而导致的标记产生变动的那一部分对象的标记记录，时间上会比初始标记稍长，但比并发标记短很多 三个缺点 CMS收集器对CPU资源很敏感，因为它是并发标记的，会占用一部分CPU资源而导致程序变慢，总吞吐量降低 无法处理浮动垃圾，可能出现”Concurent Mode Failure”失败而导致另一次Full GC的产生 基于”标记-清除”算法，产生大量空间碎片 G1收集器 JDK 1.7中HotSpot虚拟机的一个重要进化特征 具备如下特点 并行与并发：充分利用多CPU，多核环境，减短Stop-The-World停顿的时间 分代收集：不需要其他收集器就可以独立管理整个GC堆 空间整合：与CMS的”标记-清理”不同，G1从整体来看是基于”标记-整理”算法实现的，局部来看（两个Region之间）是基于”复制”算法实现 可预测的停顿：G1除了追求低停顿，还能建立可预测的停顿时间模型，让使用者明确指定长度M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒 G1收集器把JAVA堆内存划分为多个大小相等的独立区域（Region），虽然保留新生代和老年代概念，但新生代和老年代不再是物理隔离了，它们都是一部分Region的集合 G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得空间大小以及回收所需时间的经验值），在后台维护一个优先队列，每次根据允许的收集时间优先回收价值最大的Region（这也是Garbage-First名称的来由） G1收集器中，Region之间的对象引用以及其他收集器中的新生代与老年代的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描的。G1中每个Region都有一个与之对应的Remembered Set，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（分代例子就是检查老年代引用的对象引用了新生代的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中，当进行内存回收时，在GC根节点的枚举范围加入Remembered Set即可保证不对全堆扫描也不会有遗漏 不计算维护Remembered Set的操作，G1收集器的运作大致划分为以下步骤 初始标记 并发标记 最终标记 筛选回收 内存分配和回收策略使用Serial/Serial Old收集器的内存分配和回收策略 对象优先在Eden分配对象优先在Eden分配，当Eden没有足够空间时，虚拟机将发起一次Minor GC 大对象直接进入老年代大对象指需要大量连续内存空间的Java对象，最典型的是字符串和数组 长期存活的对象将进入老年代虚拟机给每个对象定义了一个对象年龄计数器，如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳，将被移动到Survivor空间，并且对象年龄设为1，对象在Survivor每经过一次Minor GC，年龄就加1岁，当年龄增加到一定程度（默认15岁），就晋升到老年代 动态对象年龄判定虚拟机并不是永远要求对象的年龄必须到达指定才晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象直接进入老年代 空间分配担保在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果成立，那么Minor GC可以确保是安全的，如果不成立，虚拟机会查看HandlePromotionFailure设置值是否允许担保失败，如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于就进行一次Minor GC，尽管这次GC是有风险的，如果小于，进行一次Full GC]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>垃圾收集</tag>
        <tag>内存分配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL索引]]></title>
    <url>%2F2019%2F05%2F17%2FMySQL%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[MySQL索引索引基础建立索引的目的是加快查询速度，数据库索引类似于图书后面的索引，能快速定位到需要查询的内容 索引能加速数据库查询，但需要占用一定存储空间，当基本表更新时，索引也要进行相应的维护，这些都会增加数据库负担 用户不能显式选择索引，索引是关系数据库管理系统的内部实现技术，属于内模式的范畴 用户对基本表建立某列的索引后，类似图书索引，键是索引的值，值是数据行的地址，e.g. 对Person表建立身份证号的索引后，SELECT 姓名,性别,年龄 FROM Person WHERE 身份证号=&#39;xxx&#39;也会用到索引（实际不一定，要看优化器的选择，一般索引不能覆盖我们要查询的信息时，还要通过书签去访问查找整行的数据信息，当访问的数据占整个表数据的蛮大一部分时(一般20%)，优化器会选择通过聚集索引(表扫描)来查找数据） 基本SQL语句建立索引CREATE INDEX indexName ON mytable(column(length)); 一般可以不指定length如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定length。 ALTER TABLE tableName ADD INDEX indexName(columnName) 123456789CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, INDEX [indexName] (column(length)) ); 一般来说，关键字KEY通常是INDEX同义词，上面所有创建INDEX的语句的INDEX关键字都可以换成KEY关键字，即ALTER TABLE sakila.city_demo ADD KEY (city(7))也是创建索引，索引为长度为7的city列ALTER TABLE sakila.city_demo ADD KEY yourIndexName(column(length)) 唯一索引唯一索引的索引值必须唯一，但允许有null，如果是组合索引，列值的组合必须唯一 CREATE UNIQUE INDEX indexName ON mytable(username(length)) ALTER table mytable ADD UNIQUE [indexName] (column(length)) 123456789CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, UNIQUE [indexName] (column(length)) ); 删除索引DROP INDEX [indexName] ON mytable; 使用ALTER添加和删除索引ALTER TABLE testalter_tbl ADD INDEX (c); ALTER TABLE testalter_tbl DROP INDEX c; 显示索引SHOW INDEX FROM table_name; 一个简单的索引查询例子执行SELECT first_name FROM sakila.actor WHERE actor_id = 5;如果在actor_id列上建有索引，则MySQL将使用该索引找到actor_id为5的行，也就是说，MySQL先在索引上按值查找，然后返回所有包含该值的数据行 建立高性能索引B+树概况对B+树的描述如下，可能细节会有些出入，但思想是一样的： **B+树叶结点包含信息，非叶结点只起索引作用，非叶结点每个索引项只含有对应子树最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址，叶结点包含所有关键字，即在非叶结点的关键字也会出现在叶结点对B+树可以有两种查找：从最小关键字开始的顺序查找和从根结点开始多路查找，根结点查找非叶结点时如果关键字等于给定值，不会终止查找，而是向下继续查找，直到叶结点上为止 B-Tree索引索引一般都是B-Tree索引或其变种，InnoDB引擎使用的是B+Tree，InnoDB索引根据主键引用被索引的行 B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同，很适合查找范围数据 B-Tree可以对&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN，以及不以通配符开始的LIKE使用索引 B-Tree索引能加快访问数据的速度，存储引擎不需要进行全表扫描来获取数据，只需要从索引的根结点开始搜索，通过比较节点页的值和要查找的值找到合适的指针进入下层节点，这些指针实际定义了子节点页中值的上限和下限，叶结点除了保存索引的值，还保存该索引指向的数据行的地址指针 假如有如下数据表 1234567CREATE TABLE People ( last_name varchar(50) not null, first_name varchar(50) not null, dob date not null, gender enum('m', 'f') not null, key(last_name, first_name, dob)); 索引包含了last_name，first_name和dob列的值，下面是B-Tree(技术上来说是B+Tree)索引的图例 索引对多个值进行排序的依据是CREATE TABLE语句定义索引时列的顺序，如果两个人姓和名都一样，则根据出生日期来排列顺序 B-Tree索引适用于全键值，键值范围或键前缀查找，其中键前缀查找只适用于根据最左前缀的查找，上述索引对如下类型的查询有效 匹配全值：和索引中所有列进行匹配，例如前面提到的索引可用于查找姓名为Cuba Allen，出生于1960-01-01的人 匹配最左前缀：可用于查找所有姓为Allen的人，即只使用索引的第一列 匹配列前缀：也可以只匹配某一列的值的开头部分，可以查找所有以J开头的姓的人，这里也只用了索引的第一列 匹配范围值：查找姓在Allen和Barrymore之间的人，只使用了索引的第一列 精确匹配某一列并范围匹配另外一列：查找所有姓为Allen，并且名以字母K开头的人，即第一列last_name全匹配，第二列first_name范围匹配 只访问索引的查询：查询只访问索引，而无须访问数据行 下面是一些关于B-Tree索引的限制： 查询必须从索引最左边的列开始，否则无法使用索引，例如不能用索引查询某一天出生的人 不能跳过某一索引列，例如不能利用索引查找last name为Smith且出生于某一天的人 不能使用索引中范围条件右边的列，例如，查询语句为`WHERE last_name=”Smith” AND first_name LIKS ‘J%’ AND dob=’1976-12-23’，该查询只会使用索引中的前两列 综上，实际只要知道多个列的索引的存储结构，怎么样的查询会使用到索引其实也就清楚了 哈希索引哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，同时在哈希表中保存每个数据行的指针，只有Memory引擎支持显式哈希索引 InnoDB引擎有一个特殊功能叫自适应哈希索引，当InnoDB注意道某些索引值被使用很频繁时，就会在内存中基于B-Tree索引之上再创建一个哈希索引，这是完全自动的，内部的行为 索引的优点例如B-Tree索引，是按照顺序存储数据的，所以MySQL也可以用来做ORDER BY和GROUP BY操作，因为数据是有序的，所以B-Tree会将相关列值存储在一起，最后，索引存储了实际的列值，所以某些查询只使用索引就能够完成全部查询，总结下来有如下3个优点： 索引大大减少了服务器需要扫描的数据量 索引可以帮助服务器避免排序和临时表 索引可以将随机I/O变成顺序I/O 索引的三星系统索引将相关记录放到一起则获得一星如果索引数据顺序和查找的排列顺序一致则获得二星如果索引的列包含了查询中需要的全部列则获得三星 高性能的索引策略独立的列指索引列不能是表达式的一部分，如 SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5; 上述查询无法使用actor_id的索引，MySQL无法自动解析这个方程式 要始终将索引列单独放在比较符号的一侧 前缀索引和索引选择性有时候需要索引很长的索引列，这会让索引变得大且慢，通常可以索引开始的部分字符，这样可以大大节约索引空间，提高索引效率，但会降低索引的选择性。索引选择性指不重复的索引值和数据表的记录总数的比值，索引选择性越高查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行 ALTER TABLE sakila.city_demo ADD KEY (city(7))创建长度为7的索引名为city的，列名为city的索引 ALTER TABLE sakila.city_demo ADD KEY yourIndexName(column(length)) 多列索引多列索引常见的错误是：为每个列都创建独立的索引，或者按错误顺序创建多列索引 12345678CREATE TABLE t ( c1 INT, c2 INT, c3 INT, KEY(c1), KEY(c2), KEY(c3)); 性能不会很好，比起最优索引可能差几个数量级，MySQL 5.0以上引入一个叫索引合并的策略，一定程度上可以使用表上多个单列索引来定位指定的行，例如，表file_actor在字段film_id和actor_id上各有一个单列索引，但对于下面的查询WHERE条件，这两个单列索引都不是很好的选择 SELECT film_id, actor_id FROM sakila.film_actor WHERE actor_id = 1 OR film_id = 1; 老版本的MySQL会对这个查询使用全表扫描（因为一次只能在一个索引树中查找，因为没有actor_id和film_id的联合索引，所以就全表查找了），除非改写成如下方式 1234SELECT film_id, actor_id FROM sakila.film_actor WHERE actor_id = 1UNION ALLSELECT film_id, actor_id FROM sakila.film_actor WHERE film_id = 1 AND actor_id &lt;&gt; 1; MySQL 5.0以上版本能够同时使用这两个单列索引进行扫描，将结果合并，这种算法有3个变种，OR的联合，AND的相交，组合前两种情况的联合及相交，下面查询使用了两个索引扫描的联合，在EXPLAIN中的Extra列可以看到这一点 1234567891011121314mysql&gt; EXPLAIN SELECT film_id, actor_id FROM sakila.film_actor WHERE actor_id = 1 OR film_id = 1\G; id: 1 select_type: SIMPLE table: film_actor partitions: NULL type: index_mergepossible_keys: PRIMARY,idx_fk_film_id key: PRIMARY,idx_fk_film_id key_len: 2,2 ref: NULL rows: 29 filtered: 100.00 Extra: Using union(PRIMARY,idx_fk_film_id); Using where 索引合并策略有时候是一种优化结果，但实际上更多时候说明表上的索引建的很糟糕 当服务器需要对多个索引做相交操作时（通常是多个AND），意味着需要一个包含所有相关列的多列索引，而不是多个单独的单列索引 当服务器需要对多个索引做联合操作时（通常由多个OR），通常需要消耗大量CPU和内存资源在算法的缓存，排序和合并操作上 优化器不会把这些计算到查询成本中，只关心随机页面读取，导致该执行计划还不如直接走全表扫描，要不就把查询改写成UNION的方式 选择合适的索引列顺序经验法则：将选择性最高的列放在索引最前列 以下面查询为例SELECT * FROM payment WHERE staff_id = 2 AND customer_id = 584; 可以通过SUM函数计算选择性的相对大小 1234SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,COUNT(DINSTINCT customer_id)/COUNT(*) AS customer_id_selectivity,COUNT(*)FROM payment\G; 聚簇索引聚簇索引是一种数据存储方式，而不是单独的索引类型，InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行 当表有聚簇索引时，它的数据行实际上存放在该聚簇索引的叶子页中，术语聚簇表示数据行和相邻的键值紧凑地存储在一起（逻辑相邻，物理不相邻），因为无法同时把数据行存放到两个不同的地方，所以一个表只能有一个聚簇索引，下面是一个聚簇索引的记录的存放显示，注意叶子页包含了行的全部数据，但是节点叶只有索引列，这里的索引列是整数值 innoDB通过主键聚集数据，如果没有定义主键，innoDB会选择一个唯一的非空索引代替，如果没有这样的索引，InnoDB会隐式定义一个主键作为聚簇索引 聚簇索引的优点 可以把相关数据保存在一起，例如电子邮箱，可以根据用户ID来聚集数据，这样只需要从磁盘读取少数的页就能够获取某个用户的全部邮件 数据访问更快，聚簇索引将索引和数据保存在同一个B-Tree中，获取数比非聚簇索引查找要快 使用覆盖索引扫描的查询可以直接使用页节点的主键值 覆盖索引一个索引包含所有要查询的字段的值，称为覆盖索引 冗余和重复索引重复索引：相同列上按相同顺序创建的相同类型的索引，应该避免重复索引，常见的重复索引有主键+唯一限制+索引，实际上MySQL的唯一限制和主键都是通过索引实现的，所以上面写法其实是创建了三个重复的索引 冗余索引：如果创建了索引(A,B)再创建(A)就是冗余索引，大部分情况不需要冗余索引]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL索引</tag>
        <tag>InnoDB</tag>
        <tag>聚簇索引</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列化]]></title>
    <url>%2F2019%2F05%2F16%2F%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[序列化基本定义对象序列化：将内存中保存的对象以二进制数据流的形式进行处理，可以实现对象的保存和网络传输（保存在文件或数据库） SerializableJava中要序列化的对象，必须实现接口java.io.Serializable，作为序列化的标记，它没有任何方法，它描述的是一种能力 serialVersionUIDprivate static final long serialVersionUID = 1L; 版本号用于表明类的不同版本的兼容性，默认是上面的值1L，反序列化时，JVM会把传来的字节流的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则出现序列化版本不一致的异常，serialVersionUID默认值依赖于Java编译器的实现，同一个类用不同的Java编译器，可能导致不同的serialVersionUID，可以显式的定义它，有2个用途 某些场合希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本有不同的serialVersionUID 当序列化一个类实例后，希望更改一个字段或添加一个字段，不设置serialVersionUID，所作的任何更改都导致无法反序列化旧实例，并在反序列化时抛出一个异常，如果添加了serialVersionUID，在反序列旧实例时，新添加或更改的字段值将设为初始化值，字段被删除将不设置 序列化和反序列化过程 类名 序列化：ObjectOutputStream 反序列化：ObjectInputStream 类定义 public class ObjectOutputStream extends OutputStream implements ObjectOutput, ObjectStreamConstants public class ObjectInputStream extends InputStream implements ObjectInput, ObjectStreamConstants 构造方法 ObjectOutputStream(OutputStream out) ObjectInputStream(InputStream in) 构造方法参数说明 Creates an ObjectOutputStream that writes to the specified OutputStream. Creates an ObjectInputStream that reads from the specified InputStream. 重要方法 writeObject(Object obj) readObject() 重要方法说明 Write the specified object to the ObjectOutputStream. Read an object from the ObjectInputStream. 12345678910111213141516@SuppressWarnings("serial")class Person implements Serializable &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return "姓名：" + this.name + "年龄：" + this.age; &#125;&#125; 实际开发中很少使用ObjectOutputStream和ObjectInputStream，因为容器会帮助开发者自动实现 transient关键字用法：private transient String xxx; 默认情况下执行了对象序列化时会将类中全部属性的内容进行全部序列化操作，但有时部分属性不需要进行序列化处理，这时可以在属性上定义使用transient关键字来完成对属性进行序列化后，属性的值是不会被保存下来的，读取对应属性的值是对应的默认值如果类中有一些需要计算保存的属性内容，往往不需要被序列化 序列化的代价Serializable接口最大代价是一旦一个类被发布，就大大降改变这个类的实现的灵活性 可能导致InvalidClassException如果没有显示声明序列版本UID，对对象需求进行了改动，那么兼容性就会破坏，运行时导致InvalidClassException，比如，增加一个不是很重要的工具方法，自动产生的序列版本UID也会发生变化，则会出现序列版本UID不一致的情况，所以最好还是显式增加序列版本号UID 增加了出现Bug和安全漏洞的可能性序列化机制是一个语言之外的对象创建机制，反序列化机制是一个”隐藏的构造器”，具备与其他构造器相同的特点，序列化之后的字节流可以被截取伪造，之后利用readObject()方法反序列会造成不安全的实例 随着类发行新的版本，测试负担会增加一个可序列化的类被修订时，需要检查是否”在新版本中序列化一个实例，可以在旧版本中反序列”，如果一个实现序列化的类有很多的子类或者是被修改时，就不得不加以测试 序列化的缺陷 序列化是保存对象的状态，也就是不会关心static静态域，静态域不会被序列化（静态变量在方法区，同一虚拟机访问反序列化的实例时，可以访问到静态变量） 序列化对象时，如果该对象中有引用对象域名，那么也要求该引用对象是可实例化的（即引用对象也要实现序列化接口），否则会报java.io.NotSerializableException错误]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存区域与内存溢出异常]]></title>
    <url>%2F2019%2F05%2F15%2FJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[Java内存区域与内存溢出异常运行时数据区域 程序计数器程序计数器可以看作当前线程所执行的字节码的行号指示器，在虚拟机概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令 由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，任一时刻一个处理器只会执行一条线程的指令，因此每个线程都有一个独立的程序计数器，它是线程私有的内存 如果线程执行的是java方法，计数器记录的是正在执行的虚拟机字节码指令的地址，如果执行的是Native方法，技术值为空，此内存区域没有规定任何OutOfMemoryError 虚拟机栈Java虚拟机栈也是线程私有的，它生命周期和线程相同。虚拟机栈描述的是java方法执行的内存模型，每个方法在执行的时候会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法出口等信息，每个方法从调用到执行完成的过程，对应一个栈帧在虚拟机栈中入栈到出栈的过程 局部变量表存放编译期可知的各种基本数据类型，对象引用和returnAddress类型，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，方法运行期间不会改变局部变量表的大小 虚拟机栈有两种异常状况：线程请求的栈深度大于虚拟机允许的深度时，抛出StackOverflowError，虚拟机栈动态扩展时无法申请到足够内存，抛出OutOfMemoryError 本地方法栈它也是线程私有的，它与虚拟机栈的区别是，虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，本地方法栈为虚拟机使用到的Native方法服务 堆Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，它的唯一目的是存放对象实例，几乎所有的对象实例都在这里分配内存 它是垃圾收集器管理的主要区域，它可以是物理上不连续的内存空间，只要逻辑上连续即可，会抛出OutOfMemoryError 方法区方法区也是线程共享的内存区域，用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据 运行时常量池它是方法区的一部分，用于存放编译期生成的各种字面量和符号引用，这部分内容在类加载后进入方法区的运行时常量池存放 字面量就是值，符号引用就是一个java类引用了另一个java类比如org.simple.People类引用了org.simple.Language类，编译时People并不知道Language的实际内存地址，只能用符号org.simple.Language表示Language的地址 HopSpot虚拟机对象以常用的虚拟机HotSpot和常用的内存区域Java堆为例，探讨HotSpot虚拟机在Java堆中对象分配布局和访问的过程 对象的创建虚拟机遇到一条new指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载，解析和初始化过，如果没有就必须先执行类加载过程类加载检查通过后，虚拟机为新生对象分配内存，分配内存即把一块确定大小的内存从Java堆中划分开，如果内存规整，用过的内存在一边，空闲内存在另一边，中间存放指针作为分界点指示器，分配内存只需要把指针挪动即可，称为指针碰撞，如果内存不规整，用空闲列表法分配除了内存分配，还要考虑线程安全的问题，如为对象A分配内存，指针还没修改时候对象B又同时使用原来的指针分配内存，解决方法一种是对分配内存空间同步处理，另一种是内存分配动作把内存分配动作按线程划分在不同的空间中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB），哪个线程需要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定内存分配完成后，虚拟机将分配到的内存空间都初始化为零值（TLAB的话可以提前到TLAB分配时进行），这一步保证了对象实例字段的默认值然后虚拟机堆对象进行必要的设置，比如这个对象是哪个类的实例，如何才能找到类的元数据信息，对象哈希码，GC分代年龄等信息，这些信息存放在对象的对象头中上面工作完成后，从虚拟机视角看，一个新的对象产生了，但从Java视角看，还需要执行&lt;init&gt;方法 总结：一个对象创建步骤如下 检查常量池是否有该类的符号引用，没有则类加载 分配内存，策略有空闲表法和指针碰撞 线程安全问题，分配内存动作同步或内存按线程划分（TLAB） 分配的内存空间初始化为0 设置对象头，存放类，元数据，哈希码，GC分代年龄等 Java执行init方法 对象的内存布局HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头，实例数据和对齐填充 对象头：包括存储对象自身运行时的数据如哈希码，GC分代年龄，锁状态标志，线程持有的锁等，以及类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针确定这个对象是哪个类的实例，如果对象为Java数组，还需要在对象头有一块记录数组长度的数据，对象头在32位/64位机的长度是32位和64位 实例数据部分是对象真正存储的有效信息，也就是代码中定义的各种类型的字段内容，无论是父类继承的还是子类定义的，都会记录下来，它们的存储顺序受虚拟机分配策略参数和字段的影响 对齐填充：不是必然存在的，也没什么含义，只起占位符作用，由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，对象头又正好是8字节的倍数，因此当对象实例数据部分没有对齐时，需要对齐填充补全 对象的访问定位Java程序需要通过栈上的reference数据来操作堆上的具体对象，由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，而没有定义这个引用通过何种方式定位访问堆中对象的具体位置，所以对象访问方式取决于虚拟机实现，目前主流的是句柄和直接指针两种 句柄访问Java堆划分一块内存作为句柄池，reference中存储的是对象的句柄地址，句柄中包含对象实例数据和类型数据各自的具体地址信息 句柄访问的优点是reference存储的是稳定的句柄地址，对象被移动时（垃圾收集移动对象很普遍）只会改变句柄的实例数据指针，reference本身不需要修改 直接指针访问reference存储的直接就是对象地址，由Java堆对象考虑如放置访问类型数据的相关信息 直接指针访问好处是速度快，它节省了一次指针定位的时间开销，HotSpot使用的是直接指针访问]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java内存区域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多态]]></title>
    <url>%2F2019%2F05%2F14%2F%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[多态是什么wiki上对多态的定义是这样的： 在编程语言和类型论中，多型（英语：polymorphism）指为不同数据类型的实体提供统一的接口。 [1]多态类型（英语：polymorphic type）可以将自身所支持的操作套用到其它类型的值上。[2] 计算机程序執行時，相同的訊息可能會送給多個不同的類別之物件，而系統可依據物件所屬類別，引發對應類別的方法，而有不同的行為。簡單來說，所謂多型意指相同的訊息給予不同的物件會引發不同的動作。 多态也可定义为“一种将不同的特殊行为和单个泛化记号相关联的能力”。 多态可分为变量多态与函数多态。变量多态是指：基类型的变量（对于C++是引用或指针）可以被赋值基类型对象，也可以被赋值派生类型的对象。函数多态是指，相同的函数调用界面（函数名与实参表），传送给一个对象变量，可以有不同的行为，这视该对象变量所指向的对象类型而定。因此，变量多态是函数多态的基础。 为什么多态通过分离”做什么”和”怎么做”，从另一角度把接口和实现分离，改善代码的组织结构和可读性，创建可扩展的程序 怎么做前提： 继承关系 子类重写父类方法 父类引用指向子类（向上转型） 123456789101112131415class Animal &#123; int num = 10; static int age = 20; public void eat() &#123; System.out.println("动物吃饭"); &#125; public static void sleep() &#123; System.out.println("动物在睡觉"); &#125; public void run()&#123; System.out.println("动物在奔跑"); &#125;&#125; 123456789101112131415class Cat extends Animal &#123; int num = 80; static int age = 90; String name = "tomCat"; public void eat() &#123; System.out.println("猫吃饭"); &#125; public static void sleep() &#123; System.out.println("猫在睡觉"); &#125; public void catchMouse() &#123; System.out.println("猫在抓老鼠"); &#125;&#125; 123456789101112class Demo_Test1 &#123; public static void main(String[] args) &#123; Animal am = new Cat(); // 基类型指向子类对象 am.eat(); // 猫吃饭 am.sleep(); // 动物在睡觉 am.run(); // 动物在奔跑 am.catchMouse(); // 报错 System.out.println(am.name); // 报错 System.out.println(am.num); // 10 System.out.println(am.age); // 20 &#125;&#125; 成员变量：编译看父类，运行看父类成员方法：编译看父类，运行看子类（动态绑定）静态方法：编译看父类，运行看父类 弊端：多态不能使用子类特有的方法和属性 可以通过强制类型转换Cat cat = (Cat)am，这样，cat指向的是最开始在堆内存中创建的那个Cat类型的对象，这是多态的向下转型]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring01-Spring IOC容器]]></title>
    <url>%2F2019%2F05%2F14%2FSpring01-Spring%20IOC%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Spring1-Spring IOC容器源代码在这 IOC 控制反转，应用程序本身不负责依赖对象的创建和维护，而是由外部容器负责创建和维护 DI是其一种实现方式，指由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中 Bean：IOC容器中把所有对象都称为bean bean配置有基于xml配置和注解 比较基础的spring目录树如下 src内有main和test文件夹，main里面有java文件夹和resources文件夹，java保存java源代码，resources保存xml文件等，test文件夹里面是java文件夹，保存测试代码 单元测试的编写 maven导入junit依赖 创建UnitTestBase类，完成对Spring配置文件的加载，销毁 所有单元测试类继承自UnitTestBase，通过它的getBean方法获取想要的对象 子类加注解@RunWith(BlockJUnit4ClassRunner.class) 单元测试方法加注释@Test 右键要执行的单元测试方法执行，或者右键类的任意空位执行所有单元测试方法 UnitTestBase类的内容InitTestBase主要有构造器，getBean方法和带Before注解的方法和带After注解的方法 123456789101112131415161718192021222324252627282930313233343536373839public class UnitTestBase &#123; private ClassPathXmlApplicationContext context; private String springXmlPath; public UnitTestBase() &#123; &#125; public UnitTestBase(String springXmlPath) &#123; this.springXmlPath = springXmlPath; &#125; @Before public void before() &#123; if (StringUtils.isEmpty(springXmlPath)) &#123; springXmlPath = "classpath*:spring-*.xml"; &#125; try &#123; context = new ClassPathXmlApplicationContext(springXmlPath.split("[,\\s]+")); context.start(); &#125; catch (BeansException e) &#123; e.printStackTrace(); &#125; &#125; @After public void after() &#123; context.destroy(); &#125; @SuppressWarnings("unchecked") protected &lt;T&gt; T getBean(String beanId) &#123; return (T)context.getBean(beanId); &#125; protected &lt;T&gt; T getBean(Class&lt;T&gt; clazz) &#123; return context.getBean(clazz); &#125;&#125; 具体的测试类编写123456789101112131415161718// 指定使用的单元测试类@RunWith(BlockJUnit4ClassRunner.class)public class TestOneInterface extends UnitTestBase &#123; public TestOneInterface() &#123; // 把classpath作为参数，调用超类的构造函数 super("classpath*:spring-ioc.xml"); &#125; // 带Test注解的方法，在执行前会调用带有Before注解的方法，执行后调用带有After注解的方法（在超类中） @Test public void testHello() &#123; OneInterface oneInterface = super.getBean("oneInterface"); // 通过超类的getBean方法得到bean System.out.println(oneInterface.hello("我的输入参数")); &#125;&#125; Bean容器的初始化 Spring注入Spring注入指启动Spring容器加载bean配置的时候，完成对变量的赋值，有设值注入（getter，setter）和构造注入（构造注入是依赖构造器参数，bean要有构造函数）xml文件的bean配置为：&lt;bean&gt;&lt;constructor-arg name=”xxx” value(ref)=”xxx” /&gt;&lt;/bean&gt; Spring设值注入12345&lt;bean id="xxx" class="xxx"&gt; &lt;property name="" value="" /&gt; &lt;property name="" ref="" /&gt; &lt;!-- name是属性名，value是基础值，ref是指向某个对象 --&gt;&lt;/bean&gt; 对应的bean必须要有getter和setter 构造注入1234&lt;bean id="xxx" class="xxx"&gt; &lt;constructor-arg name="" ref="" /&gt; &lt;!-- name是属性名，value是基础值，ref是指向某个对象 --&gt;&lt;/bean&gt; 必须要有构造器 Bean的配置项 Id：唯一标识 Class：类 Scope：范围，作用域 Constructor：构造器参数 Properties：属性 Autowiring mode：自动装配 lazy-initialization mode：懒装载 Initialization/destruction method：初始化，销毁方法 Scope作用域singleton：单例，一个bean容器中只存在一份prototype：每次请求都创建新的实例，destroy方式不生效request：每次http请求都会创建一个实例且仅在当前request内有效session：每次http请求创建，当前session内有效 Bean生命周期 定义 初始化：在IOC容器启动后加载bean时调用 使用 销毁：在IOC容器销毁前调用 初始化两种方式 bean对应类实现org.springframework.beans.factory.InitializingBean接口，覆盖afterPropertiesSet方法 xml对应bean配置init-method：&lt;bean id=”” class=”” init-method=”” /&gt;，对应类中应有init-method指定的方法 实现接口方法模板 1234567public class MyBean implements InitializingBean &#123; @Override public void afterPropertiesSet() throws Exception &#123; // do something &#125;&#125; 销毁两种方法 bean对应类实现org.springframework.beans.factory.DisposableBean接口，覆盖destroy方法 xml对应bean配置destroy-method 全局初始化和销毁方法spring xml中配置 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd" default-init-method="xxx" default-destroy-method="xxx"&gt; &lt;!-- your bean here --&gt;&lt;/beans&gt; 当默认的，内部的和接口的初始化和销毁同时存在的时候，默认的初始化销毁方法被覆盖掉，不会执行，接口的初始化方法先于内部的初始化方法执行 Awarespring提供了一些以Aware结尾的接口，实现了Aware接口的bean在被初始化后，可以获取相应资源，通过Aware接口，可以对Spring相应资源进行操作 ApplicationContextAwareWhen an ApplicationContext creates an object instance that implements the org.springframework.context.ApplicationContextAware interface, the instance is provided with a reference to that ApplicationContext. 即实现了该接口的类，在容器初始化该类的时候，会调用setApplicationContext，把上下文注入到该类实例中 BeanNameAwareWhen an ApplicationContext creates a class that implements the org.springframework.beans.factory.BeanNameAware interface, the class is provided with a reference to the name defined in its associated object definition. 1234public interface BeanNameAware &#123; void setBeanName(String name) throws BeansException;&#125; The callback is invoked after population of normal bean properties but before an initialization callback such as InitializingBean afterPropertiesSet or a custom init-method.（在bean属性填充后但在初始化bean方法调用前调用） 1234public interface ApplicationContextAware &#123; void setApplicationContext(ApplicationContext applicationContext) throws BeansException;&#125; 小DEMO123456789101112131415public class MoocBeanName implements BeanNameAware, ApplicationContextAware &#123; private String beanName; @Override public void setBeanName(String name) &#123; this.beanName = name; System.out.println("MoocBeanName：" + name); &#125; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; System.out.println(applicationContext.getBean(beanName).hashCode()); &#125;&#125; 其他Aware接口见官方文档 自动装配在对应xml配置文件的beans的属性中，设置default-autowire=”xxx”，其中xxx为下面几项 no：不做任何操作 byName：根据属性名自动装配，此选项将检查容器并根据名字查找于属性完全一致的bean，将其与属性自动装配 byType：找属性类型相同的bean，与该属性自动装配，如果有多个该类型bean，就抛出异常 Constructor：与byType类似，它应用于构造器参数，在IOC容器中查找构造器参数的类型的bean，作为构造器参数传入，如果容器中没有找到与构造器参数类型一致的bean，就抛出异常 byNamexml中配置如下 12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd" default-autowire="byName"&gt; &lt;bean id="autoWiringService" class="com.mkl.autowiring.AutoWiringService" /&gt; &lt;bean id="autoWiringDAO" class="com.mkl.autowiring.AutoWiringDAO" /&gt;&lt;/beans&gt; 123456789101112public class AutoWiringService &#123; private AutoWiringDAO autoWiringDAO; public void setAutoWiringDAO(AutoWiringDAO autoWiringDAO) &#123; this.autoWiringDAO = autoWiringDAO; &#125; public void say(String word) &#123; this.autoWiringDAO.say(word); &#125;&#125; AutoWiringService中存在成员autoWiringDAO，设置了byName的自动装配后，会在IOC容器中寻找ID为autoWiringDAO的bean，把其实例作为setAutoWiringDAO的参数赋值给AutoWiringService的成员 Resources针对资源文件的统一接口，下面是实现了Resources接口的一些类 UrlResource：URL对应的资源，根据一个URL地址可构建 ClassPathResource:：获取类路径下的资源文件 FileSystemResource：获取文件系统里面的资源 ServletContextResource：ServletContext封装的资源，用于访问ServletContext环境下的资源 InputStreamResource：针对输入流封装的资源 ByteArrayResource：针对字节数组封装的资源 ResourceLoaderThe ResourceLoader interface is meant to be implemented by objects that can return (i.e. load) Resource instances. All application contexts implement the ResourceLoader interface, and therefore all application contexts may be used to obtain Resource instances. 12345public interface ResourceLoader &#123; Resource getResource(String location);&#125; When you call getResource() on a specific application context, and the location path specified doesn’t have a specific prefix, you will get back a Resource type that is appropriate to that particular application context.For example, assume the following snippet of code was executed against a ClassPathXmlApplicationContext instance:Resource template = ctx.getResource(&quot;some/resource/path/myTemplate.txt&quot;);What would be returned would be a ClassPathResource; 不使用前缀的时候，上下文调用getResource，返回的是实现了Resource接口的符合该特定应用程序上下文Resource类型，如对ClassPathXmlApplicationContext的实例调用getResource，返回的是ClassPathResource类型 使用特定前缀，可以返回特定的Resource类型（实现了Resource接口的特定类型），常见前缀如下 一个Resource的使用例子123456789101112131415public class MoocResource implements ApplicationContextAware &#123; private ApplicationContext applicationContext; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; &#125; public void resource() throws IOException &#123; Resource resource = applicationContext.getResource("classpath:config.txt"); System.out.println(resource.getFilename()); System.out.println(resource.contentLength()); &#125;&#125; 实现ApplicationContextAware接口，实现其setApplicationContext方法，得到上下文，通过该上下文的getResource方法得到Resource，然后调用resource方法输出其文件名和长度 单元测试和配置文件略 常见问题1.POM加入了依赖却找不到例如ClassPathXmlApplicationContext类解决：右键pom，maven，reimport]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>单元测试</tag>
        <tag>Aware</tag>
        <tag>Spring注入</tag>
        <tag>Bean</tag>
        <tag>Resources</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件管理]]></title>
    <url>%2F2019%2F05%2F11%2F%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[文件管理文件的相关基本概念数据项：文件系统中最低级的数据组织形式，分为基本数据项和组合数据项，基本数据项用于描述一个对象的某种属性的字符集，是可命名的最小逻辑数据单位，又称为字段，例如，用于描述学生的基本数据项有：学号，姓名等；组合数据项是若干基本数据项的组成；数据项还应有数据类型 记录：记录是一组相关数据项的集合，用于描述一个对象在某方面的属性，一个记录应包含哪些数据项取决于需要描述对象的哪个方面。例如，一个学生，当把他作为班上一个学生时，对他的描述为学号，姓名，年龄，所在系班，若把学生当作医疗对象则不同。唯一标识记录的数据项是关键字 文件：文件是由创建者所定义的，具有文件名的一组相关元素的集合，分为有结构文件和无结构文件，有结构文件中，文件由若干个相关记录组成，而无结构文件被看成是一个字符流，文件在文件系统是一个最大的数据单位，它描述了一个对象集，例如可以将一个班的学生记录作为一个文件 文件属性可以包括：文件类型，文件长度，文件的物理位置，文件的建立时间（最后一次的修改时间等） 文件类型文件类型按用途分类可分为系统文件，用户文件和库文件按文件中数据的形式分类可分为源文件，目标文件和可执行文件按存取控制属性分类可分为只执行文件，只读文件，读写文件按组织形式和处理方式分类可分为普通文件，目录文件和特殊文件 文件系统文件系统的模型是指文件和对文件进行操纵和管理的软件集合 分为三层：对象及属性，对文件进行操纵和管理的软件集合，文件系统接口 对象及其属性层文件管理系统管理的对象如下： 文件 目录 磁盘存储空间 对对象操纵和管理的软件集合层该层是文件管理系统的核心部分，文件系统的功能大多是这一层实现，其中包括对文件存储空间的管理，对文件目录的管理，用于将文件的逻辑地址转换为物理地址的机制，对文件的读写管理，对文件的共享保护等功能 一般把与文件系统有关的软件分为4个层次： I/O控制层：磁盘驱动程序等组成 基本文件系统层：内存与磁盘之间数据块的交换 基本I/O管理程序：完成与磁盘I/O有关的事务，如文件逻辑块号转换为物理块号等 逻辑文件系统：用于处理与记录和文件相关的操作，如允许用户使用符号文件名访问文件及记录等 文件系统接口文件系统提供了命令接口和程序接口 文件逻辑结构文件的逻辑结构是从用户观点出发所观察到的文件组织形式，即文件是由一系列逻辑记录组成的，是用户可以直接处理的数据及其结构，独立于文件的物理特性，又称为文件组织 文件的物理结构又称为文件的存储结构，是指系统将文件存储在外存上所形成的一种存储组织形式，用户是不能看见的 物理结构和逻辑结构都会影响对文件的检索速度 下图是文件结构类型的概述 逻辑结构的类型文件按有无结构分为有结构文件和无结构文件 有结构文件根据记录长度分为定长和不定长两类，定长指文件的所有记录长度都是相同的，所有记录的各数据项都处在记录中相同的位置，具有相同的顺序和长度，定长记录有效提高检索记录的速度和效率，方便对文件处理和修改，文件长度用记录数目来表示；变长记录指文件中各记录长度不相同 有结构文件按文件组织方式分为 顺序文件：由一系列记录按某种顺序排列形成的文件，记录通常是定长记录（变长记录查询速度慢，不支持随机访问和删除插入记录） 索引文件：可变长记录文件建立一张索引表，为每个记录设置一个表项，加速对记录的检索 索引顺序文件：顺序文件和索引文件的结合，在为每个文件建立一张索引表时，并不是为每个记录建立索引表项，而是为一组记录中的第一个记录建立一个索引表项 无结构文件是流式文件，信息管理系统和数据库系统中广泛采用了有结构的文件形式，而源程序，可执行文件，库函数等采用的就是无结构文件，长度是以字节为单位，可以把流式文件看作记录式文件的一个特例：一个记录仅有一个字节 顺序文件顺序文件可以按照串结构或顺序结构排列，串结构指按存入时间的先后进行排序，各记录之间的顺序与关键字无关，对串结构文件检索比较费时，顺序结构是由用户指定一个字段作为关键字，文件中所有记录可以按关键字排序，具有更高的检索速度 索引文件为变长记录建立一个索引表，对主文件的每个记录在索引表中设有一个相应表项，用于记录该记录的长度L，以及指向该记录的指针 索引文件是可以实现直接存取的，索引文件支持随机访问 索引顺序文件索引顺序文件保留了顺序文件的关键字顺序，又增加了文件索引表和溢出文件，溢出文件用来记录新增加的，删除的和修改的记录 一级索引顺序文件将变长记录顺序文件的所有记录分为若干组，为顺序文件建立一张索引表，并为每组的第一个记录，在索引表建立一个索引项，其中包含该记录的关键字和指向该记录的指针 对索引顺序文件检索时，先利用提供的关键字以及某种查找算法去检索索引表，找到该记录所在记录组第一个记录的表项，从中得到该记录组第一个记录在主文件的位置，然后再利用顺序查找法去查找主文件，从中找到所要求的记录 直接文件和哈希文件直接文件直接文件可以根据给定的关键字直接获得记录的物理地址，即关键字本身就决定了记录的物理地址，由关键字到记录物理地址的转换称为键值转换，而上述的索引文件实质是对关键字计算得到对应索引表表项的物理地址，由该物理地址得到指向对应记录的指针 哈希文件利用哈希函数将关键字转换为相应记录的地址 文件的物理结构物理结构是从实现的观点出发，文件在外存上的存放组织形式，有如下三种物理结构 连续结构 链接结构 索引结构 目录管理对目录管理的要求 实现”按名存取”：用户只须向系统提供所需访问的文件的名字，便能快速准确地找到指定文件在外存地存储位置，这是目录管理最基本地功能 提高对目录的检索速度 文件共享：允许多个用户共享一个文件，这样只须在外存中保留一份该文件副本供不同用户使用，节省存储空间，提高利用率 允许文件重名：允许不同用户对不同文件采取相同的名字 文件控制块FCB文件目录：文件控制块的有序集合，即一个文件控制块就是一个文件目录项，通常一个文件目录被看成是一个文件，称为目录文件 文件控制块：描述和控制文件的数据结构，文件与文件控制块一一对应，一个文件控制块就是一个文件目录项（文件目录是文件控制块的有序集合），包含基本信息，存取控制信息和使用信息，可以分为内存FCB和外存FCB 它们的关系：文件控制块与文件一一对应，而文件目录是有结构文件，其中的每一个记录都是一个文件控制块 检索过程：检索的时候，把文件目录调入内存，查找其目录项，找到与给定的文件名对应的文件名，读出其物理地址 基本信息类 文件名 文件物理位置 文件逻辑结构：流式还是有结构，记录数，定长记录还是变长记录等 文件物理结构：顺序还是链接还是索引 存取控制信息类文件主，核准用户和一般用户的存取权限 使用信息类 文件建立日期和时间 上一次修改的日期和时间 当前使用信息（已打开文件的进程数，是否被锁等等） 索引结点OS中每有一个目录，就有一个FCB 引入：文件目录占空间，检索目录文件过程中，要把存放目录文件的第一个盘块中的目录的调入内存，然后将用户所给定的文件名与目录项的文件名一一对应，若没有找到指定文件，还需要将下一盘块的目录项调入内存。检索过程中，只用到了文件名，而没有其他描述文件的信息，仅当找到一个目录项（即其中文件名与指定要查找的文件名相匹配）时，才需从该目录项中读出该文件的物理地址，而其他一些对该文件进行描述的信息在检索目录时一概不用。显然这些信息在检索目录的时候不需要调入内存，为此，采用把文件名与文件描述信息分开的方法，即使文件描述信息单独形成一个称为索引结点的数据结构 引入后，文件目录项就不是FCB了，而是文件名+索引结点，这样可以使每个盘块可以存更多的文件目录项，减少盘块数，从而减少盘块调入内存的次数 引入索引结点前的文件目录项（FCB） 引入索引结点后的文件目录项（文件名+索引结点） 例如上图，在没有引入索引结点的时候，FCB是上图一所示，每次检索目录的时候都要把FCB调入内存，而FCB又占用比较大的空间，这样系统开销会很多，采用了上图二的文件目录项后，一个目录项只占用很小的开销（UNIX为16个字节，14字节文件名，2字节为i结点指针），可以减少磁盘启动次数，节省系统开销 我对索引结点减少磁盘启动次数的理解前提：目录文件所占盘块数为N，则检索该文件目录时平均调入盘块次数为(N+1)/2次，检索一个文件要从第一个文件目录开始检索，直到最后一个文件目录 引入索引结点可以减少磁盘启动次数，节省系统开销，主要原因是调入内存是以盘块为单位和引入索引结点后文件目录项的大小比FCB的大小要小 e.g.在文件系统中，每个盘块为256字节，文件控制块占64个字节，其中文件名占8个字节。如果索引节点编号占2个字节，对一个存放在磁盘上的128个目录项的目录，试比较引入索引节点前后，为找到其中一个文件，平均启动磁盘的次数 在引入索引结点前，每个目录项中存放的是对应文件的FCB，故128个目录项的目录总共需要占用128X64／256=32个盘块。因此，在该目录中检索到一个文件，平均启动磁盘的次数为(1+32)/2=16.5次。引入索引结点后，每个目录项中只需存放文件名和索引结点的编号，因此128个目录项的目录总共需要占用128X(8+2)／256=5个盘块。因此，找到匹配的目录项平均需要启动(1+5)／2，即3次磁盘；而得到索引结点编号后，还需启动磁盘将对应文件的索引结点读入内存，故平均需要启动磁盘4次。可见，引入索引结点后，可大大减少启动磁盘的次数，从而有效地提高检索文件的速度。 引入索引结点后的索引过程 文件目标项只存放文件名和结点号，结点号存放FCB信息 查询只调入文件名部分和结点指针，找到后才调入对应i结点指向的内容 磁盘索引结点存放在磁盘的索引结点，每个文件有唯一的磁盘索引结点，包括如下内容： 文件主标识 文件类型（正规文件，目录文件，特殊文件） 文件存取权限 文件物理地址 文件长度 文件连接计数（本文件系统所有指向该文件名的指针计数，用于共享） 文件存取时间 内存索引结点存放在内存中的索引结点，当文件被打开时，要将磁盘索引结点拷贝到内存的索引结点中方便以后使用，增加了以下内容 索引结点编号 状态 访问计数 文件所属文件系统的逻辑设备号 链接指针 单级目录结构最简单的文件目录，在整个文件系统中只建立一张目录表，每个文件占一个目录项，目录项含文件名，文件扩展名，文件长度，文件类型，文件物理地址以及其他文件属性，状态位（是否空闲） 单级目录结构不允许重名，新建文件时要检查有无同名，删除时回收块并清楚占用目录项 两级目录结构 可以为每个用户再建立一个单独的用户文件目录UFD，这些文件目录由用户所有文件的文件控制块组成，在系统中再建立一个主文件目录MFD，MFD的每个目录项为用户的目录文件 两级目录结构允许重名，但不允许用户建立自己的子目录 树形结构目录一个目录文件中目录项可以为目录文件和数据文件，允许重名，便于实现文件共享 目录查询技术当用户要访问一个已经存在的文件时，系统首先利用用户提供的文件名对目录进行查询，找出该文件的FCB或对应索引结点，然后根据FCB或索引结点中记录的文件物理地址（盘块号），换算出文件在磁盘上的物理地址，最后再通过磁盘驱动程序将所需文件读入内存 常用的目录查询方式为线性检索法和Hash方法 线性检索法 查找过程如下： 系统先读入第一个文件分量名usr，用它与根目录文件中各目录项的文件名顺序的进行比较，找到匹配者，并得到索引结点号，再从索引结点号得知物理地址号（盘块号），将该盘块132号读入内存 系统再将路径名第二个分量ast读入，与存放在132号盘块的第二级目录文件各目录项的文件名顺序比较，以此类推直到找到mbox的索引结点和物理地址 Hash方法建立一张Hash索引文件目录，利用Hash方法查询，系统利用文件名变换为文件目录的索引值，再利用该索引值到目录去查找 文件共享两种共享方式：用户直接通过路径名来访问共享文件和对需要共享的文件进行链接 文件保护 存取控制机制防止人为因素造成文件不安全 磁盘容错技术防止磁盘故障造成文件不安全 后备系统防止自然因素造成的不安全性]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>文件管理</tag>
        <tag>FCB</tag>
        <tag>索引结点</tag>
        <tag>目录管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[磁盘存储器的管理]]></title>
    <url>%2F2019%2F05%2F11%2F%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[磁盘存储器的管理磁盘存储器管理的单位是盘块 外存的组织方式文件的物理结构直接与外存的组织方式有关，不同的外存组织方式形成不同的文件物理结构 连续组织方式：为每个文件分配连续的磁盘空间 链接组织方式：为每个文件分配不连续的磁盘空间，通过链接指针将文件的所有盘块链接在一起 索引组织方式 连续组织方式特点： 顺序访问容易，速度快（磁头移动距离小） 要求连续空间，一段时间后要整理磁盘消除碎片 必须事先知道长度，文件不易动态增长和删除 文件对应目录项包含：始址，总块数，最后一块字节数 链接组织方式特点： 消除磁盘外部碎片，提高外存利用率 对插入，删除和修改记录容易 适应文件的动态增长，无需事先知道文件大小 只能顺序存取 隐式链接文件目录的每个目录项都含有指向链接文件第一个盘块和最后一个盘块的指针，只适用于顺序访问，随机访问效率低 簇：包含多个块的单位，盘块分配时以簇为单位，可以成倍减小查找指定块的时间，增大内部碎片 显示链接把用于链接文件各物理块的指针显式地存放在内存的一张链接表中，该表在整个磁盘只设置一张 表的序号是物理块号，在每个表项中存放链接指针，即下一个盘块号，凡是属于某一文件的第一个盘块号，均作为文件地址被填入相应FCB的物理地址字段，查找是在内存进行的所以速度提升且减少磁盘访问次数，该表称为文件分配表FAT 索引组织方式打开某个文件时，只要把该文件占用的索引块号读入内存即可，无需把FAT调入内存，索引的优点是支持直接访问，当要读第i块盘块时，直接从该文件的索引块中找到该盘块号 单级索引：为每个文件分配一个索引块，文件较大时有利，较小时浪费外存空间，文件较大时索引块较多，需要建立多级索引 多级索引如下 混合分配方式UNIX采用混合分配方式，一，二，多级索引合用 i.addr(0)——i.addr(9)存放直接地址，i.addr(10)存放一次间接地址，i.addr(11)存放二次间接地址 文件组织策略 文件访问通常是顺序，文件较小，用连续分配 文件较大顺序访问，链接结构 文件较大随机访问，索引结构 分配策略的小习题 文件存储空间的管理设置一个磁盘分配表，用于记住可供分配的存储空间情况，还应提供对盘块分配和回收的手段，存储空间基本分配单位都是磁盘块而非字节 空闲表法空闲表属于连续分配方式，为每个文件分配一块连续的存储空间，即系统为外存上的所有空闲区建立一张空闲表，每个空闲区对应一个空闲表项，包括表项序号，第一个盘块号，空闲盘块数等信息 空闲链表法空闲盘块链将所有空闲空间以盘块为单位拉成一条链，工作效率低 空闲盘区链将磁盘所有空闲盘区拉成一条链，每个盘区包含若干个盘块，要有指明本盘块大小的信息 位示图法利用二进制的一位来表示磁盘一个盘块的使用情况，0为盘块空闲，1为已分配 位示图法盘块的分配 顺序扫描位示图，找出一个或一组值为0的二进制位 将找到的一个或一组二进制位转换位盘块号，假定找到值为0的二进制位位于位示图第i行j列，则盘块号按下式计算：b=n(i-1)+j 修改位示图，令map[i,j]=1 位示图的回收 将回收盘块号转换为位示图的行号列号i=(b-1)DIVn+1,j=(b-1)MODn+1 修改位示图，令map[i,j]=0 成组链接法UNIX采用的方法 基本思想（汤书P281解释更详细） 空闲盘块号栈存放当前可用的一组空闲盘块号及栈中尚有的空闲盘块号数，唯一存在于内存的栈 文件区的所有空闲盘块分为若干组 每一组含有盘块总数和所有的盘块号记入前一组最后一个盘块中 第一组盘块总数和所有盘块号记入空闲盘块号栈 最末一组只有N-1各盘块 S.free(0)是栈底 空闲盘块分配首先检查空闲盘块号栈是否上锁，如未上锁，便从栈顶取出一空闲盘块号，将与之对应的盘块分配给用户，然后将栈顶指针下移一格若该盘块号已是栈底，即S.free(0)，即最后一个可分配的盘块号。 须调用磁盘读过程，将栈底盘块号所对应盘块的内容读入栈中，作为新的空闲盘块号栈的内容，然后，把原栈底对应的盘块分配出去(其中的有用数据已读入栈中) 空闲盘块的回收将回收盘块的盘块号记入空闲盘块号栈的顶部，并执行空闲盘块数加1操作。当栈中空闲盘块号数目已达100时，表示栈已满，便将现有栈中的100个盘块号，记入新回收的盘块中，再将其盘块号作为新栈底 提高磁盘I/O速度的途径 磁盘高速缓存（数据交付，置换算法，周期性写回磁盘） 提前读 延迟写 优化物理块布局 虚拟盘 数据一致性控制事务：用于访问和修改各种数据项的一个程序单位，可以看作一系列相关的读写操作，被访问的数据可以分散地存放在同一文件的不同记录中，也可放在多个文件中。只有对分布在不同位置的同一数据所进行的读和写(含修改)操作全部完成时，才能再以托付操作(Commit Operation)来终止事务。只要有一个读、写或修改操作失败，便须执行夭折操作(Abort Operation)。读或写操作的失败可能是由于逻辑错误，也可能是系统故障所导致的 事务记录 事务名：用于标识该事务的惟一名字 数据项名：它是被修改数据项的惟一名字 旧值：修改前数据项的值 新值：修改后数据项将具有的值 恢复算法undo，把所有被事务Ti修改过的数据恢复修改前的值redo，把所有被事务Ti修改过的数据设置为新值 检查点作用：使对事务记录表中事务记录的清理工作经常化]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>磁盘存储器的管理</tag>
        <tag>位示图法</tag>
        <tag>成组链接法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设备管理]]></title>
    <url>%2F2019%2F05%2F10%2F%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[设备管理I/O系统管理的主要对象是I/O设备和相应的设备控制器，其主要任务是，完成用户提出的I/O请求，提高I/O速率，以及提高设备利用率，并为更高层的进程方便地使用这些设备提供手段 I/O系统的层次结构I/O软件组织分为4个层次 用户层I/O软件：提供库函数对I/O设备操作 设备独立性软件：实现用户程序与设备驱动器的统一接口，设备命名，保护和分配释放等 设备驱动软件：与硬件直接相关，用于具体实现系统对设备发出的操作指令 中断处理程序：用于保存被中断进程的CPU环境，转入相应的中断处理程序处理，处理完恢复现场 设备控制器设备并不是直接与CPU进行通信，而是与设备控制器通信，I/O设备应提供提供数据信号线，状态信号线和控制信号线给设备控制器 设备控制器主要功能是控制一个或多个I/O设备，实现I/O设备和计算机之间的数据交换，它是CPU与I/O设备之间的接口，接收从CPU发来的命令，去控制I/O设备工作 设备控制器基本功能 接收和识别命令 数据交换：数据总线实现CPU到控制器的交换，数据寄存器实现设备控制器到I/O设备的交换 标识和报告设备的状态 地址识别 数据缓冲区 差错控制 设备控制器的组成 设备控制器与处理机的接口：数据线地址线和控制线，实现CPU和设备控制器的通信，数据线通常与数据寄存器或者控制/状态寄存器连接，与数据寄存器连接的话是传输数据，与控制/状态寄存器连接的话是存放控制信息或设备状态信息 设备控制器与设备的接口：控制器由一个或多个设备接口，由数据，控制，状态三种信号组成 I/O逻辑：实现对设备控制，通过一组控制线与处理机交互，处理I/O命令，每当CPU启动一个设备，一方面启动命令发送给控制器，另一方面同时通过地址线把地址发送给控制器，由控制器的I/O逻辑对收到的地址译码，对所选设备控制 I/O通道引入目的：解脱CPU对I/O的组织，管理。虽然设备控制器可以减少CPU对I/O的干预，但当主机所配置的外设很多时，CPU负担仍很重，为此增加了I/O通道 I/O通道是一种特殊的执行I/O指令的处理机，与CPU共享内存，可以有自己的总线，它从CPU接收I/O指令，从内存取出要执行的通道执行程序，然后执行，完成规定I/O任务后，向CPU发中断信号 通道类型 字节多路通道：各通道以时间片轮转方式共享通道，适用于低，中速设备 数组选择通道：无子通道，仅一主通道，某时间由某设备独占，适用高速设备，利用率低 数组多路通道：多子通道按需分配，综合前面两种优点 I/O控制方式四个阶段：程序I/O——中断I/O——DMA控制——通道控制 趋势：减少CPU对I/O操作的干预，提高并行度 程序I/O控制方式：采用轮询的方式，CPU需要花代价不断查询I/O状态 中断I/O控制方式：CPU向I/O发命令然后做其他事，设备管理器按照该命令控制指定I/O，当I/O中断产生，CPU转去执行中断处理程序，CPU以字节为单位干预I/O DMA控制：由DMA控制器直接控制总线传递数据块，DMA控制器完成从I/O到内存，主要用在块设备中 通道控制：DMA控制对多离散块的读取仍需要多次中断，通道方式CPU只要给出通道程序首地址，要访问的I/O设备后，通道程序就会完成一组块操作 缓冲管理缓冲管理的目的是：组织管理，分配，释放buffer 引入： 缓和CPU与I/O设备速度不匹配的矛盾 减少对CPU的中断频率 提高CPU和I/O并行性 解决数据粒度不匹配问题（数据单元大小） 单缓冲 双缓冲 收发可双向同时传送 循环多缓冲 缓冲池 设备分配包括对设备，设备控制器和通道的分配 设备分配应考虑的若干因素 设备的固有属性：共享+虚拟，独享 分配算法：FIFO，优先权 安全性 设备独立性即设备无关性，指应用程序独立于具体使用的物理设备 设备可以分为逻辑设备和物理设备，逻辑设备名到物理设备名的映射由逻辑设备表LUT实现 分配流程：进程给出逻辑名——通过LUT得到物理设备及其driver入口 优点是设备分配更灵活，可以是多对多的映射关系，提供均衡性于容错性，提高共享性，易于实现I/O重定向（改变LUT表即可） 设备独立性软件设备独立性软件执行所有设备的公有操作，如分配回收，名字映射，保护，缓冲，差错控制等，并向用户层软件提供统一接口如read，write SPOOLING技术为了缓和CPU高速性和I/O设备低速性的矛盾，引入脱机输入，脱机输出技术，利用专门的外围控制机，将低速I/O设备上的数据，传送到高速磁盘上，或者相反。当系统引入多道程序技术后，完全可以利用其中一道程序来模拟脱机输入时外围控制机的功能，把低速I/O设备上的数据传送到高速磁盘上，再用另一道程序，模拟脱机输出时外围控制器的功能，将数据从磁盘传送到低速输出设备上，这样便可在主机的直接控制下，实现以前的脱机输入，脱机输出的功能，此时外围操作与CPU对数据的处理同时进行，我们把这种联机情况下实现的同时外围操作的技术，称为SPOOLing技术（Simultaneous Periphernal Operating Online）或称为假脱机技术 SPOOLing提供了I/O速度，将独占设备改造为共享设备，实现了虚拟设备的功能 设备处理设备驱动程序的功能： 接收I/O进程发来的命令和参数，将命令中的抽象要求转换为具体要求 检查用于I/O请求的合法性 发出I/O命令 及时响应由控制器或通道发来的中断请求，并根据中断类型调用相应的中断处理程序处理 自动构成通道程序 设备处理方式 为每一类设备设置一个进程，专门用于执行这类设备的I/O操作 整个系统设置一个I/O进程，用于执行系统中所有各类设备的I/O操作 不设置专门的设备处理进程，而为各类设备设置相应的设备处理程序，供用户或系统进程调用 磁盘存储器管理 磁盘的类型 固定头磁盘：每条磁道上都有一读/写磁头，所有磁头都被装在刚性磁臂中，通过这些磁头可访问所有磁道，并进行并行读/写，有效提高I/O速度 移动头磁盘：每一个盘面仅配一个磁头，也被装入磁臂中，该磁头能移动进行寻道，仅能串行方式读/写，I/O速度慢 磁盘访问时间 寻道时间Ts：磁臂（磁头）移动到指定磁道上所经历的时间，是启动磁臂时间s与磁头移动n条磁道所花费时间之和，Ts=m*n+s，m是常数，与磁盘驱动器速度有关 旋转延迟时间Tτ：扇区移动到磁头下面所经历的时间 传输时间Tt：把数据从磁盘读出或向磁盘写入数据所经历的时间Tt=b/rN，b是每次读/写的字节数，r是磁盘每秒转数，N是一条磁道上的字节数 当一次读/写的字节数相当于半条磁道上的字节数时，Tt与Tτ相同，可将访问时间Ta表示为Ta=Ts+1/2r+b/rN 磁盘调度先来先服务FCFS根据进程请求访问磁盘的先后次序调度 最短寻道时间优先SSTF该算法选择这样的进程，要求访问的磁道与当前磁头所在的磁道距离最近 扫描算法SCANSSTF实质是基于优先级的调度算法，可能会导致低优先级进程饥饿现象，因为只要不断有新进程请求到达，且所访问的磁道与磁头距离较近，则较远的进程饥饿，扫描算法不仅考虑访问磁道与当前磁道的距离，更优先考虑磁头当前的移动方向，例如当磁头自里向外移动，SCAN算法考虑的是当前磁道之外的，又是距离最近的，直到再无更外的磁道需要访问，就将磁臂换向改为自外向里，跟电梯运行很像，又称为电梯调度算法 磁盘高速缓存利用内存中的存储空间，来暂存从磁盘中读出的一系列盘块中的信息高速缓存逻辑上属于磁盘，物理上是内存高速缓存在内存中分为两种：第一种是内存中开辟单独的存储空间来作为磁盘高速缓存，大小是固定的，不会受应用程序多少的影响，第二种是把所有未利用的内存空间变为一个缓冲池，供请求分页系统和磁盘I/O（作为磁盘高速缓存）共享 数据交付方式系统可以采取两种方式，将数据交付给请求进程 数据交付：直接将高速缓存中的数据传送到请求者进程的内存工作区中 指针交付：只将指向高速缓存中某区域的指针交付给请求者进程 置换算法高速缓存的置换算法和请求分页系统有些区别，除了考虑最近最久未使用这一原则外，还考虑了访问频率，可预见性和数据的一致性 周期性写回磁盘UNIX系统专门增设一个修改程序，该程序周期性调用一个系统调用SYNC，主要功能是强制性将所有高速缓存中已修改的盘块数据写回磁盘，一般两次SYNC间隔30s]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>设备管理</tag>
        <tag>设备控制器</tag>
        <tag>通道</tag>
        <tag>SPOOLing</tag>
        <tag>缓冲</tag>
        <tag>磁盘存储器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟存储器]]></title>
    <url>%2F2019%2F05%2F10%2F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%2F</url>
    <content type="text"><![CDATA[虚拟存储器基本概念虚拟存储器的引入：常规存储器管理方式特征：一次性（全部装入），驻留性（驻留在内存不换出） 局部性原理： 时间局部性：如循环执行，某条指令被执行，不久以后可能会再次执行，数据被访问，不久后可能会再次被访问，原因是程序中存在大量循环操作 空间局部性：如顺序执行，一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址可能集中在一定范围之内 虚拟存储器的定义：具有请求调入功能和置换功能，能从逻辑上对内存容量进行扩充的一种存储系统实质：时间换空间，但时间牺牲不大 虚拟存储器特征：离散性（部分装入），多次性（局部装入，多次装入），对换性，虚拟性 虚拟存储器的实现方式虚拟存储器的实现，全都建立在离散分配存储管理方式的基础上 需要动态重定位 目前的虚拟存储器都是采用分页请求系统和分段请求系统的方式实现的，分页请求系统就是在分页系统的基础上增加了请求调页功能和页面置换功能，分段请求系统在分段系统的基础上加入了请求调段功能和分段置换功能 分页请求系统 以页为单位转换 需硬件： 请求分页的页表机制 缺页中断 地址变换机构 需实现请求分页机制的软件 请求分段系统 以段为单位转换 请求分段的段表结构 缺段中断 地址变换机构 需实现请求分段机制的软件 请求分页存储管理方式请求分页的页表机制在纯页表机制上增加若干项形成，主要作用还是将用户地址空间中的逻辑地址映射为内存空间中的物理地址，为了满足页面换出换进换出的需要，它增加了一些字段 状态位P：仅有一位，指示该页是否已经调入内存 访问字段A：记录本页在一段时间内被访问的次数或记录本页最近已有多长时间未被访问，作为置换算法换出页面时的参考 修改位M：标识该页在调入内存后是否被修改过，由于内存每一页在外存上都有一份副本，因此置换该页时，如果未被修改，就不需要将该页写回到外存 缺页中断请求分页系统中，每当所要访问的页面不在内存时，便产生一缺页中断，请求OS将所缺之页调入内存，它与一般中断相比有明显区别，主要表现如下： 在指令执行期间产生和处理信号。通常CPU都是在一条指令执行完后才检查是否有中断请求到达。然而缺页中断在指令执行期间，若发现所要访问的指令或数据不在内存时，便立即产生和处理缺页中断信号，以便及时将所缺的页面调入内存 一条指令在执行期间可能产生多次缺页中断。例如下图中，执行一条指令copy A to B，可能要产生6次缺页中断，因为指令本身跨了两个页面，A和B各自为一个数据块，它们也都跨了两个页面 地址变换机构在分页系统地址变换机构的基础上，为实现虚拟存储器，再增加了某些功能，比如产生和处理缺页中断，以及从内存中换出一页的功能等等 请求分页的内存分配为进程分配内存时涉及三个问题：第一，为保证进程能正常运行，所需要的最小物理块数的确定；第二，在为每个进程分配物理块时，应采取什么样的分配策略，即所分配的物理块是固定的，还是可变的；第三，为不同进程分配物理块数，是平均分配算法还是根据进程大小按比例分配 最小物理块数的确定最小物理块数指保证进程正常运行所需的最小物理块数，取决于计算机硬件结构和指令格式，比如单地址指令且直接寻址的机器，最小物理块数为2，一块存放指令的页面，一块存放数据的页面，而对于单地址指令间接寻址，至少需要3个物理块，如果指令长度两个或多个字节，且指令本身可跨两个页面，源地址目标地址所涉及区域也跨两个页面，则要为每个进程分配6个物理块以装入6个页面 内存分配策略可采用固定和可变分配策略，置换时也可采取全局置换和局部置换，组合出下面三种适用的策略，全局置换指产生缺页都获得新物理块，如果没有空闲物理块，就从内存中选择一页调出，该页可能是系统中任何一个进程的，局部置换指换出的页面只能是该进程的页面，而不能是其他进程的 固定分配局部置换：固定分配指为每个进程分配一组固定数目的物理块，在进程运行时间不再改变，局部置换指如果进程在运行中发现缺页，则只能从分配给该进程的n个页面中选一页换出，再调入一页，以保证分配给该进程内存空间不变，缺点是难以确定固定分配的页数，如果少，置换率高，如果多就浪费 可变分配全局置换：可变分配指先为每个进程分配一定数目的物理块，在进程运行器件可根据情况适当增加或减少。可变分配全局置换这可能是最易于实现的一种物理块分配和置换策略，已用于若干个OS中。在采用这种策略时，凡产生缺页（中断）的进程，都将获得新的物理块，仅当空闲物理块队列中的物理块用完时，OS才能从内存中选择一页调出。被选择调出的页可能是系统中任何一个进程中的页，因此这个被选中的进程拥有的物理块会减少，这将导致其缺页率增加 可变分配局部置换：当某进程发现缺页时，只允许从该进程在内存的页面中选择一页换出，这样不会影响到其它进程的运行，如果进程运行中频繁缺页中断，系统就为该进程分配若干附加的物理块，直到进程缺页率降到适当程度为止，反之如果缺页率比较低，就适当减少该进程物理块数 物理块分配算法 平均分配算法 考虑优先权分配算法 页面调入策略问题： 何时调入页面 预调页策略：将那些预计在不久后会被访问的页面预先调入内存 请求调页策略：在进程需要访问页面不在内存的数据和程序时才提出请求，费系统开销 从何处调入页面 对换区，快 文件区，慢，在缺少对换区空间时 UNIX方式：未运行过的页面都从文件区调入，运行过但被换出的页面从对换区调入 页面调入过程：在上面地址变换机构的图的左半部分就是页面调入过程 页面置换算法最佳置换算法OPT其所选择的被淘汰页面，将是以后永不使用的，或许是在最长时间内不再被访问的页面，因为人们目前无法预知，一个进程在内存的若干页面中哪一个是未来最长时间不再被访问的，因而该算法是无法实现的，用于评价其他算法 考虑先将7，0，1三个页面装入内存，当进程要访问页面2，就会产生缺页中断，这个时候就会把页面7淘汰，因为页面0是第5个被访问的页面，页面1是第14个被访问的页面，页面7是第18个被访问的页面，访问到页面3的时候，同理页面1被淘汰，以此类推 先进先出页面置换算法FIFO该算法总是淘汰最先进入内存的页面，即选择内存中驻留时间最久的页面淘汰，该算法实现只需要把 进程已调入内存的页面按先后次序链接成一个队列，并设置一个指针，称为替换指针，它总是指向最老的页面 最近最久未使用置换算法LRU根据页面调入内存后的使用情况做出决策，选择最近最久未使用的页面淘汰，每个页面一个访问字段，用来记录一个页面自上次被访问以来经历了多少时间t，当需要淘汰一个页面时，选择现有页面中t值最大的淘汰 需要移位寄存器R=Rn-1Rn-2…R2R1R0的支持，当访问某物理块时，就将移位寄存器Rn-1置1，定时器每隔一段时间将寄存器右移一位，具有最小数值的寄存器所对应的页面就是最近最久未使用的页面或者需要栈的支持，当进程访问某页面，将该页面号从栈移出，压入栈顶，栈底就是最近最久未使用的页面号 Clock置换算法，页面缓冲算法等考纲没说要考，再看下去我要挂科了 请求分页访问内存有效时间EAT=(1-p)t+pf其中p为缺页率，t为内存访问时间，f为缺页中断时间 请求分段存储管理方式请求分段的段表机制 存取方式：执行，只读，读/写 存在位P：是否已调入内存 增补位：本段在运行过程中是否做过动态增长 缺段中断机构 与缺页中断的区别主要是有空区拼接，形成一个合适的空区 地址变换机构 分段的共享与保护分段的优点是便于实现分段的共享与保护 共享段表 分段保护提供如下分段保护 越界检查 存取控制检查 环保护机构]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>虚拟存储器</tag>
        <tag>请求分页</tag>
        <tag>请求分段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[存储器管理]]></title>
    <url>%2F2019%2F05%2F09%2F%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[存储器管理存储器管理概述存储器的多层结构由于CPU与存储器的速度不匹配，需要对存储器进行分层，经典是三层结构：CPU寄存器，主存和辅存，目前比较高级的分层是六层：寄存器，高速缓存，主存储器，磁盘缓存，固定磁盘和可移动存储介质，层次越高，速度越快，但价格越高，存储容量越小 高速缓存常用SRAM，内存DRAM，SDRAM等，外存是软盘，硬盘，光盘等 各层次作用主存又称内存，用于保存进程运行的程序和数据，处理机都是从主存储器取指令和数据的，并把指令放入指令寄存器，数据放入数据寄存器，或者反过来把寄存器中的数据存入主存储器。 寄存器有与处理机相同的速度 高速缓存是介于寄存器和存储器之间的存储器，主要用于备份主存常用的数据，减少处理机对主存的访问次数，可以大幅度提高程序执行速度 磁盘缓存是为了缓和磁盘I/O速度和主存访问速度的不匹配，主要用于暂时存放频繁使用的一部分磁盘数据和信息，以减少访问磁盘的次数，它本身不是一种实际存在的存储器，而是利用主存中部分存储空间暂时存放从磁盘中读出或写入的信息 存储器管理功能存储器管理主要有如下功能 存储分配和回收：分配和和回收算法及相应的数据结构 地址变换 可执行文件生成中的链接技术 程序加载（装入）时的重定位技术 进程运行时硬件和软件的地址变换技术和机构 存储共享和保护 代码和数据共享 地址空间访问权限（读，写，执行） 存储器扩充 重定位概念重定位是实现逻辑地址（相对地址）到物理地址（绝对地址）的映射逻辑地址：应用程序的地址都是从0开始的物理地址：主存中一系列存储信息的物理单元的地址 程序的装入一个程序一般有5个过程，编辑，编译，链接，装入和运行 程序装入分为绝对装入和可重定位装入和动态运行时装入绝对装入指编译后，装入前已产生绝对地址，装入时不需要再作地址重定位，绝对地址由编译器或程序员编程完成可重定位装入指静态重定位，静态重定位指地址转换在装入时一次完成，缺点是不允许程序在运行中在内存中移动位置动态运行时装入在把装入模块装入内存后，并不立即把装入模块中的逻辑地址转换成物理地址，而是把这种地址转换推迟到程序真正要执行的时候才进行，因此，装入内存后的地址都是逻辑地址，需要一个重定位寄存器的支持 程序的链接源程序编译后得到一组目标模块，链接程序的功能是将这组目标模块以及它们所需要的库函数装配成一个完整的装入模块 静态链接：对相对地址进行修改，变换外部调用符号动态链接：便于修改和更新，便于实现对目标模块的共享运行时动态链接 连续分配管理方式为了能将用户程序装入内存，必须为它分配一定大小的内存空间，连续分配方式是最早出现的一种存储器分配方式 单一连续分配用于单用户单任务中，把内存分为系统区和用户区，应用程序装入到用户区，可使用用户区全部空间，优点是易于管理，缺点是对要求内存空间少的程序造成内存浪费，程序全部装入，很少使用的程序部分也会占用内存 固定分区特点：有n个分区，可同时装入n个作业/任务固定分区可以把分区划分为相等的跟不相等的，不相等的利用率更高 数据结构：分区使用表，将分区按大小排序，并将地址，分配标识符（是否已分配），大小作记录，由于每个分区的大小固定，必然会造成存储空间的浪费 可变式分区数据结构 空闲分区表：记录每个空闲分区的情况，每个空闲分区占一个表目，表目中包括分区号，分区大小和分区始址等。 空闲分区链：实现对空闲分区表的分配和链接，在每个分区的起始部分设置一些用于控制分区分配的信息，以及用于链接各分区所用的前向指针，在分区尾部设置一后向指针，通过前后向链接指针，可将所有空闲分区链接成一个双向链，分区尾部重复设置状态位和分区大小表目，当分区被分配出去后，状态位由”0”改为”1”，此时前后指针无意义 分配算法为把一个新作业装入内存，须按照一定的分配算法，从空闲分区表或空闲分区链中选一分区分配给该作业 分区分配操作分配内存利用某种分配算法，从空闲分区链（表）中找到所需大小的分区，设请求的分区大小是u.size，表中每个空闲分区的大小可表示为m.size，若m.size-u.size&lt;=size（size是事先规定的不再切割的剩余分区的大小）说明多余部分太小，可不再切割，将整个分区分配给请求者，并从分区链移除，否则从该分区中按请求的大小划分找出一块内存空间分配出去，余下的部分仍留在空闲分区链（表）中，然后将分配区的首地址返回给调用者 回收内存当进程运行完毕释放内存后，系统根据回收区的首地址，从空闲区链（表）中找到相应的插入点，此时可能出现下面四种情况 回收区与插入点前一个空闲分区F1相邻接，此时应将回收区与插入点前一分区合并，不必为回收区分配新表项，而只需修改前一分区F1的大小 回收区与插入点后一个空闲分区F2相邻接，此时将两分区合并，形成新的空闲分区，但用回收区的首地址作为新空闲区的首地址，大小为两者之和 回收区同时与插入点的前，后两个分区邻接，此时将三个分区合并，使用F1的表项和F1的首地址，取消F2的表项，大小为三者之和 回收区既不与F1邻接也不与F2邻接：新建表项，填入回收区首地址和大小，插入到空闲链适当位置 分配算法基于顺序搜索的动态分区分配算法 首次适应(first fit, FF)算法：空闲分区链以地址递增的次序链接，从链首开始顺序查找直到找到一个大小能满足要求的空闲分区为止，然后从该分区划出一块内存空间分配给请求者 循环首次适应(next fit, NF)算法：不再是每次都从链首开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找 最佳适应(best fit, BF)算法：每次为作业分配内存时，总是把能满足要求又是最小的空闲分区分配给作业，要求所有空闲分区按容量从大到小顺序形成一空闲分区链 最坏适应(worst fit, WF)算法：总是挑选最大的空闲区从中分割一部分存储空间给作业使用，要求将所有空闲分区按容量从大到小形成一空闲分区链，查找时只需看第一个分区是否满足作业要求 基于索引搜索的动态分区分配算法 快速适应(quick fit)算法：将空闲分区根据容量大小分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链，内存设立一张管理索引表，索引表项对应空闲分区类型，并记录该类型空闲分区链表表头的指针，根据进程常用空间大小划分，比如2KB，4KB，8KB等，7KB可以放在8KB也可以放在特殊的空闲分区链表中 伙伴系统：无论已分配分区或空闲分区，其大小均为2的k次幂，对于相同大小空闲分区单独设立一个空闲分区双向链表，不同大小的空闲分区形成了k个空闲分区链表，对于进程分配一个长度为n的存储空间时，计算i值，使2^(i-1) &lt; n &lt;= 2^i，先从2^i的空闲分区查找，若找到就分配，没有则从2^(i+1)的空闲分区查找，找到就分为相等的两个分区，称为一对伙伴，其中一个分区用于分配，另一个分区加入到2^i的空闲分区链表中 哈希算法，构造空闲分区大小为关键字的哈希表，每一个表项记录一个对应的空闲分区链表表头指针 动态可重定位分区分配 紧凑：连续分配方式的一个重要特点是：一个系统或用户程序必须被装入一片连续的内存空间中，当计算机运行一段时间后，它的内存空间会被划分为许多小的分区，而缺乏大的空闲空间，当有大作业要加入，因为小分区不邻接，无法分配内存给大作业，紧凑就是将内存中的所有作业进行移动，使它们全都相邻接，这样，原来分散的多个空闲小分区拼接成一个大分区，每次紧凑后，必须对移动了的程序或数据进行重定位 动态重定位：动态运行时装入的方式，作业装入内存后所有地址仍然是相对地址，而将相对地址转换成绝对地址的工作被推迟到程序指令要真正执行的时候进行，设一个重定位寄存器，用它存放程序（数据）在内存中的起始地址，程序执行时真正访问的地址是相对地址与重定位寄存器的地址相加而形成的 对换对换的引入：将阻塞进程，暂时不用的程序，数据换出，将具备运行条件的进程换入类型： 整体对换：进程对换，解决内存紧张 部分对换：页面对换/分段对换：提供虚存支持 对换空间的管理具有对换功能的OS中，常把磁盘空间分为文件区和对换区，对换区比文件区侧重于对换速度，因此对换区一般采用连续分配，采用数据结构和分配回收类似于可变化分区分配 进程的换出与换入当内存不足时，便调用对换进程，实现进程的换出和换入 进程的换出 选择被换出的进程：选择因素：优先级，驻留时间，进程状态 进程换出过程：共享段计数减一，如果是0就换出，修改PCB和MCB 进程的换入 选择换入进程：优先级，换出时间等 申请内存 换入 分页存储管理方式基本概念分页主要是将用户程序的地址空间划分为若干个固定大小的区域，称为”页”或”页面”，典型的页面大小为1kb，相应地，也将内存空间分为若干个物理块或页框，页和块的大小相同，这样可以将用户程序的任一页放入任一物理块中，实现离散分配（页是相对用户程序的地址而言，页框或者块是相对内存空间而言） 离散分配的引入：连续分配引起碎片，紧凑方式消耗系统开销 分页存储管理的基本方法地址结构 A：逻辑地址空间的地址 L：页面的大小 包含两部分内容：前一部分为页号P，后一部分为位（偏）移量W，即页内地址，图中的地址长度为32位，其中0——11位为页内地址，即每页大小4KB（页面大小），12——31位为页号，地址空间最多允许有1M页 页的计算例子 页表为了能在内存中找到每个页面对应的物理块，系统为每个进程建立一张页面映射表，为页表，在进程地址空间内的所有页(0——n)，依次在页表中有一页表项，其中记录了相应页在内存中对应的物理块号，实现从页号到物理块号的地址映射 地址变换机构为了能将用户地址空间中的逻辑地址转换成内存空间中的物理地址，系统中设立了地址变换机构，地址变换机构任务实际只是将逻辑地址中的页号转换为内存中的物理块号（页内地址与物理块内的地址是一样的，所以不需要变换），地址变换任务就是借助页表实现的 基本地址变换机构 越界保护 每个进程对应一页表，其信息（如长度，始址）放在PCB中，执行时将其首地址装入页表寄存器 页表是驻留在内存中的，当调度程序调度某程序的时候，才将PCB中的页表始址和页表长度装入页表寄存器（一个进程对应一个页表，所以对不同页表，需要有页表始址来区分） 地址变换过程当进程要访问某个逻辑地址的数据时，分页地址变换机构会自动地将有效地址（相对地址）分为页号和页内地址两部分，再以页号为索引区检索页表，查找操作由硬件执行。在检索之前，先将页号与页表长度比较，若大于或等于页表长度，则表示本次所访问的地址已超越进程的地址空间，产生一地址越界中断。若未出现越界错误，则将页表始址与页号和页表项长度的乘积相加，便得到该表项在页表中的位置，于是可从中得到该页的物理块号，将它装入物理地址寄存器，然后把页内地址送入物理地址寄存器的块内地址字段中，这样便完成了逻辑地址到物理地址的变换 我对将页表始址与页号和页表项长度的乘积相加地理解页表项长度应该就是页表项（即物理块）的地址的长度通过上述式子的计算，得到的是一个地址值（页表始址+页号*页表项长度（地址长度）），这个地址值应该是页表中该页表项的物理内存地址，访问这个物理内存地址，就得到这个物理块号了 需要考虑的问题直接映射的分页系统对系统效能不利，因为CPU需要访问两次主存才能得到所需要的数据，第一次访问是访问主存中的页表，从中找到指定页的物理块号再将块号与页内偏移量W拼接形成物理地址，第二次访问是从第一次所得地址中获得实际数据，为了解决这个问题，引入快表 具有快表的地址变换机构为了提高地址变换速度，在地址变换机构中增设一个具有并行查寻能力的特殊高速缓冲寄存器，又称为”联想寄存器”，或称为”快表”，或者TLB，用以存放当前访问的那些页表项，此时地址变换过程是这样的： 在CPU给出有效地址后，由地址变换机构自动地将页号P送入高速缓冲寄存器，并将此页号与高速缓存中地所有页号进行比较，若其中有与此相匹配的页号，便表示所要访问的页表项在快表中，于是，可直接从快表中读出该页所对应的物理块号，并送到物理地址寄存器，如在快表中没有找到对应的页表项，则还须再访问内存中的页表，找到后把从页表中读出的物理块号送往地址寄存器，同时，再将此页表项存入快表的一个寄存器单元中，如果快表满了，则OS找到一个老的且被认为不需要的页表项换出 访问内存的有效时间从进程发出指定逻辑地址的访问请求，经过地址变换，到在内存中找到对应的实际物理地址单元并取出数据，所需要花费的总时间，称为内存的有效访问时间（Effective Access Time, EAT)，有效访问时间分为第一次访问内存时间（即查找页表对应的页表项所耗费的时间t）与第二次访问内存时间（即将页表项的物理块与页内地址拼接成实际物理地址所耗费的时间t）之和 t：访问一次内存所需要的时间EAT=t+t=2*t 引入快表后，快表命中率a，查找快表需要的时间λ EAT=a(t+λ)+(1-a)(2t+λ)=2t+λ-t*a 两级和多级页表 两级页表的逻辑地址结构 以前面的32位逻辑地址空间为例，当页面大小为4KB的时候(12位)，采用两级页表结构时，再对页表进行分页，使每页包含2^10个页表项，或者说，外层页表中的外层页内地址P2为10位，外层页号P1也为10位 （通过外部页号得到P2的始址，然后P2和d就可以通过上面说过的地址变换过程获得物理地址了）外层页表的每个页表项中存放的是某页表分页的首地址，地址变换机构中同样要增加外层页表寄存器，用于存放外层页表的始址，并利用逻辑地址中的外层页号作为外层页表的索引，从中找到指定页表的始址（同上页表始址与页号和页表项长度乘积相加那个原理），再利用P2作为指定页表分页的索引，找到指定页表项，即含有该页在内存中的物理块号，用该块号P和页内地址d即可构成访问的内存物理地址 一个练习小例子 对题目的理解：页号是用户程序而言的，该用户程序有32页，每页2K，而物理块是针对内存空间而言的，内存有1M，第1题第2问中，因为物理空间有1M，每页2K，即每个物理块2K，所以内存中有512个物理块，这32页必须可以对应到这512个物理块中的每一块，物理块号为0#——511#，页表项是物理块的块号，所以页表项位数应该是511的二进制位数，即9位 对第二题，由逻辑地址算出页号和页内地址，通过页号找到物理块号，物理地址=物理块号*页面大小+业内地址 分段存储管理系统基本思想：按程序的逻辑结构，将程序的地址空间划分为若干段，各段大小可不相同，在进行存储分配时，以段为单位，这些段在内存中可以不相邻接为什么引入：一方面程序可分为若干个段，主程序段，子程序段A，子程序段B，数据段，栈段等，另一方面实现和满足信息共享，信息保护，动态链接以及信息的动态增长等需要 分段系统基本原理分段每个段定义了一组逻辑信息，分段地址的地址具有如下结构 段表 地址变换过程 设置了段表寄存器，用于存放段表始址和段表长度TL，在进行地址变换时，系统将逻辑地址中的段号和段表长度TL进行比较，若S&gt;TL，表示段号太大，访问越界，若未越界，则根据段表始址和段号，计算出该段对应段表项的位置（物理地址），从中读出该段在内存的起始地址，然后检查段内地址d是否超过该段段长SL，若超过，即d&gt;SL，同样发出越界中断，若未越界，则该段基址d与段内地址相加，即可得到要访问的内存物理地址 分段同样需要访问两次内存，同样由联想存储器用于保存最近常用的段表项 分页和分段主要区别 页是信息的物理单位，段是逻辑单位 页长度固定由系统决定，段长度不固定 分页用户程序地址空间是一维的，分段是二维的，既要给出段名又要给出段内地址 段页式存储管理方式]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>存储器管理</tag>
        <tag>分页</tag>
        <tag>分段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[处理机调度与死锁]]></title>
    <url>%2F2019%2F05%2F09%2F%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[处理机调度与死锁处理机调度基本概念处理机调度分为三个层次 高级调度：作业调度，调度对象是作业，根据某种算法，决定将外存上处于后备队列的哪几个作业调入内存，为它们创建进程，分配资源，并放入就绪队列，主要用在多道批处理系统，在分时和实时系统中不设置高级调度 低级调度：进程调度，根据某种算法，决定就绪队列中哪几个进程应获得处理机，并由分派程序将处理机分配给被选中的进程，最基本的调度 中级调度：内存调度，主要目的是提高内存利用率和系统吞吐量，把暂时不能运行的进程调至外存等待，此时进程状态称为就绪驻外存状态（或挂起状态），当进程具备运行条件且内存又有空闲时，由中级调度决定，把外存上已具备运行条件的就绪进程重新调入内存，并挂在就绪队列上等待，实际上中级调度是存储器管理的对换功能 调度的运行频率是低&gt;中&gt;高 调度队列模型仅有进程调度的调度队列模型 同时具有三级调度的调度队列模型 周转时间多道批处理系统中，用户提交的作业先存放到外存，排成一个后备队列，作业调度程序按一定算法从后备队列中选择若干作业调入内存，使他们共享CPU和系统资源，当程序A因I/O而暂停执行时，再调度另一道程序B运行，这样可以保持CPU处于忙碌状态 周转时间常用于批处理系统，指从作业被提交给系统开始，到作业完成的时间，分为 驻外等待调度时间 驻内等待调度时间 执行时间 阻塞时间 平均周转时间可以表示为 带权周转时间描述进程在其周转时间中，等待和执行时间的具体分配情况，W=T/Ts，T是周转时间，Ts是系统为它提供服务的时间平均带权周转时间表示为 调度算法先来先服务(FCFS)和短作业优先(SJF)调度算法它们都可以用于作业调度和进程调度 FCFS(first-come first-served)就不解释了，SJF（short job first)以作业长短计算优先级，作业越短优先级越高，作业长度以作业所要求的运行时间来衡量，SJF缺点是必须预知作业的运行时间，对长作业非常不利，人机无法交互，未考虑作业紧迫程度。 FCFS和SJF的比较 在SJF中，当A完成后，此时时间为4，B,C,D,E均已到达，因为D的作业最短，所以处理机先为D服务，然后为B，E，C服务 高优先权优先调度算法可以作为作业调度和进程调度 优先级调度算法（PSA，priority-scheduling algorithm）分为非抢占式优先权算法和抢占式优先权算法，抢占式实时性更好 优先权的类型分为 静态优先权：整个运行期不变 动态优先权：优先权随执行时间而下降，随等待时间而上升，响应比Pp=(等待时间+服务时间)/服务时间作为优先权，优点是长短兼顾，缺点是需要计算Rp 高响应比优先算法(HRRN,Highest Response Ratio Next)响应比Rp=(tw+ts)/ts，tw为等待时间，ts为服务时间 基于时间片的轮转调度算法(RR)进程调度算法，基于时间片的轮转(RR,round robin)让就绪队列上的每个进程每次仅运行一个时间片，每个进程每次大约都可获得1/n的处理机时间 进程切换时间 若一个时间片尚未用完，正在运行的进程已经完成，则激活调度程序，将它从就绪队列中删除，再调度就绪队列中队首的进程运行，并启动一个新的时间片 若时间片用完，计时器中断处理程序激活，调度程序把它送往就绪队列的队尾 时间片大小的确定若时间片太大，则退化为FCFS，若太小，则系统开销过大，时间片大小确定应考虑系统对响应时间的要求，就绪队列中进程的数目和系统的处理能力（应保证一个时间片处理完常用命令） 实时调度实时调度必须提供： 就需时间：某任务成为就绪的起始时间 开始/完成截止时间 处理时间 资源要求 优先级 非抢占式用时间片轮转，抢占式可以时钟中断或立即抢占（只要不在临界区就抢占） 常见的实时调度算法最早截止时间优先EDF根据任务的开始截止时间来确定任务优先级 最低松弛度优先LLF松弛（紧急）程度=完成截止时间-处理时间-当前时间 主要用于可抢占的调度方式 死锁死锁定义：如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件，那么该组进程是死锁的。 产生死锁的原因 竞争资源引起死锁：竞争不可抢占的资源或可消耗资源引起死锁 进程推进顺序不当 产生死锁必要条件 互斥条件：资源必须互斥 请求和保持条件：进程已经保持至少一个资源但又提出新的资源请求 不可抢占条件：资源不可抢占 循环等待条件：发生死锁时，必然存在一个进程——资源的循环链，即P0等待P1占用的资源，P1等待P2占用的资源，Pn等待P0占用的资源 解决死锁的方法 预防死锁 避免死锁 检测死锁 解除死锁 解决死锁的方法预防死锁预防死锁：破坏产生死锁的4个必要条件之一，互斥条件一般是不能破坏的，所以主要是破坏产生死锁的后三个条件，预防死锁有效，但资源利用率低 摒弃请求和保持条件：资源一次性分配摒弃不剥夺条件：新申请不能满足就释放已获得资源摒弃环路条件：资源有序分配，为资源编号，申请时按编号进行 避免死锁避免死锁是在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁，最经典的避免死锁的算法是银行家算法 银行家算法数据结构 可利用资源向量Available：含有m个元素的数组，每个元素代表一类可利用的资源数目，初始值是系统配置的该类全部可用资源的数目，Available[j]=K表示系统中现有Rj类资源的最大数目K个 最大需求矩阵Max：是一个n*m的矩阵，定义了系统中n个进程中每一个进程对m类资源的最大需求，如果Max[i, j]=K，则表示进程i需要Rj类资源的最大数目为K 分配矩阵Allocation：n*m矩阵，定义了系统中每一类资源当前已分配给每一进程的资源数，如果Allocation[i, j]=K，则表示进程i当前已分得Rj类资源的数目为K 需求矩阵Need：n*m矩阵，用来表示每一个进程尚需的各类资源数，如果Need[i, j]=K，表示进程i还需要Rj类资源K个 Need[i, j] = Max[i, j] - Allocation[i, j] 算法流程设Requesti是进程Pi的请求向量，如果Requesti[j]=K，则表示进程Pi需要K个Rj类的资源，当Pi发出资源请求后，系统按下述步骤进行检查 如果Requesti[j] &lt;= Need[i, j]，则转向步骤2，否则认为出错，因为它申请的资源大于它宣布的最大值 如果Requesti[j] &lt;= Available[j]，则转向步骤3，否则尚无足够资源，Pi需等待 系统试探把资源分配给进程Pi，并修改下面数据结构的数值 Available[j] = Available[j] - Requesti[j]; Allocation[i, j] = Allocation[i, j] + Requesti[j]; Need[i, j] = Need[i, j] - Requesti[j]; 系统执行安全性算法，检查此次资源分配后系统是否处于安全状态，若安全，才正式分配资源给Pi，否则本次试探分配作废，恢复原来的资源分配状态，让进程Pi等待 安全性算法如上面所述，安全性算法是试探性分配后（即修改了Available，Allocation，Need但未正式分配资源）进行的，若安全才正式分配，否则试探分配作废，算法如下 设置两个向量：工作向量Work，表示系统可提供给进程继续运行所需的各类资源数目，含有m个元素，执行安全算法开始时，Work=Available；Finish，它表示系统是否有足够资源分配给进程，使之运行完成。开始时Finish[i]=false，当有足够资源分配给进程时，再令Finish[i]=true 从进程集合中找到一个满足下述条件的进程：Finish[i]=false;Need[i, j] &lt;= Work[j];若找到，则转向步骤3，否则转向步骤4 假如进程Pi获得资源，则进程Pi可顺利执行，直到完成，并释放分配给它的资源，故应执行Work[j] = Work[j] + Allocation[i, j];Finish[i] = true;go to step 2; 如果所有进程的Finish[i]=true都满足，则表示系统处于安全状态，否则，系统处于不安全状态 银行家算法安全性检查的例子 一开始检查，发现p0不满足第2步的条件，p1满足，就把p1的资源释放，加到Work，然后继续检查，p2不满足，p3满足，则释放掉p3的资源，然后释放，最后所有的进程都释放了 P.S.解题的时候，画表，行是每个进程，列依次是Work,Need,Allocation,Work+Allocation,Finish 检测死锁资源分配图 资源分配图圆圈表示进程，方框表示资源，方框内点表示资源数，箭头由资源指向进程表示一个单位的资源分配给进程，进程指向资源表示进程请求一个单位的资源 死锁定理S为死锁状态的充分条件是当且仅当S状态的资源分配图是不可完全简化 资源分配图的简化找出既不阻塞又非独立的进程结点Pi，去掉所有分配边和请求边，若能去掉所有结点的所有分配边和请求边，则不会发生死锁，否则发生死锁 解除死锁主要方法 抢占资源：从一个或多个进程抢占足够资源分配给死锁进程 终止进程]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>调度</tag>
        <tag>死锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程管理]]></title>
    <url>%2F2019%2F05%2F08%2F%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[进程管理进程的定义，与程序的区别定义进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位，是程序的一次执行。 与程序的区别 进程 程序 程序是指令的集合，是静态的概念 进程是处理机上的一次执行过程，动态的概念 程序是长期存在的 进程有生命周期，有创建，活动和消亡 程序是指令的有序集合 进程由程序，PCB和数据组成 程序和进程并非一一对应，同一程序同时运行在若干不同数据集上，它将属于若干个不同进程 一个进程可以执行多个程序 进程的状态及其转换进程三种基本状态分别是 就绪状态 执行状态 阻塞状态 它们的转换关系如下 引入挂起状态（被换出内存的状态）后，进程的转换如下 挂起状态挂起状态是把进程从内存移出外存，不释放CPU 而阻塞状态是释放CPU，但不释放内存 引入挂起状态的原因是 终端用户请求 父进程请求 负荷调节需要 操作系统需要 进程控制块PCBPCB的作用PCB是进程的唯一标识，它常驻内存 它作为独立运行基本单位的标志 能实现间断性运行方式 提供进程管理所需要的信息 提供进程调度所需要的信息 实现与其他进程的同步和通信 PCB的信息PCB主要包括以下四个方面的信息 进程标识符：外部标识符（针对用户即进程），内部标识符（针对系统） 处理机状态：通用寄存器，指令计数器，用户栈指针，程序状态字等 进程调度信息：进程状态，进程优先级，进程调度其他信息（已等待CPU时间等），事件（阻塞原因） 进程控制信息：程序和数据地址，进程同步和通信机制，资源清单，链接指针（所在队列下一个进程PCB的首地址） 进程控制任务：对系统中所有进程从产生，存在到消亡的全过程实施有效的管理和控制 进程控制由内核中原语实现。 原语（Primitive）：由若干条指令组成，用于完成一定功能的一个过程，它们是原子操作，即所有动作要么全不做，要么全做，是不可分割的，不允许被中断的。原语由内核系统态执行，常驻内存。 常见的进程控制原语如下 创建 撤销 阻塞：执行-&gt;阻塞 唤醒：阻塞-&gt;就绪 挂起：活动-&gt;静止 激活：静止-&gt;活动 进程创建进程创建的过程如下 申请空白PCB 为新进程分配资源 初始化PCB 新进程插入到就绪队列 进程同步同步同步指并发进程在执行次序上的协调，以达到有效资源共享和相互合作，是程序执行有可再现性。 进程有两种形式的制约关系，分别是 资源共享关系：进程间接制约，需互斥地访问临界资源 相互合作关系：进程直接制约 临界资源：一次仅允许一个进程访问的资源 临界区：进程访问临界资源的那段代码 同步机制应遵循： 空闲让进 忙则等待 有限等待 让权等待：不能进入临界区的进程应放弃CPU执行权 信号量机制实现进程同步有许多方法，其中比较经典的是信号量机制 整型信号量整型信号量定义为用于表示资源数目的整型量S，它除初始化外，仅能通过两个原子操作wait(S)和signal(S)来访问，这两个操作一直被称为P，V操作，wait，signal操作描述如下 1234567wait(S) &#123; while (S &lt;= 0); S--;&#125;signal(S) &#123; S++;&#125; 这两个操作是原子操作，它们在执行的时候是不可中断的 记录型信号量整型信号量并没有实现让权等待，而是让进程处于忙等状态，这个时候就需要引入记录型信号量来实现 记录型信号量有一个整型变量value表示资源数目，还有一个进程链表指针list，用于链接上述所有等待进程，定义和PV操作描述如下 12345678910111213typedef struct &#123; int value; struct process_control_block *list;&#125; semaphore;wait(semaphore *S) &#123; S-&gt;value--; if (S-&gt;value &lt; 0) block(S-&gt;list); // block是阻塞原语，它的意思是把当前进程自我阻塞并插入到S-&gt;list中&#125;signal(semaphore *S) &#123; S-&gt;value++; if (S-&gt;value &lt;= 0) wakeup(S-&gt;list); // wakeup是唤醒原语&#125; S-&gt;value是系统中某类资源数目，对它每次wait，意味进程请求一个单位的该类资源，当S-&gt;value &lt; 0，表示该资源已分配完成，进程应调用block原语自我阻塞，并插入到信号量链表S-&gt;list中。当S-&gt;value &lt; 0，它的绝对值是链表中已阻塞进程的数目。对信号量每次signal操作表示执行进程释放一个单位资源，S-&gt;value++，若+1后S-&gt;value仍然&lt;=0，表示该信号量链表中仍有等待该资源的进程被阻塞，调用wakeup原语唤醒该进程.如果S-&gt;value初值为1，则只允许一个进程访问临界资源，此时信号量为互斥信号量。 AND型信号量AND同步机制基本思想是：将进程整个运行过程中需要的所有资源，一次性全部分配给进程，使用后一次性释放，原语为Swait(Simultaneous wait)和Swakeup 管程引入原因：为了避免凡要使用临界资源的进程都自备同步操作wait(s)和signal(s)，将同步操作的机制和临界资源结合到一起，形成管程 定义：一个数据结构和能为并发进程所执行的一组操作，包括局部于管程的共享变量，对该数据结构进程操作的一组过程，对局部管程数据设置初值 管程语法描述如下： 1234567891011121314Monitor monitor_name &#123; // 管程名 share variable declarations; // 共享变量 cond declarations; // 条件变量 void P1(...) &#123;...&#125; void P2(...) &#123;...&#125; ... void(....) &#123;...&#125; &#123; // 管程主体 initialization code; // 初始化代码 &#125;&#125; 条件变量用于进程的阻塞和挂起，形式为condition x, y，对条件变量的操作仅仅是wait和signal，每个条件变量保存一个链表，用于记录因该条件变量而阻塞的所有进程，同时提供两个操作x.wait和x.signal x.wait：正在调用管程的进程因x条件需要被阻塞或挂起，调用x.wait将自己插入到x条件的等待队列上，并释放管程x.signal：正在调用管程的进程发现x条件发生了变化，则调用它，重新启动一个因x条件而阻塞或挂起的进程 进程同步的经典问题生产者-消费者问题问题描述：一组生产者向一组消费者提供消息，它们共享一个包含n个缓冲区的有界缓冲池，生产者向其中投放消息，消费者从中取得消息 问题求解：互斥信号量mutex实现诸进程对缓冲池的互斥使用，信号量empty和full分别表示缓冲池中空缓冲区和满缓冲区的数量 1234567891011121314151617181920212223242526272829303132int in = 0, out = 0;item buffer[n];semaphore mutex = 1, empty = n, full = 0;void producer() &#123; do &#123; produce an item nextp; ... wait(empty); // 当空缓冲池数量为0，即缓冲池已满 wait(mutex); buffer[in] = nextp; in = (in + 1) % n; signal(mutex); signal(full); &#125; while (TRUE);&#125;void consumer() &#123; do &#123; wait(full); // 当满缓冲池为0，即缓冲池已空 wait(mutex); nextc = buffer[out]; out = (out + 1) % n; signal(mutex); signal(empty); consume the item in nextc; ... &#125; while (TRUE); &#125;void main() &#123; cobegin producer(); consumer(); coend&#125; P操作很重要，假如颠倒了生产者的P操作，先拥有了缓冲池的使用权，但此时无空缓冲池，则会进入死锁，V操作顺序则无关紧要，当缓冲区只有一个时，mutex可以省略 哲学家进餐问题 哲学家进餐应定义5个信号量表示5只筷子，且初值均为1，而不能定义1个信号量，因为5个筷子位置不同，哲学家并不是随意拿5个筷子的，他们只能拿他们左右最靠近他们的筷子，描述如下semaphore chopstick[5] = {1, 1, 1, 1, 1}; 第i个哲学家的活动可描述为 123456789101112do &#123; wait(chopstick[i]); wait(chopstick[(i + 1) % 5]); ... // eat ... signal(chopstick[i]); signal(chopstick[(i + 1) % 5]); ... // think ...&#125; while(TRUE) 哲学家问题出现死锁的可能是：五个哲学家同时饥饿而各自拿起左边的筷子，就会使5个信号量chopstick均为0，当他们再试图去拿右边的筷子时，会因没有筷子可拿而无限等待 解决方法有如下几个： 1.至多允许有4位哲学家同时拿左边筷子，方法：设置信号量sm初值为4 12345678910111213philopher(i) &#123; do &#123; wait(sm); wait(chopstick[i]); wait(chopstick[(i + 1) % 5]); eat; signal(sm); signal(chopstick[i]); signal(chopstick[(i + 1) % 5]); signal(sm); think; &#125; while (TRUE);&#125; 2.规定奇数号哲学家先拿他左手边的筷子，再拿右手边的筷子，偶数号哲学家相反 123456789101112131415161718philopher(i) &#123; do &#123; if (i % 2 == 0) &#123; wait(chopstick[i]); wait(chopstick[(i + 1) % 5]); eat; signal(chopstick[i]); signal(chopstick[(i + 1) % 5]); &#125; else &#123; wait(chopstick[(i + 1) % 5]); wait(chopstick[i]); eat; signal(chopstick[(i + 1) % 5]); signal(chopstick[i]); &#125; think; &#125; while (TRUE);&#125; 3.仅当左右手两只筷子均可用的时候，才拿起筷子进餐，利用AND信号量解决 12345678philopher(i) &#123; do &#123; Sswait(chopstick[i], chopstick[(i + 1) % 5]) eat; Ssignal(chopstick[i], chopstick[(i + 1) % 5]); think; &#125; while (TRUE);&#125; 读者-写者问题问题描述：读进程可共享同一对象，写进程不可共享同一对象 分析：整型变量readcount表示读者数，信号量rmutex互斥访问readcount，wmutex读写互斥，只要有一个进程在读，就不允许写进程去写 1234567891011121314151617181920212223242526272829semaphore rmutex = 1, wmutex = 1;int readcount = 0;void reader() &#123; do &#123; wait(rmutex); // readcount的互斥访问 if (readcount == 0) wait(wmutex); // 读写互斥，当该进程为第一个读进程，判断是否有写进程在写，有则阻塞，无则加锁 readcount++; signal(rmutex); ... perform read operation; ... wait(rmutex); readcount--; if (readcount == 0) signal(wmutex); signal(rmutex); &#125; while (TRUE);&#125;void writer() &#123; do &#123; wait(wmutex); perform write operation; signal(wmutex); &#125; while (TRUE);&#125;void main() &#123; cobegin reader(); writer(); coend&#125; 读-写问题的扩散——写者优先即当写进程到达后，后续的读进程必须等待 方法：增加信号量S（初值1），当写进程运行时上锁，封锁后续读者。增加信号量s后，当读进程读，先wait(s)，若后续读进程运行，都会进入s的阻塞队列，而不会在其他进程读的期间（上锁了s，没有上锁rmutex）进入wmutex的阻塞队列，当有写进程运行并进入s的阻塞队列，后续再有读进程进入s的阻塞队列，都排在写进程之后，当前面读进程释放s后，写进程就可以对s上锁，阻止后续读进程了 123456789101112131415161718192021222324252627282930313233semaphore rmutex = 1, wmutex = 1, s = 1;int readcount = 0;void reader() &#123; do &#123; wait(s); wait(rmutex); // readcount的互斥访问 if (readcount == 0) wait(wmutex); // 读写互斥，当该进程为第一个读进程，判断是否有写进程在写，有则阻塞，无则加锁 readcount++; signal(rmutex); signal(s); ... perform read operation; ... wait(rmutex); readcount--; if (readcount == 0) signal(wmutex); signal(rmutex); &#125; while (TRUE);&#125;void writer() &#123; do &#123; wait(s); wait(wmutex); perform write operation; signal(wmutex); signal(s); &#125; while (TRUE);&#125;void main() &#123; cobegin reader(); writer(); coend&#125; 进程通信进程通信实质是进程间的信息交换，有如下几种通信方式 信号量机制：低级，效率低，对用户不透明 共享存贮器：共享存储区等 消息传递系统：交换报文，由一组通信原语实现 管道通信：管道是连接一个读进程和一个写进程之间通信的共享文件 客户机-服务器系统：套接字等]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript09-事件]]></title>
    <url>%2F2019%2F04%2F10%2FJavaScript09-%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[JavaScript09-事件事件流事件流描述的是从页面中接收事件的顺序。如果单击某个按钮，那么单击事件不仅仅发生在按钮上，同样发生在按钮的容器元素，甚至整个页面上。事件冒泡就是最具体的元素最先接收这个事件，然后逐级向上，事件捕获则相反。 事件冒泡事件冒泡是IE提出的，即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档） 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;aha&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="myDiv"&gt;Click Me&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 点击&lt;div&gt;元素，那么这个click事件就按照如下顺序传播： &lt;div&gt; &lt;body&gt; &lt;html&gt; document 事件捕获Netscape Communicator团队提出的另一种事件流。事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。仍以上面html代码为例，单击&lt;div&gt;元素就会以下列顺序触发click事件 document &lt;html&gt; &lt;body&gt; &lt;div&gt; 一般考虑到老版本，使用事件冒泡更多。 DOM事件流DOM2级事件规定的事件流包括三个阶段：事件捕获阶段，处于目标阶段和事件冒泡阶段。 事件处理程序事件处理程序名字以”on”开头，因此click事件的事件处理程序就是onclick，load事件的事件处理程序就是onload。 HTML事件处理程序123456&lt;script type="text/javascript"&gt; function showMessage() &#123; alert("Hello World!"); &#125;&lt;/script&gt;&lt;input type="button" value="Click Me" onclick="showMessage()" /&gt; 这样指定事件处理程序会创建一个封装着元素属性值的函数，这个函数中有一个局部变量event，也就是事件对象 &lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(event.type)&quot; /&gt; // &quot;click&quot; 通过event对象，可以直接访问事件对象，在这个函数内部，this值等于事件的目标元素 &lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(this.value)&quot; /&gt; // 返回元素的value属性，这里为&quot;Click Me&quot; 关于这个动态创建的函数，可以像访问局部变量一样访问document及该元素本身的成员，使用with像下面这样扩展： 1234567function() &#123; with(document) &#123; with(this) &#123; // 元素属性值 &#125; &#125;&#125; 如果当前元素是一个表单输入元素，则作用域还会包含访问表单元素的入口，如下： 123456789function() &#123; with(document) &#123; with(this.form) &#123; with(this) &#123; // 元素属性值 &#125; &#125; &#125;&#125; 扩展这个作用域的方式，主要是想让事件处理程序无需引用表单元素就能访问其他表单字段，例如： 1234&lt;form method="post"&gt; &lt;input type="text" name="username" value="" /&gt; &lt;input type="button" value="Echo Username" onclick="alert(username.value)"&gt;&lt;/form&gt; DOM0级事件处理程序通过JavaScript指定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性。如下 1234var btn = document.getElementById(&quot;myBtn&quot;);btn.onclick = function() &#123; alert(&quot;Clicked&quot;);&#125; 使用DOM0级方法执行的事件处理程序被认为是元素的方法，程序中的this引用的是当前元素。只需把属性值设置为null就可以删除事件处理程序 DOM2级事件处理程序DOM2级事件定义了两个方法，用于处理指定和删除事件处理程序的操作：addEventListener()和removeEventListener()。所有DOM节点都包含这两个方法，它们接收3个参数：要处理的事件名，作为事件处理程序的函数和一个布尔值。这个布尔值若为true，表示捕获阶段调用事件处理程序；如果是false，表示冒泡阶段调用事件处理程序。 DOM2级方法主要好处是可以添加多个事件处理程序，如下 123456789var btn = document.getElementById("myBtn");btn.addEventListener("click", function() &#123; alert("Hello World!");&#125;, false);btn.addEventListener("click", function()&#123; alert(this.id);&#125;, false); 通过addEventListener()添加的事件处理程序只能使用removeEventListener()来移除；移除时传入的参数要与添加处理程序时使用的参数相同，即添加的匿名参数无法移除。 大多数情况下，都是把事件处理程序添加到事件流的冒泡阶段，这样可以最大限度地兼容各种浏览器。最好只在需要在事件到达目标之前截获它的时候将事件处理程序添加到捕获阶段。如果不是特别需要，不建议在事件捕获阶段注册事件处理程序。 事件对象在触发DOM上某个事件时，会产生一个事件对象event，这个对象中包含所有与事件有关的信息，包括导致事件的元素，事件的类型以及其他与特定事件相关的信息。例如鼠标操作导致的鼠标位置的信息等。 DOM中的事件对象兼容DOM的浏览器会将一个event对象传入到事件处理程序中。 关于event的更多（比如其成员),可以看MDN的DOM Event接口 如果事件处理程序指定给目标元素，则this，currentTarget和target是相同的，事件处理程序内部，对象this始终等于currentTarget的值，如果事件处理程序存在于父节点中，则这些值是不同的，如下 123456var btn = document.getElementById("myBtn");document.body.onclick = function(event) &#123; alert(event.currentTarget == document.body); alert(document.body == this); alert(event.target == btn);&#125; 需要处理一个函数处理多个事件的时候，可以使用type属性，如下： 123456789101112131415161718var btn = document.getElementById("myBtn");var handler = function(event) &#123; switch(event.type) &#123; case "click" : alert("clicked"); break; case "mouseover" : event.target.style.backgroundColor = "red"; break; case "mouseout" : event.target.style.backgroundColor = ""; break; &#125;&#125;;btn.onclick = handler;btn.onmouseover = handler;btn.onmouseout = handler; 要阻止特定事件的默认行为，可以使用preventDefault()方法。例如，链接的默认行为就是在被单击的时候会导航到其href特性指定的URL。 1234var link = document.getElementById("myLink");link.onclick = function(event) &#123; event.preventDefault();&#125; 只有cancelable属性设置为true的事件，才可以使用preventDefault()方法来取消默认行为。 stopPropagation()方法用于立即停止事件在DOM层次中的传播，即取消进一步事件捕获或冒泡。例如，直接添加到一个按钮的事件处理程序可以调用stopPropagation()，从而避免触发注册在document.body上面的事件处理程序。 eventPhase属性可以用来确定事件当前位于事件流的哪个阶段。如果是在捕获阶段调用事件处理程序，那么eventPhase的值为1，如果事件处理程序在目标对象上，则eventPhase值为2，如果是在冒泡阶段调用的事件处理程序，eventPhase等于3。 跨浏览器的事件对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182var EventUtil = &#123; addHandler: function(element, type, handler) &#123; if (element.addEventListener) &#123; element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; // IE事件处理程序 element.attachEvent("on" + type, handler); &#125; else &#123; element["on" + type] = handler; &#125; &#125;, getEvent: function(event) &#123; return event ? event : window.event; &#125;, getTarget: function(event) &#123; return event.target || event.srcElement; &#125;, preventDefault: function(event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, removeHandler: function(element, type, handler) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if (element.detachEvent) &#123; element.detachEvent("on" + type, handler); &#125; else &#123; element["on" + type] = null; &#125; &#125;, stopPropagation: function(event) &#123; if (event.stopPropagation) &#123; event.stopPropagation(); &#125; else &#123; event.cancelBubble = true; &#125; &#125;, // 与mouseout，mouseover事件相关的属性，见下面 getRelatedTarget: function(event) &#123; if (event.relatedTarget) &#123; return event.relatedTarget; &#125; else if (event.toElement) &#123; // 兼容IE8 return event.toElement; &#125; else if (event.fromElement) &#123; return event.fromElement; &#125; else &#123; return null; &#125; &#125;, // 与mousedown，mouseout事件相关的鼠标属性 getButton: function(event) &#123; if (document.implementation.hasFeature("MouseEvents", "2.0")) &#123; return event.button; &#125; else &#123; switch(event.button) &#123; case 0: case 1: case 3: case 5: case 7: return 0; case 2: case 6: return 2; case 4: return 1; &#125; &#125; &#125;&#125;; 事件类型DOM3级事件规定了以下几类事件 UI事件：当用户与页面上的元素交互时触发； 焦点事件：当元素获得或失去焦点时触发； 鼠标事件：当用户通过鼠标在页面上执行操作时触发； 滚轮事件：当使用鼠标滚轮时触发； 文本事件：当在文档中输入文本时触发； 键盘事件：当用户通过键盘在页面上执行操作时触发； 合成事件：当为IME（输入法编辑器）输入字符时触发； 变动事件：当底层DOM结构发生变化时触发。 UI事件UI事件指的是那些不一定与用户操作有关的事件，有如下UI事件。 load：当页面完全加载后在window上触发，当所有框架都加载完毕时在框架集上触发，当图像加载完毕在&lt;img&gt;元素上触发，或者当嵌入的内容加载完毕时在&lt;object&gt;元素上触发。 unload：当页面完全卸载后在window上触发，当所有框架都卸载后在框架集上触发，或当嵌入的内容卸载后在&lt;object&gt;元素上触发。 abort：在用户停止下载过程时，如果浅入的内容没有加载完，则在&lt;object&gt;元素上触发。 error：当发生在JavaScript错误时在window上触发，当无法加载图像时在&lt;img&gt;上触发，当无法加载嵌入内容时在&lt;object&gt;上触发，或者当有一或多个框架无法加载时在框架集上触发。 select：当用户选择文本框（&lt;input&gt;或&lt;texterea&gt;）中的一或多个字符时触发。 resize：当窗口或框架大小变化时在window或框架上触发。 scroll：当用户滚动带滚动条的元素中的内容时，在该元素上触发。&lt;body&gt;元素中包含所加载页面的滚动条。 确定浏览器是否支持DOM2级事件规定的HTML事件，可以用如下代码 var isSupported = document.implementation.hasFeature(&quot;HTMLEvents&quot;, &quot;2.0&quot;); 确定浏览器是否支持DOM3级事件定义的事件，可以用如下代码 var isSupported = document.implementation.hasFeature(&quot;UIEvent&quot;, &quot;3.0&quot;); load事件当页面完全加载后（包括所有图像，JS文件，CSS等外部资源），就会触发window上的load事件。 有两种添加onload事件处理程序的方式，一个是使用上面的EventUtil，另一个就是给&lt;body&gt;元素添加onload特性。 123EventUtil.addHandler(window, "load", function(event) &#123; alert("loaded!");&#125;); &lt;body onload=&quot;alert(&#39;Loaded!&#39;)&quot;&gt;&lt;/body&gt; 一般来说，在window上面发生的任何事件都可以在&lt;body&gt;元素中通过相应的特性来指定。 对于&lt;img&gt;元素，可以为其指定一个事件处理程序，以便图像加载完毕后给出提示。此时，最重要的是要在指定的属性之前先加载指定事件。 123456789EventUtil.addHandler(window, "load", function(event) &#123; var image = document.createElement("img"); EventUtil.addHandler(image, "load", function(event) &#123; event = EventUtil.getEvent(event); alert(EventUtil.getTarget(event).src); &#125;); document.body.appendChild(image); image.src = "./a.jpg"; &#125;); 还有一些元素也以非标准方式支持load事件，&lt;script&gt;元素也会触发load事件，以便开发人员确定动态加载的JS文件是否加载完毕。 12345678EventUtil.addHandler(window, "load", function(event) &#123; var script = document.createElement("script"); EventUtil.addHandler(script, "load", function(event) &#123; alert("Loaded!"); &#125;); script.src = "example.js"; document.body.appendChild(script); &#125;); unload事件在文档被完全卸载后触发。只要用户从一个页面切换到另一个页面，就会发生unload事件。利用这个事件最多的情况就是清除引用，以避免内存泄漏。unload事件的对象同样是window。 resize事件当浏览器窗口被调整到一个新的高度或宽度的时候，就会触发resize事件。这个事件在window上触发。不同浏览器resize事件处理不同，有可能是变化了1像素就触发，然后随着变化不断重复触发，也有可能用户停止调整窗口大小的时候才触发。 scroll事件scroll事件同样是在window上发生的，尽管它实际表示的是页面中相应元素的变化。scroll事件在滚动期间重复被触发。 焦点事件焦点事件会在页面元素获得或失去焦点时触发。利用这些元素并与document.hasFocus()方法及document.activeElement属性配合，可以知晓用户在页面上的行踪。有以下6个焦点事件。 blur：在元素失去焦点时触发。这个事件不会冒泡。 focus：元素获得焦点的时候触发。不会冒泡。 focusin：元素获得焦点时触发，与HTML事件focus等价。 focusout：元素失去焦点时触发。 当焦点从页面中一个元素移动到另一个元素，会依次触发下列事件： focusout在失去焦点元素上触发。 focusin在获得焦点元素上触发。 blur focus 确定浏览器是否支持这些事件： var isSupported = document.implementation.hasFeature(&quot;FocusEvent&quot;, &quot;3.0&quot;); 鼠标与滚轮事件 click：用户单击主鼠标按钮或按下回车触发。 dblclick：用户双击主鼠标按钮触发。 mousedown：用户按下任意鼠标按钮触发。 mouseenter：鼠标光标从元素外部首次移动到元素范围之内时触发。这个事件不冒泡，在光标移动到后代元素上不会触发。 mouseleave：在位于元素上方的鼠标光标移动到元素范围之外时触发。这个事件不冒泡，光标移到后代元素上不会触发。 mousemove：鼠标指针在元素内部移动时重复触发。 mouseout：鼠标指针位于一个元素上方，然后用户将其移入到另一个元素时触发。另一个元素可以是该元素的外部元素或子元素。 mouseover：鼠标指针位于一个元素外部，首次移入另一个元素边界之内触发。 mouseup：用户释放鼠标按钮时触发。 检查是否支持上面事件可以使用如下代码 var isSupported = document.implementation.hasFeature(&quot;MouseEvent&quot;, &quot;3.0&quot;); alert(isSupported); 客户区坐标位置鼠标事件都是在浏览器视口中的特定位置上发生的，这个位置信息保存在事件对象的clientX和clientY属性中。视口坐标，页面坐标，屏幕坐标的区别可以看这个 12345var div = document.getElementById("myDiv");EventUtil.addHandler(div, "click", function(event) &#123; event = EventUtil.getEvent(event); alert("Client coordinates: " + event.clientX + "," + event.clientY);&#125;) 页面坐标位置通过客户区坐标位置能够知道鼠标是在视口中什么位置发生的，而页面坐标通过事件对象的pageX和pageY属性，告诉你事件是在页面中什么位置发生的。这两个属性表示鼠标光标在页面中的位置。坐标是从页面本身而非视口左边和顶边计算。 当页面没有滚动的的时候，页面坐标等于视口坐标，如果有滚动，页面坐标为滚动高度加上视口坐标。 12345var div = document.getElementById("myDiv");EventUtil.addHandler(div, "click", function(event) &#123; event = EventUtil.getEvent(event); alert("Page coordinates: " + event.pageX + "," + event.pageY);&#125;) 屏幕坐标位置屏幕坐标位置是相对于整个电脑屏幕的位置。属性为screenX和screenY。 12345var div = document.getElementById("myDiv");EventUtil.addHandler(div, "click", function(event) &#123; event = EventUtil.getEvent(event); alert("Screen coordinates: " + event.screenX + "," + event.screenY);&#125;) 修改键按下鼠标时键盘上的某些键的状态也可以影响到所要采取的操作。这些修改键是Shift，Ctrl，Alt和Meta（Windows的win键）。DOM为此规定了4个属性，表示这4个修改键的状态：shiftKey，ctrlKey，altKey和metaKey。这些属性中包含的都是布尔值，如果相应键按下，值为true，否则为false。 1234567891011121314151617181920212223var div = document.getElementById("myDiv");EventUtil.addHandler(div, "click", function(event) &#123; event = EventUtil.getEvent(event); var keys = new Array(); if (event.shiftKey) &#123; keys.push("shift"); &#125; if (event.ctrlKey) &#123; keys.push("ctrl"); &#125; if (event.altKey) &#123; keys.push("alt"); &#125; if (event.metaKey) &#123; keys.push("meta"); &#125; alert("Keys: " + keys.join(","));&#125;) 相关元素发生mouseover和mouseout事件时，还会涉及更多的元素。这两个事件都会涉及把鼠标指针从一个元素的边界之内移动到另一个元素的边界之内。对mouseover事件而言，事件的主目标是获得光标的元素，而相关元素是那个失去光标的元素。类似地，对mouseout事件而言，事件的主目标是失去光标的元素，而相关元素则是获得光标的元素。 DOM通过event对象的relatedTarget属性提供了相关元素的信息。这个属性只对mouseover和mouseout事件才包含值。 1234567var div = document.getElementById("myDiv");EventUtil.addHandler(div, "mouseout", function(event) &#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); var relatedTarget = EventUtil.getRelatedTarget(event); alert("Mouse out of " + target.tagName + " to " + relatedTarget.tagName);&#125;); 鼠标按钮只有在主鼠标按钮被单击（或键盘回车被按下）的时候才会触发click事件，因此检测按钮的信息并不是必要的。但对于mousedown和mouseup事件来说，在其event对象内存在一个button属性，表示按下或释放的按钮。DOM的button属性可能有如下3个值：0表示主鼠标按钮，1表示中间鼠标按钮（滚轮按钮），2表示次鼠标按钮。IE8之前的button属性与DOM有很大差异，不做表述。具体的兼容鼠标检测见上面EventUtil 更多的事件信息DOM2级事件规范在event事件中还提供了detail属性，用于给出有关事件的更多信息。对于鼠标事件来说，detail中包含一个数值，表示在给定位置上发生了多少次单击。同一元素上相继发生一次mousedown和一次mouseup事件算一次单击。detail属性从1开始计数，每次单击后递增。如果鼠标在mouseup和mousedown之间移动了位置，detail会被重置为0. 鼠标滚轮事件mousewheel事件，当用户通过鼠标滚轮与页面发生交互，在垂直方向上滚动页面时（无论向上向下），就会触发mousewheel事件。这个事件可以在任何元素上触发，最终冒泡到window对象。mousewheel事件包含一个特殊的wheelDelta属性。当用户向前滚动鼠标滚轮，wheelDelta是120的倍数，当用户向后滚动滚轮，wheelDelta是-120的倍数。 1234EventUtil.addHandler(document, "mousewheel", function(event) &#123; event = EventUtil.getEvent(event); alert(event.wheelDelta);&#125;) 跨浏览器的解决方案 1234567getWheelDelta: function(event) &#123; if (event.wheelDelta) &#123; return (client.engine.opera &amp;&amp; client.engine.opera &lt; 9.5 ? -event.wheelDelta : event.wheelDelta); &#125; else &#123; return -event.detail * 40; //兼容Firefox &#125;&#125; 键盘与文本事件有三个键盘事件，如下： keydown：当用户按下键盘上的任意键时触发，如果按住不放，则重复触发。 keypress：当用户按下键盘上的字符键时触发，如果按住不放会重复触发。 keyup：当用户释放键盘上的键时触发。 用户按下一个字符键时，首先触发keydown，其次是keypress，最后是keyup。键盘事件同样也有shiftKey，ctrlKey，altKey和metaKey。 键码在发生keydown和keyup事件时，event对象的keyCode属性会包含一个代码。对数字字母字符键，keyCode属性的值与ASCII中对应小写字母或数字的编码相同。其他keyCode值在这里！ 字符编码charCode属性只有在发生keypress事件时才包含值，而且这个值是按下的那个键所代表的字符的ASCII编码。此时keyCode通常等于0或者也可能等于所按键的键码。对于IE8及其之前版本和Opera，则用keyCode来保存字符的ASCII编码，跨浏览器获取字符编码如下： 1234567getCharCode: function(event) &#123; if(typeof event.charCode == "number") &#123; return event.charCode; &#125; else &#123; return event.keyCode; &#125;&#125; 在DOM3级事件中，不再有charCode属性，而是key和char属性。key属性是一个字符串，当按下字符键，他的值是字符键的值（如”A”，”k”），当按下非字符键，他的值是相应键的名（如”Shift”，”Down”）。char属性按下字符键时显示字符键的值，按下非字符键，显示null。（存在跨浏览器的问题，所以不推荐使用上面两个值，以及Chorme和Safari 5的KeyIdentifier） textInput事件DOM3级事件规范引入的一个新事件，当用户在可编辑区域输入字符时，就会触发这个事件。任何可以获得焦点的元素都可以触发keypress事件，但只有可编辑区域才会触发textInput事件。textInput只会在用户按下能够输入实际字符的键时才会被触发，而keypress事件则在按下那些能够影响文本显示的键时也会触发（比如退格）。 textInput事件有一个data属性，表示用户输入的字符。 变动事件DOM2级的变动事件能在DOM中某一部分发生变化时给出提示。为XML或HTML DOM设计。DOM2级定义了如下变动事件。 DOMSubtreeModified：在DOM结构中发生任何变化时触发。这个事件在其他任何事件触发后都会触发。 DOMNodeInserted：在一个结点作为子节点被插入到另一个节点中触发。 DOMNodeRemoved：在结点从其父节点中被移除时触发。 var isSupported = document.implementation.hasFeature(&quot;MutationEvents&quot;, &quot;2.0&quot;);检查是否支持变动事件。 MDN的mutation事件 设备事件与触摸手势事件主要用于智能手机和平板电脑]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络之DNS服务]]></title>
    <url>%2F2019%2F04%2F10%2FDNS%2F</url>
    <content type="text"><![CDATA[DNSDNS是计算机网络应用层一个很重要的服务，了解它基本就了解了整个网络中域名到IP转换的过程。 DNS是什么在《计算机网络-自顶向下方法》中有这么一句话 DNS：因特网的目录服务 DNS（Domain Name System）其实就是一个目录，他的作用是通过用户给定域名，查出对应的IP地址。 而更为严格的定义就是：DNS是： 一个由分层的DNS服务器实现的分布式数据库 一个使得主机能够查询分布式数据库的应用层协议 或者说DNS是一个黑盒子，它提供了主机名到IP地址的转换，一个简便的DNS黑盒子过程如下： 同一台用户主机上运行着DNS应用的客户端 浏览器从URL中抽取出主机名，传给DNS应用的客户端 DNS客户向DNS服务器发送一个包含主机名的请求 DNS客户最终收到一份回答报文，其中含有对应该主机名的IP地址 一旦浏览器获得该地址，就可以向位于该IP地址的80端口的HTTP服务器进程发起一个TCP连接 DNS主要任务是主机名到IP地址转换的目录服务DNS除了有主机名到IP地址的转换服务外，还有如下服务： 主机别名 邮件服务器别名 负载分配 值得一提的是，DNS协议运行在UDP之上，使用53端口。 DNS分布式，层次数据库DNS是一个分布式，层次数据库，大致有三类：根DNS服务器，顶级域(TLD)DNS服务器和权威DNS服务器。还有一类是本地DNS服务器，每个ISP都有一台本地DNS服务器，本地DNS服务器起着代理的作用，将请求转发到DNS服务器的层次结构中。 在说服务器分层作用之前，先要说一下域名，常见的域名是例如www.example.com，但是它真正的域名是www.example.com.root，只是省略了后面的.root。.root称为根域名，.com，.net等等称为顶级域名(TLD)，.example称为次级域名，这个域名是用户可以注册的，再下一级是主机名(host)，比如www，又称为三级域名。 总结一下，域名的层级结构如下： 主机名(三级域名).次级域名.顶级域名.根域名 即host.sld.tld.root 根DNS服务器它将返回顶级域名的TLD服务器的IP地址，根域名服务器的NS记录和IP地址一般是不会变化的 顶级域DNS服务器它返回权威服务器的IP地址 权威DNS服务器它返回主机名(如www.amazon.com)的IP地址 本地DNS服务器严格上来说它不属于DNS层次结构，但它也很重要。本地DNS服务器由ISP提供，当主机发出DNS请求时，通常被发往到本地DNS服务器，由本地DNS服务器代理转发到DNS服务器层次结构 工作机理 以主机cis.poly.edu请求gaia.cs.umass.ude的IP地址为例，假设cis.poly.edu的本地DNS为dns.poly.edu，并且gaia.cs.umass.edu的权威DNS服务器为dns.umass.edu 主机cis.poly.edu首先向它的本地DNS服务器dns.poly.edu发送一个DNS查询报文 本地DNS服务器dns.poly.edu将报文转发到根DNS服务器，根DNS服务器注意到edu前缀并向本地DNS服务器返回负责edu的TLD的IP地址列表 该本地DNS服务器则再次向这些TLD服务器之一发送查询报文 该TLD服务器注意到umass.edu前缀，并用权威DNS服务器的IP地址进行响应 最后，本地DNS服务器直接向dns.umass.edu重发查询报文，dns.umass.edu将gaia.cs.umass.edu的IP地址进行响应 从请求主机到本地DNS服务器的查询是递归的，其余的查询是迭代的 DNS缓存为了改善时延性能并减少在因特网上到处传输的DNS报文数量，DNS广泛采用了缓存技术 它能够把回答中的信息缓存在本地存储器中，但该缓存不是永久的，由于主机和主机名与IP地址间的映射并不是永久的，所以DNS服务器一般在一段时间后（通常为2天）将丢弃缓存的信息。 DNS报文和记录DNS记录共同实现DNS分布式数据库的所有DNS服务器存储了资源记录（Resource Record，RR），RR提供了主机名到IP地址的映射。 RR是一个包含了下列字段的4元组：(Name, Value, Type, TTL) TTL是该记录的生存时间，它决定了资源记录应当从缓存中删除的时间 如果Type=A，则Name是主机名，Value是该主机名对应的IP地址 如果Type=NS，则Name是个域（如foo.com），Value是个知道如何获得该域中主机IP地址的权威DNS服务器的主机名。这个记录用于沿着查询链来路由DNS查询。（如(foo.com, dns.foo.com, NS)就是一个NS记录） 如果Type=CNAME，则Value是别名为Name的主机对应的规范主机名 如果Type=MX，则Value是个别名为Name的邮件服务器的规范主机名 如果一台DNS服务器是用于某特定主机名的权威DNS服务器，那么该DNS服务器会有一条包含该主机名的类型A记录如果服务器不是用于某主机名的权威服务器，那么该服务器将包含一条类型NS记录，该记录对应包含主机名的域；它还包括一条类型A记录，提供在NS记录的Value字段中的DNS的IP地址（比如edu TLD服务器不是主机gaia.cs.umass.edu的权威DNS服务器，则该服务器将包含一条包括主机cs.umass.edu的域记录，如(umass.edu, dns.umass.edu, NS)，该TLD服务器还将包含一条类型A记录，如(dns.umass.edu, 128.199.40.111, A)，该记录将名字dns.umass.edu映射为一个IP地址） DNS报文 对分级查询的进一步解释所谓”分级查询”，就是从根域名开始，依次查询每一级域名的NS记录，直到查到最终的IP地址，见下面的DNS记录可知 从”根域名服务器”查到”顶级域名服务器”的NS记录和A记录（IP地址） 从”顶级域名服务器”查到”次级域名服务器”的NS记录和A记录（IP地址） 从”次级域名服务器”查出”主机名”的IP地址 （根域名服务器的NS记录和IP地址一般是不会变化的，所以内置在DNS服务器中）]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码剖析-对String,StringBuilder,StringBuffer的区分]]></title>
    <url>%2F2019%2F03%2F25%2F%E5%AF%B9String%2CStringBuilder%2CStringBuffer%E7%9A%84%E5%8C%BA%E5%88%86(%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90)%2F</url>
    <content type="text"><![CDATA[源码剖析-对String,StringBuilder,StringBuffer的区分首先观察他们继承的类和接口 String：public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {}StringBuilder：public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, CharSequence {}StringBuffer：public final class StringBuffer extends AbstractStringBuilder implements java.io.Serializable, CharSequence {} 可以观察到，String对象继承了Serializable，Comparable，CharSequence接口StringBuilder与StringBuffer均继承自AbstractStringBuilder父类，Serializable，CharSequence接口 Serializable是序列化接口，它的作用是： Serializability of a class is enabled by the class implementing the java.io.Serializable interface. String 源码剖析12private final char[] value;private int hash; // 默认为0，哈希缓存 String由value，hash组成，value就是它的值了，hash是哈希缓存，注意value是final char[]类型的，即String对象是不可变的 String的equals方法重写了，实现的是依次判断value数组的每个值是否相等，都相等就返回true，否则返回false Comparable接口String实现了Comparable接口，即String对象可以通过调用compareTo()方法进行比较，这是String与StringBuilder和StringBuffer的第一个区别 12345678910public int compareTo(String anotherString) &#123; byte v1[] = value; byte v2[] = anotherString.value; if (coder() == anotherString.coder()) &#123; return isLatin1() ? StringLatin1.compareTo(v1, v2) : StringUTF16.compareTo(v1, v2); &#125; return isLatin1() ? StringLatin1.compareToUTF16(v1, v2) : StringUTF16.compareToLatin1(v1, v2); &#125; 他主要实现了在当前字符编码上对字符串的比较，判断字符串是否相等 StringBuilder与StringBufferAbstractStringBuilder注意到在这个抽象类中定义了 12char[] value;int count; 但注意到value不是final类型，即他是可变的，这个是与String的第二个区别 CharSequence StringBuilderStringBuilder继承自AbstractStringBuilder，大部分代码都已经由其实现，StringBuilder只需要在构造器中调用super()方法即可，包括append()方法，delete()方法，replace()方法，insert()方法，indexOf()方法，lastIndexOf()方法，reverse()方法也都是调用super()方法即可。 StringBuffer而StringBuffer则是在AbstractStringBuilder的方法上添加了synchronized的关键字，即它是线程安全的 总结 String是可以比较的，通过compareTo()方法，而StringBuilder和StringBuffer只能通过toString()方法后再调用compareTo()方法来比较。 String对象是不可变的，其值是final类型，而StringBuilder和StringBuffer对象可变，并没有final修饰。 String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。 对他们的使用，应该遵循下面原则： 操作少量的数据 = String 单线程操作字符串缓冲区下操作大量数据 = StringBuilder 多线程操作字符串缓冲区下操作大量数据 = StringBuffer]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>StringBuilder</tag>
        <tag>StringBuffer</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git快速入门]]></title>
    <url>%2F2019%2F03%2F17%2Fgit%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Git本地仓库创建版本库通过git init把当前目录变为Git可以管理的仓库 把文件放到Git仓库-add指令第一步,编写一个文件,放到该仓库目录下第二步,用命令git add yourFileName告诉git把文件添加到仓库 可以添加多个文件git add file1.txt file2.txt 提交到仓库-commit指令git add -m &quot;提本次提交的说明&quot;,用参数-m输入本次提交的说明 查看暂存区状态-status指令可以使用git status查看当前git状态 版本回退查看历史记录-log指令git log可以查看历史提交记录如果输出信息太多,可以加上--pretty=oneline参数 版本回退-reset指令git的当前版本用HEAD表示,上一个版本是HEAD^,上上个版本是HEAD^^,如果是上100个版本,可以表示为HEAD~100 git reset --hard HEAD^表示回退到上一个版本 如果后悔了,可以找到上面的命令行窗口,找到未来版本的commit id,比如当前版本最新ID为1094adb...,可以通过git reset --hard 1094a回到未来(可以不指定完整的id,git会自动寻找) 记录命令-reflog指令可以通过git reflog查询执行过的命令,并依此找到版本号,这样就可以通过git reset --hard 版本号回到任何版本 工作区和暂存区工作区就是电脑可以看到的目录工作区有一个目录.git，是Git的版本库，里面存了很多东西，其中有称为stage(或者叫index)的暂存区，还有Git自动创建的第一个分支master，以及指向master的一个指针叫HEAD。git add实际是把文件修改添加到暂存区 git commit实际是把暂存区的所有内容提交到当前分支 查看工作区和版本库区别-diff指令git diff HEAD -- youFile.txt：可以查看工作区和版本库最新版本的区别 撤销修改丢弃工作区的修改-checkout可以使用git checkout -- &lt;file&gt;把工作区中file的修改全部撤销 把暂存区的修改放回到工作区-resetgit reset HEAD &lt;file&gt;把暂存区的修改撤销掉,重新放回工作区，然后使用git checkout -- &lt;file&gt;即可撤销修改 删除文件在Git中,删除文件也是一个修改操作 删除暂存区文件-rm在Linux中,对于已经通过add添加到暂存区的文件，如果使用rm删除了文件,删错的情况下,可以git checkout -- &lt;file&gt;恢复文件如果确定删除，git rm &lt;file&gt;删掉，然后git commit提交对于在工作区的文件，使用rm删除无法恢复。 远程仓库添加远程仓库1.在GitHub上create a new repo新建一个仓库，填写仓库名后其他默认（不要生成readme，生成后不是空远程库了，手动在本地库添加上传即可）2.本地仓库与之关联，关联后远程库的名字是origin3.把本地库内容推送到远程（实际是把master分支推送到远程） 远程库关联本地库-remote add根据GitHub上的提示，在本地git bash上git remote add origin https://github.com/youGithubName/youRepo.git 即可关联，若取消关联git remote remove origin 本地库推送到远程-push第一次推送的时候git push -u origin master-u不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 后续推送只需要git push origin master 从远程库克隆克隆远程库到本地-clonegit clone git@github.com:otherName/otherRepo.git 使用ssh克隆git clone https://github.com/otherName/otherRepo.git 使用https克隆 分支管理创建与合并分支每次提交时，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点： 每次提交时，master分支都会向前移动一步。 当我们创建分支的时候，例如dev时，Git会新建一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上： 从现在开始，对工作区任何修改和提交都是针对dev分支了，新提交一次后，dev和HEAD往前一步，master不变： 假如我们在dev上的工作完成了，就可以把dev合并到master上，把master指向dev当前的提交即可： 合并完分支后，甚至可以删除dev分支： 创建分支-branchgit branch dev创建dev分支 切换分支-checkoutgit checkout dev切换到dev分支 创建并切换分支-checkout -bgit checkout -b dev可以新建dev分支并切换到dev分支它相当于下面两条指令git branch dev创建dev分支git checkout dev切换到dev分支 现在，对git进行add和commit操作都是针对dev分支而言 修改完后git checkout master可以切换回master分支，此时，所有针对dev分支进行的改变都是不可见的 注意！暂存区对所有分支来说都是可见的！ 查看所有分支-branchgit branch可以查看所有分支，当前分支前会有 * 指示出来 合并分支-mergegit merge dev把dev分支合并到当前分支上 删除分支-branch -dgit branch -d dev可以删除分支dev，删除前提是当前分支不是dev（即HEAD指针不是指向dev） 解决冲突当两个分支修改的地方有冲突的时候，执行merge就会报错合并冲突，可以使用git stauts查看。冲突发生时分支如下： 打开冲突的文件，可以看到大概类似下面的东西 12345&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADxxxxxx=============XXXXXX&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1 这里xxxxxx是HEAD分支修改的内容，XXXXXX是dev分支修改的内容 只要把这一部分修改成想要的内容，再git add xxx.txtgit commit -m &quot;conflict fixed即可 此时分支如下：（使用下一小节的命令可以查看图形化的分支） (P.S:对这样的分支树进行版本回退，他会退回到master的上一个版本而不是feature1） 然后删除feature1分支即可 也可以选择git merge --abort放弃合并 查看分支合并情况-log –graphgit log --graph --pretty=oneline --abbrev-commit可以以图形的信息查看分支情况 分支策略管理通常，合并分支的时候，Git会用Fast forward模式，在这种模式下，删除分支后，会丢掉分支信息。 如果强制禁用Fast forward，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 禁用fast forward-merge –no-ffe.g.1.创建一个分支git checkout -b dev2.修改readme.txt并提交一个commitgit add readme.txt，git commit -m &quot;add merge&quot;3.切换到master，git checkout master4.合并dev分支，git merge --no-ff -m &quot;merge with no-ff&quot; dev 然后用git log可以看到merge的信息，使用 在fast forward模式下，log里是看不到merge的信息的，即 禁用fast forward的图示执行git merge --no-ff -m &quot;merge with no-ff&quot; dev合并后，禁用fast forward时，在合并分支后，git log的图示如下 可以看到是有一条merge的log的。 删除dev分支之前的git log --graph --pretty=oneline --abbrev-commit 此时虽然执行了merge操作，但dev和master并不指向同一目标，此时master指向的是在master分支下执行merge操作的log，而不是在dev分支下执行commit操作的log 对比下面是执行git merge dev的图示 git log如下： git log --graph --pretty=oneline --abbrev-commit如下： 可以看到并没有merge操作的log，而只有commit操作的log，非fast forward下的合并，仅仅是把master指针指向dev 分支策略实际开发应该遵循下面的基本原则进行分支管理：首先，master分支是非常稳定的，仅仅用来发布新版本，平时不能在上面干活；干活都在dev分支上，dev分支是不稳定的，到某个时候，比如发布1.0版本时，再把dev分支合并到master分支上，在master分支上发布1.0版本多人开发时，每个人都有自己的分支，时不时往dev分支上合并就可以，如下图所示 Bug分支每次出现Bug的时候，都可以新建一个临时分支来修复，修复后合并分支，然后删除临时分支，但如果出现BUG的时候当前手头工作未完成时，Git可以把当前工作现场保存，然后去修改BUG，再恢复现场继续工作 保存工作现场-stashgit stash可以保存当前工作现场，它大概就是，在工作区修改的文件，还没上传到暂存区，则保存工作区修改过的文件，或者已经上传到暂存区的文件，但还没有commit，则保存该文件，然后把工作区置干净(git status查看是干净的)，此时就可以放心创建分支来修复bug。如果没有stash，切换到master分支上修改bug的时候，会发现在dev分支修改的东西还存在，但因为还没写完，所以修改完bug之后commit的话，没写完的东西也会commit上去，这明显是错误的，stash就是为此而生，它把工作区暂存区的东西保存下来，然后让工作区干净，这样在dev上正在工作的，未完成的东西就不会出现了，也不会因为修改bug而提交到master了，然后创建分支修改完bug之后再切换回dev分支恢复现场即可。 注意！！，如果要在master分支上修复bug，则必须先切换到master分支，再新建一个分支！修改完分支后，切换回master分支并合并，然后删除bug分支即可 此时修复完bug，切换回工作分支，然后恢复刚刚stash的内容 查看stash内容-stash listgit stash list可以查看stash内容 恢复工作现场-stash applygit stash apply恢复工作现场，然后git stash drop删除stash内容 多次stash的时候，先用git stash list查看，然后恢复指定的stashgit stash apply stash@{0} 恢复工作现场-stash popgit stash pop恢复工作现场同时把stash内容删除 Feature分支软件开发中，当要添加新功能时，可以新建一个feature分支来实现。 强制删除分支—branch -D如果新功能要舍弃，分支还没合并就要删除，可以通过git branch -D &lt;name&gt;来删除参数-D是强制删除 多人协作当从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin 查看远程库的信息-remotegit remote可以查看远程库的信息git remote -v可以显示更详细的信息，显示了可以抓取和推送的origin地址，如果没有推送权限，则看不到push地址 推送分支git push origin master 如果要推送其他分支，比如dev，就改成git push origin dev 下面是分支的简介 master分支是主分支，时刻与远程同步 dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步 bug分支只用于本地修复bug，一般不需要推送到远程 feature分支是否推送到远程，取决于是否合作开发 抓取分支当另外一个人从远程库克隆的时候，默认情况下，他只能看到本地的master分支，如果要在dev分支上开发，就必须创建远程origin的dev分支到本地。 创建远程分支到本地git checkout -b dev origin/dev pullgit pull命令用于从另一个存储库或本地分支获取并集成，它的作用是：取回远程主机某个分支的更新，再与本地指定分支合并。 常见格式是git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;若与当前分支合并，则冒号和之后的内容不需要 多人协作的工作模式 首先，可以试图用git push origin &lt;branch-name&gt;推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin &lt;branch-name&gt;推送就能成功！ 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;。 Rebasegit rebase：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了 标签管理它是版本的一个快照，发布一个版本时，先在版本库中打一个标签，然后将来某个时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。 实质上标签就是指向某个commit的指针（和分支很像，但它不能移动） 创建标签创建标签-tag首先切换到需要打标签的分支上然后输入git tag v1.0即可打上v1.0的标签 可以用命令git tag查看所有标签 默认标签是打在最新提交的commit上的，如果要打历史版本的标签，只需要找到历史提交的commit id，然后打上即可git tag v0.9 &lt;commit ID&gt; 还可以指定带有说明的标签，参数-a表示标签名，-m表示说明文字git tag -a v0.1 -m &quot;version 0.1 released&quot; &lt;commit ID&gt; git show &lt;tagname&gt;可以看到说明文字 操作标签删除标签-tag -dgit tag -d v0.1可以删除这个标签 推送标签到远程git push origin &lt;tagname&gt; 一次性推送全部标签git push origin --tags 删除远程标签 git tag -d &lt;tagname&gt;删除本地标签 git push origin :refs/tags/&lt;tagname&gt;删除远程标签 使用GitHub 点击Fork可以在自己账号下的远程仓库克隆一个别人的远程仓库 从自己账号下clone：git clone git@github.com:makloao/xxx.git，一定要克隆自己远程仓库到本地仓库，否则不能推送修改 如果想把自己的修改推送到官方，可以在GitHub上发起一个pull request 自定义Gitgit config --global.user.name &quot;Your name&quot;git config --global user.email &quot;email@example.com&quot;指定用户名和Email git config --global color.ui true让Git显示颜色 忽略特殊文件有些时候要把某些文件放到Git工作目录但又不能提交它们，比如保存了数据密码的配置文件等等只需要在Git工作区的目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去即可，如何写可以看GitHub的.gitignore文件写法 忽略文件的原则 忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 如果想强行添加被.gitignore忽略的文件git add -f xxx.class即可 .gitignore本身要放到版本库中，并且可以对其做版本管理 配置别名可以给命令配置别名git config --global alias.st status：把git status配置别名成git st，同理可以配置其他 一些比较推荐的别名1234567git config --global alias.st statusgit config --global alias.co checkoutgit config --global alias.ci commitgit config --global alias.br branchgit config --global alias.unstage &apos;reset HEAD&apos;git config --global alias.last &apos;log -1&apos; 显示最后一次提交git config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot; 设置log的显示颜色 配置文件配置文件都放在.git/config文件中 而当前用户的Git配置文件放在用户主目录的.gitconfig中 搭建Git服务器如果不想公开代码，又不想给GitHub交保护费 教程在这]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript08-DOM扩展]]></title>
    <url>%2F2018%2F11%2F09%2FJavaScript08-DOM%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[JavaScript08-DOM扩展对JavaScript的两个主要扩展主要是Selectors API和HTML5 选择符API根据CSS选择符选择与某个模式匹配的DOM元素。jQuery的核心就是通过CSS选择符查询DOM文档取得元素的引用，从而抛开了getElementById()和getElementsByTagName()，它有两个核心方法：querySelector()和querySelectorAll()，可以通过Document及Element类型的实例调用它们。 querySelector()方法它接收一个CSS选择符，返回与该模式匹配的第一个元素，如果没有就返回null。 1234567891011// 取得body元素var body = document.querySelector("body");// 取得ID为myDiv的元素var myDiv = document.querySelector("#myDiv");// 取得类为"selected"的第一个元素var selected = document.querySelector(".selected");// 取得类为"button"的第一个图像元素var img = document.body.querySelector("img.button"); querySelectorAll()方法querySelectorAll()方法接收的参数和上面一样，都是一个CSS选择符，但返回的是所有匹配的元素，是一个NodeList实例。 元素遍历Chrome Version 70.0.3538.77不支持 Element Travelsal API为DOM元素添加以下5个属性，用于预防元素间空格造成的childNodes和firstChild等属性不一致的差异。 childElementCount：返回子元素（不包括文本节点和注释）的个数 firstElementChild：指向第一个元素 lastElementChild：指向最后一个元素 previousElementSibling：指向前一个同辈元素 nextElementSibling：指向后一个同辈元素 HTML5与类相关的扩充getElementsByClassName()方法可以通过document对象以及所有HTML元素调用该方法，它接收一个参数，即一个包含一个或多个类名的字符串，返回带有指定类的所有元素的NodeList。 取得所有类中包含”username”和”current”的元素，类先后无所谓var allCurrentUsernames = document.getElementByClassName(&quot;username current&quot;); 取得ID为myDiv的元素中带有类名”selected”的所有元素var selected = document.getElementById(&quot;myDiv&quot;).getElementsByClassName(&quot;selected&quot;); classList属性操作类名的时候，可以使用classList属性，classList属性是DOMTokenList的实例，他有一个表示自己包含多少元素的length属性，要取得每个元素，可以使用item()方法，也可以使用方括号。如下： &lt;div class=&quot;bd user disabled&quot;&gt;&lt;/div&gt; classList属性有三个值分别是bd user和disabled。 这个属性还定义了下面方法 add(value)：将给定的字符串值添加到列表中。 contains(value)：表示列表中是否存在给定的值，存在返回true。 remove(value)：删除value toggle(value)：如果列表中存在给定值，就删除它，如果不存在，就添加它。 这样，就可以通过上述方法操控className了，如下 div.classList.remove(&quot;user&quot;); // 删除user类 焦点管理HTML5添加了辅助管理DOM焦点的功能。document.activeElement属性始终会引用DOM中当前获得焦点的元素。元素获得焦点方式有页面加载，用户输入和在代码中调用focus()方法 123456&lt;body&gt; &lt;button type="button" id="myButton"&gt;Click Me!&lt;/button&gt; &lt;p&gt;&lt;/p&gt; &lt;button type="button" onclick="focusMethod()"&gt;Click me to focus on the button!&lt;/button&gt; &lt;script type="text/javascript" src="./aha.js"&gt;&lt;/script&gt; &lt;/body&gt; 1234focusMethod = function getFocus() &#123; document.getElementById("myButton").focus(); alert(document.activeElement == document.getElementById("myButton")); &#125; 文档刚刚加载完，document.activeElement中保存的是document.body元素的引用。 document.hasFocus()用于确定文档是否获得了焦点。 HTMLDocument的变化HTML5扩展了HTMLDocument，增加了新功能。 readyState属性Document的readyState属性可能有两个值 loading：正在加载文档 complete：已经加载完文档 基本用法如下 123if(document.readyState == "complete") &#123; // 执行操作&#125; head属性作为对document.body引用文档&lt;body&gt;元素的补充，HTML5新增了document.head属性，引用文档的&lt;head&gt;元素。 var head = document.head || document.getElementsByTagName(&quot;head&quot;)[0]; 字符集属性charset属性表示文档中实际使用的字符集，也可以用来指定新字符集，可以通过&lt;meta&gt;元素，响应头部或直接设置charset属性修改这个值。 document.charset = &quot;UTF-8&quot;; 自定义数据属性HTML5可以为元素添加非标准的属性，但要添加前缀data-，目的是为元素提供与渲染无关的信息，或提供语义信息。可以通过元素dataset属性访问这些自定义属性的值。dataset是一个DOMStringMap的实例，键为非标准属性名减去data-前缀（比如自定义属性是data-myname，映射对应属性就是myname） &lt;div id=&quot;myDiv&quot; data-appid=&quot;12345&quot; data-myname=&quot;Nicholas&quot;&gt;&lt;/div&gt; 123456var div = document.getElementById("myDiv");var appId = div.dataset.appid;var myName = div.dataset.myname;alert(appId); 插入标记innerHTML属性在读模式下，innerHTML属性返回与调用元素的所有子节点（包括元素，注释和文本节点）对应的HTML标记。写模式下，innerHTML会根据指定的值创建新的DOM树，然后用这个DOM树完全替换调用元素原先的所有子节点。 写模式下，innerHTML的值会被解析为DOM子树，替换调用元素原来的所有子节点。因为它的值被认为是HTML，所以其中的所有标签都会按照浏览器处理HTML的标准方式转换为元素。设置了innerHTML之后，可以像访问文档中其他节点一样访问新创建的节点。 对下面代码的div块调用innerHTML，会返回其内部子元素（字符串形式） 12345678&lt;div id="content"&gt; &lt;p&gt;This is a &lt;strong&gt;paragraph&lt;/strong&gt; with a list following it.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 下面元素不支持innerHTML属性：&lt;col&gt;,&lt;colgroup&gt;,&lt;frameset&gt;,&lt;head&gt;,&lt;html&gt;,&lt;style&gt;,&lt;table&gt;,&lt;tbody&gt;,&lt;thead&gt;,&lt;tfoot&gt;和&lt;tr&gt; outerHTML属性在读模式下，outerHTML返回调用它的元素及所有子节点的HTML标签。写模式下，outerHTML会根据指定的HTML字符串创建新的DOM子树，然后用这个DOM子树完全替换调用元素。 对上面代码div块调用outerHTML，会返回上面相同的代码，包括div本身。 div.outerHTML = &quot;&lt;p&gt;This is a paragraph.&lt;/p&gt;&quot;; 对上面代码的调用，等价于下面的代码 123var p = document.createElement("p");p.appendChild(document.createTextNode("This is a paragraph."));div.parentNode.replaceChild(p, div); insertAdjacentHTML()方法它接收两个参数，插入位置和要插入的HTML文本。第一个参数必须是下列值之一： beforebegin：当前元素之前插入一个紧邻的同辈元素 afterbegin：当前元素之下插入一个新的子元素或在第一个子元素之前再插入新的子元素 beforeend：当前元素之下插入一个新的子元素或再最后一个子元素之后再插入一个新的子元素 afterend：当前元素之后插入一个紧邻的同辈元素 内存与性能问题使用上面2个属性1个方法之前，最好先手工删除要被替换的元素的所有时间处理程序和JavaScript对象属性。 对上面2个属性，最佳做法是单独构建一个字符串，然后一次性把结果字符串赋值给innerHTML（或outerHTML），这样可以减少访问属性的开支。 scrollIntoView()方法可以在所有HTML元素上调用，通过滚动浏览器窗口或某个容器元素，调用元素就可以出现在视口中，传入true作为参数，或者不传入参数，则窗口滚动之后会让调用元素的顶部与视口顶部尽可能平齐。传入false，调用元素会尽可能出现在视口中（可能的话，调用元素底部会与视口底部平齐） Chrome不支持。。。 专有扩展children属性这个属性是HTMLCollection的实例，只包含元素中同样还是元素的子节点。children属性与childNodes没什么区别 contains()方法调用contains()方法的应该是祖先节点，这个方法接收一个参数，就是要检测的后代节点。如果被检测的节点是后代节点，就返回true。 插入文本innerText属性通过这个属性可以操作元素中包含的所有文本内容，包括子文档树中的文本。在通过innerText读取值时，它会按照由浅入深顺序将子文档中所有文本拼接起来。在通过innerText写值时，结果会删除元素的所有子节点。插入包含相应文本值的文本节点。 outerText属性作用范围扩大到了包含调用它的节点，写操作下会替换整个元素（包括子节点）。 滚动 scrollIntoViewIfNeeded(alignCenter)：只在当前元素在视口中不可见的情况下，才滚动浏览器窗口或容器元素，最终让它可见。如果参数为true，尽量让元素显示在视口中部。 scrollByLines(lineCount)：元素内容滚动指定的行高，可以正或负值。 scrollByPages(pageCount)：元素内容滚动指定的页面高度。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSCript07-DOM]]></title>
    <url>%2F2018%2F11%2F01%2FJavaScript07-DOM%2F</url>
    <content type="text"><![CDATA[JavaScript07-DOM节点层次DOM将任何HTML文档描绘成一个多层节点构成的结构。根节点为文档节点，文档节点下一般有一个子节点&lt;html&gt;元素，称为文档元素。 Node类型DOM定义了一个Node接口，由DOM中所有节点类型实现。每个节点都有一个nodeType属性，用于表明节点的类型，该属性有如下12个数值常量 Node.ELEMENT_NODE(1); Node.ATTRIBUTE_NODE(2); Node.TEXT_NODE(3); Node.CDATA_SECTION_NODE(4); Node.ENTITY_REFERENCE_NODE(5); Node.ENTITY_NODE(6); Node.PROCESSING_INSTRUCTION_NODE(7); Node.COMMENT_NODE(8); Node.DOCUMENT_NODE(9); Node.DOCUMENT_TYPE_NODE(10); Node.DOCUMENT_FRAGMENT_NODE(11); Node.NOTATION_NODE(12); nodeName和nodeValue属性要了解节点具体信息，可以使用这两个属性。 if (someNode.nodeType==1){ value = someNode.nodeName; } 对于元素节点，nodeName始终保存元素标签名，nodeValue始终为null 节点关系每个节点都有一个childNodes属性，其中保存着一个NodeList对象，它是一个类数组对象，用于保存一组有序的节点，也有length属性，但它是基于DOM结构动态执行查询的结果，因此DOM结构的变化能够自动反映在NodeList对象中。 可以通过下面方法访问保存在NodeList中的节点 123var firstChild = someNode.childNodes[0];var secondChild = someNode.childNodes.item(1);var count = somNode.childNodes.length; 每个节点都有一个parentNode属性，该属性指向文档树中的父节点。包含在childNodes列表中的所有节点都具有相同的父节点。此外，包含在childNodes列表中的每个节点相互之间都是同胞节点。使用列表中每个节点的previousSibling和nextSibling属性，可以访问同一列表的其他节点。父节点与其第一个和最后一个子节点之间也有关系，使用父节点的firstChild和lastChild属性分别指向childNodes列表的抵押给和最后一个节点。 所有节点都有最后一个属性是ownerDocument，该属性指向表示整个文档的文档节点。 操作节点appendChild()可以通过appendChild()方法向childNodes列表末尾添加一个节点，如下 1var returndNode = someNode.appendChild(newNode); 如果传入到appendChild()的节点已经是文档的一部分，那结果是将该节点从原来位置转移到新位置。DOM树可以看成是一系列指针连接起来的，但任何DOM节点不能同时出现在文档中的多个位置上。 insertBefore()可以使用insertBefore()方法把节点放在childNodes的某个特定位置上，接收两个参数，要插入的节点和作为参考的节点。插入节点后，被插入的节点会变成参考节点的前一个同胞节点，然后被该方法返回。 1returnedNode = someNode.insertBefore(newNode, null); // 插入到最后 replaceChild()它接收两个参数：要插入的节点和要替换的节点，然后把插入的节点返回。 removeChild()接收一个参数：要移除的节点。然后该节点被该方法返回。 其他方法#####cloneNode() cloneNode()接收一个布尔值参数，表示是否执行深复制。如果为true，则复制节点及其整个子节点树，如果为false，只复制节点本身。 Document类型Document类型表示文档，在浏览器中，document对象是HTMLDocument的一个实例，表示整个HTML页面。而且document类型是window对象的一个属性，有下列特征： nodeType为9； nodeName为”#document”； nodeValue为null； parentNode为null； ownerDucument为null; 文档的子节点有一个documentElement属性，始终指向HTML页面的&lt;html&gt;元素，另外还有一个childNodes列表访问文档元素。 document还提供了body，doctype属性访问对于的标签var body = document.body; 文档信息titledocument对象作为HTMLDocument的一个实例，还有一些其他属性表现网页的一些信息，其中一个是title属性 1234// 一个修改title的例子var originalTitle = document.title;document.title = "New page title"; URL,domain和referrerURL属性包含页面完整的URL，domain属性只包含域名，而referrer属性中则保存链接到当前页面的那个页面的URL，这些属性都保存在HTTP头部，JS提供了这些属性访问它们。 这三个属性中只有domain可以设置，但只能设置成URL包含的域，否则报错，这个属性可以用于跨页面通信，比如一个页面加载自www.wrox.com，包含一个内嵌框架加载自p2p.wrox.com。只需要把它们的document.domain都设置成wrox.com，就可以实现两者的通信。注意一旦设置为wrox.com后，就不能设置回p2p.wrox.com了 查找元素Document类型提供了两个方法查找元素，分别为getElementById()和getElementByTagName()。 getElementById()getElementById()接收一个参数：要取得的元素的ID，区分大小写,返回该元素。 &lt;div id=&quot;myDiv&quot;&gt;&lt;/div&gt;var div = document.getElementById(&quot;myDiv&quot;); getElementsByTagName()getElementByTagName()接收一个参数：要取得的元素的标签名，返回的是包含零个或多个元素的NodeList。在HTML文档中，这个方法返回一个HTMLCollection对象，作为一个动态集合。 var images = document.getElementsByTagName(&quot;img&quot;); 可以通过images.item(i).src取得第i个images对象的src属性 HTMLCollection对象还有一个方法nameItem()，可以通过元素的name特性取得集合中的项。 &lt;img src=&quot;xxx.gif&quot; name=&quot;myImage&quot;&gt;var myImage = images.namedItem(&quot;myImage&quot;);这与直接用方括号语法等效var myImage = images[&quot;myImage&quot;]; 要取得文档所有元素，可以传入参数”*” var allElements = document.getElementsByTagName(&quot;*&quot;); getElementsByName()这是只有HTMLDocument类型才有的方法，它返回带有给定name特性的所有元素。通常用于取得单选按钮，如下 1234567891011&lt;fieldset&gt; &lt;legend&gt;Which color do you prefer?&lt;/legend&gt; &lt;ul&gt; &lt;li&gt;&lt;input type="radio" value="red" name="color" id="colorRed"&gt; &lt;label for="colorRed"&gt;Red&lt;/label&gt;&lt;/li&gt; &lt;li&gt;&lt;input type="radio" value="green" name="color" id="colorGreen"&gt; &lt;label for="colorGreen"&gt;Green&lt;/label&gt;&lt;/li&gt; &lt;li&gt;&lt;input type="radio" value="blue" name="color" id="colorBlue"&gt; &lt;label for="colorBlue"&gt;Blue&lt;/label&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/fieldset&gt; 在这里，所有单选按钮的name属性都是”color”，但他们的ID可以不同，ID的作用是把&lt;label&gt;元素应用到每个单选按钮，而name特性则用以确保三个值中只有一个被发送到浏览器，这样就可以用下面代码取得所有单选按钮 var radios = document.getElementByName(&quot;color&quot;); 特殊集合document对象还有一些特殊的集合。这些集合都是HTMLCollection对象。 document.anchors,包含文档中所有带name特性的&lt;a&gt;元素 document.forms,包含所有&lt;form&gt;元素 documents.images,包含所有&lt;img&gt;元素 document.links,包含所有带href的&lt;a&gt;元素 文档写入document有四个方法可以写入:write(),writeln(),open()和close() 123&lt;script type="text/javascript"&gt; document.write((new Date()).toString()); &lt;/script&gt; Element类型Element类型提供了对元素标签名，子节点以及特性的访问。有如下特征： nodeType值为1 nodeName值为元素的标签名 nodeValue值为null parentNode可能是Document或Element 其子结点可能是Element,Text,Comment等等 要访问元素的标签名，可以使用nodeName属性也可以使用tagName属性。 HTML元素所有HTML元素都由HTMLElement类型及其子类型表示，HTMLElement类型直接继承Element并添加了一些属性 id:元素在文档中的唯一标识符 className:元素的class特性对应，即为元素指定的CSS类 这些属性都是可修改的，直接复制即可 取得特性操作特性有三个方法，分别为getAttribute(),setAttribute()和removeAttribute()。这三个方法可以针对任何特性使用。 getAttribute()也可以取得自定义特性（HTML5中，自定义特性应该加上data-前缀） 123var div = document.getElementById(&quot;myDiv&quot;);alert(div.getAttribute(&quot;class&quot;));alert(div.getAttribute(&quot;data-yourData&quot;); 通常更建议直接使用对象的属性，只有在取得自定义特性的情况下才使用getAttribute()方法 设置特性setAttribute()接收两个参数：要设置的特性名和值，如果特性已经存在，他就会替换现有的值，若不存在，就创建该属性并设置值。 attributes属性Element类型是使用attributes属性的唯一一个DOM节点类型。attributes属性中包含一个NamedNodeMap，与NodeList类似，也是一个动态集合。元素的每一个特性都由一个Attr节点表示，每个节点都保存在NamedNodeMap对象中。它有下列方法： getNamedItem(name):返回nodeName属性等于name的节点 removeNamedItem(name):从列表中移除nodeName属性等于name的节点 setNamedItem(node):向列表中添加节点，以节点的nodeName属性为索引 item(pos):返回数字pos位置的节点 attributes包含一系列节点，每个节点的nodeName是特性名，nodeValue为特性值 var id = element.attributes.getNamedItem(&quot;id&quot;).nodeValue; // 取得element节点特性id的值 等效于 var id = element.attributes[&quot;id&quot;].nodeValue; 创建元素使用document.createElement()方法可以创建新元素 var div = document.createElement(&quot;div&quot;); 创建的同时也指定了其ownerDocument属性。 新创建的元素还没加入文档树 document.body.appendChild(div); 可以把它加入到body元素中 元素的子节点childNodes属性包含了它的所有子节点，这些子节点可能是元素，文本节点，注释或处理指令，可以通过element.childNodes[i].nodeType == 1来作检测 Text类型文本节点可以是字面解释的纯文本内容，也可以是包含转义后的HTML字符，但不能包含HTML代码。 nodeType=3 nodeName=”#text” nodeValue为节点所包含的文本 parentNode是一个Element 不支持子节点 可以通过nodeValue属性或data属性访问节点中包含的文本。使用下列方法可以操作节点中的文本 appendData(text)：把text添加到节点末尾 deleteData(offset, count)：从offset指定的位置开始删除count个字符 insertData(offset, text)：在offset指定位置插入text replaceData(offset, count, text)：用text替换从offset指定的位置开始到offset+count位置的文本 splitText(offset)：从offset指定的位置将当前文本分开两个文本节点 substringData(offset, count)：提取从offset指定的位置开始到offset+count为止处的字符串 &lt;div&gt;Hello World!&lt;/div&gt; 上述文本子节点可以通过var textNode = div.firstChild访问 创建文本节点可以使用document.createTextNode()创建新文本节点，接收一个参数：要插入节点的文本。 一个创建新节点并插入创建文本的例子 1234567var element = document.createElement("div");element.className = "message";var textNode = document.createTextNode("Hello World!");element.appendChild(textNode);document.body.appendChild(element); 一般情况下每个元素只有一个文本子节点，但也可以同时有多个文本子节点，当他们是相邻的同胞节点，那么这两个节点就会连起来显示，中间不会有空格。 规范化文本节点DOM文档中存在相邻的同胞文本节点很容易导致混乱，因为分不清哪个文本节点表示哪个字符串。DOM文档中出现相邻文本节点的情况也不在少数，于是催生了一个能够将相邻文本节点合并的方法，为normalize()，它把所有文本节点合并成一个子节点，结果节点的nodeValue为合并前每个文本节点nodeValue拼接起来的值。 分割文本节点splitText()可以用于分割文本节点。 Comment类型注释在DOM中是通过Comment类型来表示的，有如下特征： nodeType值为8 nodeName值为”#comment” nodeValue值为注释的内容 parentNode可能是Document或Element 不支持子节点 Comment类型与Text类型继承自相同的基类，因此它拥有除splitText()之外的所有字符串操作方法，也可以通过nodeValue或data属性来取得注释的内容。 注释节点可以通过其父节点来访问 1234567&lt;div id="myDiv"&gt;&lt;!-- TODO: do what? --&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var div = document.getElementById("myDiv"); var comment = div.firstChild; alert(comment.data); &lt;/script&gt; 另外，使用createComment()方法也可以创建注释节点 CDATASection类型只针对基于XML的文档，表示的CDATA区域 DocumentType类型DocumentFragment类型Attr类型元素的特性在DOM中以Attr类型来表示，在所有浏览器中都可以访问Attr类型的构造函数和原型，有下列特征 nodeType=2 nodeName是特性的名称 nodeValue是特性的值 parentNode是null HTML中不支持子节点 要取得特性，通常用getAttribute(),setAttribute()和removeAttribute()方法，很少直接引用特性节点 Attr有三个属性，name，value和specified，其中specified是一个布尔值，用于区分特性是在代码中指定还是默认的。 可以使用document.createAttribute()方法并传入特性的名称来创建新的特性节点。 DOM操作技术动态脚本页面加载时不存在，但将来某一时刻通过修改DOM动态添加的脚本。 动态加载外部JS文件123456function loadScript(url) &#123; var script = document.createElement("script"); script.type = "text/javascript"; script.src = url; document.body.appendChild(script);&#125; 动态添加行内JS代码123456789101112function loadScriptString(code) &#123; var script = document.createElement("script"); script.type = "text/javascript"; try &#123; script.appendChild(document.createTextNode(code)); &#125; catch (ex) &#123; script.text = code; &#125; document.body.appendChild(script);&#125;loadScriptString("function sayHi()&#123; alert('hi'); &#125;"); 动态样式加载外部CSS 12345678function loadStyles(url) &#123; var link = document.createElement("link"); link.rel = "stylesheet"; link.type = "text/css"; link.href = url; var head = document.getElementsByTagName("head")[0]; head.appendChild(link);&#125; 操作表格对于一个表格 123456789101112&lt;table border="1" width="100%"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Cell 1,1&lt;/td&gt; &lt;td&gt;Cell 2,1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Cell 1,2&lt;/td&gt; &lt;td&gt;Cell 2,2&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 要创建的节点太多了，所以DOM为&lt;table&gt;,&lt;tbody&gt;和&lt;tr&gt;元素添加了一些属性和方法 &lt;table&gt;的属性和方法如下： caption：保存对&lt;caption&gt;元素的指针 tBodies：是一个&lt;tbody&gt;元素的HTMLCollection tFoot：保存对&lt;tfoot&gt;元素的指针 tHead：保存对&lt;thead&gt;元素的指针 rows：一个表格中所有行的HTMLCollection createTHead()：创建&lt;thead&gt;元素，将其放到表格中，返回引用 createTFoot()：创建&lt;tfoot&gt;元素，同上 createCaption()：创建&lt;caption&gt;元素，同上 deleteCaption() deleteTHead() deleteCaption() deleteRow(pos)：删除指定位置的行 insertRow(pos)：向rows集合中指定位置插入一行 &lt;tbody&gt;元素的属性和方法如下： rows：保存&lt;tbody&gt;元素中行的HTMLCollection deleteRow(pos)：删除指定位置的行 insertRow(pos)：向rows集合中的指定位置插入一行，返回对新插入行的引用 &lt;tr&gt;元素添加的属性和方法如下： cells：保存&lt;tr&gt;元素中单元格的HTMLCollection deleteCell(pos)：删除指定位置的单元格 insertCell(pos)：向cells集合中指定位置插入一个单元格，返回对新插入单元格的引用 1234567891011121314151617181920var table = document.createElement("table");table.border = 1;table.width = "100%";var tbody = document.createElement("tbody");table.appendChild(tbody);tbody.insertRow(0);tbody.rows[0].insertCell(0);tbody.rows[0].cells[0].appendChild(document.createTextNode("Cell 1,1"));tbody.rows[0].insertCell(1);tbody.rows[0].cells[1].appendChild(document.createTextNode("Cell 2,1"));tbody.insertRow(1);tbody.rows[1].insertCell(0);tbody.rows[1].cells[0].appendChild(document.createTextNode("Cell 1,2"));tbody.rows[1].insertCell(1);tbody.rows[1].cells[1].appendChild(document.createTextNode("Cell 2,2"));document.body.appendChild(table);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSCript06-BOM]]></title>
    <url>%2F2018%2F10%2F26%2FJavaScript06-BOM%2F</url>
    <content type="text"><![CDATA[JavaScript06-BOMBOM是浏览器对象模型，它提供了很多用于访问浏览器的功能。 window对象window对象表示浏览器的一个实例，它既是通过JavaScript访问浏览器的一个接口，又是ECMAScript规定的Global对象。这意味着在网页中定义的任何一个对象，变量和函数，都以window作为其Global对象，因此有权访问parseInt等方法。 全局作用域所有在全局作用域中声明的变量，函数都会变成window对象的属性和方法，但注意，定义全局变量与在window对象直接定义还是有一点差别：全局变量不能通过delete操作符删除，而直接在window对象上定义的属性可以 123456var age = 29;window.color = "red";delete window.age; // return falsedelete window.color; // return true 可以通过window对象查询变量是否存在 123var newValue = oldValue; // error,oldValue not definedvar newValue = window.oldValue; // OK,newValue is undefined 窗口位置IE，Safari，Opera，Chrome提供了screenLeft，screenTop属性表示窗口相对于屏幕左边和上边的位置。Firefox提供了screenX和screenY属性。 123// 获取窗口左边和上边的位置var leftPos = (typeof window.screenLeft == "number")?window.screenLeft:window.screenX;var topPos = (typeof winodw.screenTop == "number")?window.screenTop:window.screenY; 可以使用moveTo()和moveBy()将窗口精确移动到某个位置moveTo()接收的是新位置的x和y坐标，而moveBy()接收的是在水平和锤石方向上移动的像素数 12345// 将窗口移动到屏幕左上角window.moveTo(0,0);// 将窗口向左移动50像素window.moveBy(-50,0); 需要注意这两个方法可能会被浏览器禁用 窗口大小IE9+,Firefox,Safari,Opera和Chrome提供4个属性：innerWidth,innerHeight,outerWidth,outerHeight。在Chrome中，outer和inner返回的是相同的值，都是viewport大小而非浏览器窗口大小。在Firefox中，outer返回的是浏览器窗口本身的尺寸，inner返回的是该容器中页面视图区的大小（减去边框宽度）。 下面方法可以获得viewport大小 123456789101112var pageWidth = window.innerWidth, pageHeight = window.innerHeight;if(typeof pageWidth != "number") &#123; if(document.compatMode == "CSS1Compat") &#123; pageWidth = document.documentElement.clientWidth; pageHeight = document.documentElement.clientHeight; &#125; else &#123; pageWidth = document.body.clientWidth; pageHeight = document.body.clientHeight; &#125;&#125; 可以使用resizeTo()和resizeBy()方法来调整浏览器窗口大小。 12345// 调整到100*100window.resizeTo(100,100); // 调整到200*150window.resizeBy(100,50); 同样的，部分浏览器可能禁用这两个方法 导航和打开窗口使用window.open()方法既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口。这个方法接收4个参数：要加载的URL，窗口目标，一个特性字符串以及一个表示新页面是否取代浏览器历史纪录中当前加载页面的布尔值。如果传递第二个参数，而且该参数是已有窗口或框架的名称，那么就会在具有该名称的窗口或框架中加载第一个参数指定的URL。看下面例子 12// 等同于&lt;a href="http://www.wrox.com" target="topFrame"&gt;&lt;/a&gt;window.open("http://www.wrox.com", "topFrame"); 如果有topFrame的窗口，就会在该窗口加载URL，否则创建一个新窗口并命名为topFrame,第二个参数也可以是下列特殊名称:_self,_parent,_top或_blank。 弹出窗口若第二个参数并不是一个已经存在的窗口或框架，那么该方法就会根据在第三个参数位置上传入的参数创建一个新窗口或新标签页。第三个参数是一个逗号分隔的设置字符串，表示在新窗口中都显示哪些特性。 设置 值 说明 height num 窗口高度，不能小于100 left num 窗口左坐标，不能小于0 location yes or no 显示地址栏，不同浏览器默认值不同 menubar yes or no 默认no，显示菜单栏 resizable yes or no 是否可以通过拖动浏览器窗口边框改变其大小 scrollbars yes or no 内容在视口显示不下，是否运训滚动，默认no status yes or no 状态栏，默认no toolbar yes or no 工具栏，默认no top num 上坐标 width num 新窗口宽度 window.open(&quot;http://www.wrox.com/&quot;,&quot;wroxWindow&quot;,&quot;height=400,width=400,top=10,resizable=yes&quot;); 通过window.open()新创建的窗口可以使用resizeTo或moveTo等方法，并且其有一个属性opener保存着打开它的原始窗口对象chrome会在独立进程中运行每个标签页，当一个标签页打开另一个标签页时，如果两个window对象之间需要彼此通信，那么新标签页就不能运行在独立的进程中。在chrome中，把新创建的标签页的opener属性设置为null，即表示在单独的进程中运行新标签页，即告诉浏览器新创建的标签页不需要与打开它的标签页通信，因此可以在独立进程中运行。 弹出窗口屏蔽程序大多数浏览器都内置弹出窗口屏蔽程序，如下所示可以检测是否被屏蔽 1234567891011121314var blocked = false;try &#123; var wroxWin = window.open("http://www.wrox.com", "_blank"); if(wroxWin == null) &#123; blocked = true; &#125;&#125; catch (ex）&#123; blocked = true;&#125;if (blocked) &#123; alert("The popup was blocked!");&#125; 间歇调用和超时调用JS是单线程语言，但它允许通过设置超时值和间歇时间来调度代码在特定时刻执行。 超时调用超时调用需要使用window对象的setTimeout()方法，它接收两个参数，要运行的代码和毫秒表示的时间（执行代码之前需要等待的毫秒数），第一个参数可以是包含JS代码的字符串，也可以是一个函数（更推荐用函数） 123setTimeout(function() &#123; alert("Hello World!");&#125;, 1000); 注意上述代码经过1000ms不一定会执行，因为JS是一个单线程的解释器。调用setTimeout后，该方法会返回一个数值ID，表示超时调用。可以通过这个ID取消超时调用，如下 12345var itmeoutId = setTimeout(function() &#123; alert("Hello World!");&#125;, 1000);clearTimeout(timeoutId); 间歇调用按照指定的时间间隔重复执行代码，调用的方法是setInterval()，调用方法与上面setTimeout差不多，只不过第二个参数为每次执行之前要等待的毫秒数，同样可以通过clearInterval()方法传入间歇调用ID取消间歇调用尽量不要使用间歇调用，因为后一个间歇调用可能在前一个间歇调用停止之前启动下面是一个用超时调用实现间歇调用的例子，不会出现上述问题 123456789101112var num = 0;var max = 10;function incrementNumber() &#123; if (num &lt; max) &#123; setTimeout(incrementNumber, 500); &#125; else &#123; alert("Done"); &#125;&#125;setTimeout(incrementNumber, 500); 系统对话框浏览器通过alert(),confirm()和prompt()方法可以调用系统对话框，注意系统对话框都是同步和拟态的，即显示这些对话框的时候代码回停止执行，直到关掉对话框 alert()alert()显示的对话框包括文本和一个OK按钮 confirm()confirm()除了文本和OK按钮，还有一个取消按钮，可以通过检查confirm()方法返回的布尔值来确定用户点了哪个按钮 prompt()prompt()方法除了显示OK和Cancel按钮，还会显示一个文本输入框，接收两个参数，要显示给用户的文本提示和和文本输入域的默认值（可以为空字符串）。如果点击OK，该方法返回输入域的值，点击Cancel或其他，该方法返回null location对象location提供了与当前窗口加载的文档有关的信息，它既是window对象的属性，也是document对象的属性，location对象有如下属性 属性名 例子 说明 hash “#contents” 返回URL中的hash（#号后跟0个或多个字符） host “www.wrox.com:80&quot; 返回服务器名称和端口号 hostname “www.wrox.com&quot; 返回不带端口号的服务器名称 href “http:/www.wrox.com&quot; 完整URL，与location.toString()方法返回值一样 pathname “/WileyCDA/“ URL中目录和文件名 port “8080” 端口号 protocol “http:” 页面协议 search “?q=javascript” URL的查询字符串，以问号开头 查询字符串参数一个查询字符串参数的例子，注意字符串参数是被编码过的，需要通过decodeURIComponent解码 1234567891011121314151617181920function getQueryStringArgs() &#123; var qs = (location.search.length &gt; 0 ? location.search.substring(1) : "" ), args = &#123;&#125;, items = qs.length ? qs.split("&amp;") : [], item = null, name = null, value = null, i = 0, length = items.length; for (i = 0; i &lt; len; i++) &#123; item = items[i].split("="); name = decodeURIComponent(item[0]); value = decodeURIComponent(item[1]); if (name.length) &#123; args[name] = value; &#125; &#125; &#125; 位置操作可以通过修改上面的属性（直接赋值）来改变当前加载的页面，也可以通过location.assign(&quot;http://www.wrox.com&quot;)来改变，这样的改变会在浏览器的历史记录中生成一条新纪录，用户通过后退按钮都会导航到前一个页面，如果不想在历史记录中生成新纪录，则可以通过调用location.replace(&quot;http://www.wrox.com/&quot;)reload()方法会重新加载当前页面，如果不传递参数，页面会以最有效的方式重新加载，有可能是从缓存中加载，如果强制从服务器加载，则传入参数true即可 navigator对象navigator对象主要用来检测客户端浏览器，其主要属性和方法可以参考w3c的navigator对象 检测插件对于非IE浏览器，可以使用plugins数组来达到检测插件的目的，该数组每一项都有下列属性 name:插件的名字 description:插件的描述 filename:插件的文件名 length:插件所处理的MIME类型数量 123456789101112function hasPlugin(name) &#123; name = name.toLowerCase(); for (var i = 0; i &lt; navigator.length; i++) &#123; if (navigator.plugins[i].name.toLowerCase().indexOf(name) &gt; -1) &#123; return true; &#125; &#125;&#125;alert(hasPlugin("Flash"));alert(hasPlugin("QucikTime")); history对象history对象保存用户的上网记录，无法得知具体的URL，但是可以通过go()方法来实现用户历史记录的任意跳转，这个方法接收一个参数，表示向后或向前的页面书的一个整数，也可以传入字符串参数，浏览器会跳转到历史纪录中包含该字符串的第一个位置，可能前进也可能后退。 12345history.go(-1); // 后退一页history.go(1); // 前进一页history("wrox.com"); 另外还可以用history.back()和history.forward()方法前进或后退此外还有一个length属性表示历史纪录数量。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>BOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSCript05-函数表达式]]></title>
    <url>%2F2018%2F10%2F26%2FJavaScript05-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[JavaScript函数表达式递归递归更好的建议是使用arguments.callee，这是一个指向正在执行的函数的指针 12345678function factorial(num) &#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num-1); &#125;&#125; 通过arguments.callee代替函数名，可以确保无论怎么样调用函数都不会出问题。 闭包闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包常见方法，就是在一个函数内部创建另一个函数 1234567891011121314function createComparisonFunction(propertyName) &#123; return function(object1, object2) &#123; var value1 = object1[propertyName]; var value2 = object2[propertyName]; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125; &#125;&#125; 注意到在内部函数访问了外部函数中的变量propertyName，即使这个内部函数被返回了，而且在其他地方被调用了，它仍然可以访问变量propertyName。 在另一个函数内部定义的函数会将包含函数的活动对象添加到它的作用域链中，这样，匿名函数就可以访问其包含函数中定义的所有变量。即使包含函数被执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象。换句话说，包含函数返回后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中，直到匿名函数被销毁。 闭包与变量上述作用域链的机制引出了一个副作用，就是闭包只能取得包含函数中任何变量的最后一个值，闭包所保存的是整个变量对象，而不是某个特殊的变量。 12345678910function createFunctions() &#123; var result = new Array(); for(var i = 0; i &lt; 10; i++) &#123; result[i] = function() &#123; return i; &#125;; &#125; return result;&#125; 这里的结果是每个函数都返回10，因为每个匿名函数都引用了外部变量i，而i最后的值为10. 可以作如下调整 123456789101112function createFunctions() &#123; var result = new Array(); for(var i = 0; i &lt; 10; i++) &#123; result[i] = function(num) &#123; return function() &#123; return num; &#125;; &#125;(i); &#125; return result;&#125; 关于this对象闭包中使用this，需要注意匿名函数的执行环境具有全局性，因此其this对象通常指向window。 12345678910111213var name = "Thie Window";var object = &#123; name : "My Object", getNameFunc : function() &#123; return function() &#123; return this.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); // "The Window" 可以作如下修改 1234567891011121314var name = "Thie Window";var object = &#123; name : "My Object", getNameFunc : function() &#123; var that = this; return function() &#123; return that.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); // "My Object" 模仿块级作用域在JavaScript中没有块级作用域的概念。这意味着在块语句中定义的变量，实际上是在包含语句中而非语句中创建的。 123456function outputNumbers(count) &#123; for(var i = 0; i &lt; count; i++) &#123; alert(i); &#125; alert(i);&#125; 在这里，JS仍然可以访问i，而不同于Java，C++。 可以用匿名函数来模仿块级作用域，语法如下(function(){ //code here })();以上代码定义并立即调用了一个匿名函数 私有变量JavaScript中没有私有成员的概念，所有对象属性都是公有的。不过有一个私有变量的概念，任何在函数中定义的变量，都可以认为是私有变量。如果在函数内部创建一个闭包，那么闭包通过自己的作用域链可以访问这些变量，利用这一点就可以创建用于访问私有变量的公有方法，这种方法成为特权方法。 123456789101112131415function Person(name) &#123; this.getName = function() &#123; return name; &#125;; this.setName = function(value) &#123; name = value; &#125;;&#125;var person = new Person("Nicholas");alert(person.getName());person.setName("Greg");alert(person.getName()); 静态私有变量123456789101112131415161718192021(function() &#123; // 私有变量和私有函数 var name = ""; // 构造函数 Person = function(value) &#123; name = value; &#125; Person.prototype.getName = function() &#123; return name; &#125;; Person.prototype.setName = function(value) &#123; name = value; &#125;;&#125;)();var person1 = new Person("Nicholas");// 测试代码 注意name是静态变量，是所有实例共享的。 模块模式模块模式用于只有一个实例的对象，JS用对象字面量方式创建单例对象，如下 1234567891011121314151617181920var application = function() &#123; //私有 var components = new Array(); //初始化 components.push(new BaseComponent()); //公有 return &#123; getComponentCount : function() &#123; return components.length; &#125;; registerComponent : function(component) &#123; if (typeof component == "object") &#123; components.push(component); &#125; &#125; &#125;&#125; 增强的模块模式增强模块模式适合单例必须是某种类型的实例，同时还必须添加某些属性和方法对其加以增强的情况 12345678910111213141516171819202122var application = function() &#123; //私有 var components = new Array(); //初始化 components.push(new BaseComponent()); //创建application的一个局部副本 var app = new BaseComponent(); //公有 app.getComponentCount : function() &#123; return components.length; &#125;; app.registerComponent : function(component) &#123; if (typeof component == "object") &#123; components.push(component); &#125; &#125;; return app;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>JS函数表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet06-JSTL-强大的定制标记]]></title>
    <url>%2F2018%2F10%2F09%2FServlet06-JSTL%2F</url>
    <content type="text"><![CDATA[Servlet06-JSTL-强大的定制标记有时只是EL或标准动作还不够，需要用到JSTL，使用JSTL之前，要把jstl.jar与standard.jar放在WEB应用的lib目录里 &lt;c:out&gt;显示表达式&lt;c:out&gt;作用与脚本的&lt;%=%&gt;作用相似，但是&lt;c:out&gt;可以直接通过”.”操作符来访问属性。 语法格式如下&lt;c:out value=&quot;&lt;string&gt;&quot; default=&quot;&lt;string&gt;&quot; escapeXml=&quot;&lt;true|false&gt;&quot;/&gt; 属性 描述 value 要输出的内容，必要，可以设置为${class:function}输出函数的结果 default 输出的默认值，非必要 escapeXml 设置是否忽略XML特殊字符，默认为true，设置为false则输出HTML内容 &lt;c:forEach&gt;实现循环可以在JSP中使用&lt;c:forEach&gt;实现循环，例子如下 e.g. 1234567&lt;table&gt; &lt;c:forEach var="movie" items="$&#123;movieList&#125;" &gt; &lt;tr&gt; &lt;td&gt;$&#123;movie&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/table&gt; 对应脚本如下 12345String[] items = (String[]) request.getAttribute("movieList");for (int i = 0; i &lt; items.length; i++) &#123; String movie = items[i]; out.println(movie);&#125; &lt;c:forEach&gt;属性如下 属性 描述 items 要被循环的信息 begin 开始的元素，0为索引起点 end 最后一个元素 step 迭代的步长 var 代表当前条目的变量名称 varStatus 代表循环状态的变量名称 varStatus建立一个新变量，保存javax.servlet.jsp.jstl.core.LoopTagStatus的一个实例，可以通过在&lt;c:forEach ... varStatus=&quot;movieLoopCount&quot;&gt;内嵌中添加${movieLoopCount.count}得到一个循环计数器，每迭代一次就自增1并输出 嵌套&lt;c:forEach&gt;12345&lt;c:forEach var="listElement" ...&gt; &lt;c:forEach ... items="$&#123;listElement&#125;"&gt; ... &lt;/c:forEach&gt;&lt;/c:forEach&gt; &lt;c:if&gt;实现判断语法格式 123&lt;c:if test="&lt;boolean&gt;" var="&lt;string&gt;" scope="&lt;string&gt;"&gt; ...&lt;/c:if&gt; 属性 描述 test 条件，必要 var 用于存储条件结果的变量，不必要 scope var属性的作用域 e.g. 123&lt;c:if test="$&#123;userType eq 'member'&#125;" &gt; &lt;jsp:include page="xxx.jsp" /&gt;&lt;/c:if&gt; &lt;c:choose&gt;实现if-else效果&lt;c:choose&gt;是&lt;c:when&gt;与&lt;c:otherwise&gt;的父标签，通过这三个标签可以实现if-else或者switch效果 语法格式 12345678910111213&lt;c:choose&gt; &lt;c:when test="&lt;boolean&gt;"&gt; ... &lt;/c:when&gt; &lt;c:when test="&lt;boolean&gt;"&gt; ... &lt;/c:when&gt; ... ... &lt;c:otherwise&gt; ... &lt;/c:otherwise&gt;&lt;/c:choose&gt; &lt;c:set&gt;设置变量和对象属性语法格式 123456&lt;c:set var="&lt;string&gt;" value="&lt;string&gt;" target="&lt;string&gt;" property="&lt;string&gt;" scope="&lt;string&gt;"/&gt; 属性 描述 value 要存储的值 target 要修改的属性所属的对象 property 要修改的属性 var 存储信息的变量 scope var属性的作用域 使用&lt;c:set&gt;设置属性变量var1.没有体&lt;c:set var=&quot;userLevel&quot; scope=&quot;session&quot; value=&quot;Cowboy&quot; /&gt; 2.有体&lt;c:set var=&quot;userLevel&quot; scope=&quot;session&quot; &gt;Sheriff, Bartender, Cowgirl&lt;/c:set&gt; 有体的情况下，会计算体并作为变量的值，如果值计算为null，变量会被删除 对bean和Map使用&lt;c:set&gt;这一类&lt;c:set&gt;只能用来设置bean属性和Map值，不能用它来向列表或数组增加元素 1.没有体&lt;c:set target=&quot;${PetMap}&quot; property=&quot;dogName&quot; value=&quot;Clover&quot;&gt; 如果target是一个bean，则property为属性，如果target是一个Map，则property为键。 2.有体&lt;c:set target=&quot;${person}&quot; property=&quot;name&quot; &gt;${foo.name}&lt;/c:set&gt; 体可以是一个String或表达式 &lt;c:set&gt;要点和技巧 &lt;c:set&gt;不能同时有var和target属性 scope是可选的，默认为page作用域 如果value为null，var指定的属性将被删除 target必须放入一个能解析为实际对象的表达式，不能为String &lt;c:remove&gt;删除元素语法格式&lt;c:remove var=&quot;&lt;string&gt;&quot; scope=&quot;&lt;string&gt;&quot; var为要删除的变量名，scope为变量的作用域var属性必须是一个String直接量，不能是表达式 1&lt;c:remove var="userState" scoper="request" /&gt; &lt;c:import&gt;包含内容语法格式 1234567&lt;c:import url="&lt;string&gt;" var="&lt;string&gt;" scope="&lt;string&gt;" varReader="&lt;string&gt;" context="&lt;string&gt;" charEncoding="&lt;string&gt;"/&gt; 属性 描述 url 待导入资源的URL，可以是相对路径或绝对路径 context 当使用相对路径访问外部context时，context指定了这个资源的名字 charEncoding 所引入的数据的字符编码集 var 用于存储所引入的文本的变量 scope var属性的作用域 varReader 可选的用于提供java.io.Reader对象的变量 三种包含内容方法的区别1.include指令&nbsp;&nbsp;&nbsp;&nbsp;&lt;%@ include file=&quot;Header.html&quot; %&gt;&nbsp;&nbsp;&nbsp;&nbsp;静态导入，在转换时将file指定的文件内容加入到当前页面 2.&lt;jsp:include&gt;标准动作&nbsp;&nbsp;&nbsp;&nbsp;动态，在请求时将page属性指定的内容添加到当前页面 3.&lt;c:import&gt;JSTL标记&nbsp;&nbsp;&nbsp;&nbsp;动态，与标准动作相似但更强大更灵活。 引用WEB应用之外的内容&lt;c:import&gt;可以加载WEB应用之外的内容，只需指定url即可，如下 123456&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;&lt;html&gt;&lt;body&gt; &lt;c:import url="http://www.wickedlysmart.com/skyler/horse.html" /&gt;&lt;/body&gt;&lt;/html&gt; 注意！导入的horse.html应该是一个HTML片段，而不是一个有开始和结束标记的完整页面！ &lt;c:param&gt;定制包含的内容语法格式 &lt;c:param name=&quot;&lt;string&gt;&quot; value=&quot;&lt;string&gt;&quot;/&gt; name：URL中要设置的参数的名称 value：参数的值 使用&lt;c:param&gt;实现子标题上一节中我们使用&lt;jsp:param&gt;实现了页眉的子标题，&lt;c:param&gt;也能实现同样的效果 使用&lt;jsp:import&gt;的JSP 1234567&lt;html&gt;&lt;body&gt; &lt;c:import url="Header.jsp" &gt; &lt;c:param name="subTitle" value="this is a subtitle name"/&gt; &lt;/c:import&gt;&lt;/body&gt;&lt;/html&gt; 所包含的文件Header.jsp 12&lt;!-- some html --&gt;&lt;p&gt;$&#123;param.subTitle&#125;&lt;/p&gt; &lt;c:url&gt;满足所有超链接需求语法格式 12345&lt;c:url var="&lt;string&gt;" scope="&lt;string&gt;" value="&lt;string&gt;" context="&lt;string&gt;"/&gt; value是基本url，context是本地网络应用名，var是代表URL的变量名，scope是var的作用域。 对URL编码，可以把用户的jsessionid追加到特定的 URL最后，具体编码方法如下 在servlet中 123public void doGet(...) &#123; out.println(response.encodeURL("/BeerTest.do"));&#125; 在JSP中 1&lt;a href="&lt;c:url value='/xxx.jsp' /&gt;"&gt;click here&lt;/a&gt; GET请求需要在URL中传入参数，而参数有时有空格的时候需要对URL编码 e.g. 1234&lt;c:set var="last" value="Hidden Cursor" /&gt;&lt;c:set var="first" value="Crouching Pixels" /&gt;&lt;c:url value="/inputComments.jsp?first=$&#123;first&#125;&amp;last=$&#123;last&#125;" var="inputURL" /&gt; 在&lt;c:url&gt;中使用&lt;c:param&gt;可以解决编码的问题 1234567&lt;c:set var="last" value="Hidden Cursor" /&gt;&lt;c:set var="first" value="Crouching Pixels" /&gt;&lt;c:url value="/inputComments.jsp" var="inputURL" &gt; &lt;c:param name="firstName" value="$&#123;first&#125;" /&gt; &lt;c:param name="lastName" value="$&#123;last&#125;" /&gt;&lt;/c:url&gt; 使用参数编码后，URL如下所示/inputComments.jsp?firstName=Crouching+Pixels&amp;lastName=Hidden+Cursor 建立自己的错误页面指定错误页面errorPage.jsp 1234567&lt;%@ page isErrorPage="true" %&gt;&lt;html&gt;&lt;body&gt; ...&lt;/body&gt;&lt;/html&gt; 抛出异常坏页面的普通页面 1&lt;%@ page errorPage="errorPage.jsp" %&gt; 使用&lt;error-page&gt;DD标记可以在DD中为整个WEB应用声明错误页面，甚至可以为不同异常或HTTP错误码类型（404,500等）配置不同的错误页面。如下： 声明一个普遍型错误页面，在DD中 1234&lt;error-page&gt; &lt;exception-type&gt;java.lang.Throwable&lt;/exception-type&gt; &lt;location&gt;/errorPage.jsp&lt;/location&gt;&lt;/error-page&gt; 为更明确的异常声明一个错误页面 1234&lt;error-page&gt; &lt;exception-type&gt;java.lang.ArithmeticExcption&lt;/exception-type&gt; &lt;location&gt;/arithmeticError.jsp&lt;/location&gt;&lt;/error-page&gt; 根据一个HTTP状态码声明错误页面 1234&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/notFoundError.jsp&lt;/location&gt;&lt;/error-page&gt; exception对象错误页面提供一个exception对象，可以使用隐式对象exception也可以使用${pageContext.exception}得到，这个对象的类型是java.lang.Throwable注意，该隐式对象仅对有声明isErrorPage=&quot;true&quot;的页面可用 &lt;c:catch&gt;实现try/catch&lt;c:catch&gt;&lt;/c:catch&gt;体内元素相当于JAVA的try/catch，可以使用属性var保存该异常放在页面作用域，并按var值命名 1234567&lt;c:catch var="myException"&gt; &lt;% int x = 10/0; %&gt;&lt;/c:catch&gt;&lt;c:if test="$&#123;myException != null&#125;"&gt; exception is $&#123;myException.message&#125;&lt;/c:if&gt; 理解TLDTLD配置文件TLD描述了两个主要内容：定制标记和EL函数，上一章曾经用过只有一个&lt;function&gt;元素的TLD，这节还要用到&lt;tag&gt;元素，如下 123456789101112131415161718&lt;tlib-version&gt;1.2&lt;/tlib-version&gt;&lt;short-name&gt;RandomTags&lt;/short-name&gt;&lt;uri&gt;randomThings&lt;/uri&gt;&lt;tag&gt; &lt;description&gt;random advice&lt;/description&gt; &lt;name&gt;advice&lt;/name&gt; &lt;tag-class&gt;foo.AdvisorTagHandler&lt;/tag-class&gt; &lt;body-content&gt;empty&lt;/body-content&gt; &lt;attribute&gt; &lt;name&gt;user&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt; &lt;/attribute&gt;&lt;/tag&gt; 解释TLDTLD解释如下:&lt;tlib-version&gt;必要，声明标记库版本&lt;short-name&gt;必要，主要由工具使用&lt;uri&gt;taglib指令使用的唯一名&lt;description&gt;不解释&lt;name&gt;必要，标记中使用的就是这个名（冒号右边）&lt;tag-class&gt;必要，在JSP使用这个标记要调用什么&lt;body-content&gt;必要，说明体内不可以有任何内容&lt;attribute&gt;用来设置属性，rtexprvalue指定该属性是否可以是一个表达式，如果设置为false或者没有设置，则不能使用类似&quot;${userName}&quot;这样的表达式 如何使用定制标记使用这个标记的JSP如下 123&lt;%@ taglib prefix="mine" uri="randomThings" %&gt;&lt;mine:advice user="$&#123;userName&#125;" /&gt;&gt; 定制标记处理器1234567891011public class AdvisorTagHandler extends SimpleTagSupport &#123; public void doTag() throws JspException, IOException &#123; ... &#125; // 这里的XXX对应的是标记的属性 public void setXXX(String xxx) &#123; ...; &#125;&#125; 容器对TLD的查找容器会在4个地方查找TLD WEB-INF WEB-INF的子目录 WEB-INF/lib下一个JAR文件的META-INF WEB-INF/lib下一个JAR文件的META-INF目录的子目录]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>JSP</tag>
        <tag>JSTL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript03-引用类型]]></title>
    <url>%2F2018%2F09%2F03%2FJavaScript03-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[JavaScript03-引用类型Object类型引用类型的值是引用类型的一个实例，注意引用类型虽然常被称为类，但它与传统面向对象语言的类不一样，ECMAScript没有类和接口等基本结构，ECMAScript的引用类型有时候也称为对象定义，因为它们描述的是一类对象所具有的属性和方法。 两种构造Object实例的方法构造函数123var person = new Object();person.name = "Nicholas";person.age = 29; 对面字面量表示法1234var person = &#123; name : "Nicholas", age : 29&#125;; 访问对象属性1234alert(person.name); // "Nicholas"alert(person["name"]); // "Nicholas"var propertyName = "name";alert(person[propertyName]); // "Nicholas" Array类型与其他语言不一样的是，ECMAScript数组的每一项可以保存任何类型的数据，而且ECMAScript的大小是可以动态调整的。 创建Array的基本方式Array构造函数1234var colors1 = new Array();var colors2 = new Array(20); // 指定Array的长度为20，注意，这里并不是让colors2的第一个元素是20，而是指定其长度20var colors3 = new Array("red", "blue", "green"); 字面量表示法12var colors = ["red", "blue", "green"];var names = []; Arrays.length由于ECMAScript的数组是可以动态调整的，因此其属性length不是只读的，可以为其赋值达到调整数组长度的效果，也可以12var colors = [ some colors ];colors[colors.length] = "other-color"; 为Array添加新元素 一些Array的属性检测数组Array.isArray(value)判断Array是否为数组 转换方法toLocaleString() 返回逗号分割开的字符串，但是调用的是toLocaleString()方法toString() 返回用逗号分割开的数组的每个元素valueOf() 返回数组本身join(param) 用param分割开数组的每个元素 栈方法push(param1,param2,...,paramn)可以接收任意数量参数，按顺序逐个入栈，并返回修改后数组的长度pop()出栈并返回 队列方法shift()删除第一个元素并返回push()同上栈方法的push()unshift(param)数组前端添加任意个项并返回数组的长度 重排序方法reverse()sort()默认的sort()会调用toString()然后比较其字符串的大小来排序，在很多情况下这样排序都不是最佳方案，如下123var values = [0, 1, 5, 10, 15];values.sort();alert(values); // 0,1,10,15,5 可以通过重排序方法接收一个比较函数作为参数来排序比较函数接收两个参数，如果第一个参数应位于第二个参数之前则返回一个负数，相等返回0,否则返回正数，以下为一个简单的比较函数123456789101112function compare(value1, value2) &#123; if(value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125;&#125;var values = [0, 1, 5, 10, 15];values.sort(compare);alert(values); // 0,1,5,10,15 对于数值类型或者valueOf()方法会返回数值的类型，只要123function compare(value1, value2) &#123; return value2-value1;&#125; 操作方法cancat()会创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组，如果没有参数，则只是复制当前数组并返回副本slice()切片，接收1个或2个参数，即要返回项的起始和结束位置。 splice()： 删除：接收2个参数，删除的第一项的位置和要删除的项数 插入：三个参数，起始位置，0（要删除的项数），要插入的项，如果要插入多项，可以传递3个以上的参数 替换：三个参数，起始位置，要删除的项，要插入的任意数量的项 它始终返回一个数组，包含从原始数组中删除的项。 位置方法indexOf()lastIndexOf()接收2个参数，要查找的项和表示查找起点位置的索引，indexOf()从起点开始往后查找，lastIndexOf()从起点开始往前查找，返回要查找的项在数组中的位置，没找到则返回-1注意位置方法必须严格相等12345var person = &#123; name : "Nicholas" &#125;;var errPeople = [&#123; name : "Nicholas" &#125;];var corPeoole = [person];alert(errPeople.indexOf(person)); // -1alert(corPeople.indexOf(person)); // 0 迭代方法ECMAScript的迭代方法接收2个参数，要在每一项上运行的函数和（可选）运行该函数的作用域对象，传入的函数接收三个参数，数组项的值，该项在数组的位置和数组对象本身。every()对数组的每一项运行给定函数，如果该函数对每一项都返回true，则返回truefilter()对数组的每一项运行给定函数，返回该函数会返回true的项组成的数组forEach()对数组每一项运行给定函数，这个方法没有返回值map()对数组每一项运行给定函数，返回每次函数调用的结果组成的数组some()对数组每一项运行给定函数，如果该函数对任一项返回true，则返回true123456789var numbers = [1,2,3,4,5,4,3,2,1];var everyResult = numbers.every(function(item,index,array)&#123;return (item&gt;2)&#125;);alert(everyResule); // falsevar mapResult = numbers.map(function(item, index, array)&#123;return item * 2;&#125;);alert(mapResult); // [2,4,6,8,10,8,6,4,2]numbers.forEach(function(item, index, array)&#123; /* do something on item */ &#125;); 归并方法reduce()reduceRight()迭代数组的所有项，然后构建一个最终返回的值，reduce()从第一项开始迭代，reduceRight()从最后一项开始，接收两个参数，一个在每一项上调用的函数和（可选）作为归并基础的初始值，传入的函数接收4个参数，前一个值，当前值，项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项1234// e.g. 求和var values = [1,2,3,4,5];var sum = values.reduce(function(prev, cur, index, array)&#123;return prev + cur;&#125;);alert(sum); // 15 Date类型ECMAScript的Date类型类似于java.util.Date类，使用自UTC 1970年1月1日午夜开始经过的毫秒数来保存日期创建一个日期对象可以var now = new Date()可以为构造函数传递毫秒来构建Date对象 Date.parse()接收一个表示日期的字符串参数，转换为毫秒数地区为美国的浏览器接收下列日期格式： “月/日/年”，如6/13/2004; “英文月名 日,年”，如January 12,2004 “英文星期几 英文月名 日 年 时:分:秒 时区”，如 Tue May 25 2004 00:00:00 GMT-0700 ISO 8601扩展格式 YYYY-MM-DDTHH:mm:ss.sssz(如2004-05-25T00:00:00) e.g. 构建2004/5/24的日期对象 var someDate = new Date(Date.parse(&quot;May 25, 2004&quot;));实际上var someDate = new Date(&quot;May 25, 2004&quot;);会自动调用parse Date.UTC()Date.UTC()参数为年份，基于0的月份，月中的日，小时，分钟，秒以及毫秒，年和月是必须的，其他可选，返回对应的毫秒数 e.g. var y2k = new Date(2000, 0);构建2000年1月1日0时的时间 Date.now()返回调用这个函数的时间的毫秒数 继承的方法toLocaleString()可能时间格式会有AM或PMtoString()带有时区信息的日期和时间valueOf()返回毫秒 日期格式化方法 toDateString()——以特定于实现的格式显示星期几，月，日，年 toTimeString()——以特定于实现的格式显示时，分，秒和时区 toLocaleDateString()——以特定于地区的格式显示 toLocaleTimeString()——同上 toUTCString()——以特定于实现的格式完整的UTC日期 其他日期/时间组件方法w3school列出的Date对象方法 RegExp类型ECMAScript通过RegExp类型来支持正则表达式,由于之前学Python的时候有认真的学过正则，但是一段时间没用就忘得差不多了，所以在没有用到的时候就先不学了，摆个链接在需要的时候再去看w3school RegExp对象 Function类型函数是对象，因此函数名实际上是一个指向函数对象的指针，不会与某个函数绑定由于函数名是指针,所以ECMAScript也没有函数重载的概念 函数声明与函数表达式看下面例子1234alert(sum(10, 10));function sum(num1, num2) &#123; return num1 + num2;&#125; 以上代码完全可以执行,因为在代码开始执行之前,解析器会通过一个名为函数声明提升的过程,读取并将函数声明添加到执行环境中,对代码求值时,JavaScript引擎在第一遍会声明函数并将它们放到源代码树的顶部,所以即使先调用函数再定义也不会出错,而像下面的例子就会报错1234alert(sum(10, 10));var sum = function(num1, num2) &#123; return num1 + num2;&#125; 原因在于函数位于一个初始化语句中,而不是一个函数声明 同样的,由于函数为对象,它可以作为另一个函数的参数或返回值. 函数内部属性arguments及其属性callee函数内部有两个特殊的对象:arguments和this,arguments保存传入函数中的所有参数,arguments还有一个属性名为callee,该属性是一个指针,指向拥有这个arguments对象的函数请看下面例子1234567function factorial(num) &#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * factorial(num-1); &#125;&#125; 上面例子中,如果函数名字不会发生改变,那么这样定义是没有问题的,但如果函数名字改变了,则会发生错误,可以用下面的例子来解决1234567function factorial(num) &#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num-1); &#125;&#125; thisthis与Java的this类似,引用的是函数执行的环境对象(当在网页的全局作用域中调用函数时,this对象引用的就是window)1234567891011window.color = "red";var o = &#123; color: "blue" &#125;;function sayColor() &#123; alert(this.color);&#125;sayColor(); // "red" 引用this对象为windowo.sayColor = sayColor;o.sayColor(); // "blue" caller这个属性保存调用当前函数的函数的引用,若在全局作用域中调用当前函数,则它的值为null123456789function outer() &#123; inner();&#125;function inner() &#123; alert(inner.caller); // 返回outer的源码&#125;outer(); 函数属性和方法lengthlength属性表示函数希望接收的命名参数的个数 prototype保存实例方法,不可枚举 call()与apply()在特定的作用域中调用函数,call()接收第一个参数为运行函数的作用域,后面多个参数为函数的参数,allpy()接收2个参数,第一个为运行函数的作用域,第二个为参数数组或arguments,它们可以用于扩充函数的作用域123456789101112window.color = "red";var o = &#123; color: "blue" &#125;;function sayColor() &#123; alert(this.color);&#125;sayColor(); //redsayColor.call(this); //redsayColor.call(window); //redsayColor.call(o); //blue bind()创建一个函数的实例,并将该实例的this绑定在bind()的参数上123456789window.color = "red";var o = &#123; color: "blue" &#125;;function sayColor() &#123; alert(this.color);&#125;var objectSayColor = sayColor.bind(o);objectSayColor(); //blue 基本包装类型–特殊的引用类型引用类型与基本包装类型最大的区别是对象的生命周期,使用new创建的引用类型的实例,在执行流离开当前作用域之前都一直保存在内存中,而自动创建的基本包装类型的对象,则只存在于一行代码的执行瞬间,然后就会销毁. Boolean建议不适用Boolean对象,而是使用布尔值 Number重写了valueOf(),toLocaleString()和toString(),toString()可以传入参数显示返回几进制数值,除了继承的方法,Number类型还提供了一些用于将数值格式化为字符串的方法num.toFixed(2) // 仅显示小数点后两位,四舍五入num.toExponential(1) // 小数位数为1的指数表示法(e表示法)num.toPrecision() // 返回自适应格式,参数为小数位显示 String字符方法stringValue.charAt(num);stringValue[num];stringValue.charCodeAt(num); // 返回num所在的字符的字符编码 字符串操作方法stringValue.concat(otherString);stringValue.substring();stringValue.slice();stringValue.substr(); // 第一个参数开始位置，第二个为字符串长传入负数后它们的行为不一样，不详述 字符串位置方法stringValue.indexOf()stringValue.lastIndexOf()stringValue.trim() // 删除前置后缀所有空格并返回 字符串大小写转换方法stringValue.toLocaleUpperCase(); // 和下面那个一样，不过一般用这个比较多stringValue.toUpperCase();stringValue.toLocaleLowerCase();stringValue.toLowerCase(); 字符串模式匹配方法stringValue.match()stringValue.search()涉及到正则，偷懒就不写了 localeCompare()比较两个字符串，根据结果返回-1,0,1 单体内置对象由ECMAScript实现提供的，不依赖于寄主环境的对象，在ECMAScript程序执行之前就已经存在了 Global对象偷懒，很多前面都有写，不重复了，书本P131 window对象同上 Math对象提供了数学公式和信息 Math.E 自然对数 Math.LN10 10为底的自然对数 Math.PI π Math.LOG10E 10为底e的对数 Math.SQRT2 2的平方根 等等其他值 舍入方法 Math.ceil() 向上舍入 Math.floor() 向下舍入 Math.round() 四舍五入 random()返回0-1的随机数 其他方法 Math.abs() Math.exp() Math.log() 等等]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>JS引用类型</tag>
        <tag>JS包装类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript02-变量，作用域和内存问题]]></title>
    <url>%2F2018%2F09%2F02%2FJavaScript02-%E5%8F%98%E9%87%8F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[JavaScript02-变量，作用域和内存问题变量JavaScript变量只是在特定时间用于保存特定值的一个名字，不存在定义某个变量就必须保存何种数据类型值的规则，变量的值及其数据类型可以在脚本的生命周期内改变。 基本类型和引用类型的值ECMAScript规定基本类型值指的是简单的数据段，而引用数据值指那些可能由多个值构成的对象，在JavaScript中，Undefined,Null,Boolean,Number,String都是基本数据类型，都是按值访问的。而引用类型的值是保存在内存中的对象，只有Object类型是引用数据类型。 动态的属性123var person = new Object();person.name = "PersonName";alert(person.name); // "PersonName" 以上代码我们创建了一个对象并将其值保存在person中，然后为该对象添加了一个名为name的属性，而对基本数据类型，虽然为其添加属性不会报错，但访问该属性的时候并不能成功访问。 复制变量值对于基本数据类型，12var num1 = 5;var num2 = num1; 两个变量之间不会相互影响。 而对于引用数据类型1234var obj1 = new Object();var obj2 = obj1;obj1.name = "objName";alert(obj2.name); // "objName" obj1和obj2引用的都是同一个对象 传递参数基本类型值的传递就如同基本类型变量的复制一样，而引用类型值的传递，也如同引用类型变量的复制一样。 执行环境及作用域执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为，每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中，解析器在处理数据时会在后台使用它。全局执行环境是最外围的一个执行环境。根据ECMAScript实现所在宿主环境不同，表示环境的对象也不同，在WEB浏览器中，全局执行环境被认为是window对象。每个函数都有自己的执行环境，当执行流进入一个函数的时候，函数的环境会进入环境栈，函数执行完毕后栈将其环境弹出，把控制权交还给之前的执行环境。当代码在一个环境中执行，会创建变量对象的一个作用域链。作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前段始终是当前执行代码所在环境的变量对象，如果这个环境是函数，则将其活动对象作为变量对象，该活动最开始时只有一个变量arguments对象。作用域链的下一对象来自包含的环境，再下一个变量对象来自下一个包含环境，一直到全局执行环境。标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，逐级往后回溯，直至找到标识符为止。其实跟Java的作用域在表现上差不多。 延长作用域链以下两个语句都会在作用域链的前端添加一个变量对象。 try-catch语句的catch块 with语句 没有块级作用域123456789if (true) &#123; var color = "blue";&#125;alert(color); // "blue"for (var i = 0; i &lt; 10; i++) &#123; doSomeThing(i);&#125;alert(i); // 10 在JavaScript中，if和for中创建的变量依旧存在于外部的执行环境中。 垃圾收集JavaScript具有自动垃圾收集机制，执行环境会负责管理代码执行过程中使用的内存。 标记清除垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而再次之后再被加上标记的变量将被视为准备删除的变量。 引用计数跟踪记录每个值被引用的次数，当引用次数变为0的时候，就回收其占用的内存空间，循环引用问题无法解决，很少使用。 管理内存对于全局变量，当确定不再使用的时候，可以为其赋值null，让值脱离执行环境，以便垃圾收集器下次运行时将其回收。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>JS作用域链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet之WEB应用体系与MVC]]></title>
    <url>%2F2018%2F09%2F01%2FServlet01-WEB%E5%BA%94%E7%94%A8%E4%BD%93%E7%B3%BB%E4%B8%8E%E5%88%9D%E7%AA%A5MVC%2F</url>
    <content type="text"><![CDATA[#Servlet之WEB应用体系与MVC ##WEB应用体系 ###TOMCAT容器的作用 通信支持容器可以让servlet与WEB容器对话，创建ServerSocket，监听端口，创建流等生命周期管理容器控制着servlet的生命周期，负责加载类，实例化，初始化servlet，调用servlet方法，垃圾回收等多线程支持每次接收到用户servlet请求，就会创建一个新的Java线程，声明方式实现安全使用XML部署描述文件配置安全性JSP支持容器负责把JSP翻译成Java ###容器处理请求 用户点击一个链接，指向一个servlet 容器看出来这个请求要的是一个servlet，创建两个对象，分别为HttpServletResponse，HttpServletRequest 容器根据请求的URL找到对应的servlet，为这个请求分配一个线程，并把请求和响应对象传递给这个servlet线程 容器调用service的service()方法，根据请求的不同类型，service()方法会调用doGet()或doPost()方法 doGet()方法生成动态页面，塞到响应对象里 线程结束，容器把响应对象转换为一个HTTP响应，把它发回给客户，然后删除请求和响应对象 ###servlet的映射方式通过配置部署描述文件web.xml可以配置servlet名对应的URL路径一般的web.xml内容如下1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"&gt; &lt;servlet&gt; &lt;servlet-name&gt;yourDefinedName&lt;/servlet-name&gt; &lt;servlet-class&gt;yourServletClassName&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;yourDefinedName&lt;/servlet-name&gt; &lt;url-pattern&gt;/yourUrl&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; &lt;servlet&gt;元素告诉容器有哪个类文件&lt;servlet-name&gt;元素用于把一个&lt;servlet&gt;元素与一个特定的&lt;servlet-mapping&gt;元素绑定，最终用户看不到这个名字，这个名字只在这个部署文件的其他部分使用&lt;servlet-class&gt;类的完全限定名，但不要加上.class后缀&lt;servlet-mapping&gt;请求到来时，容器会在运行时使用这个元素，来调用对应的servlet&lt;url-pattern&gt;URL的路径 客户知道的URL名对应的是&lt;url-pattern&gt;的值，部署人员知道的秘密的内部名对应的是&lt;servlet-name&gt;的值，实际的文件名对应的是&lt;servlet-class&gt;的值 ##初窥MVCMVC分别为model，view，controller，MVC的关键是业务逻辑与表示分离，实际上，业务逻辑甚至根本不知道有表示存在 ###Model实际的业务逻辑和状态放在模型中，系统中只有这部分与数据库通信 ###Controller从请求获得用户输入，并明确输入对模型的影响，告诉模型自行更新，并让视图得到新的模型状态，一个servlet实际上就是一个控制器 ###View负责表示，它从控制器得到模型的状态，还要获得用户输入，交给控制器，一个JSP文件其实就是一个View ##一个简单的MVC应用目录树如下其中，com.example.web.BeerSelect为控制器，com.example.model.BeerExpert为模型，result.jsp为view web.xml内容如下1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"&gt; &lt;servlet&gt; &lt;servlet-name&gt;Ch3 Beer&lt;/servlet-name&gt; &lt;servlet-class&gt;com.example.web.BeerSelect&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;Ch3 Beer&lt;/servlet-name&gt; &lt;url-pattern&gt;/SelectBeer.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; form.html如下123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;form test&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="css/form.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 align="center"&gt;Beer Selection Page&lt;/h1&gt; &lt;div id="formT"&gt; &lt;form method="POST" action="SelectBeer.do"&gt; &lt;p&gt;Color: &lt;select name="color"&gt; &lt;option name="light"&gt;light&lt;/option&gt; &lt;option name="dark"&gt;dark&lt;/option&gt; &lt;/select&gt; &lt;p&gt; &lt;input type="submit"&gt; &lt;/p&gt; &lt;/p&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; result.jsp123456789101112131415161718192021&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;%@ page import="java.util.*" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 align="center"&gt;Bear Recommendations JSP&lt;/h1&gt; &lt;p&gt; &lt;% List styles = (List)request.getAttribute("styles"); Iterator it = styles.iterator(); while (it.hasNext()) &#123; out.print("try: " + it.next()); &#125; %&gt; &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 模型BeerExpert.java如下12345678910111213141516171819package com.example.model;import java.util.ArrayList;import java.util.List;public class BeerExpert &#123; public List getBrands(String color) &#123; List brands = new ArrayList(); if (color.equals("light")) &#123; brands.add("light a"); brands.add("light b"); &#125; else &#123; brands.add("dark1"); brands.add("dark2"); &#125; return brands; &#125;&#125; 控制器BeelSelect如下1234567891011121314151617181920212223242526272829package com.example.web;import com.example.model.BeerExpert;import javax.servlet.RequestDispatcher;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.List;@WebServlet(name = "BeerSelect")public class BeerSelect extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String c = request.getParameter("color"); BeerExpert be = new BeerExpert(); List result = be.getBrands(c); request.setAttribute("styles", result); RequestDispatcher view = request.getRequestDispatcher("result.jsp"); view.forward(request, response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125;&#125; ##作为Servlet在上述代码中，Servlet作为控制器有如下功能 获得html页面中参数color的值 创建一个模型，通过参数获得模型对应的属性 设置请求的属性并设置对应值为从模型得到的结果（键-值对应） 创建一个请求分派器对象，获得result.jsp页面 通过view.forward(request,response)把请求和响应发送给该view，view通过request.getAttribute(“key”)来得到模型发送来的结果 ###Servlet生命周期 WEB容器加载servlet类 实例化servlet（构造函数运行） init() service()调用doGet(),doPost()等等 destroy() ###HttpServletRequest API ###HttpServletResponse API ###输出字符或字节对于输出，可以选择输出字符或者字节输出字符的时候12PrintWriter writer = response.getWriter();writer.println("some text or HTML"); 输出字节的时候12ServletOutputStream out = response.getOutputStream();out.write(aByteArray); ####使用响应完成I/Oe.g.Servlet处理下载JAR文件1234567891011121314151617181920public class CodeReutrn extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123; response.setContentType("application/jar"); // 对于这里的ContentType，还有很多其他的，具体可以自行Google ServletContext ctx = getServletContext(); InputStream is = ctx.getResourceAsStream("/directory/xxx.jar"); int read = 0; byte[] bytes = new byte[1024]; OutputStream os = response.getOutputStream(); while((read = is.read(bytes)) != -1) &#123; os.write(bytes, 0, read); &#125; os.flush(); os.close(); &#125;&#125;]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>MVC</tag>
        <tag>TOMCAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSCript04-面向对象的程序设计]]></title>
    <url>%2F2018%2F09%2F01%2FJavaScript04-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[JavaSCript04-面向对象的程序设计理解对象可以通过以下方式初始化一个对象 123456789var person = &#123; name: "Nicholas", age: 29, job: "Software Engineer", sayName: function() &#123; alert(this.name); &#125;&#125; 属性类型数据属性数据属性包含一个数据值的位置，在这个位置可以读取和写入值，数据属性有4个描述其行为的特性 Configurable: 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性改为访问器属性，默认为true Enumerable: 表示能否通过for-in循环返回属性，默认为true Writable: 表示能否修改属性的值，默认为true Value: 包含这个属性的数据值，默认为undefined 可以通过Object.defineProperty()方法修改默认的特性，接收三个参数：属性所在的对象，属性名和一个描述符对象e.g. 12345678var person = &#123;&#125;;Object.defineProperty(person, "name", &#123; writable: false, value: "Nicholas"&#125;);alert(person.name); // "Nicholas"person.name = "Greg";alert(person.name); // "Nicholas" 在调用Object.defineProperty()方法修改同一个属性时，如果不指定，configurable、enumerable、writable特性的默认值都为false 访问器属性访问器属性不包含数据值，它们包含一对getter函数和setter函数，在读取访问器属性时会调用getter函数，这个函数负责返回有效的值，在写入访问器属性时调用setter函数，这个函数负责决定如何处理数据，访问器属性有如下4个特性 Configurable: 同上 Enumerable: 同上 Get: 在读取属性时调用的函数，默认为undefined Set: 在写入属性时调用的函数，默认为undefined 访问器属性不能直接定义，必须使用Object.defineProperty()来定义 e.g. 12345678910111213141516171819var book = &#123; _year: 2004, edition: 1&#125;;Object.defineProperty(book, "year" &#123; get: function() &#123; return this._year; &#125;, set: function(newValue) &#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125;&#125;);book.year = 2005;alert(book.edition); // 2 若没有指定getter，则属性不能读，若没有指定setter，则属性不能写 定义多个属性ECMAScript5定义了一个Object.defineProperties()方法，可以通过描述符一次定义多个属性，这个方法接收2个对象参数，第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应 e.g. 123456789101112131415161718192021222324var book = &#123;&#125;;Object.defineProperties(book, &#123; _year: &#123; writable: true, value: 2004 &#125;, edition: &#123; writable: true, value: 1 &#125;, year: &#123; get: function() &#123; return this._year; &#125;, set: function() &#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125; &#125;&#125;); 可以使用Object.getOwnPropertyDescriptor()来获取对象的特性值 123456789var descriptor = Object.getOwnPropertyDescriptor(book, "_year");alert(descriptor.value); // 2004alert(descriptor.configurable); // falsealert(typeof descriptor.get); // undefinedvar descriptor = Object.getOwnPropertyDescriptor(book, "year");alert(descriptor.value); // undefinedalert(descriptor.enumerable); // falsealert(typeof descriptor.get); // "function" 创建对象工厂模式工厂模式抽象了创建具体对象的过程e.g. 123456789101112function createPerson(name, age, job) &#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function() &#123; alert(this.name); &#125; return o;&#125;var person1 = createPerson("Nicholas", 29, "Software Engineer"); 构造函数模式类似Object，Array都有原生的构造函数，此外还可以创建自定义构造函数，从而定义自定义对象类型的属性和方法e.g. 1234567891011function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; o.sayName = function() &#123; alert(this.name); &#125;&#125;var person1 = new Person("Nicholas", 29, "Software Engineer");var person2 = new Person("Greg", 27, "Doctor"); 构造函数的问题使用构造函数模式的缺点就是每个方法都要在每个实例上重新创建一遍在前面例子中，person1和person2的sayName()方法不是同一个Function的实例。每个Person对象的实例都包含一个不同的Function实例alert(person1.sayName == person2.sayName); // false可以通过把函数定义转移到构造函数外部解决这个问题 1234567891011121314function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; o.sayName = sayName; &#125;&#125;function sayName() &#123; alert(this.name);&#125;var person1 = new Person("Nicholas", 29, "Software Engineer");var person2 = new Person("Greg", 27, "Doctor"); 原型模式我们创建的每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。按字面意思理解，prototype就是通过调用构造函数创建的那个对象实例的原型对象。使用原型对象好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中，如下例子 123456789101112131415function Person() &#123; &#125;Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function() &#123; alert(this.name);&#125;;var person1 = new Person();person1.sayName(); // "Nicholas"var person2 = new Person();alert(person1.sayName == person2.sayName); // true 与构造函数模式不同，新对象的这些属性和方法是由所有实例共享的。 虽然可以通过对象实例访问保存在原型中的值，但不能通过对象实例重写原型中的值，如果我们在实例中添加一个与原型中一个属性同名的属性，那我们就在实例中创建该属性，并屏蔽原型中的那个属性。通过delete可以重新获取来自原型的属性 1234var person1 = new Person();person1.name = "Greg";delete person1.name;alert(person1.name); // "Nicholas" 理解原型对象无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性是一个指向prototype属性所在函数的指针，关系如下图。 更简单的原型语法12345678910function Person() &#123; &#125;Person.prototype = &#123; name : "Nicholas", age : 29, job : "Software Engineer", sayName : function() &#123; alert(this.name); &#125;&#125;; 但是使用对象字面量重写prototype的问题是constructor属性不再指向Person了，可以通过Object.defineProperty()方法解决 1234Object.defineProperty(Person.prototype, "constructor", &#123; enumerable: false, value: Person&#125;); 原型的动态性尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果是重写整个原型对象，那么情况就不一样了。把原型修改为另一个对象就等于切断了构造函数与最初原型之间的联系，看下面例子 1234567891011121314function Person() &#123; &#125;var friend = new Person();Person.prototype = &#123; constructor : Person, age : 29, job : "Software Engineer", sayName : function() &#123; alert(this.name); &#125;&#125;;friend.sayName(); // error!!! 下图揭示了上述代码整个过程的内幕 原型对象的问题原型对象最大的问题就是它共享的本性，对于包含引用类型值的属性来说，问题就比较突出了，见下面例子 1234567891011121314151617181920function Person() &#123; &#125;Person.prototype = &#123; constructor : Person, name : "Nicholas", age : 29, job : "Software Engineer", friends : ["Shelby", "Court"], sayName : function() &#123; alert(this.name); &#125;&#125;;var person1 = new Person();var person2 = new Person();person1.frineds.push("Van");alert(person2.friends); // "Shelby","Court","Van"alert(person1.friends == person2.friends) // true 组合使用构造函数模式和原型模式构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都有自己的一份实例属性，同时又共享着对方法的引用，最大限度节省了内存。 123456789101112131415function Person(name ,age, job) &#123; this.name = name; this.job = hob; this.age = age; this.friends = ["Shelby", "Court"];&#125;Person.prototype = &#123; constructor : Person, sayName : function() &#123; alert(this.name); &#125;&#125;// 测试代码 动态原型模式它把所有信息都封装在构造函数中，而通过在构造函数中初始化原型，又保持了同时使用构造函数和原型的优点。 1234567891011function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; if (typeof this.sayName != "function") &#123; Person.prototype.sayName = function() &#123; alert(this.name); &#125;; &#125;&#125; 判断语句if那里，只在sayName()不存在的情况下才将它添加到原型中。这段代码只会在初次调用构造函数时才会执行，其中，if语句检查的可以是初始化之后应该存在的任何属性和方法，不必用一大堆if语句检查每个属性和方法。 继承ECMAScript只支持实现继承，主要依靠原型链来实现的 原型链原型链的基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。假如我们让原型对象等于另一个类型的实例，此时的原型对象将包含一个指向另一个原型的指针，响应，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。 123456789101112131415161718192021function SuperType() &#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function() &#123; return this.property;&#125;;function SubType() &#123; this.subproperty = false;&#125;// 继承SuperTypeSubType.prototype = new SuperType();SubType.prototype.getSubValue = function() &#123; return this.subproperty;&#125;;var instance = new SubType();alert(instance.getSuperType()); // true 别忘记默认的原型所有引用类型默认都继承了Object，这个继承也是通过原型链实现的，下图为完整的原型链 原型链要注意的事项 子类型有时候要覆盖超类型中的某个方法，或者需要添加超类型中不存在的某个方法，但不管怎么样，给原型添加方法的代码一定要放在替换原型的语句之后 通过原型链实现继承时，不能使用对象字面量创建原型方法，因为这样做会重写原型链 原型链的问题原型链主要的问题仍然是包含引用类型值的原型。通过原型来实现继承时，原型实际上会变成另一个类型的实例，于是，原先的实例属性也就变成现在的原型属性了。 1234567891011121314function SuperType() &#123; this.colors = ["red", "blue", "green"];&#125;function SubType() &#123; &#125;SubType.prototype = new SuperType();var instance1 = new SubType();instance1.colors.push("black");alert(instance1.colors); // "red","blue","green","black"var instance2 = new SubType();alert(instance2.colors); // "red","blue","green","black" 第二个问题是创建子类型的实例时，不能向超类型的构造函数传递参数。鉴于这两个问题，下面介绍的方法更加实用 借用构造函数在子类型的构造函数的内部调用超类型构造函数，如下 1234567function SuperType() &#123; this.colors = ["red", "blue", "green"];&#125;function SubType() &#123; SuperType.call(this);&#125; 传递参数12345678function SuperType(name) &#123; this.name = name;&#125;function SubType() &#123; SuperType.call(this, "Nicholas"); this.age = 29;&#125; 借用构造函数的问题 方法都在构造函数中定义，函数复用无从谈起 超类型的原型中定义的方法，对子类型而言不可见 组合继承（伪经典继承）把原型链和借用构造函数的技术组合到一起，使用原型链对原型属性和方法继承，借用构造函数对实例属性的继承。 123456789101112131415161718192021function SuperType(name) &#123; this.name = name; this.colors = ["red", "blue", "green"];&#125;SuperType.prototype.sayName = function() &#123; alert(this.name);&#125;function SubType(name, age) &#123; // 继承属性 SuperType.call(this.name); this.age = age;&#125;// 继承方法SubType.prototype = new SuperType();SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function()&#123; alert(this.age);&#125;; 寄生组合式继承组合继承的问题就在于无论什么情况下，都会调用两次超类型构造函数，一次是在创建子类型原型的时候，另一次是在子类型构造函数内部，第一次调用的时候，SubType.prototype会得到两个属性：name和colors，当调用SubType构造函数的时候，又会调用一次SuperType构造函数，这一次又在新对象上创建了实例属性name和colors（与SubType原型一样的属性），于是这两个属性就屏蔽了原型中同名的两个属性。 所谓寄生组合式继承，就是通过借用构造函数来继承属性，通过原型链混成形式继承方法，其背后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型的原型的一个副本而已，这样，子类型的原型就不会有重复多余的超类型继承得来的属性了（因为超类型的原型没有这些属性）。 1234567891011121314151617181920212223242526272829303132function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;function inheritPrototype(subType, superType) &#123; var prototype = object(superType.prototype); prototype.constructor = subType; subType.prototype = prototype;&#125;function SuperType(name) &#123; this.name = name; this.colors = ["red", "blue", "green"];&#125;SuperType.prototype.sayName = function() &#123; alert(this.name);&#125;function SubType(name, age) &#123; // 继承属性 SuperType.call(this.name); this.age = age;&#125;inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function() &#123; alert(this.age);&#125; 这种继承方法高效率体现在它只调用了一次SuperType构造函数，因此避免了在SubType.prototype上创建不必要的，多余的属性。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>JS面向对象</tag>
        <tag>JS原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript01-语法]]></title>
    <url>%2F2018%2F09%2F01%2FJavaScript01-%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[JavaScript01-语法在HTML中嵌入JavaScript有两种方法，第一种是内嵌在&lt;head&gt;标签的&lt;script&gt;标签之间123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Example&lt;/title&gt; &lt;script&gt; JavaScript goes here... &lt;/script&gt; &lt;body&gt; Mark-up goes here... &lt;/body&gt;&lt;/html&gt; 另一种更好的方法是存在.js文件中，利用&lt;script&gt;标签的src属性指向该文件12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Example&lt;/title&gt; &lt;script src="file.js"&gt;&lt;/script&gt; &lt;body&gt; Mark-up goes here... &lt;/body&gt;&lt;/html&gt; Script标签元素详解有如下6个属性 async: 可选，表示立即下载脚本，但不应妨碍页面其他操作，只对外部脚本有效。 charset: 可选，基本不用。 defer: 可选，表示脚本可以延迟到文档完全被解析和显示后再执行。只对外部脚本有效。 src: 可选，表示包含要执行代码的外部文件。 type: 可选，使用脚的脚本语言的内容类型，目前用的比较多的还是 text/javascript Script标签的位置最好的做法就是把&lt;script&gt;标签放在HTML文档的最后，&lt;body&gt;标签的前面12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Example&lt;/title&gt; &lt;body&gt; Mark-up goes here... &lt;script src="file.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; JavaScript数据类型JS有6种数据类型，可以通过关键词typeof检测。 Undefined类型 只有一个值undefined。 Null类型 只有一个值null，undefined派生于null，typeof null检测null会返回boject。 Boolean类型 只有true与false。 Number类型 NaN(Not a number)是一个特殊的数值，表示一个本来要返回数值的操作数未返回数值的情况。 String类型 与Python类似，用双引号或者单引号都OK。 Object类型 ECMAScript的对象其实就是一组数据和功能的集合，可以通过new操作符创建，后续会讲到。 JavaScript语句JS很多语句都和Java类似，这里就只列举JS独有的语句 for-in语句1234for(var propName in window) &#123; document.write(propName);&#125;// 枚举BOM中window对象的所有属性，顺序不可预测 for-in语句是一种精准的迭代语句，可以用来枚举对象的属性。 label语句与Java类似，在代码中添加标签以便将来使用，多用于for语句等循环语句1234start: for (var i=0; i &lt; count; i++)&#123; alert(i); &#125;// start标签可以在将来由break或continue语句引用 with语句将代码的作用于设置到一个特定的对象中123var qs = location.search.substring(1);var hostName = location.hostname;var url = location.href; 等价于下面代码12345with(location) &#123; var qs = search.substring(1); var hostName = hostname; var url = href;&#125; JavaScript函数123function functionName(arg0, arg1, arg2, ... ,argN) &#123; statements;&#125; 理解参数ECMAScript函数的参数与大多数其他语言函数的参数不同，ECMAScript函数不介意传递进来多少个参数，也不在乎传进来参数是什么类型的。即使你定义的函数只接受两个参数，在调用这个函数的时候传递多少个也没问题，原因是ECMAScript中参数在内部是用一个数组来表示的，函数接受到的始终都是这个数组，实际上可以在函数体内通过arguments对象来访问这个数组，从而获取传递给函数的每一个参数。 ECMAScript所有参数传递都是值传递，不可能通过引用传递参数，对于引用数据类型，其值就是其引用 没有重载对于同一名字的多个函数，该名字只属于最后定义的]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet04-JSP]]></title>
    <url>%2F2018%2F09%2F01%2FServlet04-JSP%2F</url>
    <content type="text"><![CDATA[Servlet04-JSP基本指令page使用page指令导入包&lt;%@ page import=&quot;foo.*&quot; %&gt;&lt;%@ page import=&quot;foo.*,java.util.*&quot; %&gt; page指令的属性 taglibtaglib定义JSP可用的标记库&lt;%@ taglib tagdir=&quot;/WEB-INF/tags/cool&quot; prefix=&quot;cool&quot; %&gt; includeinclude定义在转换时增加到当前页面的文本和代码&lt;%@ include file=&quot;xxx.html&quot; %&gt;使用此指令允许你建立可重用的块（如标准页面标题或导航栏），这些可重用的块能增加到各个页面上，而不用每个JSP都重复写这些代码 表达式对于&lt;% out.println(Counter.getCount()); %&gt;可以用&lt;%= Counter.getCount() %&gt;代替，不需要分号，表达式内的内容为out.print的参数 声明&lt;%! int count = 0; %&gt;声明该JSP所生成的servlet类的成员 初始化JSP在配置文件中如下配置 12345678910&lt;web-app ...&gt; &lt;servlet&gt; &lt;servlet-name&gt;name&lt;/servlet-name&gt; &lt;jsp-file&gt;/directory/xxx.jsp&lt;/jsp-file&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;name&lt;/servlet-name&gt; &lt;url-pattern&gt;/xxx&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 覆盖jspInit()只要在.jsp文件中实现了jspInit()方法，在JSP页面成为servlet的最开始容器就会调用这个方法，这个方法由servlet的init()方法调用，所以在运行jspInit()方法时，已经有一个ServletConfig和ServletContext可供servlet使用，可以在jspInit()中调用getServletConfig()和getServletContext() 123456&lt;%! public void jspInit() &#123; ServletConfig sConfig = getServletConfig(); // do something &#125;%&gt; 同理jspDestroy()也可以覆盖 JSP的属性除了Servlet拥有的请求，会话和上下文这三个属性，JSP还拥有页面作用域pageContext（隐式对象），常用于开发定制标记 使用PageContext得到属性可以在PageContext引用得到任意作用域的属性 同理使用&lt;% pageContext.setAttribute(&quot;foo&quot;, &quot;attr&quot;, PageContext.SESSION_SCOPE); %&gt;等同于&lt;% session.setAttribute(&quot;foo&quot;, &quot;attr&quot;); %&gt; 使用&lt;%= pageContext.findAttribute(&quot;foo&quot;) %&gt;可以在不知道作用域的情况下查找一个属性 EL预热EL(Expression Language)是无脚本JSP，可以允许开发人员在JSP中不适用Java也能达到同样的效果 为什么使用EL？ 不应该要求WEB页面设计人员必须懂Java JSP中的Java代码很难修改和维护 开启无脚本JSP在配置文件web.xml中 123456789101112&lt;web-app ...&gt; ... &lt;jsp-config&gt; &lt;jsp-property-group&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;scripting-invalid&gt; true &lt;/scripting-invalid&gt; &lt;/jsp-property-group&gt; &lt;/jsp-config&gt; ...&lt;/web-app&gt; 选择忽略EL123456789101112&lt;web-app ...&gt; ... &lt;jsp-config&gt; &lt;jsp-property-group&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;el-ignored&gt; true &lt;/el-ignored&gt; &lt;/jsp-property-group&gt; &lt;/jsp-config&gt; ...&lt;/web-app&gt;]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>JSP</tag>
        <tag>EL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet02-ServletConfig,ServletContext与监听器]]></title>
    <url>%2F2018%2F09%2F01%2FServlet02-ServletConfig%2CServletContext%E4%B8%8E%E7%9B%91%E5%90%AC%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Servlet02-ServletConfig,ServletContext与监听器通过web.xml可以初始化参数，避免了硬编码改变了源码与重新编译的麻烦，如下：12345678&lt;servlet&gt; &lt;init-param&gt; &lt;param-name&gt;name&lt;/param-name&gt; &lt;param-value&gt;value&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet-name&gt; 在servlet代码中通过1234567来获取该值或者通过下面例子处理```Java Enumeration e = getServletConfig().getInitParameterNames(); while(e.hasMoreElements()) &#123; // do something with e.nextElement(); &#125; 但ServletConfig仅仅能在该servlet中使用，对于想要在全局使用的参数实在不方便，ServletContext可以很好的解决这个问题 ServletContext在web.xml中添加1234&lt;context-param&gt; &lt;param-name&gt;adminEmail&lt;/param-name&gt; &lt;param-value&gt;231232@oaiw.com&lt;/param-value&gt;&lt;/context-param&gt; Servlet中通过getServletContext().getInitParameter(&quot;adminEmail&quot;);来获取 ServletConfig与ServletContext的区别 在部署文件中，上下文初始化参数是在&lt;web-app&gt;中的，而Servlet初始化参数是在servlet中的 ServletConfig的作用域为每个servlet，而ServletContext的作用域为整个WEB应用 ServletContextListener由于ServletContext在初始化的时候只能保存字符串，若要保存一个对象或在应用启动之前利用该字符串做一些准备工作（比如打开数据库），则需要监听器的帮助。ServletContextListener接口可以监听一个上下文初始化事件，得到上下文初始化参数，并在应用为客户提供服务之前运行一些代码，要实现该接口，就要实现下面两个方法public void contextInitialized(ServletContextEvent event)public void contextDestroyed(ServletContextEvent event) 建立一个上下文监听者 创建一个监听者类 把编译后的类*.class放入WEB-INF/classes 在web.xml部署描述文件放一个&lt;listener&gt;元素，如下12345&lt;listener&gt; &lt;listener-class&gt; com.example.MyServletContextListener &lt;/listener-class&gt;&lt;/listener&gt; 一个监听器的例子web.xml中先注册该Listener，然后设置好对应的servlet以及context-param，如下12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"&gt; &lt;servlet&gt; &lt;servlet-name&gt;ListenerTester&lt;/servlet-name&gt; &lt;servlet-class&gt;com.example.web.ListenerTester&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ListenerTester&lt;/servlet-name&gt; &lt;url-pattern&gt;/listen.ht&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;context-param&gt; &lt;param-name&gt;breed&lt;/param-name&gt; &lt;param-value&gt;Great Dane&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;com.example.web.MyServletContextListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt; 监听器的工作是得到该ServletContext的初始值，然后创建一个Dog对象，把该值作为参数传入对象构造函数，并构造一个ServletContext对象，设置该Dog对象作为新的ServletContext的属性。123456789101112131415161718192021package com.example.web;import com.example.model.Dog;import javax.servlet.ServletContext;import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;public class MyServletContextListener implements ServletContextListener &#123; public void contextInitialized(ServletContextEvent event) &#123; ServletContext sc = event.getServletContext(); String dogBreed = sc.getInitParameter("breed"); Dog d = new Dog(dogBreed); sc.setAttribute("dog", d); &#125; public void contextDestroyed(ServletContextEvent event) &#123; &#125;&#125; Dog对象如下1234567891011121314package com.example.model;public class Dog &#123; private String breed; public Dog(String breed) &#123; this.breed = breed; &#125; public String getBreed() &#123; return breed; &#125;&#125; Servlet通过getServletContext().getAttribute(&quot;dog&quot;)得到ServletContext的属性值来获取该Dog对象，这样就可以通过ServletContext对象来获取String以外的值了。 123456789101112131415161718192021222324252627282930package com.example.web;import com.example.model.Dog;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@WebServlet(name = "ListenerTester")public class ListenerTester extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html"); PrintWriter out = response.getWriter(); out.println("test context attributes set by listener&lt;br&gt;"); out.println("&lt;br&gt;"); Dog dog = (Dog) getServletContext().getAttribute("dog"); out.println("Dog's breed is : " + dog.getBreed()); &#125;&#125; 其他监听者 属性API与属性安全 上下文属性无法确保线程安全，要对上下文加锁。 请求属性和请求分派1234request.setAttribute("attrName", attrValue);RequestDispatcher view = request.getRequestDispatcher("*.jsp");view.forward(request, response); 通过从ServletRequest（或ServletContext）得到RequestDispatcher对象，调用forward()把请求转交给JSP处理 注意！如果已经提交了响应，就不能转发请求，否则会报IllegalStateException，os.flush()等方法都是提交响应]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>ServletConfig</tag>
        <tag>ServletContext</tag>
        <tag>Listener</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet03-会话状态]]></title>
    <url>%2F2018%2F09%2F01%2FServlet03-%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%2F</url>
    <content type="text"><![CDATA[Servlet03-会话状态前言：这部分涉及到http cookie相关的知识，这里不再赘述 HttpSession一个HttpSession的例子代码摘自runoob，原网站为runoob的Session教程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869@WebServlet("/SessionTrack")public class SessionTrack extends HttpServlet &#123; private static final long serialVersionUID = 1L; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 如果不存在 session 会话，则创建一个 session 对象 HttpSession session = request.getSession(true); // 获取 session 创建时间 Date createTime = new Date(session.getCreationTime()); // 获取该网页的最后一次访问时间 Date lastAccessTime = new Date(session.getLastAccessedTime()); //设置日期输出的格式 SimpleDateFormat df=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String title = "Servlet Session 实例 - 菜鸟教程"; Integer visitCount = new Integer(0); String visitCountKey = new String("visitCount"); String userIDKey = new String("userID"); String userID = new String("Runoob"); // 检查网页上是否有新的访问者 if (session.isNew())&#123; title = "Servlet Session 实例 - 菜鸟教程"; session.setAttribute(userIDKey, userID); &#125; else &#123; visitCount = (Integer)session.getAttribute(visitCountKey); visitCount = visitCount + 1; userID = (String)session.getAttribute(userIDKey); &#125; session.setAttribute(visitCountKey, visitCount); // 设置响应内容类型 response.setContentType("text/html;charset=UTF-8"); PrintWriter out = response.getWriter(); String docType = "&lt;!DOCTYPE html&gt;\n"; out.println(docType + "&lt;html&gt;\n" + "&lt;head&gt;&lt;title&gt;" + title + "&lt;/title&gt;&lt;/head&gt;\n" + "&lt;body bgcolor=\"#f0f0f0\"&gt;\n" + "&lt;h1 align=\"center\"&gt;" + title + "&lt;/h1&gt;\n" + "&lt;h2 align=\"center\"&gt;Session 信息&lt;/h2&gt;\n" + "&lt;table border=\"1\" align=\"center\"&gt;\n" + "&lt;tr bgcolor=\"#949494\"&gt;\n" + " &lt;th&gt;Session 信息&lt;/th&gt;&lt;th&gt;值&lt;/th&gt;&lt;/tr&gt;\n" + "&lt;tr&gt;\n" + " &lt;td&gt;id&lt;/td&gt;\n" + " &lt;td&gt;" + session.getId() + "&lt;/td&gt;&lt;/tr&gt;\n" + "&lt;tr&gt;\n" + " &lt;td&gt;创建时间&lt;/td&gt;\n" + " &lt;td&gt;" + df.format(createTime) + " &lt;/td&gt;&lt;/tr&gt;\n" + "&lt;tr&gt;\n" + " &lt;td&gt;最后访问时间&lt;/td&gt;\n" + " &lt;td&gt;" + df.format(lastAccessTime) + " &lt;/td&gt;&lt;/tr&gt;\n" + "&lt;tr&gt;\n" + " &lt;td&gt;用户 ID&lt;/td&gt;\n" + " &lt;td&gt;" + userID + " &lt;/td&gt;&lt;/tr&gt;\n" + "&lt;tr&gt;\n" + " &lt;td&gt;访问统计：&lt;/td&gt;\n" + " &lt;td&gt;" + visitCount + "&lt;/td&gt;&lt;/tr&gt;\n" + "&lt;/table&gt;\n" + "&lt;/body&gt;&lt;/html&gt;"); &#125;&#125; 配置好web.xml即可 对这段代码的解释以及补充request.getSession()以及其重构方法request.getSession(false)HttpSession session = request.getSession(boolean create)返回当前reqeust中的HttpSession，如果当前reqeust中的HttpSession为null，当create为true，就创建一个新的Session，否则返回null 当向Session中存取登录信息时，一般建议：HttpSession session =request.getSession(); 当从Session中获取登录信息时，一般建议：HttpSession session =request.getSession(false); session.isNew() - 判断是否为新的用户12345if(session.isNew()) &#123; // do something with new user&#125; else &#123; // do something&#125; session.getId() - 获取当前用户的sessionID其他HttpSession API 禁用cookie的解决方法-URL重写您可以在每个 URL 末尾追加一些额外的数据来标识 session 会话，服务器会把该 session 会话标识符与已存储的有关 session 会话的数据相关联。 例如，http://w3cschool.cc/file.htm;sessionid=12345，session 会话标识符被附加为 sessionid=12345，标识符可被 Web 服务器访问以识别客户端。 URL 重写是一种更好的维持 session 会话的方式，它在浏览器不支持 cookie 时能够很好地工作，但是它的缺点是会动态生成每个 URL 来为页面分配一个 session 会话 ID，即使是在很简单的静态HTML页面中也会如此。 对URL重写，必须要先对URL进行编码可以通过以下两种方法对URL进行编码 jsp中添加&lt;% response.encodeURL(&quot;hello.jsp&quot;); %&gt; Servlet中使用response.encodeRedirectURL()与sendRedirect()，见下面 12345678910@Overrideprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; HttpSession session = request.getSession(); //下面请求重定向的路径。 String path = response.encodeRedirectURL("/BeerTest.do"); String sessionId = request.getSession().getId(); request.setAttribute("sessionId",sessionId); response.sendRedirect(path);&#125; 设置会话超时在web.xml中配置,下面例子是设置15分钟超时 123456&lt;web-app ...&gt; &lt;servlet&gt; ... &lt;/servlet&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt;&lt;/web-app&gt; 设置特定会话的会话超时session.setMaxInactiveInterval(20*60); // 设置20分钟没有做任何请求就超时 Cookie创建一个新CookieCookie cookie = new Cookie(&quot;username&quot;, name);设置cookie在客户端存活时间cookie.setMaxAge(30*60); // 30min把cookie发送给客户response.addCookie(cookie);从客户请求得到cookie 123456789Cookie[] cookies = request.getCookies();for (int i = 0; i &lt; cookies.length; i++) &#123; Cookie cookie = cookies[i]; if (cookie.getName().equals("username")) &#123; String userName = cookie.getValue(); out.println("Hello " + userName); break; &#125; 简单的cookie示例login.jsp设置表单提交账号密码，如果账号为test，则点击index.jsp的提交按钮可以显示其密码可以在F12 Application Cookies可以看到cookie web.xml 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"&gt; &lt;servlet&gt; &lt;servlet-name&gt;cookieTest&lt;/servlet-name&gt; &lt;servlet-class&gt;ServletCookie&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;cookieTest&lt;/servlet-name&gt; &lt;url-pattern&gt;/sv.html&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;cookieTest2&lt;/servlet-name&gt; &lt;servlet-class&gt;CheckCookie&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;cookieTest2&lt;/servlet-name&gt; &lt;url-pattern&gt;/result.html&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; login.jsp 1234567891011121314&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="sv.html" method="post"&gt; &lt;input type="text" name="username" /&gt; &lt;input type="password" name="password" /&gt; &lt;input type="submit" value="提交" /&gt;&lt;/form&gt;&lt;/body&gt; index.jsp 1234567891011&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="result.html" method="post"&gt; &lt;input type="submit" value="提交" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html ServletCookie.java 12345678910111213141516171819202122232425import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(name = "ServletCookie")public class ServletCookie extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String username = request.getParameter("username"); String password = request.getParameter("password"); //定义一个名为username，值为Tom的cookie Cookie cookie = new Cookie(username, password); response.addCookie(cookie); request.getRequestDispatcher("index.jsp").forward(request, response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125;&#125; CheckCookie.java 1234567891011121314151617181920212223242526272829303132import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@WebServlet(name = "CheckCookie")public class CheckCookie extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html"); PrintWriter out = response.getWriter(); Cookie[] cookies = request.getCookies(); if (cookies != null) &#123; for (Cookie cookie : cookies) &#123; if(cookie.getName().equals("test")) &#123; String userName = cookie.getValue(); out.println(userName); break; &#125; &#125; &#125; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125;&#125; HttpSessionBindingListener]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>HttpSession</tag>
        <tag>Cookie</tag>
        <tag>HttpSessionBindingListener</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet05-无脚本JSP]]></title>
    <url>%2F2018%2F09%2F01%2FServlet05-%E6%97%A0%E8%84%9A%E6%9C%ACJSP%2F</url>
    <content type="text"><![CDATA[Servlet05-无脚本JSPbean法则-使用bean的规范 必须有一个无参数的公共构造函数 必须按命名规范来命名公共的getter和setter setter的参数类型和getter的返回类型必须一致 性质名和类型是由setter和getter得出，而不得来自于类中的一个成员 结合JSP使用时，性质类型必须是String或其他基本类型 使用EL对于model Person，它是一个JavaBean，所以我们要使用与bean相关的标准动作 使用脚本： 123456&lt;html&gt;&lt;body&gt;&lt;% foo.Person p = (foo.Person) request.getAttribute("person"); %&gt;Person is : &lt;%= p.getName() %&gt;&lt;/body&gt;&lt;/html&gt; 使用标准动作： 123456&lt;html&gt;&lt;body&gt;&lt;jsp:useBean id="person" class="foo.Person" scope="request" /&gt;Person created by servlet: &lt;jsp:getProperty name="person" property="name" /&gt;&lt;/body&gt;&lt;/html&gt; 分析&lt;jsp:useBean&gt;和&lt;jsp:getProperty&gt;&lt;jsp:useBean&gt;用 &lt;jsp:useBean&gt; 声明和初始化一个bean属性，id为声明bean对象的标识符，对应于servlet的request.setAttribute(&quot;person&quot;, p)，class为声明的对象的类类型，scope标识这个bean对象的属性作用域 &lt;jsp:useBean&gt;还可以创建一个bean，如果它找不到一个名为”person”的属性对象，它就会建一个 &lt;jsp:getProperty&gt;用 &lt;jsp:getProperty&gt;得到bean属性的性质值，name标识具体的bean对象，与&lt;jsp:useBean&gt;的id属性相匹配，property标识属性中的性质名(也就是与bean类中getter和setter对应的性质) &lt;jsp:setProperty&gt;&lt;jsp:setProperty&gt;是第三个（也是最后一个）bean标准动作，具体使用如下 &lt;jsp:setProperty name=&quot;person&quot; property=&quot;name&quot; value=&quot;yourNameVal&quot; /&gt; &lt;jsp:useBean&gt;可以有体如果把设置方法代码&lt;jsp:setProperty&gt;放在&lt;jsp:useBean&gt;的体中，就可以有条件地设置性质，只有创建新bean时才设置性质值 123&lt;jsp:useBean id="person" class="foo.Person" scope="page" &gt; &lt;jsp:setProperty name="person" property="name" value="yourNameVal" /&gt;&lt;/jsp:useBean&gt; 多态bean引用 &lt;jsp:useBean&gt;的type属性可以用&lt;jsp:useBean&gt;的type属性实现引用类型不同于具体的对象类型，假设新对象的类型为Employee，引用类型是Person &lt;jsp:useBean id=&quot;person&quot; type=&quot;foo.Person&quot; class=&quot;foo.Employee&quot; scope=&quot;page&quot;&gt; 可以实现效果，生成的servlet代码大概如下 12345foo.Person person = null;// 得到person属性的代码if (person == null) &#123; person = new foo.Employee();&#125; type可以是class类型，抽象类型或者是一个接口，class必须是type的一个子类或具体实现，type是声明的类型，而class是要实例化的类 直接从表单请求到JSP - param属性可以通过设置name一致达到直接从请求到JSP的效果，不需要途中经过servlet 假设表单是这样的： 123456789&lt;html&gt; &lt;body&gt; &lt;form action="TestBean.jsp"&gt; name: &lt;input type="text" name="userName"&gt; ID#: &lt;input type="text" name="userID"&gt; &lt;input type="submit"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 在TestBean.jsp中 123&lt;jsp:useBean id="person" type="foo.Person" class="foo.Employee"&gt; &lt;jsp:setProperty name="person" property="name" param="userName" /&gt;&lt;/jsp:useBean&gt; 利用param属性，可以把bean的性质值设置为一个请求参数的值，只需指定请求参数 甚至不需要param属性只要把表单内的内容设置与bean的性质一致，甚至可以不需要param属性，如下 123456789&lt;html&gt; &lt;body&gt; &lt;form action="TestBean.jsp"&gt; name: &lt;input type="text" name="name"&gt; ID#: &lt;input type="text" name="userID"&gt; &lt;input type="submit"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 在TestBean.jsp中 123&lt;jsp:useBean id="person" type="foo.Person" class="foo.Employee"&gt; &lt;jsp:setProperty name="person" property="name" /&gt;&lt;/jsp:useBean&gt; 如果设置表单中所有请求参数名都与bean性质名匹配，那么甚至连property都可以省略 如下 123456789&lt;html&gt; &lt;body&gt; &lt;form action="TestBean.jsp"&gt; name: &lt;input type="text" name="name"&gt; ID#: &lt;input type="text" name="empID"&gt; &lt;input type="submit"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 在TestBean.jsp中 123&lt;jsp:useBean id="person" type="foo.Person" class="foo.Employee"&gt; &lt;jsp:setProperty name="*" property="name" /&gt;&lt;/jsp:useBean&gt; 性质是引用类型的情况假如Person有一个Dog “dog”性质，Dog有一个String “name”性质，如果想打印Person的dog的name，可以用到EL，如下 123&lt;html&gt;&lt;body&gt;Dog's name is : $&#123;person.dog.name&#125;&lt;/body&gt;&lt;/html&gt; 对${person.dog.name}的解释${person.dog.name} 等同于 &lt;%= ((foo.Person) request.getAttribute(&quot;person&quot;)).getDog().getName() %&gt; 使用点号(.)可以访问性质和映射值 使用中括号[]，更好的点号点号右边是一个bean性质或映射键的时候，点号操作符才能正常工作，但[]操作符就强大很多，它既可以完成点号操作符能完成的工作，也可以当左边变量是一个数组或者List或者右边不遵循正常的Java命名规范的时候仍然可以正常工作 EL中的隐式对象param与paramValuesHTML表单中 12345678&lt;form action="TestBean.jsp"&gt; name: &lt;input type="text" name="name"&gt; ID#: &lt;input type="text" name="empID"&gt; First food: &lt;input type="text" name="food"&gt; Second food: &lt;input type="text" name="food"&gt; &lt;input type="submit"&gt;&lt;/form&gt; 对于单个值，可以在JSP中${param.name}获取表单的name对于多个值，可以在JSP中${paramValues.food[0]}获取多个值中的一个 EL的其他隐式对象得到”host”首部${header[&quot;host&quot;]}或${header.host} 得到Cookie打印”userName” Cookie的值 使用脚本： 12345678&lt;% Cookie[] cookies = request.getCookies();for (int i = 0; i &lt; cookies.length; i++) &#123; if ((cookies[i].getName()).equals("userName")) &#123; out.println(cookies[i].getValue()); &#125;&#125;%&gt; 使用EL： ${cookie.uesrName.value} 上下文参数在web.xml中 1234&lt;context-param&gt; &lt;param-name&gt;mainEmail&lt;/param-name&gt; &lt;param-value&gt;12345@outlook.com&lt;/param-value&gt;&lt;/context-param&gt; 使用脚本：&lt;%= application.getInitParameter(&quot;mainEmail&quot;) %&gt; 使用EL：${initParam.mainEmail} EL函数使用EL函数有如下四步骤 编写一个有公共静态方法的Java类 编写一个标记库描述文件(.tld) 在JSP中放一个taglib指令 使用EL调用函数 编写一个有公共静态方法的Java类1234567package com.xhj.web;public class DiceRoller &#123; public static int rollDice() &#123; return (int) ((Math.random() * 6) + 1); &#125;&#125; 编写一个标记库描述文件IDEA中在web目录右键new -&gt; xml configuration file -&gt; JSP tag library descriptor 重命名为*.tld 123456789101112131415161718&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;&lt;taglib xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-jsptaglibrary_2_1.xsd" version="2.1"&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;uri&gt;DiceFunctions&lt;/uri&gt; &lt;function&gt; &lt;name&gt;rollIt&lt;/name&gt; &lt;function-class&gt;com.xhj.web.DiceRoller&lt;/function-class&gt; &lt;function-signature&gt;int rollDice()&lt;/function-signature&gt; &lt;/function&gt; &lt;!-- Invoke 'Generate' action to add tags or functions --&gt;&lt;/taglib&gt; 在JSP中放一个taglib指令&lt;%@ taglib prefix=&quot;mine&quot; uri=&quot;DiceFunctions&quot; %&gt; 使用EL调用函数正文添加${mine:rollIt()} 对TLD文件的解释 TLD中的uri对应JSP中taglib指令的uri属性 TLD中function里的name标签的值对应EL表达式中冒号右边使用的函数 TLD中function-class标签对应.class TLD中function-signature标签的值对应.class里的公共静态方法及其返回值 taglib指令中的prefix属性的值对应EL表达式冒号左边的值 *.tld文件可以放在WEB-INF目录或者其某个子目录中 EL处理null对于找不到表达式中指定的属性/性质/键，也会显示页面，在算术表达式中，EL把null值看做是0，在逻辑表达式中，EL把null看做是false 可复用的模板部件对于网站上每个页面的页眉和页脚都一样的情况下，每个JSP反复编写同样的页眉页脚，会显得效率低下，这个时候可以使用include指令把相同的页面放在不同网页对应的位置上 &lt;include&gt;指令用法：&lt;%@ include file=&quot;*.jsp&quot; %&gt; &lt;jsp:include&gt;标准动作用法&lt;jsp:include page=&quot;*.jsp&quot; /&gt; &lt;include&gt;与&lt;jsp:include&gt;的区别include指令在转换时发生，&lt;jsp:include&gt;标准动作在运行时发生include指令相当于复制代码粘贴，标准动作则根据页面属性创建一个RequestDispatcher，并应用include()方法。 注意！不需要把&lt;html&gt;和&lt;body&gt;标签放到可复用部件中 &lt;jsp:param&gt;定制包含的内容假设我们已经有了一个页眉，但是如果我们想要定制页眉的某一部分，比如我希望在页眉上有一个与上下文相关的子标题，它要依页面而定，如下 在对应的jsp文件中 1234567&lt;html&gt;&lt;body&gt;&lt;jsp:include page="Header.jsp"&gt; &lt;jsp:param name="subTitle" value="aha!this is a sub title." /&gt;&lt;/jsp:include&gt;&lt;/body&gt;&lt;/html&gt; 在Header.jsp中 12&lt;img src="directory/images/xxx.png"&gt;&lt;em&gt;&lt;strong&gt;$&#123;param.subTitle&#125;&lt;/strong&gt;&lt;/em&gt; &lt;jsp:forward&gt;转发可以从一个JSP转发到另一个JSP，或者从一个JSP转发到一个servlet，还可以从一个JSP转发到WEB应用中任何其他资源。比如客户访问页面，如果没有登录，就转向另一个页面 123&lt;% if (request.getParameter("userName") == null) &#123; &gt; &lt;jsp:forward page="xx.jsp" /&gt;&lt;% &#125; %&gt;]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>JSP</tag>
        <tag>EL</tag>
        <tag>bean</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础之初窥反射]]></title>
    <url>%2F2018%2F06%2F19%2FJava%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%9D%E7%AA%A5%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[前言:之前写安卓的时候有遇到过反射,但是当时怎么都不理解,现在正好借此机会初步了解一下反射 什么是反射 Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.The API accommodates applications that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class. It also allows programs to suppress default reflective access control. 简单来说,反射能够分析类能力,他可以做以下几件事: 在运行时分析类的能力 在运行时查看对象,例如,写一个toString方法供所有类使用 实现通用的数组操作代码 利用Method对象(类比C中的函数指针) 获得对象的Class类反射比较重要的一点是获得对象的类,对象的类是一个Class对象(但不是所有Class对象都是一种类,例如int也是Class对象) 以下是三种获得Class类的方法1234// 第一种:通过对象.getClass()获得Employee e;...Class cl = e.getClass(); 1234567// 第二种:通过Class类的静态方法forName()获得try &#123; String className = "java.util.Random"; Class cl = Class.forName(className);&#125; catch (Execption e) &#123; e.printStackTrace();&#125; 1234// 第三种:通过T.class获得(T是任意Java类型)Class cl1 = Random.class;Class cl2 = int.class;Class cl3 = Double[].class; Class类的一些常用方法getName() Returns the name of the entity (class, interface, array class, primitive type, or void) represented by this Class object, as a String. 123Employee e;...System.out.println(e.getClass().getName()); newInstance() Creates a new instance of the class represented by this Class object. 123Employee e;e.getClass().newInstance();// 调用默认的构造函数,如果要传参,请使用Constructor类的newInstance(Objcet[] args)方法 getMethod() Modifier and Type Method and Description Method getMethod(String name, Class&lt;?&gt;… parameterTypes) &nbsp; Returns a Method object that reflects the specified public member method of the class or interface represented by this Class object. e.g. 获得Employee的raiseSalary方法 Method m1 = Employee.class.getMethod(&quot;raiseSalary&quot;, double.class); getDeclaredFields() Returns an array of Field objects reflecting all the fields declared by the class or interface represented by this Class object. getDeclaredMethods() Returns an array containing Method objects reflecting all the declared methods of the class or interface represented by this Class object, including public, protected, default (package) access, and private methods, but excluding inherited methods. getDeclaredConsstructors() Returns an array of Constructor objects reflecting all the constructors declared by the class represented by this Class object. getDeclaredFields()与getFields()的区别getFields()返回一个包含Field对象的数组,这些对象记录了这个类或其超类的公有域,而getDeclaredFields()的对象记录了这个类的全部域类比Methods与Constructors 反射包中重要类的简单描述在java.lang.reflect包中有三个类Field,Method,和Constructor分别用于描述类的域,方法和构造器 FieldField用于描述类的域,常见的方法有 Modifier and Type Method and Description Object get(Object obj) &nbsp; Returns the value of the field represented by this Field, on the specified object. void set(Object obj, Object value) &nbsp; Sets the field represented by this Field object on the specified object argument to the specified new value. int getModifiers() &nbsp; Returns the Java language modifiers for the field represented by this Field object, as an integer. Class&lt;?&gt; getType() &nbsp; Returns a Class object that identifies the declared type for the field represented by this Field object. String getName() &nbsp; Returns the name of the field represented by this Field object. Method Modifier and Type Method and Description String getName() &nbsp; Returns the name of the method represented by this Method object, as a String. Class&lt;?&gt; getReturnType() &nbsp; Returns a Class object that represents the formal return type of the method represented by this Method object. int getModifiers() &nbsp; Returns the Java language modifiers for the field represented by this Field object, as an integer. Class&lt;?&gt;[] getParameterTypes() &nbsp; Returns an array of Class objects that represent the formal parameter types, in declaration order, of the executable represented by this object. Object invoke(Object obj, Object… args) &nbsp; Invokes the underlying method represented by this Method object, on the specified object with the specified parameters. Constructor Modifier and Type Method and Description String getName() &nbsp; Returns the name of this constructor, as a string. Class&lt;?&gt;[] getParameterTypes() &nbsp; Returns an array of Class objects that represent the formal parameter types, in declaration order, of the executable represented by this object. int getModifiers() &nbsp; Returns the Java language modifiers for the field represented by this Field object, as an integer. 利用反射分析类的能力12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class ReflectionTest &#123; public static void main(String[] args) &#123; String name; if (args.length &gt; 0) name = args[0]; else &#123; Scanner in = new Scanner(System.in); System.out.println("Enter class name (e.g. java.util.Date):"); name = in.next(); &#125; try &#123; Class cl = Class.forName(name); Class supercl = cl.getSuperclass(); String modifiers = Modifier.toString(cl.getModifiers()); if (modifiers.length() &gt; 0) System.out.print(modifiers + " "); System.out.print("class " + name); if (supercl != null &amp;&amp; supercl != Object.class) System.out.print(" extends " + supercl.getName()); System.out.print("\n&#123;\n"); printConstructors(cl); System.out.println(); printMethods(cl); System.out.println(); printFields(cl); System.out.println("&#125;"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.exit(0); &#125; public static void printConstructors(Class cl) &#123; Constructor[] constructors = cl.getDeclaredConstructors(); for (Constructor c : constructors) &#123; String name = c.getName(); System.out.print(" "); String modifiers = Modifier.toString(c.getModifiers()); if (modifiers.length() &gt; 0) System.out.print(modifiers + " "); System.out.print(name + "("); Class[] paramTypes = c.getParameterTypes(); // 构造器的参数是Class类型 for (int j = 0; j &lt; paramTypes.length; j++) &#123; if (j &gt; 0) System.out.print(", "); System.out.print(paramTypes[j].getName()); &#125; System.out.println(");"); &#125; &#125; public static void printMethods(Class cl) &#123; Method[] methods = cl.getDeclaredMethods(); for (Method m : methods) &#123; Class retType = m.getReturnType(); // 方法的返回值是Class类型,注意:int等基本数据类型也是Class类型 String name = m.getName(); System.out.print(" "); String modifiers = Modifier.toString(m.getModifiers()); if (modifiers.length() &gt; 0) System.out.print(modifiers + " "); System.out.print(retType.getName() + " " + name + "("); // 这里返回了int, boolean等 Class[] paramTypes = m.getParameterTypes(); for (int j = 0; j &lt; paramTypes.length; j++) &#123; if (j &gt; 0) System.out.print(", "); System.out.print(paramTypes[j].getName()); &#125; System.out.println(");"); &#125; &#125; public static void printFields(Class cl) &#123; Field[] fields = cl.getDeclaredFields(); for (Field f : fields) &#123; Class type = f.getType(); // Returns a Class object that identifies the declared type for the field represented by this Field object. String name = f.getName(); System.out.print(" "); String modifiers = Modifier.toString(f.getModifiers()); if (modifiers.length() &gt; 0) System.out.print(modifiers + " "); System.out.println(type.getName() + " " + name + ";"); &#125; &#125;&#125; 在运行时使用反射分析对象上面讲的是如何查看任意对象的数据域名称和类型,这次进一步查看数据域的实际内容12345Employee harry = new Employee("Harry Hacker", 35000, 10, 1 1989);Class cl = harry.getClass();Field f = cl.getDeclaredField("name");f.setAccessible(true);Object v = f.get(harry) // the value of v is "Harry Hacker" 上面是一个获得对象域的例子,注意反射机制默认受限于Java的访问控制,可以通过以下方法覆盖访问控制 f.setAccessible(true) Field继承自AccessibleObject,可通过其父类方法setAccessible()设置权限 AccessibleObject.setAccessible(fields, true) 调用静态方法对fields设置权限(见下面代码) 下面是一个通用的toString方法12345678910111213141516public class ObjectAnalyzerTest &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; squares = new ArrayList&lt;&gt;(); String[] ss = &#123;"a", "b", "c"&#125;; for (int i = 1; i &lt;= 5; i++) &#123; squares.add(i * i); &#125; ObjectAnalyzer objectAnalyzer = new ObjectAnalyzer();// System.out.println(objectAnalyzer.toString(ss)); System.out.println(objectAnalyzer.toString(squares));// System.out.println(new ObjectAnalyzer().toString(12345));// System.out.println(new ObjectAnalyzer().toString("test"));// System.out.println(new ObjectAnalyzer().toString(null)); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class ObjectAnalyzer &#123; private ArrayList&lt;Object&gt; visited = new ArrayList&lt;&gt;(); // 循环引用可能导致无限递归 public String toString(Object obj) &#123; if (obj == null) return "null"; if (visited.contains(obj)) return "..."; visited.add(obj); Class cl = obj.getClass(); if (cl == String.class) return (String)obj; if (cl.isArray()) &#123; String r = cl.getComponentType() + "[]&#123;"; // getComponentType() Returns the Class representing the component type of an array. for (int i = 0; i &lt; Array.getLength(obj); i++) &#123; if (i &gt; 0) r += ","; Object val = Array.get(obj, i); if (cl.getComponentType().isPrimitive()) r += val; else r += toString(val); &#125; return r + "&#125;"; &#125; String r = cl.getName(); do &#123; r += "["; Field[] fields = cl.getDeclaredFields(); AccessibleObject.setAccessible(fields, true); for (Field f : fields) &#123; if (!Modifier.isStatic((f.getModifiers()))) &#123; // 静态域舍弃 if (!r.endsWith("[")) r += ","; r += f.getName() + "="; try &#123; Class t = f.getType(); Object val = f.get(obj); if (t.isPrimitive()) r += val; // 如果为原始数据类型则直接添加 else r += toString(val); // 否则递归调用 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; r += "]"; cl = cl.getSuperclass(); &#125; while (cl != null); return r; &#125;&#125; 使用反射编写泛型数组代码123456789101112131415161718192021222324252627282930public class CopyOfTest &#123; public static void main(String[] args) &#123; int[] a = &#123; 1, 2, 3 &#125;; a = (int[]) goodCopyOf(a, 10); System.out.println(Arrays.toString(a)); String[] b = &#123; "Tom", "Dick", "Harry" &#125;; b = (String[]) goodCopyOf(b, 10); System.out.println(Arrays.toString(b)); &#125; // int[]无法转换为Object[] public static Object[] badCopyOf(Object[] a, int newLength) &#123; Object[] newArray = new Object[newLength]; System.arraycopy(a, 0, newArray, 0, Math.min(a.length, newLength)); return newArray; &#125; public static Object goodCopyOf(Object a, int newLength) &#123; Class cl = a.getClass(); if (!cl.isArray()) return null; Class componentType = cl.getComponentType(); // Returns the Class representing the component type of an array. int length = Array.getLength(a); Object newArray = Array.newInstance(componentType, newLength); System.arraycopy(a, 0, newArray, 0, Math.min(length, newLength)); return newArray; &#125;&#125; 注意getComponentType()是Class的方法而不是Array的方法Array.newInstance()返回Object对象 调用任意方法类似C语言的函数指针,通过Java的反射机制可以调用任意方法 Object invoke(Object obj, Object... args)第一个参数是隐式参数,其余的对象提供了显示参数,对于静态方法,第一个参数可以被忽略,即设置为null,e.g. ml是一个Method,代表Employee的getName方法,harry是一个Employee对象String n = (String) ml.invoke(harry) // 调用harry的getName()方法method.invoke(a, s); // 调用a的method方法,参数为smethod.invoke(null, s); // 调用静态method方法,参数为s注意invoke返回的是Object 而获得方法可以通过Class cl = harry.getClass()cl.getMethod(String name, Class&lt;?&gt;... parameterTypes) 一个使用invoke的例子123456789101112131415161718192021222324252627282930public class MethodTableTest &#123; public static void main(String[] args) &#123; try &#123; Method square = MethodTableTest.class.getMethod("square", double.class); Method sqrt = Math.class.getMethod("sqrt", double.class); printTable(1, 10, 10, square); printTable(1, 10, 10, sqrt); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static double square(double x) &#123; return x * x; &#125; public static void printTable(double from, double to, int n, Method f) &#123; System.out.println(f); double dx = (to - from) / (n - 1); for (double x = from; x &lt;= to; x += dx) &#123; try &#123; double y = (Double) f.invoke(null, x); System.out.printf("%10.4f | %10.4f%n", x, y); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 后言:这次仅仅是跟着课本尝试了一下反射,以后有了相应的基础后会深入理解反射的机制]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object,所有类的超类]]></title>
    <url>%2F2018%2F06%2F03%2FObject-%E6%89%80%E6%9C%89%E7%B1%BB%E7%9A%84%E8%B6%85%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Object类是Java中所有类的超类,在Java中每个类都由它扩展而来Object类的方法如下 其中最为关键的3个方法为equals(),hashCode()和toString() equals方法官方文档 在文档中说到,equals用于检测一个对象是否等于另一个对象,该方法必须有以下5个特性: 自反性:对任意非空引用x,&nbsp;&nbsp;&nbsp;x.equals(x)&nbsp;&nbsp;必须返回true 对称性:对任意非空引用x,y,&nbsp;&nbsp;x.equals(y)&nbsp;&nbsp;返回true当且仅当&nbsp;&nbsp;y.equals(x)&nbsp;&nbsp;返回true 传递性:对任意非空引用x,y,z,如果&nbsp;&nbsp;x.equals(y)&nbsp;&nbsp;返回true并且&nbsp;&nbsp;y.equals(x)&nbsp;&nbsp;返回true,则&nbsp;&nbsp;x.equals(z)&nbsp;&nbsp;返回true 一致性:如果x和y引用的对象没有发生变化,反复调用&nbsp;&nbsp;x.equals(y)&nbsp;&nbsp;应该返回同样的结果 对于任意非空引用x,&nbsp;&nbsp;x.equals(y)&nbsp;&nbsp;应该返回false Object类的equals方法而Object类中的默认的equals方法如下123public boolean equals(Object obj) &#123; return (this == obj);&#125; 自定义类的equals方法如果两个对象具有相同的引用,则返回true,否则返回false,这是最经济的符合以上5个特性的equals方法了,但是很多时候这种判断并没有什么意义,更多时候我们要判断对象是否相等,需要检测他们状态的相等性,如果两个对象的状态相等,则认为他们是相等的,比如有一个雇员Employee类,如果两个雇员对象的姓名,薪水和雇佣日期都相等,则认为他们是相等的,那么雇员类的equals方法可以如下(完整的Employee类请见最后)1234567891011121314 public boolean equals(Object otherObject) &#123; if (this == otherObject) return true; // 先判断这两个对象是否具有相同的引用 if (otherObject == null) return false; // 然后判断otherObject是否为null if (getClass() != otherObject.getClass()) return false; // 使用getClass()判断是否为同一类 Employee other = (Employee) otherObject; // 把Object类转换成Employee类 return Objects.equals(name, other.name) // 详细比较他们的域 &amp;&amp; salary == other.salary &amp;&amp; Objects.equals(hireDay, other.hireDay); &#125;&#125; Employee类的equals方法代码解释代码中使用&nbsp;Objects.equals(name, other.name)&nbsp;是为了防备name和hireDay可能为null的情况,下面是Objects类的equals方法,当对象a和b都是null,则返回true,如果其中一个是null则返回false,否则调用a.equals(b)123public static boolean equals(Object a, Object b) &#123; return (a == b) || (a != null &amp;&amp; a.equals(b));&#125; 在是否为同一类的比较中,,除了&nbsp;&nbsp;if (getClass() != otherObject.getClass()) return false;&nbsp;&nbsp;这个判断外,还可以使用&nbsp;&nbsp;if (!(otherObject instanceof Employee)) return false;&nbsp;&nbsp;来判断,但是使用instanceof判断没有解决otherObject是子类的情况(&nbsp;子类引用 instanceof 父类&nbsp;返回true,但反过来则返回false,不符合对称性)所以,使用getClass()与instanceof可以根据下面情况判断: 如果子类能够拥有自己的相等概念,则对称性需求将强制性采用getClass进行检测 如果由超类决定相等的概念(比如Employee与其子类Manager中使用Employee类的成员ID来判断是否相等),那么就可以使用instanceof进行检测 完美的equals方法 显示参数命名为otherObject,稍后强制类型转换为变量other 检测this与ohetObject是否引用同一对象 检测ohterObject是否为null,如果为null返回false 比较this与otherObject是否属于同一类,根据相等概念由父类还是子类决定用getClass()还是instanceof检测 将ohterObject转换为相应的类类型变量 开始对需要比较的域进行比较,对于对象的比较,用Objects.equals(field, other.field) 子类中的equals方法12345public boolean equals(Object otherObject) &#123; if (!super.equals(otherObject)) return false; Manager other = (Manager) otherObject; return bonus == other.bonus; &#125; 先调用super.equals(otherObject)检测父类元素是否相等,然后再比较子类的域 其他对于数组类型的域,使用静态方法Arrays.equals方法判断 hashCode方法散列码hashCode是由对象导出的一个整型值,不同的对象散列码一般不会相同 官方文档根据说明我们可以得知: 只要在Java应用程序执行过程中多次调用同一对象时，hashCode方法就必须始终返回相同的整数，前提是未修改对象的等同比较中使用的信息。 该整数不需要从应用程序的一次执行到同一应用程序的另一次执行保持一致。 如果两个对象由equals方法得到的结果为true，则对这两个对象中的每个对象调用hashCode方法必须产生相同的整数结果。 根据equals方法，如果两个对象不相等，则不要求对两个对象中的每一个调用hashCode方法都必须生成不同的整数结果。 但是，程序员应该意识到，为不相等的对象生成不同的整数结果可能会提高散列表的性能。 Object类中的hashCode方法在源码中,hashCode()不是由Java代码生成的,它返回的值为对象的存储地址,这里就不赘述了 自定义类的hashCode方法如果要重新定义equals方法,则必须重新定义hashCode方法equals方法与什么成员有关,hashCode也必须与该成员有关e.g:如果equals方法与Employee类的salary,hireDay,name相关,则Employee的hashCode方法可以定义如下 123456public int hashCode() &#123; return 7 * Objects.hashCode(name) + 11 * Double.hashCode(salary) + 13 * Objects.hashCode(hireDay);// 如果成员为数组,则使用Arrays.hashCode()&#125; 或者使用Objects.hash(Object… values)123public int hashCode() &#123; return Objects.hash(name, salary, hireDay);&#125; Objects.hashCode(Object o)是null安全的,当参数为null则返回0,否则返回对参数调用Object.hashCode()的结果注意:只有一个参数的时候不要使用Objects.hash(),而是Objects.hashCode(Object o)或者Doubles.hashCode(Double d) Objects.hash(Object… values)源码123public static int hash(Object... values) &#123; return Arrays.hashCode(values);&#125; Arrays.hashCode(Object a[])源码1234567891011public static int hashCode(Object a[]) &#123; if (a == null) return 0; int result = 1; for (Object element : a) result = 31 * result + (element == null ? 0 : element.hashCode()); return result; &#125; toString方法toString()方法返回表示对象值的字符串 官方文档 Object类的toString方法123public String toString() &#123; return getClass().getName() + "@" + Integer.toHexString(hashCode());&#125; 他返回 getClass().getName() + &#39;@&#39; + Integer.toHexString(hashCode()) toString()为什么随处可见只要对象与一个字符串通过操作符”+”连接起来,Java编译就会自动调用toString方法 数组的toString方法数组继承了Object类的toString,仍会像Object类那样输出字符串,大概输出如下[I@1a46e30]这不符合我们的预期,修正方法如下: Arrays.toString()调用静态方法Arrays.toString(),返回对象大概为[2,3,5,7,11,13]如果想要打印多维数组,调用 Arrays.deepToString() 测试类Employee与Manager的源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.time.LocalDate;import java.util.Objects;public class Employee &#123; private String name; private double salary; private LocalDate hireDay; public Employee(String n, double s, int year, int month, int day) &#123; name = n; salary = s; hireDay = LocalDate.of(year, month, day); &#125; public String getName() &#123; return name; &#125; public double getSalary() &#123; return salary; &#125; public LocalDate getHireDay() &#123; return hireDay; &#125; public void raiseSalary(double byPercent) &#123; double raise = salary * byPercent / 100; salary += raise; &#125; public boolean equals(Object otherObject) &#123; if (this == otherObject) return true; if (otherObject == null) return false; if (getClass() != otherObject.getClass()) return false; Employee other = (Employee) otherObject; return Objects.equals(name, other.name) &amp;&amp; salary == other.salary &amp;&amp; Objects.equals(hireDay, other.hireDay); &#125; public int hashCode() &#123; return 7 * Objects.hashCode(name) + 11 * Double.hashCode(salary) + 13 * Objects.hashCode(hireDay); &#125; /* public int hashCode() &#123; * return Objects.hash(name, salary, hireDay); * &#125; * */ public String toString() &#123; return getClass().getName() + "[name = " + name + ",salary = " + salary + ",hireDay = " + hireDay + "]"; &#125;&#125; 1234567891011121314151617181920212223242526272829303132public class Manager extends Employee &#123; private double bonus; public Manager(String n, double s, int year, int month, int day) &#123; super(n, s, year, month, day); bonus = 0; &#125; public double getSalary() &#123; double baseSalary = super.getSalary(); return baseSalary + bonus; &#125; public void setBonus(double b) &#123; bonus = b; &#125; public boolean equals(Object otherObject) &#123; if (!super.equals(otherObject)) return false; Manager other = (Manager) otherObject; return bonus == other.bonus; &#125; public int hashCode() &#123; return super.hashCode() + 17 * Double.hashCode(bonus); &#125; public String toString() &#123; return super.toString() + "[bonus = " + bonus + "]"; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java继承之子类访问父类的私有域]]></title>
    <url>%2F2018%2F06%2F01%2FJava%E7%BB%A7%E6%89%BF%E4%B9%8B%E5%AD%90%E7%B1%BB%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[在类的继承中,子类可以访问父类的公有方法和域,但对于父类的私有成员则不能访问,但很多情况下,子类也应当拥有父类的私有属性,例如一个雇员Employee有名字,薪资,雇佣时间等属性,经理Manager也属于雇员,那么经理也应当有名字,薪资,雇佣时间等,那么问题就来了,子类如何才能使用父类的私有成员?请看下面代码123456789101112131415161718public class Father &#123; private int a; // 默认构造方法,如果没有此方法,子类构造器第一句必须调用super() public Father() &#123; &#125; public Father(int a) &#123; this.a = a; &#125; public int getA() &#123; return a; &#125; public void setA(int a) &#123; this.a = a; &#125;&#125; 1234567891011121314151617public class Son extends Father&#123; public Son() &#123; // 如果子类没有显式调用super(),则自动调用父类默认(没有参数)的构造器,如果父类没有默认构造器,则报错 &#125; public Son(int a) &#123; super(a); // super()必须是子类构造器的第一句 &#125; public static void main(String[] args) &#123; Son son1 = new Son(); son1.setA(123); // 第一种给父类成员赋值的方法,调用setter() Son son2 = new Son(234); // 第二种给父类成员赋值的方法,构造器初始化 System.out.println(son.getA()); // 调用getter()获取父类成员 &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找]]></title>
    <url>%2F2018%2F06%2F01%2F%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%E7%9A%84%E6%80%9D%E6%83%B3%E4%B8%8E%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[折半查找的思想与作用折半查找又称二分查找，是适用于有序表的查找，它的查找时间复杂度是O(logn)，代码如下： 12345678910111213int Binary_Search(SeqList L, ElemType key) &#123; int low = 0, high = L.length - 1, mid; while (low &lt;= high) &#123; mid = (low + high) / 2; if (L.elem[mid] == key) return mid; else if (L.elem[mid] &gt; key) high = mid - 1; else low = mid + 1; &#125; return -1;&#125; 对二分查找的应用，不仅仅是在有序表中找到key那么简单，它还有很多的变通，最让我印象深刻的是leetcode上的Longest Common Prefix，使用二分查找对第0个字符串进行二分，然后判断mid之前的子串是否为共同子串，如果是则high=mid+1，如果不是则low=mid-1，最后返回substring(0,(low+high)/2) 需要注意的是，二分查找查找失败时low和high的值，high为有序表中待查元素的直接前驱，low为待查元素的直接后驱，这个结论用处很多。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让类实现for-each loop:Iterable与Iterator接口]]></title>
    <url>%2F2018%2F06%2F01%2FIterable%E4%B8%8EIterator%2F</url>
    <content type="text"><![CDATA[Interface Iterable&lt;T&gt;根据Java API上写: Implementing this interface allows an object to be the target of the “for-each loop” statement. 也就是说,实现该接口可以让类实现for循环阅读Iterable源码,该接口有3个方法 Modifier,Type and Method Description public interface Iterable&lt;T&gt; &nbsp; default void forEach(Consumer action) Performs the given action for each element of the Iterable until all elements have been processed or the action throws an exception. Iterator&lt;T&gt; iterator() Returns an iterator over elements of type T. default Spliterator spliterator() Creates a Spliterator over the elements described by this Iterable. 可以知道,实现该接口,我们只需要实现Iterator iterator()由API: Iterator iterator()Returns an iterator over elements of type T.Returns:an Iterator. 我们只需要返回一个Iterator对象就可以了 Interface IteratorJava API中说到: An iterator over a collection. Iterator takes the place of Enumeration in the Java Collections Framework. Iterators differ from enumerations in two ways:Iterators allow the caller to remove elements from the underlying collection during the iteration with well-defined semantics.Method names have been improved. 其实就是一个迭代器啦… Modifier,Type and Method Description public interface Iterator&lt;E&gt; &nbsp; default void forEachRemaining(Consumer action) Performs the given action for each remaining element until all elements have been processed or the action throws an exception. boolean hasNext() Returns true if the iteration has more elements. E next() Returns the next element in the iteration. default void remove() Removes from the underlying collection the last element returned by this iterator (optional operation). 可以知道,实现该接口,只要实现next()与hasNext(),当有remove()需求时,也要实现该方法. 下面是具体实现1.类名中加上implements Iterable1public class ClassName&lt;E&gt; implements Iterable&lt;E&gt; 2.实现Iterator iterator(),返回Iterator对象1public Iterator&lt;E&gt; iterator() &#123; return new MyIterator&lt;E&gt;(); &#125; 3.实现内部类MyIterator1234567891011121314private class MyIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123; public boolean hasNext() &#123; //return true if the iteration has more elements &#125; public E next() &#123; if (!hasNext()) throw NoSuchElementException(); // returns the next element in the iteration &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125;&#125; 对Iterator的next()与remove()方法的解释Java的迭代器认为是位于两个元素之间的,当调用next()的时候,迭代器就会越过下一个元素,并返回越过的元素的引用 即如果要用remove()连续删除2个相邻的元素1234Iterator&lt;String&gt; it = instance.iterator(); // 假设instance是实现了Iterable接口的类的实例,泛型指定为Stringit.next();it.remove();it.remove(); // error! 上面的是不行的,因为Java的迭代器并不像C++根据数组索引建模的,在Java迭代器中,查找操作与位置变更是紧密相连的,查找一个元素的唯一方法是调用next(),而执行查找操作的同时,迭代器的位置随之向前移动12345Iterator&lt;String&gt; it = instance.iterator(); // 假设instance是实现了Iterable接口的类的实例,泛型指定为Stringit.next();it.remove();it.next();it.remove(); // OK 调用next()的过程见下图]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Iterable</tag>
        <tag>Iterator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaDoc与Jar]]></title>
    <url>%2F2018%2F06%2F01%2FJavaDoc%E4%B8%8EJar%2F</url>
    <content type="text"><![CDATA[使用JavaDoc生成文档1javadoc -d 目录名 -encoding UTF-8 -charset UTF-8 xxx.java java内格式： /** 文档内容 / @author : 对类的说明，表明开发该类模块的作者 @version : 对类的说明，表明该模块版本 @see : 对类，属性，方法的说明，参考转向，也就是相关主题 @param : 对方法的说明，对方法中某参数的说明 @return : 对方法的说明，对方法返回值的说明 @exception : 对方法的说明，对方法可能抛出的异常进行说明 下为《算法》中StdRandom.java源码的注释与文档效果 使用jar打包（1）编译 javac A.java （2）打包 jar cvfm A.jar A.man A.class ——c表示创建(create)，v表示显示详情(verbose)，f表示指定文件名，m表示清单文件（3）运行 java -jar A.jar 其中A.man是清单文件（manifest），内容如下：·Manifest-Version：1.0Class-Path：.Main-Class：A]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JavaDoc</tag>
        <tag>Jar</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大西瓜VPS]]></title>
    <url>%2F1999%2F06%2F29%2F%E7%94%A8markdown%E8%BD%AF%E4%BB%B6%E6%89%93%E5%BC%80%E6%88%91%2F</url>
    <content type="text"><![CDATA[大西瓜VPS因为各种原因，网址和配置总会不断变化，如果网址无效用搜索引擎(google)重新搜索即可 使用篇电脑端以谷歌浏览器为例: 浏览器扩展SwitchyOmega插件SwitchyOmega官网先在谷歌浏览器打开扩展，如下图，然后把下载下来的SwitchyOmega_Chromium.crx拖到扩展里面(我已经下载了，可以直接拖，如果拖不进来，百度查一下怎么解决) 拖进来之后如果成功，会直接跳到SwitchyOmega的配置栏，然后根据下图操作 成功后： 打开v2ray.exe，界面如下 谷歌浏览器设置自动切换 愉快的科学上网吧 手机端 下载并安装v2rayNG.apk，打开 电脑端右键daxigua，分享服务器配置 点击APP右上角的加号 扫描或者复制二维码下面的vmess点击APP的从剪切板导入 成功后，点击那个V启动服务 启动服务后点击”已连接,点击测试连接”，如果显示连接成功即可 点击设置 分应用代理，然后把需要科学上网的应用打勾就行了，不需要科学上网的应用不要打勾，然后手机就可以科学上网了 注意事项电脑端每次科学上网浏览器都要设置GFWed或者自动切换，自动切换是国内网站绕行（即国内网站不经代理，不计流量），GFWed是所有网站都经代理 手机端每次科学上网都要开启APP代理，注意记得要弄分应用代理 每个月只有550G，每年7月17日要重新缴费，详情看续命篇]]></content>
  </entry>
</search>
