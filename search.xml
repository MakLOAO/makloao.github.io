<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringMVC03-数据处理,乱码,Restful和文件上传]]></title>
    <url>%2F2019%2F06%2F12%2FSpringMVC03-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%2C%E4%B9%B1%E7%A0%81%2CRestful%E5%92%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[SpringMVC03-数据处理,乱码,Restful和文件上传源码 数据处理 DataController.java 12345678910@Controllerpublic class DataController &#123; // @RequestParam为提交的域名称 @RequestMapping("/data") public String data(@RequestParam("uname") String name) &#123; System.out.println(name); return "index"; &#125;&#125; URL输入时添加参数uname 控制台输出 对象数据的处理主要是表单域名和对象属性名一致，方法参数使用对象即可，如下 创建实体类User(id, name, pwd)，略 Controller如下 12345@RequestMapping("/user")public String user(User user) &#123; System.out.println(user); return "index";&#125; 网址输入http://localhost:8080/user.do?name=zs&amp;pwd=1234，一般是提交表单输入的 控制台输出User{id=0, name=&#39;zs&#39;, pwd=&#39;1234&#39;} 数据显示到UI层通过ModelAndView略 通过ModelMap只需要在对应方法上添加参数ModelMap即可，如下 1.Controller 123456@RequestMapping("/user")public String user(User user, ModelMap modelMap) &#123; modelMap.addAttribute("user", user); System.out.println(user); return "user";&#125; 编写user.jsp文件，略 网址输入http://localhost:8080/user.do?name=zs&amp;pwd=1234 网址输出Hello, User{id=0, name=&#39;zs&#39;, pwd=&#39;1234&#39;} 乱码及RESTful乱码的解决对POST方法中文出现乱码的情况，通过过滤器CharacterEncodingFilter来解决 web.xml添加如下配置 12345678910111213&lt;!--配置spring的字符编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; RESTful风格RESTful风格的URL：轻量级，安全，效率高，编写如下： 1234567@RequestMapping("/&#123;name&#125;/&#123;id&#125;/restful")public String restful(@PathVariable String name, @PathVariable int id, ModelMap modelMap) &#123; System.out.println(id + name); modelMap.addAttribute("name", name); modelMap.addAttribute("id", id); return "/data";&#125; data.jsp 12345678910&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;%@ page isELIgnored="false"%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; Hello, this is data page， $&#123;name&#125;, $&#123;id&#125;&lt;/body&gt;&lt;/html&gt; 在网址输入http://localhost:8080/mkl/1/restful.do，可以输出Hello, this is data page， mkl, 1 它是根据URL路径的uname，uid设置方法的属性name和id，然后通过ModelMap传给转发的页面data.jsp的 文件上传 导入相关jar包commons-fileupload,commons-io 12345678910&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 配置springmvc配置文件，配置解析器 12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="defaultEncoding" value="utf-8"/&gt; &lt;property name="maxUploadSize" value="10485760000"/&gt; &lt;property name="maxInMemorySize" value="40960"/&gt; &lt;/bean&gt; &lt;!-- 还有一个InternalResourceViewResolver，略 --&gt;&lt;/beans&gt; 编写Controller 12345678910111213141516171819202122@Controllerpublic class FileUploadController &#123; @RequestMapping("/file") public String file() &#123; return "fileupload"; &#125; @RequestMapping("/upload") public String fileupload(@RequestParam("file") CommonsMultipartFile file, HttpServletRequest req) throws IOException &#123; String path = req.getRealPath("/WEB-INF"); OutputStream os = new FileOutputStream(new File(path, file.getOriginalFilename())); InputStream is = file.getInputStream(); int len = 0; byte[] buffer = new byte[400]; while((len = is.read(buffer)) != -1) os.write(buffer, 0, len); os.close(); is.close(); return "index"; &#125;&#125; fileupload.jsp 1234567891011&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="upload.do" method="post" enctype="multipart/form-data"&gt; file:&lt;input type="file" name="file"&gt;&lt;input type="submit" value="上传"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 工作流程是这样的：输入http://localhost:8080/file.do，他会转交给fileupload.jsp处理，然后上传文件，点击上传后，交由upload.do处理，即交给Controller的fileupload方法处理，他得到一个CommonsMultipartFile，通过Java IO把它写进tomcat路径的WEB-INF下，然后页面跳转到index]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>MVC</tag>
        <tag>RESTful</tag>
        <tag>MVC文件上传</tag>
        <tag>MVC表单数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC01-HelloSpringMVC]]></title>
    <url>%2F2019%2F06%2F11%2FSpringMVC01-HelloSpringMVC%2F</url>
    <content type="text"><![CDATA[SpringMVC01-HelloSpringMVC源码 概述mvc框架可以做如下事情： 将URL映射到java类或java类的方法 封装用户提交的数据 处理请求-调用相关的业务处理-封装响应的数据 将响应的数据进行渲染，jsp，html，freemarker等 SpringMVC是一个轻量级的，基于请求响应的mvc框架 对上图的解释： 请求第一站是DispatcherServlet，它是一个前端控制器，负责将请求委托给应用程序的其他组件来执行实际的处理DispatcherServlet的任务是将请求发送给SpringMVC控制器(Controller)，应用程序有多个控制器，所以DispatcherServlet会查询一个或多个处理器映射(handler mapping)来确定请求的下一站在哪里，处理器映射根据URL信息决策一旦选择了合适的控制器，DispatcherServlet就会将请求发送给选中的controller，到了controller，请求会卸下负载（用户提交的信息）并等待控制器处理这些信息，实际上controller会把业务逻辑委托给一个或多个service对象处理控制器完成逻辑后，会产生一些信息，这些信息需要返回给用户并在浏览器上显示，这些信息就是model，但信息一般需要格式化，比如HTML，所以，信息需要发送给一个view，通常是JSP控制器最后一件事就是模型数据打包，并标示出用于渲染输出的视图名，然后将请求连同模型和视图名发送回DispatcherServlet（这样controller就不会与特定的view相耦合）传递回DispatcherServlet的视图名不直接表示某个特定的JSP（甚至不是JSP），它只是一个逻辑名，用于查找产生结果的真正视图，DispatcherServlet使用视图解析器（view resolver）将逻辑视图名匹配为一个特定的视图实现最后，DispatcherServlet把模型数据交付给view，view通过响应对象传递给客户端即可 Hello Spring MVCHello Spring MVC是完全不使用注解开发的，主要是了解上述MVC框架的工作流程，实际开发最好不采用下述方法 导入相关jar包，pom.xml关键依赖如下 123456789101112131415161718192021222324&lt;!-- 省略了Spring相关的依赖包，关键是mvc包和servlet包，具体依赖见源码 --&gt;&lt;dependencies&gt; &lt;!-- 3.Spring web依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0-alpha-1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置web.xml文件-配置分发器 123456789101112&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 编写springmvc-serlvet.xml（它的名字必须为web.xml的&lt;serlvet-name&gt;的值加上-servlet） 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 配置handler mapping --&gt; &lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping" /&gt; &lt;!-- 配置handler adapter --&gt; &lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter" /&gt; &lt;!-- 配置view resolver --&gt; &lt;bean id="jspViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt; &lt;!-- 配置请求和处理器 --&gt; &lt;bean name="/hello.do" class="com.mkl.Controller.HelloController" /&gt;&lt;/beans&gt; 编写HelloController.java，注意导入的javax包和Controller为org.springframework.web.servlet.mvc.Controller，默认导入的不是那个Controller 1234567891011121314151617181920// HelloController.javapackage com.mkl.Controller;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class HelloController implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; ModelAndView mv = new ModelAndView(); // 封装要显示到视图的数据 mv.addObject(&quot;msg&quot;, &quot;hello springmvc&quot;); // 封装视图名称 mv.setViewName(&quot;hello&quot;); return mv; &#125;&#125; 编写视图hello.jsp，记得开启EL表达式 12345678910&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;%@ page isELIgnored="false"%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 配置TOMCAT 运行TOMCAT，浏览器输入http://localhost:8080/hello.do ，即可看到hello springmvc 工作流程简要介绍 在web.xml配置了分发器，通过servlet-name指定对应的xxx-servlet.xml，url-pattern表示该servlet处理所有.do的网址，然后当用户输入xxx/hello.do，由springmvc-mapping.xml的bean知该URL对应的Controller为HelloController，转而交给该Controller处理，该Controller处理完后返回一个ModelAndView对象，指定了View的逻辑名与一个键值对数据，view resolver通过为该View的逻辑名添加前缀和后缀得出其物理名，把模型返回给View处理，然后View返回给用户]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring05-整合MyBatis]]></title>
    <url>%2F2019%2F06%2F10%2FSpring05-%E6%95%B4%E5%90%88MyBatis%2F</url>
    <content type="text"><![CDATA[Spring05-整合MyBatis源代码在这 步骤 导入相关jar包 编写配置文件 实现 导入jar包主要是spring相关的包加上mybatis加上mysql-connector-java加上mybatis-spring 123456789101112131415161718&lt;dependencies&gt; &lt;!-- spring相关依赖，略 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 编写配置文件mybatis-conf.xml如下： 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name="com.mkl.mybatis" /&gt; &lt;/typeAliases&gt; &lt;!-- 对数据源的配置已经由bean实现 &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://127.0.0.1:3306/yourDBName?useUnicode=true&amp;amp;serverTimezone=UTC&amp;amp;characterEncoding=utf8"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="123456"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; --&gt; &lt;mappers&gt; &lt;mapper resource="com/mkl/mybatis/entity/UserMapper.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 事实上，甚至不需要这个mybatis-conf.xml，任何配置都可以在bean中实现，只要为对应SqlSessionFactory配置property即可 spring-mybatis.xml配置文件如下： 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://127.0.0.1:3306/sampledb?useUnicode=true&amp;amp;serverTimezone=UTC&amp;amp;characterEncoding=utf8" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="123456" /&gt; &lt;/bean&gt; &lt;!-- 配置SqlSessionFactory --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;property name="configLocation" value="classpath:mybatis-conf.xml" /&gt; &lt;/bean&gt; &lt;!-- 配置SqlSession --&gt; &lt;bean id="sqlSessionTemplate" class="org.mybatis.spring.SqlSessionTemplate"&gt; &lt;constructor-arg index="0" ref="sqlSessionFactory" /&gt; &lt;/bean&gt; &lt;!-- 配置DAO --&gt; &lt;bean id="userDao" class="com.mkl.mybatis.dao.UserDaoI" &gt; &lt;property name="sqlSession" ref="sqlSessionTemplate" /&gt; &lt;/bean&gt;&lt;/beans&gt; 在这个spring配置文件中，主要配置了数据源，并通过这个数据源配置了SqlSessionFactory，通过把这个sqlSessionFactory作为参数，构造器注入创建SqlSessionTemplate对象，作为SqlSession UserMapper.xml如下 12345678910&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.mkl.mybatis.UserMapper"&gt; &lt;select id="selectUser" resultType="com.mkl.mybatis.entity.User"&gt; SELECT * FROM user &lt;/select&gt;&lt;/mapper&gt; 实现User是一个实体类，主要有id，name和password三个属性，UserDaoI如下 12345678910111213public class UserDaoI implements UserDao &#123; private SqlSessionTemplate sqlSession; @Override public List&lt;User&gt; selectUser() &#123; return sqlSession.selectList("com.mkl.mybatis.UserMapper.selectUser"); &#125; public void setSqlSession(SqlSessionTemplate sqlSession) &#123; this.sqlSession = sqlSession; &#125;&#125; 测试类只要获得这个Dao对象并调用其方法即可 注解实现声明式事务事务：方法要么全成功，要么全失败 主要是配置spring配置文件，如下 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://127.0.0.1:3306/sampledb?useUnicode=true&amp;amp;serverTimezone=UTC&amp;amp;characterEncoding=utf8" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="123456" /&gt; &lt;/bean&gt; &lt;!-- 其他配置如SqlSessionFactory，略 --&gt; &lt;!-- 声明式事务配置 --&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- 配置事务通知 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="txManager" &gt; &lt;tx:attributes&gt; &lt;tx:method name="insert*" propagation="REQUIRED" /&gt; &lt;tx:method name="delete*" propagation="REQUIRED" /&gt; &lt;tx:method name="update*" propagation="REQUIRED" /&gt; &lt;tx:method name="add*" propagation="REQUIRED" /&gt; &lt;tx:method name="*" propagation="REQUIRED" /&gt; &lt;tx:method name="get*" read-only="true" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 这里的execution表达式其实不应该写dao，而应该写service --&gt; &lt;aop:config&gt; &lt;aop:pointcut id="pointcut" expression="execution(* com.mkl.mybatis.dao.daoImpl.*.*(..))" /&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="pointcut" /&gt; &lt;/aop:config&gt;&lt;/beans&gt; 注意&lt;beans&gt;标签的属性要加入xmlns:tx，xsi:schemaLocation也要加入相应值，详情看上面 这样，对execution(* com.mkl.mybatis.dao.daoImpl.*.*(..))里的所有方法，都是一个事务，方法体内的SQL语句执行要么全部执行，要么全部不执行 通过Dao继承SqlSessionDaoSupport整合这种方法可以不用定义SqlSessionTemplate的bean，在Dao中不需要设置SqlSession属性，只要继承SqlSessionDaoSupport父类，并在对应类bean中设置sqlSessionFactory属性，然后调用getSession()方法即可 1234567public class UserDaoI2 extends SqlSessionDaoSupport implements UserDao &#123; @Override public List&lt;User&gt; selectUser() &#123; return getSqlSession().selectList("com.mkl.mybatis.UserMapper.selectUser"); &#125;&#125; 通过接口的实现继承父类SqlSessionDaoSupport，然后调用getSqlSession()方法获取SqlSession对象，注意此时的bean要传入SqlSessionFactory参数，如下 123&lt;bean id="userDao2" class="com.mkl.mybatis.dao.daoImpl.UserDaoI2" &gt; &lt;property name="sqlSessionFactory" ref="sqlSessionFactory" /&gt;&lt;/bean&gt; mapper注入（最好用这个）编写mapper，然后编写接口，接口名必须与mapper名一致，且接口方法和mapper对应sql语句的id一致，且mapper和接口在同一目录下 UserMapper.xml 123456789101112&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.mkl.mybatis.mapper.UserMapper"&gt; &lt;select id="selectAll" resultType="User" &gt; SELECT * FROM user; &lt;/select&gt; &lt;select id="selectById" resultType="User" parameterType="int"&gt; SELECT * FROM user WHERE id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; UserMapper.java 123456public interface UserMapper &#123; List&lt;User&gt; selectAll(); User selectById(int id);&#125; UserServiceImpl 1234567891011121314151617// spring配置文件开启自动扫描，它自动装配了UserMapper@Service("userService")public class UserServiceImpl implements UserService &#123; @Autowired private UserMapper userMapper; @Override public List&lt;User&gt; selectAll() &#123; return userMapper.selectAll(); &#125; @Override public User selectById(int id) &#123; return userMapper.selectById(id); &#125;&#125; Spring配置文件启用mybatis的接口代理开发模式（接口和Xml配置必须同名，并且在同一目录下） 1234&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.mkl.mybatis.mapper"/&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/&gt;&lt;/bean&gt; 测试类只需获得service对象，并调用其方法即可]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring整合MyBatis</tag>
        <tag>声明式事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL事务]]></title>
    <url>%2F2019%2F06%2F10%2FMySQL%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[MySQL事务 认识事务概述事务符合ACID特性 原子性(atomicity)：整个事务操作为原子操作 一致性(consistency)：指事务将数据库从一种状态转变为下一种一致的状态。事务开始之前和事务结束之后，数据库的完整性约束都没有被破坏 隔离性(isolation)：要求每个读写事务的对象对其他事务的操作对象能相互分离，即事务提交前对其他事务都不可见（并发控制，可串行化，锁等） 持久性(durability)：事务一旦提交，其结果就是永久性的。即使发生宕机等故障，数据库也能将数据恢复 事务指一些操作要么都做，要么都不做 对一致性和原子性理解的一个小例子比如有A有500块存款，B有500块存款，A转200给B，则一致性操作如下：A-200;B+200如果这两条操作都执行完毕，那同时它也是原子性的如果操作变为A-200;B+100，且都完成了，那这个操作是原子性的，但不是一致性的 原子性关注状态，要么全部成功，要么全部失败，不存在部分成功的状态。而一致性关注数据的可见性，中间状态的数据对外部不可见，只有最初状态和最终状态的数据对外可见 分类InnoDB存储引擎不原生支持嵌套事务，但可以用带保存点的扁平事务来模拟 扁平事务扁平事务所有操作都处于同一层次，由BEGIN WORK开始，COMMIT WORK或ROLLBACK WORK结束，期间操作是原子性的 扁平事务主要限制是不能提交或回滚事务的某一部分，或分几个步骤提交 带有保存点的扁平事务允许在事务执行过程中回滚到同一事务中较早的一个状态，某些事务可能在执行过程中出现的错误并不会导致所有操作都无效，放弃整个事务不合乎要求，保存点用来通知系统应该记住事务当前的状态，以便之后发生错误时，事务能回到保存点当时的状态 扁平事务隐式地设置了一个事务开始时的保存点，用SAVE WORK函数来建立保存点，保存点在事务内部是递增的，如下： 链事务保存点是易失的，当系统崩溃时，保存点都会消失，恢复时事务要从开始处重新执行，链事务可视为保存点模式的一种变种链事务思想：提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传给下一个要开始的事务，提交事务操作和开始下一个事务操作合并为一个原子操作，意味下一个事务可以看到上一个事务的结果，他们好像在同一个事务中进行一样 链事务只能回滚到最近一个的保存点，而带保存点的扁平事务可以回滚到任意正确的保存点，链事务COMMIT后释放当前事务所持有的所，而带保存点的扁平事务不影响锁 嵌套事务由一个顶层事务控制着各个层次的子事务 嵌套事务是由若干事务组成的一棵树，子树既可以是嵌套事务，也可以是扁平事务 处在叶节点的事务是扁平事务，但是每个事务从根到叶距离可以不同 位于根节点的事务为顶层事务，其他为子事务 子事务既可以提交也可以回滚，但是它的提交不会立即生效，除非其父事务已经提交（可以一直回溯到顶层事务的提交） 树种任意一个事务的回滚会引起它的所有子事务一同回滚，子事务只有ACI特性，没有D特性 分布式事务分布式环境下的扁平事务 事务的实现redo log保证事务的原子性和持久性，undo log来保证事务的一致性 redo恢复提交事务修改的页操作，undo回滚行记录到某个特定版本，redo通常是物理日志，记录的是页的物理修改操作，undo是逻辑日志，根据每行记录进行记录 不详述 事务控制语句 隐式提交的SQL语句以下语句会产生一个隐式的提交操作，即执行完这些语句后，会有一个隐式的COMMIT操作 DDL语句：ALTER TABLE,CREATE DATABASE, CREATE TABLE, CREATE INDEX, DROP DATABASE… 隐式修改MySQL架构的操作：CREATE USER, DROP USER, GRANT, RENAME USER, SET PASSWORD… 管理语句：CACHE INDEX, CHECK TABLE… 事务的隔离级别ISO和ANSI SQL标准制定了四种事务隔离级别的标准，但很少有厂商遵循，如Oracle就不支持READ UNCOMMITTED和REPEATABLE READ READ UNCOMMITTED：称为浏览访问，仅仅针对事务而言 READ COMMITTED：称为游标稳定 REPEATABLE READ：2.9999°的隔离，没有幻读的保护 SERIALIZABLE：称为隔离，或3°的隔离 InnoDB存储引擎默认支持的隔离级别是REPEATABLE READ，但与标准不同的是，InnoDB在REPEATABLE READ事务级别下，使用Next-Key Lock锁的算法，避免幻读的产生，即已经达到了SQL标准的SERIALIZABLE隔离级别 隔离级别越低，事务请求的锁越少或保持的锁的时间越短 分布式事务常见于银行的转账，InnoDB存储引擎提供对XA事务的支持，并通过XA事务支持分布式事务的实现。分布式事务指允许多个独立的事务资源参与到一个全局的事务中。事务资源通常是关系型数据库系统。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚。在使用分布式事务时，InnoDB引擎的事务隔离级别必须设置为SERIALIZABLE XA事务允许不同数据库之间的分布式事务，XA事务由一个或多个资源管理器，一个事务管理器以及一个应用程序组成 资源管理器：提供访问事务资源的方法，通常一个数据库就是一个资源管理器 事务管理器：协调参与全局事务的各个事务，需要和参与全局事务的所有资源管理器进行通信，一般为连接数据库的客户端 应用程序：定义事务的边界，指定全局事务的操作 分布式事务采用两段式提交，第一阶段，所有参与全局事务的节点都开始准备（PREPARE），告诉事务管理器他们准备好提交了，第二阶段，事务管理器告诉资源管理器执行ROLLBACK还是COMMIT，如果任何一个节点显示不能提交，则所有节点都被告知需要回滚。它与本地事务不同的是，分布式事务需要多一次的PREPARE操作，待收到所有节点同意信息后再进行COMMIT或是ROLLBACK操作 MySQL定义的XA操作如下 在XA START和XA END之间是一些SQL语句]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>InnoDB</tag>
        <tag>MySQL事务</tag>
        <tag>事务隔离级别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis从入门到秃头]]></title>
    <url>%2F2019%2F06%2F06%2FMyBatis%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%A7%83%E5%A4%B4%2F</url>
    <content type="text"><![CDATA[MyBatis从入门到秃头源码地址 入门MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录 安装要使用MyBatis，只需将mybatis-x.x.x.jar文件置于classpath中即可。 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;x.x.x&lt;/version&gt;&lt;/dependency&gt; 从0构造一个MyBatis应用数据库MySQL账户root，密码123456数据库名sampledb，表名person，有id，name，age三列 步骤： 配置mybatis的conf.xml：配置数据库信息和需要加载的映射文件 配置映射文件xxMapper.xml，增删改查标签 在测试类中拿到SqlSession对象进行数据操作，session.selectOne(&quot;需要查询的namespace.id&quot;,&quot;SQL的参数值&quot;) 目录树： 123456789101112131415161718// Person.javapackage com.mkl.entity;public class Person &#123; private int id; private String name; private int age; public Person() &#123; &#125; // constructor, setter and getter @Override public String toString() &#123; return this.id + "," + this.name + "," + this.age; &#125;&#125; 12345678910&lt;!-- personMapper.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.mkl.entity.personMapper"&gt; &lt;select id="queryPersonById" resultType="com.mkl.entity.Person" parameterType="int"&gt; select * from person where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 1234567891011121314151617181920212223242526&lt;!-- conf.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;typeAlias type="com.mkl.entity.Person" alias="Person" /&gt; &lt;/typeAliases&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt; &lt;!-- ?useUnicode=true&amp;amp;characterEncoding=utf8为了支持中文数据的写入 --&gt; &lt;property name="url" value="jdbc:mysql://127.0.0.1:3306/sampledb?useUnicode=true&amp;amp;serverTimezone=UTC&amp;amp;characterEncoding=utf8" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="123456" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="com/mkl/entity/personMapper.xml" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; 123456789101112131415// TestMybatis.javapublic class TestMybatis extends UnitTestBase &#123; @Test public void testMybatis() throws IOException &#123; Reader reader = Resources.getResourceAsReader("conf.xml"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader); SqlSession session = sessionFactory.openSession(); // 通过mapper的namespace+对应查询语句的id选择唯一的查询语句 String statement = "com.mkl.entity.personMapper.queryPersonById"; Person person = session.selectOne(statement, 1); System.out.println(person); session.close(); &#125;&#125; 配置文件解析环境配置的官方文档 多个environment 可以在conf.xml中配置多个environment，比如开发环境的environment，测试环境的environment，部署上线环境的environment，每个environment的数据库参数都不一样 除了在&lt;environments&gt;中设置default的environment，还可以SqlSessionFactoryBuilder().build(reader, &quot;xxx&quot;)，为build方法传入第二个字符串参数，指定选择哪个environment 数据源类型通过&lt;environment&gt;的子标签&lt;dataSource type=&quot;xxx&quot;&gt;指定数据源，有如下几种： POOLED：MyBatis创建一个数据库连接池，连接池中的一个连接用于数据库操作，一旦操作完成，MyBatis将此连接返回给连接池，开发和测试的时候经常使用这种方式 UNPOOLED：传统JDBC模式，为每一个数据库操作创建一个新的连接，在使用完毕后关闭它（创建Connection对象非常耗时） JNDI：从应用服务器（TOMCAT）中内置的配置好的数据源（数据库连接池）获取数据库连接，一般生产环境优先使用该方式 事务提交方式通过&lt;environment&gt;的子标签&lt;transactionManager type=&quot;xxx&quot; /&gt;指定事务提交方式，有如下两种 JDBC：使用JDBC的事务管理机制,就是利用java.sql.Connection对象完成对事务的提交 MANAGED：使用MANAGED的事务管理机制，这种机制mybatis自身不会去实现事务管理，而是让程序的容器（Spring）来实现对事务的管理 SQL语句传入多个参数12345678910&lt;!-- personMapper.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.mkl.entity.personMapper"&gt; &lt;select id="queryPersonById" resultType="com.mkl.entity.Person" parameterType="int"&gt; select * from person where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 如上mapper，MyBaits规定一个增删改查标签只能有一个resultType和一个parameterType，即只能有一个输入参数和一个输出参数，但逻辑上是可以传入多个参数的，如下 1234&lt;!-- personMapper.xml --&gt;&lt;insert id="addPerson" parameterType="com.mkl.entity.Person" &gt; INSERT INTO person(id, name, age) VALUES (#&#123;id&#125;, #&#123;name&#125;, #&#123;age&#125;)&lt;/insert&gt; 只要传入对象参数即可，注意当参数类型是对象的时候，#{xxx}的xxx必须要和对象的属性名一致 然后构造一个Person对象，调用session.insert(statement, person)即可完成多参数的插入 多个对象的返回时，resultType为这多个对象的共同类型，只要session.selectList(statement);即可返回包含这多个对象的List类型 XML映射文件XML映射文件官方文档 所有&lt;insert&gt;,&lt;delete&gt;,&lt;update&gt;,&lt;select&gt;的属性在官方文档都有详细说明，值得注意的是在&lt;insert&gt;和&lt;update&gt;中有useGeneratedKeys和keyProperty属性，它们的作用是：如果你的数据库支持自动生成主键的字段（比如 MySQL 和 SQL Server），那么你可以设置 useGeneratedKeys=”true”，然后再把 keyProperty 设置到目标属性上就 OK 了。例如，如果 Author 表已经对 id 使用了自动生成的列类型，那么语句可以修改为： 12345&lt;insert id="insertAuthor" useGeneratedKeys="true" keyProperty="id"&gt; insert into Author (username,password,email,bio) values (#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)&lt;/insert&gt; 不用自己显式的为id设置值 在底层，SqlSession接口的insert和update和delete的实现其实都是调用了update方法，即调用java的insert和delete方法和调用update方法是一样的，只要确保XML的SQL语句不一样即可 XML配置优化MyBatis配置官方文档 MyBatis的配置文件包含各种设置和属性，如下： 配置config.properties文件properties属性 新建.properties文件，如下 12345# db.propertiesjdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://127.0.0.1:3306/sampledb?useUnicode=true&amp;serverTimezone=UTC&amp;characterEncoding=utf8jdbc.username=rootjdbc.password=123456 然后修改MyBatis的配置文件conf.xml 1234567891011&lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;" /&gt; &lt;!-- ?useUnicode=true&amp;amp;characterEncoding=utf8为了支持中文数据的写入 --&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;/dataSource&gt;&lt;/environment&gt; 指定别名类型别名是为 Java 类型设置一个短的名字。 它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余，可以使得 mapper 映射文件中的 resultType 和 parameterType 直接饮用别名即可 12345678&lt;typeAliases&gt; &lt;typeAlias alias="Author" type="domain.blog.Author"/&gt; &lt;typeAlias alias="Blog" type="domain.blog.Blog"/&gt; &lt;typeAlias alias="Comment" type="domain.blog.Comment"/&gt; &lt;typeAlias alias="Post" type="domain.blog.Post"/&gt; &lt;typeAlias alias="Section" type="domain.blog.Section"/&gt; &lt;typeAlias alias="Tag" type="domain.blog.Tag"/&gt;&lt;/typeAliases&gt; 也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如： 123&lt;typeAliases&gt; &lt;package name="domain.blog"/&gt;&lt;/typeAliases&gt; 每一个在包 domain.blog 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 domain.blog.Author 的别名为 author；若有注解，则别名为其注解值。见下面的例子： 1234@Alias("author")public class Author &#123; ...&#125; 它内建了部分Java类型的别名，详情可以去看官方文档 解决属性名和列名不一致当Java实体类的属性名和数据库中列名不一致的时候，查询时MyBatis无法通过setter为实体类对应属性设置值，同理，增改时无法通过getter获取实体类属性对数据库修改列，解决方法如下： 为列名指定别名，别名和Java实体类属性名一致 123456&lt;mapper namespace="com.mkl.entity.personMapper"&gt; &lt;!-- 为name设置别名name1，name1和实体类的属性名一致，name为数据库的列名 --&gt; &lt;select id="queryPersonById" resultType="com.mkl.entity.Person"&gt; SELECT id, name name1, age FROM person WHERE id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 设置结果映射类型 1234567891011121314&lt;mapper namespace="com.mkl.entity.personMapper"&gt; &lt;select id="queryPersonById" resultMap="PersonMap"&gt; SELECT id, name, age FROM person WHERE id = #&#123;id&#125; &lt;/select&gt; &lt;!-- resultMap的type与实体类名一致 --&gt; &lt;!-- column为数据库列名，property为实体类属性名 --&gt; &lt;resultMap id="PersonMap" type="Person" &gt; &lt;result column="id" property="id" /&gt; &lt;result column="name" property="name1" /&gt; &lt;result column="age" property="age" /&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 注意自增主键要设置的标签不是&lt;result&gt;而是&lt;id&gt;，官方文档在这里 分页MySQL的分页语句SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset LIMIT子句可以被用于指定 SELECT 语句返回的记录数。需注意以下几点： 第一个参数指定第一个返回记录行的偏移量 第二个参数指定返回记录行的最大数目 如果只给定一个参数：它表示返回最大的记录行数目 第二个参数为 -1 表示检索从某一个偏移量到记录集的结束所有的记录行 初始记录行的偏移量是0(而不是 1) 需要注意分页的原理是先读取前面offset条记录，然后抛弃前offset条，读后面rows条想要的，所以offset越大，偏移量越大，性能就越差因此需要对分页进行优化，但这个内容不是MyBatis相关的，所以就不赘述，分页优化看这篇就够了 MyBatis分页的Map实现首先在mapper中设置分页的SQL语句，注意指定的parameterType为Map，然后传入SQL参数为#{startIndex}, #{pageSize} 123&lt;select id="queryPage" parameterType="Map" resultMap="PersonMap"&gt; SELECT * FROM person LIMIT #&#123;startIndex&#125;, #&#123;pageSize&#125;&lt;/select&gt; 然后为session.selectList(statement, map)传入statement，map，代码如下（该代码应该在Dao中）： 123456789101112public List&lt;Person&gt; queryPersonPage(int currentPage, int pageSize) throws IOException &#123; SqlSession session = MyBatisUtil.getSqlSession(); // 获取SqlSession String statement = "com.mkl.entity.personMapper.queryPage"; Map&lt;String ,Integer&gt; map = new HashMap&lt;String, Integer&gt;(); // startIndex为MySQL分页的偏移量，currentPage是第几页，pageSize是每页的size，也是返回记录行的最大数目 // 基于它们的定义，currentPage和startIndex的关系为startIndex = (currentPage - 1) * pageSize map.put("startIndex", (currentPage - 1) * pageSize); map.put("pageSize", pageSize); List&lt;Person&gt; list = session.selectList(statement, map); session.close(); return list;&#125; MyBatis分页的RowBounds实现用RowBounds实现，不需要在SQL语句中加入LIMIT关键字，也不需要指定Map，只需要在session.selectList(statement, null, rowBounds)传入rowBounds参数即可，RowBounds对象构造器有两个参数，第一个是offset，第二个是limit 123&lt;select id="queryPageRowBounds" resultMap="PersonMap"&gt; SELECT * FROM person&lt;/select&gt; 12345678public List&lt;Person&gt; queryPersonPageRowBounds(int currentPage, int pageSize) throws IOException &#123; SqlSession session = MyBatisUtil.getSqlSession(); // 获取SqlSession String statement = "com.mkl.entity.personMapper.queryPageRowBounds"; RowBounds rowBounds = new RowBounds((currentPage - 1) * pageSize, pageSize); List&lt;Person&gt; list = session.selectList(statement, null, rowBounds); session.close(); return list;&#125; 使用注解实现MyBatis使用MyBtis可以在接口中通过注解实现SQL语句，这样不需要mapper.xml的编写面向接口编程好处：扩展性好，分层开发中，上层不用管具体的实现，大家都遵循共同的标准，规范性更好 编写Dao接口 12345678public interface PersonDao &#123; @Select("SELECT * FROM person") public List&lt;Person&gt; getList(); @Insert("INSERT INTO user(id, name, age) VALUES(#&#123;id&#125;, #&#123;name&#125;, #&#123;age&#125;)") public int insert(Person person);&#125; 然后在核心配置文件中导入该接口，注意使用的是全限定类名，而不是路径 123&lt;mapper&gt; &lt;mapper class="com.mkl.dao.PersonDao"&lt;/mapper&gt; 然后在service层得到SqlSession对象，通过session.getMapper(PersonDao.class)得到动态代理的PersonDao接口的实现类，通过调用其方法即可执行对应SQL语句 12345SqlSession session = MyBatisUtil.getSqlSession(); PersonDao personDao = session.getMapper(PersonDao.class); List&lt;Person&gt; list = personDao.getList(); for (Person person : list) System.out.println(person); 关于联表的处理多对一关系的处理一个老师对应多个学生，就学生而言（学生设置外键为老师的id），对象关系是多对一的多对一有两种处理方式，一种是按结果嵌套处理，另一种是按查询嵌套处理 假设我们有一个学生表，有id，name，外键tid为老师的id，一个老师表，有id，name，下面以这个假设为前提就这两种处理进行说明 按结果嵌套处理 首先创建实体类，Student有属性id,name和teacher，Teacher有属性id和name 123456789public class Student &#123; private int id; private String name; // 这是多对一关系的实现，多个学生对应一个老师 private Teacher teacher; // getter setter constructor toString&#125; 创建StudentMapper.xml，SQL语句使用常用的联表查询语句，注意返回类型是一个resultMap，在该resultMap里有一个&lt;association&gt;子标签关联实体类Teacher，如下： 123456789101112131415&lt;mapper namespace="com.mkl.entity.StudentMapper"&gt; &lt;select id="getStudents" resultMap="StudentTeacher"&gt; SELECT s.id sid, s.name sname, s.tid stid, t.id tid, t.name tname FROM student s, teacher t WHERE s.tid = t.id &lt;/select&gt; &lt;resultMap id="StudentTeacher" type="Student" &gt; &lt;id column="sid" property="id" /&gt; &lt;result column="sname" property="name" /&gt; &lt;!-- javaType要用全类名或别名，表示对应实体类，property表示Student类的teacher属性 --&gt; &lt;association property="teacher" javaType="Teacher" &gt; &lt;id column="tid" property="id" /&gt; &lt;result column="tname" property="name" /&gt; &lt;/association&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 在MyBatis核心配置文件配置好mapper，然后获取SqlSession查询即可 按查询嵌套处理按查询嵌套处理的过程是先查询Student表，再通过Student表的tid查询Teacher表，把对应Teacher实例赋值给Student的teacher属性 实体类同上，StudentMapper.xml先查询Student表 1234567891011121314&lt;mapper namespace="com.mkl.entity.StudentMapper"&gt; &lt;select id="getStudents2" resultMap="StudentTeacher2"&gt; SELECT * FROM student &lt;/select&gt; &lt;resultMap id="StudentTeacher2" type="Student" &gt; &lt;!-- 按查询嵌套的处理过程是：先SELECT从数据库取出数据，然后对应id和name赋值给Student实体类 tid则作为参数传给&lt;association&gt;的select属性的SQL语句，查出对应的Teacher赋值给Student的teacher属性 --&gt; &lt;association property="teacher" column="tid" javaType="Teacher" select="com.mkl.entity.TeacherMapper.getTeachers" /&gt; &lt;/resultMap&gt;&lt;/mapper&gt; TeacherMapper.xml如下 12345&lt;mapper namespace="com.mkl.entity.TeacherMapper"&gt; &lt;select id="getTeachers" resultType="Teacher" &gt; SELECT * FROM teacher WHERE id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 一对多关系的处理一个老师对应多个学生，就老师而言（实体类不是学生设置老师，而是老师设置学生的集合），数据关系是一对多的 不需要修改数据库表，修改实体类，把学生类的tid删除，然后为老师类添加List属性，List指定类型为Student 按结果嵌套处理 修改相关实体类，修改规则如上所述 mapper编写如下，按id联表查找出一个老师的所有列，返回类型是resultMap，Map指定collection子标签，collection指定studentList的实体类属性 1234567891011&lt;select id="getTeacher" resultMap="TeacherStudent"&gt; SELECT s.id sid, s.name sname, s.tid stid, t.id tid, t.name tname FROM student s, teacher t WHERE s.tid = t.id AND t.id = #&#123;id&#125;&lt;/select&gt;&lt;resultMap id="TeacherStudent" type="Teacher" &gt; &lt;id column="tid" property="id" /&gt; &lt;result column="tname" property="name" /&gt; &lt;collection property="studentList" ofType="Student"&gt; &lt;id column="sid" property="id" /&gt; &lt;result column="sname" property="name" /&gt; &lt;/collection&gt;&lt;/resultMap&gt; 获取SqlSession对象，selectOne方法获取Teacher对象即可 按查询嵌套处理 TeacherMapper 123456789101112&lt;!--先找出Teacher表，然后根据Teacher表的id作为参数传入到select子标签去查Student表根据select标签的SQL语句，Student表找出tid为id的Student，并构造出Student对象作为studentList的一份子--&gt;&lt;select id="getTeacher2" resultMap="TeacherStudent2" &gt; SELECT * FROM teacher WHERE id = #&#123;id&#125;&lt;/select&gt;&lt;resultMap id="TeacherStudent2" type="Teacher"&gt; &lt;collection property="studentList" javaType="ArrayList" ofType="Student" column="id" select="com.mkl.entity.StudentMapper.getStudents3" /&gt;&lt;/resultMap&gt; StudentMapper 123&lt;select id=&quot;getStudents3&quot; resultType=&quot;Student&quot;&gt; SELECT * FROM student WHERE tid = #&#123;id&#125;&lt;/select&gt; 获取SqlSession对象，selectOne方法获取Teacher对象即可 动态SQL动态SQL指根据不同的查询条件生成不同的SQL语句MyBatis使用了OGNL表达式来实现动态SQL官方文档简单又易懂，稍微看一下就会用了呢需要注意的是，对动态SQL传入参数的时候，要用Map来传参，例子如下 123456789101112&lt;select id="getStudentsByObject" resultType="Student"&gt; SELECT * FROM student &lt;where&gt; &lt;if test="id != null"&gt; id = #&#123;id&#125; &lt;/if&gt; &lt;if test="name != null"&gt; AND name = #&#123;name&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 1234567891011121314151617181920// StudentDao的方法public List&lt;Student&gt; getStudentsByObject(Map&lt;String, Object&gt; map) throws IOException &#123; SqlSession session = MyBatisUtil.getSqlSession(); String statement; statement = "com.mkl.entity.StudentMapper.getStudentsByObject"; List&lt;Student&gt; students = session.selectList(statement, map); session.close(); return students;&#125;// 单元测试的代码StudentDao studentDao = new StudentDao();// List&lt;Student&gt; students = studentDao.getStudentsByObject(null);Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();// 使用map传参map.put("name", "zs");List&lt;Student&gt; students = studentDao.getStudentsByObject(map);for (Student s : students) System.out.println(s); Mybatis注意事项 Maven导入包 1234567891011&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt; 配置conf.xml时要指定serverTimezone，分隔符要用&amp;amp;代替 IDEA查找接口实现类的时候，可以通过在接口的源码界面ctrl+alt+B查找]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java异常]]></title>
    <url>%2F2019%2F05%2F22%2FJava%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[Java异常异常分类 Error类层次结构描述了Java运行时系统的内部错误和资源耗尽错误，应用程序不应该抛出这种类型的对象 Exception分为RuntimeException和IOException，RuntimeException是程序错误导致的异常，有下面几种情况 错误的类型转换 数组访问越界 访问null指针 不是派生于RuntimeException的有 试图在文件尾部后读取数据 试图打开一个不存在的文件 试图根据给定的字符串查找Class对象，而这个字符串表示的类并不存在 Java语言规范将派生于Error或RuntimeException类的所有异常称为非受查异常，所有其他异常称为受查异常，一个方法必须声明所有可能抛出的受查异常，非受查异常要么不可控制（Error），要么避免发生（RuntimeException），编译器会核实是否为所有受查异常提供了异常处理器 声明受查异常e.g.public FileInputStream(String name) throws FileNotFoundException，这个声明表示这个构造器将根据给定的String参数产生一个FileInputStream对象，但也有可能抛出一个FileNotFoundException异常，抛出异常后，运行时系统就会开始搜索异常处理器，以便知道如何处理FileNotFoundException对象 自己编写方法时，不必将所有可能抛出的异常都进行声明，什么时候需要在方法中throws子句声明异常，什么异常必须使用throws子句声明，需要记住遇到下面4种情况应该抛出异常 调用一个抛出受查异常的方法，例如FileInputStream构造器 程序运行过程中发现错误，并且利用throw语句抛出一个受查异常（注意不是方法中的throws） 程序出现错误，比如a[-1]=0会抛出一个ArrayIndexOutOfBoundsException这样的非受查异常 Java虚拟机和运行时库出现的内部错误 不需要声明Java的内部错误，即Error继承的错误，也不应该声明RuntimeException继承的非受查异常 1234class MyAnimation &#123; ... void drawImage(int i) throws ArrayIndexOutOfBoundsException // bad style&#125; 抛出异常语法：throw new IOException(); e.g. 12345678String readData(Scanner in) throws EOFException &#123; ... while(...) &#123; if (!in.hasNext()) &#123; throw new EOFException(); &#125; &#125;&#125; 步骤： 找到一个合适的异常类 创建这个类的一个对象 throw语句抛出 捕获异常try，catch，finally语句，不多说了 如果超类没有抛出任何异常，子类也不能抛出任何异常，如果编写一个覆盖超类的方法，这个方法又没有抛出异常，就必须捕获方法代码种出现的每一个受查异常]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring04-AspectJ]]></title>
    <url>%2F2019%2F05%2F22%2FSpring04-AspectJ%2F</url>
    <content type="text"><![CDATA[Spring04-AspectJ源代码在这 @AspectJ的风格类似于纯Java注解的普通Java类 Spring可以使用AspectJ来做切入点解析 AOP的运行时仍旧是纯的Spring AOP，对AspectJ的编译器或者织入无依赖性 Enabling @AspectJ Support对@AspectJ支持可以使用XML或Java风格的配置 Java注解方式1234@Configuration@EnableAspectJAutoProxypublic class AppConfig &#123;&#125; XML配置1&lt;aop:aspectj-autoproxy /&gt; Declaring an aspect@AspectJ切面使用@Aspect注解配置，拥有@Aspect的任何bean将被Spring自动识别并应用，用@Aspect注解的类可以有方法和字段，他们也可能包括切入点（pointcut），通知（advice）和引入（introduction）声明，@Aspect注解不能通过类路径自动检测发现，需要配合使用@Component注释或者在xml配置bean一个类中的@Aspect注解标识它为一个切面，并且将自己从自动代理中排除（假如切面类和业务类在同一包下，或者相同包的不同子包中，切入点的声明只声明了它们的基本包，声明了@Aspect的切面不会代理它自己，即检测到自己不会调用通知方法） 定义一个切面模板如下： 123&lt;bean id="myAspect" class="org.xyz.NotVeryUsefulAspect"&gt; &lt;!-- configure properties of aspect here as normal --&gt;&lt;/bean&gt; 1234567package org.xyz;import org.aspectj.lang.annotation.Aspect;@Aspectpublic class NotVeryUsefulAspect &#123;&#125; Declaring a pointcut一个切入点通过一个普通的方法定义来提供，并且切入点表达式使用@Pointcut注解，方法返回类型必须是void 下面定义一个名为anyOldTransfer，这个切入点将匹配任何名为”transfer”的方法的执行 12@Pointcut("execution(* transfer(..))")// the pointcut expressionprivate void anyOldTransfer() &#123;&#125;// the pointcut signature Supported Pointcut Designators execution - for matching method execution join points, this is the primary pointcut designator you will use when working with Spring AOP（匹配方法执行的切入点） within - limits matching to join points within certain types (simply the execution of a method declared within a matching type when using Spring AOP)（限定匹配特定类型的切入点） this - limits matching to join points (the execution of methods when using Spring AOP) where the bean reference (Spring AOP proxy) is an instance of the given type（匹配特定切入点的bean引用是指定类型的实例的限制） target - limits matching to join points (the execution of methods when using Spring AOP) where the target object (application object being proxied) is an instance of the given type args - limits matching to join points (the execution of methods when using Spring AOP) where the arguments are instances of the given types @target - limits matching to join points (the execution of methods when using Spring AOP) where the class of the executing object has an annotation of the given type @args - limits matching to join points (the execution of methods when using Spring AOP) where the runtime type of the actual arguments passed have annotations of the given type(s) @within - limits matching to join points within types that have the given annotation (the execution of methods declared in types with the given annotation when using Spring AOP) @annotation - limits matching to join points where the subject of the join point (method being executed in Spring AOP) has the given annotation e.g. 123456789101112@Component@Aspectpublic class MoocAspect &#123; // 当检测到biz这个包里任何以Biz结尾的类的任何方法时，都会匹配当前这个切入点 @Pointcut("execution(* com.mkl.aop.aspectj.biz.*Biz.*(..))") public void pointcut() &#123;&#125; // 检测到biz这个包的任何类都会匹配到这个切入点 @Pointcut("within(com.mkl.aop.aspectj.biz.*)") public void bizPointcut() &#123;&#125;&#125; Combining pointcut expressions切入点表达式可以通过&amp;&amp;，||和!进行组合，也可以通过名字引用切入点表达式，通过组合，可以建立更加复杂的切入点表达式 12345678@Pointcut("execution(public * *(..))")private void anyPublicOperation() &#123;&#125;@Pointcut("within(com.xyz.someapp.trading..*)")private void inTrading() &#123;&#125;@Pointcut("anyPublicOperation() &amp;&amp; inTrading()")private void tradingOperation() &#123;&#125; 定义良好的pointcutsAspectJ是编译器的AOP，检查代码并匹配连接点与切入点的代价是昂贵的 一个好的切入点应该包括以下几点 选择特定类型的连接点，如：execution,get,set,call,handler 确定连接点范围，如：within,withincode 匹配上下文信息，如：this,target,@annotation Before adviceBefore advice is declared in an aspect using the @Before annotation: 123456789@Aspectpublic class BeforeExample &#123; @Before("com.xyz.myapp.SystemArchitecture.dataAccessOperation()") public void doAccessCheck() &#123; // ... &#125;&#125; If using an in-place pointcut expression we could rewrite the above example as: 123456789@Aspectpublic class BeforeExample &#123; @Before("execution(* com.xyz.myapp.dao.*.*(..))") public void doAccessCheck() &#123; // ... &#125;&#125; Before Advice的小DEMO12345678&lt;!-- spring-aop-aspectj.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans ...&gt; &lt;context:component-scan base-package="com.mkl.aop.aspectj" /&gt; &lt;aop:aspectj-autoproxy /&gt;&lt;/beans&gt; 12345678910111213141516171819202122232425262728293031323334// MoocBiz.java@Servicepublic class MoocBiz &#123; public String save(String arg) &#123; System.out.println("MoocBiz save: " + arg); return "Save success"; &#125;&#125;// MoocAspect.java@Component@Aspectpublic class MoocAspect &#123; @Pointcut("execution(* com.mkl.aop.aspectj.biz.*Biz.*(..))") public void pointcut() &#123;&#125;// @Before("execution(* com.mkl.aop.aspectj.biz.*Biz.*(..))") @Before("com.mkl.aop.aspectj.MoocAspect.pointcut()") public void before() &#123; System.out.println("Before"); &#125;&#125;// 单元测试方法@Testpublic void test() &#123; MoocBiz biz = super.getBean("moocBiz"); biz.save("This is test");&#125;// 输出：// Before// MoocBiz save: This is test After returning advice123456789@Aspectpublic class AfterReturningExample &#123; @AfterReturning("com.xyz.myapp.SystemArchitecture.dataAccessOperation()") public void doAccessCheck() &#123; // ... &#125;&#125; 有时候需要在通知体内得到返回的实际值，可以使用@AfterReturning绑定返回值的形式，这里的返回值指的是连接点指定的方法，即被通知的方法的返回值，把该返回值作为参数传递给通知 1234567891011@Aspectpublic class AfterReturningExample &#123; @AfterReturning( pointcut="com.xyz.myapp.SystemArchitecture.dataAccessOperation()", returning="retVal") public void doAccessCheck(Object retVal) &#123; // ... &#125;&#125; AfterReturning的小DEMO大部分和Before advice的一样 12345678910111213141516171819202122232425@Servicepublic class MoocBiz &#123; public String save(String arg) &#123; System.out.println("MoocBiz save: " + arg); return "Save success"; &#125;&#125;@Component@Aspectpublic class MoocAspect &#123; @Pointcut("execution(* com.mkl.aop.aspectj.biz.*Biz.*(..))") public void pointcut() &#123;&#125; @AfterReturning(pointcut = "com.mkl.aop.aspectj.MoocAspect.pointcut()", returning = "returnValue") public void afterReturning(Object returnValue) &#123; System.out.println("AfterReturning : " + returnValue); &#125;&#125;// 输出结果：（Save success是MoocBiz的save方法的返回值）// MoocBiz save: This is test// AfterReturning : Save success After throwing advice123456789@Aspectpublic class AfterThrowingExample &#123; @AfterThrowing("com.xyz.myapp.SystemArchitecture.dataAccessOperation()") public void doRecoveryActions() &#123; // ... &#125;&#125; Often you want the advice to run only when exceptions of a given type are thrown, and you also often need access to the thrown exception in the advice body. Use the throwing attribute to both restrict matching (if desired, use Throwable as the exception type otherwise) and bind the thrown exception to an advice parameter. 123456789101112@Aspectpublic class AfterThrowingExample &#123; // The name used in the throwing attribute must correspond to the name of a parameter in the advice method. @AfterThrowing( pointcut="com.xyz.myapp.SystemArchitecture.dataAccessOperation()", throwing="ex") public void doRecoveryActions(DataAccessException ex) &#123; // ... &#125;&#125; After throwing advice的小DEMO12345678910111213141516171819202122232425262728@Servicepublic class MoocBiz &#123; public String save(String arg) &#123; System.out.println("MoocBiz save: " + arg); throw new RuntimeException("Save failed!");// return "Save success"; &#125;&#125;@Component@Aspectpublic class MoocAspect &#123; @AfterThrowing(pointcut = "com.mkl.aop.aspectj.MoocAspect.pointcut()", throwing = "e") public void afterThrowing(RuntimeException e) &#123; System.out.println("AfterThrowing： " + e.getMessage()); &#125;&#125;@Testpublic void test() &#123; MoocBiz biz = super.getBean("moocBiz"); biz.save("This is test");&#125;// MoocBiz save: This is test// AfterThrowing： Save failed! After (finally) advice最终通知必须准备处理正常和异常两种返回情况，它通常用于释放资源 123456789@Aspectpublic class AfterFinallyExample &#123; @After("com.xyz.myapp.SystemArchitecture.dataAccessOperation()") public void doReleaseLock() &#123; // ... &#125;&#125; Around advice环绕通知使用@Around注解来声明，通知方法的第一个参数必须是ProceedingJoinPoint类型，在通知内部调用ProceedingJoinPoint的proceed()方法会导致执行真正的方法，传入一个Object[]对象，数组中的值将被作为参数传递给该方法，Object retVal是真正方法的返回值 123456789101112@Aspectpublic class AroundExample &#123; @Around("com.xyz.myapp.SystemArchitecture.businessService()") public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable &#123; // start stopwatch Object retVal = pjp.proceed(); // stop stopwatch return retVal; &#125;&#125; Advice扩展给advice传递参数1234567891011121314@Before("com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp; args(account,..)")public void validateAccount(Account account) &#123; // ...&#125;// 也可以先给pointcut传递参数，再通过pointcut把参数传递给advice@Pointcut("com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp; args(account,..)")private void accountDataAccessOperation(Account account) &#123;&#125;@Before("accountDataAccessOperation(account)")public void validateAccount(Account account) &#123; // ...&#125; 前两种方法是把切入点的方法的参数通过args(..)，作为参数传递给通知，让通知可以得到被通知的方法的参数 第三种方法是，首先定义一个注解 12345@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface Auditable &#123; AuditCode value();&#125; 然后在advice中引用这个注解 12345@Before("com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; @annotation(auditable)")public void audit(Auditable auditable) &#123; AuditCode code = auditable.value(); // ...&#125; 具体流程是：首先按上面的模板定义一个注解MyAnnotation，然后在切入点的方法中使用这个注解并传入参数，然后在advice添加@Before(&quot;xxx &amp;&amp; @annotation(myAnnotation)&quot;)，然后给advice添加参数public void advice(MyAnnotation myAnnotation)，注解的value就可以通过该参数传递给通知了（注解的value在切入点方法中定义，在通知中使用） 使用注解的DEMO123456789101112131415161718192021222324252627282930313233343536373839404142@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface MoocMethod &#123; String value();&#125;@Component@Aspectpublic class MoocAspect &#123; @Pointcut("execution(* com.mkl.aop.aspectj.biz.*Biz.*(..))") public void pointcut() &#123;&#125; @Before("pointcut() &amp;&amp; @annotation(moocMethod)") public void beforeWithAnnotation(MoocMethod moocMethod) &#123; System.out.println("BeforeWithParam: " + moocMethod.value()); &#125;&#125;@Servicepublic class MoocBiz &#123; @MoocMethod("MoocBiz save MoocMethod.") public String save(String arg) &#123; System.out.println("MoocBiz save: " + arg);// throw new RuntimeException("Save failed!"); return "Save success"; &#125;&#125;@Testpublic void test() &#123; MoocBiz biz = super.getBean("moocBiz"); biz.save("This is test");&#125;// 输出结果/*BeforeWithParam: MoocBiz save MoocMethod.MoocBiz save: This is test*/ 其他的Advice扩展比如对泛型的处理，通过argNames决定参数名称，都可以去看Spring-5.0.14官方文档 Introductions允许一个切面声明一个通知对象实现指定接口，并提供一个接口实现类来代表这些对象 introduction使用@DeclareParents进行注解，这个注解用来定义匹配的类型拥有一个新的parent e.g.给定一个接口UsageTracked，并且该接口拥有DefaultUsageTracked的实现，接下来的切面声明了所有的service包下的类的实现都实现了UsageTracked接口 123456789101112@Aspectpublic class UsageTracking &#123; @DeclareParents(value="com.xzy.myapp.service.*+", defaultImpl=DefaultUsageTracked.class) public static UsageTracked mixin; @Before("com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; this(usageTracked)") public void recordUsage(UsageTracked usageTracked) &#123; usageTracked.incrementUseCount(); &#125;&#125; 切面实例化模型“perthis”切面通过指定@Aspect注解perthis子句实现每个独立的service对象执行时都会创建一个切面实例service对象的每个方法在第一次执行的时候创建切面实例，切面在service对象失效的同时失效 1234567891011@Aspect("perthis(com.xyz.myapp.SystemArchitecture.businessService())")public class MyAspect &#123; private int someState; @Before(com.xyz.myapp.SystemArchitecture.businessService()) public void recordServiceUsage() &#123; // ... &#125;&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>AOP</tag>
        <tag>切面</tag>
        <tag>切入点</tag>
        <tag>通知</tag>
        <tag>AspectJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring03-AOP基本概念]]></title>
    <url>%2F2019%2F05%2F21%2FSpring03-AOP%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[Spring03-AOP基本概念源代码在这 基本概念什么是AOP？AOP：Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术主要功能：日志记录，性能统计，安全控制，事务管理，异常处理等等 AOP实现方式 预编译：AspectJ 运行期动态代理（JDK动态代理，CGLib动态代理）：SpringAOP，JbossAOP AOP几个相关概念 名称 说明 切面Aspect 一个关注点的模块化，这个关注点可能会横切多个对象 连接点Joinpoint 程序执行过程中的某个特定的点（比如某个类的方法） 通知Advice 在切面的某个特定的连接点上执行的动作（比如上述方法执行时额外执行的切面的动作） 切入点Pointcut 匹配连接点的断言，在AOP中通知和一个切入点表达式关联（如何在切面中去匹配一个连接点） 引入Introduction 在不修改类代码前提下，为类添加新的方法和属性 目标对象Target Object 被一个或者多个切面所通知的对象 AOP代理AOP Proxy AOP框架创建的对象，用来实现切面契约（包括通知方法执行等功能） 织入Weaving 把切面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象，分为：编译时织入，类加载时织入，执行时织入 通知Advice的类型 名称 说明 前置通知 在某连接点之前执行的通知，但不能阻止连接点前的执行（除非它抛出异常） 返回后通知 在某连接点正常完成后执行的通知 抛出异常后通知 在方法抛出异常退出时执行的通知 后通知 当某连接点退出的时候执行的通知（不论是正常返回还是异常退出） 环绕通知 包围一个连接点的通知 Spring框架中AOP的用途 提供了声明式的企业服务，特别是EJB的代替服务的声明 允许用户定制自己的方面，以完成OOP与AOP的互补使用 Spring的AOP的实现 纯Java实现，无需特殊的编译过程，不需要控制类加载器层次 目前只支持方法执行连接点（通知Spring Bean的方法执行） 不是为了提供最完整的AOP实现，而是侧重于提供一种AOP实现和Spring IoC容器之间的整合，用于帮助解决企业应用中常见的问题 Spring AOP不会与AspectJ竞争，从而提供综合全面的AOP解决方案 有接口和无接口的Spring AOP实现区别 Spring AOP默认使用标准的JavaSE动态代理作为AOP代理，使得任何接口都可以被代理 Spring AOP中也可以使用CGLIB代理（如果一个业务对象并没有实现一个接口） Schema-base的AOP实现官方文档的schema-based AOP support 看官方文档写的挺全的，也不难懂 schema-defined aspects只支持singleton model Declaring an aspect基于使用配置的AOP实现Spring所有的切面和通知器都必须放在一个&lt;aop:config&gt;内（可以配置多个），每个&lt;aop:config&gt;可以包含pointcut，advisor和aspect元素（它们必须按照这个顺序进行声明） 12345678910&lt;!-- 把下面的bean作为一个AOP声明 --&gt;&lt;aop:config&gt; &lt;aop:aspect id="myASpect" ref="aBean"&gt; ... &lt;/aop::aspect&gt;&lt;/aop:config&gt;&lt;bean id="aBean" class="..."&gt; ...&lt;/bean&gt; Declaring a pointcut官方文档里面上一节AspectJ support的切入点基本包括了所有的切入点表达式 A named pointcut can be declared inside an aop:config element, enabling the pointcut definition to be shared across several aspects and advisors. 123456&lt;aop:config&gt; &lt;aop:pointcut id="businessService" expression="execution(* com.xyz.myapp.service.*.*(..))"/&gt;&lt;/aop:config&gt; Declaring a pointcut inside an aspect is very similar to declaring a top-level pointcut: 123456789101112&lt;aop:config&gt; &lt;aop:aspect id="myAspect" ref="aBean"&gt; &lt;aop:pointcut id="businessService" expression="execution(* com.xyz.myapp.service.*.*(..))"/&gt; ... &lt;/aop:aspect&gt;&lt;/aop:config&gt; Declaring advice可以在&lt;aop:before&gt;中指定pointcut-ref，该ref为aop:pointcut的id，method为&lt;aop:aspect&gt;指定的bean的方法 Before advice123456789&lt;aop:aspect id="beforeExample" ref="aBean"&gt; &lt;aop:before pointcut-ref="dataAccessOperation" method="doAccessCheck"/&gt; ...&lt;/aop:aspect&gt; 也可以直接在&lt;aop:before&gt;中直接指定pointcut 123456789&lt;aop:aspect id=&quot;beforeExample&quot; ref=&quot;aBean&quot;&gt; &lt;aop:before pointcut=&quot;execution(* com.xyz.myapp.dao.*.*(..))&quot; method=&quot;doAccessCheck&quot;/&gt; ...&lt;/aop:aspect&gt; After returning advice123456789&lt;aop:aspect id="afterReturningExample" ref="aBean"&gt; &lt;aop:after-returning pointcut-ref="dataAccessOperation" method="doAccessCheck"/&gt; ...&lt;/aop:aspect&gt; Just as in the @AspectJ style, it is possible to get hold of the return value within the advice body. Use the returning attribute to specify the name of the parameter to which the return value should be passed: 12345678910&lt;aop:aspect id="afterReturningExample" ref="aBean"&gt; &lt;aop:after-returning pointcut-ref="dataAccessOperation" returning="retVal" method="doAccessCheck"/&gt; ...&lt;/aop:aspect&gt; The doAccessCheck method must declare a parameter named retVal. The type of this parameter constrains matching in the same way as described for @AfterReturning. For example, the method signature may be declared as: public void doAccessCheck(Object retVal) {... After throwing advice123456789&lt;aop:aspect id="afterThrowingExample" ref="aBean"&gt; &lt;aop:after-throwing pointcut-ref="dataAccessOperation" method="doRecoveryActions"/&gt; ...&lt;/aop:aspect&gt; Just as in the @AspectJ style, it is possible to get hold of the thrown exception within the advice body. Use the throwing attribute to specify the name of the parameter to which the exception should be passed: 12345678910&lt;aop:aspect id="afterThrowingExample" ref="aBean"&gt; &lt;aop:after-throwing pointcut-ref="dataAccessOperation" throwing="dataAccessEx" method="doRecoveryActions"/&gt; ...&lt;/aop:aspect&gt; The doRecoveryActions method must declare a parameter named dataAccessEx. The type of this parameter constrains matching in the same way as described for @AfterThrowing. For example, the method signature may be declared as: public void doRecoveryActions(DataAccessException dataAccessEx) {... After (finally) adviceAfter (finally) advice runs however a matched method execution exits. It is declared using the after element: 123456789&lt;aop:aspect id="afterFinallyExample" ref="aBean"&gt; &lt;aop:after pointcut-ref="dataAccessOperation" method="doReleaseLock"/&gt; ...&lt;/aop:aspect&gt; Around adviceIt has the opportunity to do work both before and after the method executes, and to determine when, how, and even if, the method actually gets to execute at all. Around advice is often used if you need to share state before and after a method execution in a thread-safe manner (starting and stopping a timer for example). Always use the least powerful form of advice that meets your requirements; don’t use around advice if simple before advice would do. Around advice is declared using the aop:around element. The first parameter of the advice method must be of type ProceedingJoinPoint. Within the body of the advice, calling proceed() on the ProceedingJoinPoint causes the underlying method to execute. The proceed method may also be calling passing in an Object[] - the values in the array will be used as the arguments to the method execution when it proceeds. 123456789&lt;aop:aspect id="aroundExample" ref="aBean"&gt; &lt;aop:around pointcut-ref="businessService" method="doBasicProfiling"/&gt; ...&lt;/aop:aspect&gt; 123456public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable &#123; // start stopwatch Object retVal = pjp.proceed(); // stop stopwatch return retVal;&#125; Advice parametersAdvice可以传入参数，如下面例子，指定切面为MoocAspect，切入点为* com.mkl.aop.schema.advice.biz.AspectBiz.init(String, int)，注意表达式pointcut=&quot;execution(* com.mkl.aop.schema.advice.biz.AspectBiz.init(String, int)) and args(bizName, times)&quot;，表示指定切入点，并且把切入点的参数作为通知的参数传入给通知，切面的通知方法aroundInit除了一个ProceedingJoinPoint参数，还要有一个String bizName，int times参数，通知的参数名必须要和表达式的args里面的参数名一致 执行AspectInit的init方法的时候，会有MoocAspect切面的通知来临，并把init方法的参数传递给该通知作为该通知的参数，需要注意配置的时候，切入点的args(arg1, arg2, …)的arg1,arg2,…必须要和切面对应通知方法的参数名对应起来 1234567&lt;bean id="moocAspect" class="com.mkl.aop.schema.advice.MoocAspect" /&gt;&lt;bean id="aspectBiz" class="com.mkl.aop.schema.advice.biz.AspectBiz" /&gt;&lt;aop:config&gt; &lt;aop:aspect id="moocAspectAOP" ref="moocAspect"&gt; &lt;aop:around method="aroundInit" pointcut="execution(* com.mkl.aop.schema.advice.biz.AspectBiz.init(String, int)) and args(bizName, times)" /&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 123456789101112131415161718192021222324252627public class AspectBiz &#123; public void init(String bizName, int times) &#123; System.out.println("AspectBiz init: " + bizName + " " + times); &#125;&#125;public class MoocAspect &#123; public Object aroundInit(ProceedingJoinPoint pjp, String bizName, int times) throws Throwable &#123; System.out.println(bizName + " " + times + " before"); Object retVal = pjp.proceed(); System.out.println(bizName + " " + times + " after"); return retVal; &#125;&#125;// 单元测试方法@Testpublic void testInit() &#123; AspectBiz biz = super.getBean("aspectBiz"); biz.init("moocService", 3);&#125;/*moocService 3 beforeAspectBiz init: moocService 3moocService 3 after*/ 一个切面，切入点和通知整合的schema-based AOP的例子123456789101112&lt;aop:config&gt; &lt;aop:aspect id="moocAspectAOP" ref="moocAspect"&gt; &lt;aop:pointcut id="moocPointcut" expression="execution(* com.mkl.aop.schema.advice.biz.*Biz.*(..))" /&gt; &lt;aop:before method="before" pointcut-ref="moocPointcut" /&gt; &lt;aop:after-returning method="afterReturning" pointcut-ref="moocPointcut" /&gt; &lt;aop:after-throwing method="afterThrowing" pointcut-ref="moocPointcut" /&gt; &lt;aop:after method="after" pointcut-ref="moocPointcut" /&gt; &lt;aop:around method="around" pointcut-ref="moocPointcut" /&gt; &lt;aop:around method="aroundInit" pointcut="execution(* com.mkl.aop.schema.advice.biz.AspectBiz.init(String, int)) and args(bizName, times)" /&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; Introductions简介允许一个切面声明一个实现指定接口的通知对象，并且提供了一个接口实现类来代表这些对象 An introduction is made using the aop:declare-parents element inside an aop:aspect This element is used to declare that matching types have a new parent (hence the name).（此元素用于声明匹配类型具有新父级） 看一个例子，下面xml中types-matching就是匹配的类型，即上文中实现指定接口的通知对象，implement-interface就是指定接口，default-impl就是接口的实现类，它把匹配到的类型声明一个新的父级，该父级就是接口Fit，可以通过强制转换调用父级的方法 123456789&lt;bean id="moocAspect" class="com.mkl.aop.schema.advice.MoocAspect" /&gt;&lt;bean id="aspectBiz" class="com.mkl.aop.schema.advice.biz.AspectBiz" /&gt;&lt;aop:config&gt; &lt;aop:aspect id="moocAspectAOP" ref="moocAspect"&gt; &lt;aop:declare-parents types-matching="com.mkl.aop.schema.advice.biz.*(+)" implement-interface="com.mkl.aop.schema.advice.Fit" default-impl="com.mkl.aop.schema.advice.FitImpl" /&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 1234567891011121314151617181920212223242526// AspectBiz.java不重要，随意// Fit.javapublic interface Fit &#123; void filter();&#125;// FitImpl.javapublic class FitImpl implements Fit &#123; @Override public void filter() &#123; System.out.println("FitImpl filter"); &#125;&#125;// 单元测试方法@Testpublic void testFit() &#123; Fit fit = (Fit) super.getBean("aspectBiz"); fit.filter();&#125;// 输出：// FitImpl filter Advisorsadvisor就像一个小的自包含的方面，只有一个advice 切面自身通过一个bean表示，并且必须实现某个advice接口，同时，advisor也可以很好的利用AspectJ的切入点表达式 Spring通过配置文件中&lt;aop:advisor&gt;元素支持advisor实际使用，大多数情况下它会和transactional advice配合使用 为了定义一个advisor的优先级以便让advice可以有序，可以使用order属性来定义advisor的顺序，它的语法如下： 12345678910111213141516&lt;aop:config&gt; &lt;aop:pointcut id="businessService" expression="execution(* com.xyz.myapp.service.*.*(..))"/&gt; &lt;aop:advisor pointcut-ref="businessService" advice-ref="tx-advice"/&gt;&lt;/aop:config&gt;&lt;tx:advice id="tx-advice"&gt; &lt;tx:attributes&gt; &lt;tx:method name="*" propagation="REQUIRED"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 常见问题1.面向切面编写时报下面错误java.lang.NoClassDefFoundError: org/aspectj/weaver/reflect/ReflectionWorld$ReflectionWorldException原因：缺少aspectjweaver.jar这个包解决：maven查找该包导入]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>AOP</tag>
        <tag>切面</tag>
        <tag>切入点</tag>
        <tag>通知</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM性能调优]]></title>
    <url>%2F2019%2F05%2F18%2FJVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%2F</url>
    <content type="text"><![CDATA[JVM性能调优JVM参数 -Xmx：堆最大内存数 -Xms：堆初始化大小 -Xmn：堆新生代初始及最大大小 -Xss：线程栈大小 -XX:PermSize,-XX:MaxPermSize：方法区大小，永久代大小，JDK1.7之前适用 -XX:MaxDirectMemorySize：直接内存，默认大小与-Xmx大小一样 -XX:SurvivorRatio=n：Survivor与Eden大小的比例为2:n，n默认是8 -XX：NewRatio=n：年轻代(eden+2*survivor)和年老代比值为1:n -XX:+HeapDumpOnOutOfMemoryError：虚拟机出现内存溢出异常时Dump出当前内存堆转快照 Full GC对整个堆进行整理，包括年轻代，老年代，永久代，JVM调优要减少Full GC次数 导致Full GC原因 老年代被写满 持久代空间不足 System.gc()调用 CMS GC时出现promotion failed和concurrent mode failure 统计得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间 Minor GC年轻代的GC叫minor GC，老年代的GC叫Full GC 导致Minor GC原因 Eden区满，触发新生代Minor GC将Eden和非空闲Survivor存活的对象复制到另一个空闲Survivor中 当Survivor区满，通过Minor GC将对象复制到老年代 JVM性能调优方法和步骤 监控GC状态：使用各种JVM工具，查看当前日志，分析当前JVM参数设置，堆内存快照和GC日志，根据实际各区域划分和GC执行时间，判断是否进行优化 生成堆的dump文件 分析dump文件：用Visual VM等待工具 分析结果，判断是否需要优化：如果系统没有超时日志出现，GC频率不高耗时不高，没有必要进行优化 调整GC类型和内存分配 不断分析调整 JVM调优参数参考 针对JVM设置，一般可以通过-Xms -Xmx限定最小，最大值，防止垃圾收集器在最小最大之间收缩堆而产生额外的时间，通常把最大最小值设为相同的值 年轻代和老年代根据默认比例（1：2）分配堆内存，同样的，对于年轻代为了防止堆收缩，-XX:newSize,-XX:MaxNewSize设为相同大小 如果应用存在大量临时对象，应选择更大的年轻代，如果存在相对较多的持久对象，应选择年老代 配置较好的机器上（多核，大内存），可以为年老代选择并行收集算法：XX:+UseParallelOldGC 线程堆栈设置：默认1M，建议256K]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM参数</tag>
        <tag>FullGC与MinorGC</tag>
        <tag>JVM调优</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垃圾收集器与内存分配策略]]></title>
    <url>%2F2019%2F05%2F18%2F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[垃圾收集器与内存分配策略概述GC（Garbage Collection）考虑三个问题：哪些内存需要回收？什么时候回收？如何回收？ 程序计数器，虚拟机栈，本地方法栈随线程而生，随线程而灭，其中栈帧需要的内存是随着方法的进入和退出而有条不紊地执行者出栈和入栈操作，每一个栈帧分配多少内存是在类结构确定下来的时候就已知的，因此这几个区域的内存分配和回收都具备确定性，不需要过多考虑回收的问题。而方法区和堆的内存不一样，一个接口多个实现类需要的内存可能不一样，一个方法中多个分支需要的内存也可能不一样，只有在程序运行期间才知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器关注的是这部分的内存 GC分代分代的垃圾回收策略，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。在Java程序运行过程中，会产生大量的对象，其中有些对象是与业务信息有关的，比如Http请求的Session对象，Socket连接，它们的生命周期比较长，但是有些对象，主要是程序运行过程生成的，比如String对象，不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间，花费时间相对会比较长，但实际上，对长周期对象而言，这种遍历是没有效果的，因为可能进行了很多次遍历后他们依旧存在，因此分代垃圾回收采用分治的思想，把不同生命周期的对象放在不同代上，不同代采用适合它们的垃圾回收方式进行回收 GC分代分为年轻代，年老代和持久代，持久代一般在方法区，保存Java类的类信息，所有新生成的对象都是放在年轻代的，年轻代分为1个Eden区，2个Survivor区，年轻代经历N此垃圾回收后仍然存活的对象，会放到年老代 对象已死吗引用计数算法给对象添加一个引用计数器，每当一个地方引用它时，计数器就加1，当引用失效时，计数器就减1，任何时刻计数器为0的对象就是不可能再被使用的 它实现简单，判定效率也很高，但是很难解决对象之间相互循环引用的问题 如下： 1234567891011121314151617181920212223public class ReferenceCountingGC &#123; public Object instance = null; private static final int _1MB = 1024 * 1024; // 占点内存，以便GC日志看清是否被回收 private byte[] bigSize = new byte[2 * _1MB]; public static void main(String[] args) &#123; ReferenceCountingGC objA = new ReferenceCountingGC(); ReferenceCountingGC objB = new ReferenceCountingGC(); objA.instance = objB; // objA.instance引用了objB这片内存 objB.instance = objA; // objB.instance引用了objA这片内存 objA = null; // 令objA引用null objB = null; // 令objB引用null // 此时，新创建的2个ReferenceCountingGC实例因为互相引用，其引用计数值仍为1，但没有其他引用引用它们，即它们是不可达的 System.gc(); &#125;&#125; 对象objA和objB都有字段instance，赋值令objA.instance = objB及objB.instance = objA;，除此之外这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但因为它们之间互相引用对方，导致它们的引用计数都不为0，引用计数法无法通知GC收集器回收它们 可达性分析算法Java的主流实现就是可达性分析算法，这个算法基本思想是通过一系列称为”GC Roots”的对象作为起始点，从这些节点开始往下搜索。搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（图论知识来说，就是从GC Roots到这个对象不可达），证明此对象是不可用的 Java中，GC Roots对象包括下面几种 虚拟机栈（栈帧的本地变量表）中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈JNI（Native方法）引用的对象 再谈引用在JDK 1.2之前，Java引用的定义很传统：如果reference类型的数据中存储的数值代表另外一块内存的起始地址，就称这块内存代表一个引用，在1.2之后，Java对引用的概念进行了扩充，将引用分为强引用，软引用，弱引用，虚引用4种 强引用：程序代码之中普遍存在的，类似Object obj = new Object()的引用，只要强引用还存在，垃圾收集器就永远不会回收被引用的对象 软引用：描述一些还有用但并非必需的对象，对于软引用关联的对象，在系统将要发生内存溢出溢出之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收完还没有足够的内存，才会抛出内存溢出异常。JDK 1.2后提供了SoftReference类实现软引用 弱引用：也是描述非必需对象的，强度比软引用更弱，只能生存到下次垃圾回收发生之前，WeakReference类实现弱引用 虚引用：最弱的引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通知虚引用来取得一个对象实例，为一个对象设置虚引用的唯一目的是能在这个对象被收集器回收时收到一个系统通知，PhantomReference类实现虚引用 生存还是死亡可达性分析算法中不可达的对象，并不一定真的会死亡，要真正宣告一个对象死亡，至少经历两次标记过程，如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法，当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用，虚拟机将这两种情况视为”没有必要执行” 如果这个对象被判定为有必要执行finalize()方法，那么这个对象就会被放置在一个叫F-Queue的队列中，并在稍后由一个虚拟机自动建立的，低优先级的Finalizer线程去执行它，”执行”指虚拟机会触发这个方法，但不承诺会等待它运行结束，原因是：如果一个对象在finalize()方法执行缓慢，或者发生死循环，很可能导致F-Queue队列的其他对象永久处于等待，甚至整个内存回收系统崩溃。稍后GC对F-Queue中的对象进行第二次小规模的标记，对象如果在finalize()方法中重新与引用链上的任何一个对象关联（this赋值给某个类变量或者对象的成员变量），那么第二次标记时它将被移除出”即将回收”的集合，finalize()方法只会被调用一次，它是C/C++的一种妥协，尽量不要使用它，用try-finally或者其他方法会更好 回收方法区堆中，尤其是新生代中，常规应用一次垃圾收集一般可以回收70%——95%的空间，而永久代（方法区）的垃圾收集效率远低于此 永久代的垃圾收集主要回收两部分：废弃常量和无用的类，回收废弃常量和回收Java堆中的对象非常类似，常量池中字面量回收为例，假如字符串”abc”已经进入常量池，但是没有任何String对象引用常量池的”abc”，也没有其他地方引用这个字面量，如果这时发生内存回收，且必要的话，”abc”就会被系统清理出常量池，常量池其他类，接口，方法，字段的符号引用也与此类似 判断类是否为无用的类，要满足下面三个条件 该类所有实例已经被回收，Java堆中不存在该类任何实例 加载该类的ClassLoader已经被回收 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法 垃圾回收算法标记-清除算法首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象，标记过程前面有说。主要两个不足：标记和清除的效率都不高，标记清除后会产生大量不连续内存碎片，导致分配较大对象时无法得到足够的内存而触发另一次垃圾收集动作 复制算法为了解决效率问题，它将可用内存按容量划分为大小相等的两块，每次只使用其中一块，当一块内存用完，就将还存活的对象复制到另外一块上，然后把已使用的内存空间一次清理掉，这样使得每次都是对整个半区进行内存回收，内存分配时也不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，但代价是内存缩小为原来一半 现在商业虚拟机都采用这种收集算法回收新生代，实际应用并不需要1：1比例划分空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor，新建的对象都被分配到Eden区，经过第一次Minor GC后仍存活就放到Survivor区，当回收时，将Eden和Survivor中还存活的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才使用的过Survivor空间，HotSpot虚拟机默认Eden和Survivor大小比例是8：1，也就是每次新生代中可用的内存空间为整个新生代容量的90%(80%+10%)，没办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够时，需要依赖其他内存呢（老年代）进行分配担保 标记-整理算法复制收集算法在对象存活率比较高时要进行较多的复制操作，效率会变低，在老年代中，对象存活率会很高，不适合复制收集算法根据老年代的特点，可以使用标记-整理算法，标记过程与标记-清除算法的标记过程一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉端边界以外的内存 分代收集算法根据对象存活周期不同将内存划分为几块，一般是把Java堆分为新生代和老年代，新生代采用复制算法，老年代采用标记-清理或标记-整理算法 HotSpot的算法实现枚举根节点可达性分析中从GC Roots节点找引用链这个操作为例，可作为GC Roots的节点主要在全局性的引用（常量或类静态属性）与执行上下文（栈帧的本地变量表）中，现在很多应用仅仅方法区都有数百兆，如果逐个检查这里面的引用，那么必然消耗很多时间 另外，可达性分析对执行时间的敏感还体现在GC停顿上，因为这项工作必须在一个能确保一致性的快照中进行，一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上，不可能出现分析过程对象引用还在不断变化的情况 目前主流Java虚拟机使用的都是准确式GC，当执行系统停顿下来，并不需要一个不漏地检查完所有执行上下文和全局引用位置，而是有办法得知哪些地方存放对象引用，HotSpot中，使用一组OopMap数据结构达到这个目的，在类加载完成时，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，JIT编译过程中，也会特定位置记录下栈和寄存器哪些位置是引用，这样GC扫描时就可以得知这些信息了 安全点OopMap协助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个很现实的问题是，可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，就会需要大量额外的空间，GC的空间成本就会很高 实际上HotSpot只会在特定的位置记录这些信息，这些位置称为安全点，程序执行并非在所有地方都能停顿下来开始GC，只会在安全点才暂停，安全点的选择是以程序”是否具有让程序长时间执行的特征”为标准，例如方法调用，循环跳转，异常跳转等，具有这些功能的指令才会产生Safepoint Safepoint需要考虑的另一个问题是GC发生时所有线程都”跑”到最近安全点再停顿，主流的是主动式中断，思想是：当GC需要中断线程的时候，不直接对线程操作，仅仅简单设置一个标志，各个线程执行时主动轮询这个标志，发现中断标志为真时就自己中断挂起，轮询标志的地方和安全点是重合的 安全区域Safepoint机制保证程序执行时，在不太长时间内就会遇到可进入GC的Safepoint，但是程序不执行时，即没有分配CPU时间时（Sleep或Blocked）状态，这时线程无法响应JVM中断请求，”走”到安全的地方去中断挂起，就需要安全区域(Safe Region)来解决 安全区域指在一段代码片段里，引用关系不会发生变化。在这个区域任意地方开始的GC都是安全的，线程执行到Safe Region的代码时，首先标识自己已经进入Safe Region，这样当这段时间JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了，在线程离开Safe Region，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成，那程序就继续执行，否则它必须等待直到收到可以安全离开Safe Region的信号为止 垃圾收集器 上图展示了7种用于不同分代的垃圾收集器，如果两个收集器之间存在连线，表示它们可以搭配使用，虚拟机所处的区域表示它是新生代收集器还是老年代收集器 Serial收集器 单线程，垃圾收集时必须暂停其他所有工作线程直到收集结束，它是虚拟机运行在Client模式下的默认新生代收集器 ParNew收集器Serial的多线程版本，多条线程进行垃圾收集 左边是ParNew新生代收集器，右边是Serial Old老年代收集器 Parallel Scavenge收集器 它也是新生代收集器，也是使用复制算法的收集器，也是多线程收集器，与ParNew的主要区别是它的关注点不是缩短垃圾收集时用户线程的停顿时间，而是达到一个可控制的吞吐量，即CPU用于运行用户代码的时间与CPU总消耗时间的比值，吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间) 停顿时间越短越适合与用户交互的程序，良好的响应速度能提升用户体验，而提高吞吐量可以高效地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务 Serial Old收集器Serial收集器的老年代版本，使用标记-整理算法 Parallel Old收集器Parallel Scavenge收集器的老年代版本 CMS收集器CMS收集器是一种以获取最短回收停顿时间为目标的收集器，尤其重视响应速度，希望停顿时间最短，基于”标记-清除”算法实现，分为4个步骤 初始标记 并发标记 重新标记 并发清除 初始标记和重新标记需要”Stop The World”，初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记就是进行GC Roots Tracing的过程，重新标记是为了修正并发标记期间因用户程序继续运作而导致的标记产生变动的那一部分对象的标记记录，时间上会比初始标记稍长，但比并发标记短很多 三个缺点 CMS收集器对CPU资源很敏感，因为它是并发标记的，会占用一部分CPU资源而导致程序变慢，总吞吐量降低 无法处理浮动垃圾，可能出现”Concurent Mode Failure”失败而导致另一次Full GC的产生 基于”标记-清除”算法，产生大量空间碎片 G1收集器 JDK 1.7中HotSpot虚拟机的一个重要进化特征 具备如下特点 并行与并发：充分利用多CPU，多核环境，减短Stop-The-World停顿的时间 分代收集：不需要其他收集器就可以独立管理整个GC堆 空间整合：与CMS的”标记-清理”不同，G1从整体来看是基于”标记-整理”算法实现的，局部来看（两个Region之间）是基于”复制”算法实现 可预测的停顿：G1除了追求低停顿，还能建立可预测的停顿时间模型，让使用者明确指定长度M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒 G1收集器把JAVA堆内存划分为多个大小相等的独立区域（Region），虽然保留新生代和老年代概念，但新生代和老年代不再是物理隔离了，它们都是一部分Region的集合 G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得空间大小以及回收所需时间的经验值），在后台维护一个优先队列，每次根据允许的收集时间优先回收价值最大的Region（这也是Garbage-First名称的来由） G1收集器中，Region之间的对象引用以及其他收集器中的新生代与老年代的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描的。G1中每个Region都有一个与之对应的Remembered Set，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（分代例子就是检查老年代引用的对象引用了新生代的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中，当进行内存回收时，在GC根节点的枚举范围加入Remembered Set即可保证不对全堆扫描也不会有遗漏 不计算维护Remembered Set的操作，G1收集器的运作大致划分为以下步骤 初始标记 并发标记 最终标记 筛选回收 内存分配和回收策略使用Serial/Serial Old收集器的内存分配和回收策略 对象优先在Eden分配对象优先在Eden分配，当Eden没有足够空间时，虚拟机将发起一次Minor GC 大对象直接进入老年代大对象指需要大量连续内存空间的Java对象，最典型的是字符串和数组 长期存活的对象将进入老年代虚拟机给每个对象定义了一个对象年龄计数器，如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳，将被移动到Survivor空间，并且对象年龄设为1，对象在Survivor每经过一次Minor GC，年龄就加1岁，当年龄增加到一定程度（默认15岁），就晋升到老年代 动态对象年龄判定虚拟机并不是永远要求对象的年龄必须到达指定才晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象直接进入老年代 空间分配担保在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果成立，那么Minor GC可以确保是安全的，如果不成立，虚拟机会查看HandlePromotionFailure设置值是否允许担保失败，如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于就进行一次Minor GC，尽管这次GC是有风险的，如果小于，进行一次Full GC]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>垃圾收集</tag>
        <tag>内存分配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL索引]]></title>
    <url>%2F2019%2F05%2F17%2FMySQL%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[MySQL索引索引基础建立索引的目的是加快查询速度，数据库索引类似于图书后面的索引，能快速定位到需要查询的内容 索引能加速数据库查询，但需要占用一定存储空间，当基本表更新时，索引也要进行相应的维护，这些都会增加数据库负担 用户不能显式选择索引，索引是关系数据库管理系统的内部实现技术，属于内模式的范畴 用户对基本表建立某列的索引后，类似图书索引，键是索引的值，值是数据行的地址，e.g. 对Person表建立身份证号的索引后，SELECT 姓名,性别,年龄 FROM Person WHERE 身份证号=&#39;xxx&#39;也会用到索引（实际不一定，要看优化器的选择，一般索引不能覆盖我们要查询的信息时，还要通过书签去访问查找整行的数据信息，当访问的数据占整个表数据的蛮大一部分时(一般20%)，优化器会选择通过聚集索引(表扫描)来查找数据） 基本SQL语句建立索引CREATE INDEX indexName ON mytable(column(length)); 一般可以不指定length如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定length。 ALTER TABLE tableName ADD INDEX indexName(columnName) 123456789CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, INDEX [indexName] (column(length)) ); 一般来说，关键字KEY通常是INDEX同义词，上面所有创建INDEX的语句的INDEX关键字都可以换成KEY关键字，即ALTER TABLE sakila.city_demo ADD KEY (city(7))也是创建索引，索引为长度为7的city列ALTER TABLE sakila.city_demo ADD KEY yourIndexName(column(length)) 唯一索引唯一索引的索引值必须唯一，但允许有null，如果是组合索引，列值的组合必须唯一 CREATE UNIQUE INDEX indexName ON mytable(username(length)) ALTER table mytable ADD UNIQUE [indexName] (column(length)) 123456789CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, UNIQUE [indexName] (column(length)) ); 删除索引DROP INDEX [indexName] ON mytable; 使用ALTER添加和删除索引ALTER TABLE testalter_tbl ADD INDEX (c); ALTER TABLE testalter_tbl DROP INDEX c; 显示索引SHOW INDEX FROM table_name; 一个简单的索引查询例子执行SELECT first_name FROM sakila.actor WHERE actor_id = 5;如果在actor_id列上建有索引，则MySQL将使用该索引找到actor_id为5的行，也就是说，MySQL先在索引上按值查找，然后返回所有包含该值的数据行 建立高性能索引B+树概况对B+树的描述如下，可能细节会有些出入，但思想是一样的： **B+树叶结点包含信息，非叶结点只起索引作用，非叶结点每个索引项只含有对应子树最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址，叶结点包含所有关键字，即在非叶结点的关键字也会出现在叶结点对B+树可以有两种查找：从最小关键字开始的顺序查找和从根结点开始多路查找，根结点查找非叶结点时如果关键字等于给定值，不会终止查找，而是向下继续查找，直到叶结点上为止 B-Tree索引索引一般都是B-Tree索引或其变种，InnoDB引擎使用的是B+Tree，InnoDB索引根据主键引用被索引的行 B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同，很适合查找范围数据 B-Tree可以对&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN，以及不以通配符开始的LIKE使用索引 B-Tree索引能加快访问数据的速度，存储引擎不需要进行全表扫描来获取数据，只需要从索引的根结点开始搜索，通过比较节点页的值和要查找的值找到合适的指针进入下层节点，这些指针实际定义了子节点页中值的上限和下限，叶结点除了保存索引的值，还保存该索引指向的数据行的地址指针 假如有如下数据表 1234567CREATE TABLE People ( last_name varchar(50) not null, first_name varchar(50) not null, dob date not null, gender enum('m', 'f') not null, key(last_name, first_name, dob)); 索引包含了last_name，first_name和dob列的值，下面是B-Tree(技术上来说是B+Tree)索引的图例 索引对多个值进行排序的依据是CREATE TABLE语句定义索引时列的顺序，如果两个人姓和名都一样，则根据出生日期来排列顺序 B-Tree索引适用于全键值，键值范围或键前缀查找，其中键前缀查找只适用于根据最左前缀的查找，上述索引对如下类型的查询有效 匹配全值：和索引中所有列进行匹配，例如前面提到的索引可用于查找姓名为Cuba Allen，出生于1960-01-01的人 匹配最左前缀：可用于查找所有姓为Allen的人，即只使用索引的第一列 匹配列前缀：也可以只匹配某一列的值的开头部分，可以查找所有以J开头的姓的人，这里也只用了索引的第一列 匹配范围值：查找姓在Allen和Barrymore之间的人，只使用了索引的第一列 精确匹配某一列并范围匹配另外一列：查找所有姓为Allen，并且名以字母K开头的人，即第一列last_name全匹配，第二列first_name范围匹配 只访问索引的查询：查询只访问索引，而无须访问数据行 下面是一些关于B-Tree索引的限制： 查询必须从索引最左边的列开始，否则无法使用索引，例如不能用索引查询某一天出生的人 不能跳过某一索引列，例如不能利用索引查找last name为Smith且出生于某一天的人 不能使用索引中范围条件右边的列，例如，查询语句为`WHERE last_name=”Smith” AND first_name LIKS ‘J%’ AND dob=’1976-12-23’，该查询只会使用索引中的前两列 综上，实际只要知道多个列的索引的存储结构，怎么样的查询会使用到索引其实也就清楚了 哈希索引哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，同时在哈希表中保存每个数据行的指针，只有Memory引擎支持显式哈希索引 InnoDB引擎有一个特殊功能叫自适应哈希索引，当InnoDB注意道某些索引值被使用很频繁时，就会在内存中基于B-Tree索引之上再创建一个哈希索引，这是完全自动的，内部的行为 索引的优点例如B-Tree索引，是按照顺序存储数据的，所以MySQL也可以用来做ORDER BY和GROUP BY操作，因为数据是有序的，所以B-Tree会将相关列值存储在一起，最后，索引存储了实际的列值，所以某些查询只使用索引就能够完成全部查询，总结下来有如下3个优点： 索引大大减少了服务器需要扫描的数据量 索引可以帮助服务器避免排序和临时表 索引可以将随机I/O变成顺序I/O 索引的三星系统索引将相关记录放到一起则获得一星如果索引数据顺序和查找的排列顺序一致则获得二星如果索引的列包含了查询中需要的全部列则获得三星 高性能的索引策略独立的列指索引列不能是表达式的一部分，如 SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5; 上述查询无法使用actor_id的索引，MySQL无法自动解析这个方程式 要始终将索引列单独放在比较符号的一侧 前缀索引和索引选择性有时候需要索引很长的索引列，这会让索引变得大且慢，通常可以索引开始的部分字符，这样可以大大节约索引空间，提高索引效率，但会降低索引的选择性。索引选择性指不重复的索引值和数据表的记录总数的比值，索引选择性越高查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行 ALTER TABLE sakila.city_demo ADD KEY (city(7))创建长度为7的索引名为city的，列名为city的索引 ALTER TABLE sakila.city_demo ADD KEY yourIndexName(column(length)) 多列索引多列索引常见的错误是：为每个列都创建独立的索引，或者按错误顺序创建多列索引 12345678CREATE TABLE t ( c1 INT, c2 INT, c3 INT, KEY(c1), KEY(c2), KEY(c3)); 性能不会很好，比起最优索引可能差几个数量级，MySQL 5.0以上引入一个叫索引合并的策略，一定程度上可以使用表上多个单列索引来定位指定的行，例如，表file_actor在字段film_id和actor_id上各有一个单列索引，但对于下面的查询WHERE条件，这两个单列索引都不是很好的选择 SELECT film_id, actor_id FROM sakila.film_actor WHERE actor_id = 1 OR film_id = 1; 老版本的MySQL会对这个查询使用全表扫描（因为一次只能在一个索引树中查找，因为没有actor_id和film_id的联合索引，所以就全表查找了），除非改写成如下方式 1234SELECT film_id, actor_id FROM sakila.film_actor WHERE actor_id = 1UNION ALLSELECT film_id, actor_id FROM sakila.film_actor WHERE film_id = 1 AND actor_id &lt;&gt; 1; MySQL 5.0以上版本能够同时使用这两个单列索引进行扫描，将结果合并，这种算法有3个变种，OR的联合，AND的相交，组合前两种情况的联合及相交，下面查询使用了两个索引扫描的联合，在EXPLAIN中的Extra列可以看到这一点 1234567891011121314mysql&gt; EXPLAIN SELECT film_id, actor_id FROM sakila.film_actor WHERE actor_id = 1 OR film_id = 1\G; id: 1 select_type: SIMPLE table: film_actor partitions: NULL type: index_mergepossible_keys: PRIMARY,idx_fk_film_id key: PRIMARY,idx_fk_film_id key_len: 2,2 ref: NULL rows: 29 filtered: 100.00 Extra: Using union(PRIMARY,idx_fk_film_id); Using where 索引合并策略有时候是一种优化结果，但实际上更多时候说明表上的索引建的很糟糕 当服务器需要对多个索引做相交操作时（通常是多个AND），意味着需要一个包含所有相关列的多列索引，而不是多个单独的单列索引 当服务器需要对多个索引做联合操作时（通常由多个OR），通常需要消耗大量CPU和内存资源在算法的缓存，排序和合并操作上 优化器不会把这些计算到查询成本中，只关心随机页面读取，导致该执行计划还不如直接走全表扫描，要不就把查询改写成UNION的方式 选择合适的索引列顺序经验法则：将选择性最高的列放在索引最前列 以下面查询为例SELECT * FROM payment WHERE staff_id = 2 AND customer_id = 584; 可以通过SUM函数计算选择性的相对大小 1234SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,COUNT(DINSTINCT customer_id)/COUNT(*) AS customer_id_selectivity,COUNT(*)FROM payment\G; 聚簇索引聚簇索引是一种数据存储方式，而不是单独的索引类型，InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行 当表有聚簇索引时，它的数据行实际上存放在该聚簇索引的叶子页中，术语聚簇表示数据行和相邻的键值紧凑地存储在一起（逻辑相邻，物理不相邻），因为无法同时把数据行存放到两个不同的地方，所以一个表只能有一个聚簇索引，下面是一个聚簇索引的记录的存放显示，注意叶子页包含了行的全部数据，但是节点叶只有索引列，这里的索引列是整数值 innoDB通过主键聚集数据，如果没有定义主键，innoDB会选择一个唯一的非空索引代替，如果没有这样的索引，InnoDB会隐式定义一个主键作为聚簇索引 聚簇索引的优点 可以把相关数据保存在一起，例如电子邮箱，可以根据用户ID来聚集数据，这样只需要从磁盘读取少数的页就能够获取某个用户的全部邮件 数据访问更快，聚簇索引将索引和数据保存在同一个B-Tree中，获取数比非聚簇索引查找要快 使用覆盖索引扫描的查询可以直接使用页节点的主键值 覆盖索引一个索引包含所有要查询的字段的值，称为覆盖索引 冗余和重复索引重复索引：相同列上按相同顺序创建的相同类型的索引，应该避免重复索引，常见的重复索引有主键+唯一限制+索引，实际上MySQL的唯一限制和主键都是通过索引实现的，所以上面写法其实是创建了三个重复的索引 冗余索引：如果创建了索引(A,B)再创建(A)就是冗余索引，大部分情况不需要冗余索引]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL索引</tag>
        <tag>InnoDB</tag>
        <tag>聚簇索引</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列化]]></title>
    <url>%2F2019%2F05%2F16%2F%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[序列化基本定义对象序列化：将内存中保存的对象以二进制数据流的形式进行处理，可以实现对象的保存和网络传输（保存在文件或数据库） SerializableJava中要序列化的对象，必须实现接口java.io.Serializable，作为序列化的标记，它没有任何方法，它描述的是一种能力 serialVersionUIDprivate static final long serialVersionUID = 1L; 版本号用于表明类的不同版本的兼容性，默认是上面的值1L，反序列化时，JVM会把传来的字节流的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则出现序列化版本不一致的异常，serialVersionUID默认值依赖于Java编译器的实现，同一个类用不同的Java编译器，可能导致不同的serialVersionUID，可以显式的定义它，有2个用途 某些场合希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本有不同的serialVersionUID 当序列化一个类实例后，希望更改一个字段或添加一个字段，不设置serialVersionUID，所作的任何更改都导致无法反序列化旧实例，并在反序列化时抛出一个异常，如果添加了serialVersionUID，在反序列旧实例时，新添加或更改的字段值将设为初始化值，字段被删除将不设置 序列化和反序列化过程 类名 序列化：ObjectOutputStream 反序列化：ObjectInputStream 类定义 public class ObjectOutputStream extends OutputStream implements ObjectOutput, ObjectStreamConstants public class ObjectInputStream extends InputStream implements ObjectInput, ObjectStreamConstants 构造方法 ObjectOutputStream(OutputStream out) ObjectInputStream(InputStream in) 构造方法参数说明 Creates an ObjectOutputStream that writes to the specified OutputStream. Creates an ObjectInputStream that reads from the specified InputStream. 重要方法 writeObject(Object obj) readObject() 重要方法说明 Write the specified object to the ObjectOutputStream. Read an object from the ObjectInputStream. 12345678910111213141516@SuppressWarnings("serial")class Person implements Serializable &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return "姓名：" + this.name + "年龄：" + this.age; &#125;&#125; 实际开发中很少使用ObjectOutputStream和ObjectInputStream，因为容器会帮助开发者自动实现 transient关键字用法：private transient String xxx; 默认情况下执行了对象序列化时会将类中全部属性的内容进行全部序列化操作，但有时部分属性不需要进行序列化处理，这时可以在属性上定义使用transient关键字来完成对属性进行序列化后，属性的值是不会被保存下来的，读取对应属性的值是对应的默认值如果类中有一些需要计算保存的属性内容，往往不需要被序列化 序列化的代价Serializable接口最大代价是一旦一个类被发布，就大大降改变这个类的实现的灵活性 可能导致InvalidClassException如果没有显示声明序列版本UID，对对象需求进行了改动，那么兼容性就会破坏，运行时导致InvalidClassException，比如，增加一个不是很重要的工具方法，自动产生的序列版本UID也会发生变化，则会出现序列版本UID不一致的情况，所以最好还是显式增加序列版本号UID 增加了出现Bug和安全漏洞的可能性序列化机制是一个语言之外的对象创建机制，反序列化机制是一个”隐藏的构造器”，具备与其他构造器相同的特点，序列化之后的字节流可以被截取伪造，之后利用readObject()方法反序列会造成不安全的实例 随着类发行新的版本，测试负担会增加一个可序列化的类被修订时，需要检查是否”在新版本中序列化一个实例，可以在旧版本中反序列”，如果一个实现序列化的类有很多的子类或者是被修改时，就不得不加以测试 序列化的缺陷 序列化是保存对象的状态，也就是不会关心static静态域，静态域不会被序列化（静态变量在方法区，同一虚拟机访问反序列化的实例时，可以访问到静态变量） 序列化对象时，如果该对象中有引用对象域名，那么也要求该引用对象是可实例化的（即引用对象也要实现序列化接口），否则会报java.io.NotSerializableException错误]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存区域与内存溢出异常]]></title>
    <url>%2F2019%2F05%2F15%2FJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[Java内存区域与内存溢出异常运行时数据区域 程序计数器程序计数器可以看作当前线程所执行的字节码的行号指示器，在虚拟机概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令 由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，任一时刻一个处理器只会执行一条线程的指令，因此每个线程都有一个独立的程序计数器，它是线程私有的内存 如果线程执行的是java方法，计数器记录的是正在执行的虚拟机字节码指令的地址，如果执行的是Native方法，技术值为空，此内存区域没有规定任何OutOfMemoryError 虚拟机栈Java虚拟机栈也是线程私有的，它生命周期和线程相同。虚拟机栈描述的是java方法执行的内存模型，每个方法在执行的时候会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法出口等信息，每个方法从调用到执行完成的过程，对应一个栈帧在虚拟机栈中入栈到出栈的过程 局部变量表存放编译期可知的各种基本数据类型，对象引用和returnAddress类型，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，方法运行期间不会改变局部变量表的大小 虚拟机栈有两种异常状况：线程请求的栈深度大于虚拟机允许的深度时，抛出StackOverflowError，虚拟机栈动态扩展时无法申请到足够内存，抛出OutOfMemoryError 本地方法栈它也是线程私有的，它与虚拟机栈的区别是，虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，本地方法栈为虚拟机使用到的Native方法服务 堆Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，它的唯一目的是存放对象实例，几乎所有的对象实例都在这里分配内存 它是垃圾收集器管理的主要区域，它可以是物理上不连续的内存空间，只要逻辑上连续即可，会抛出OutOfMemoryError 方法区方法区也是线程共享的内存区域，用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据 运行时常量池它是方法区的一部分，用于存放编译期生成的各种字面量和符号引用，这部分内容在类加载后进入方法区的运行时常量池存放 字面量就是值，符号引用就是一个java类引用了另一个java类比如org.simple.People类引用了org.simple.Language类，编译时People并不知道Language的实际内存地址，只能用符号org.simple.Language表示Language的地址 HopSpot虚拟机对象以常用的虚拟机HotSpot和常用的内存区域Java堆为例，探讨HotSpot虚拟机在Java堆中对象分配布局和访问的过程 对象的创建虚拟机遇到一条new指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载，解析和初始化过，如果没有就必须先执行类加载过程类加载检查通过后，虚拟机为新生对象分配内存，分配内存即把一块确定大小的内存从Java堆中划分开，如果内存规整，用过的内存在一边，空闲内存在另一边，中间存放指针作为分界点指示器，分配内存只需要把指针挪动即可，称为指针碰撞，如果内存不规整，用空闲列表法分配除了内存分配，还要考虑线程安全的问题，如为对象A分配内存，指针还没修改时候对象B又同时使用原来的指针分配内存，解决方法一种是对分配内存空间同步处理，另一种是内存分配动作把内存分配动作按线程划分在不同的空间中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB），哪个线程需要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定内存分配完成后，虚拟机将分配到的内存空间都初始化为零值（TLAB的话可以提前到TLAB分配时进行），这一步保证了对象实例字段的默认值然后虚拟机堆对象进行必要的设置，比如这个对象是哪个类的实例，如何才能找到类的元数据信息，对象哈希码，GC分代年龄等信息，这些信息存放在对象的对象头中上面工作完成后，从虚拟机视角看，一个新的对象产生了，但从Java视角看，还需要执行&lt;init&gt;方法 总结：一个对象创建步骤如下 检查常量池是否有该类的符号引用，没有则类加载 分配内存，策略有空闲表法和指针碰撞 线程安全问题，分配内存动作同步或内存按线程划分（TLAB） 分配的内存空间初始化为0 设置对象头，存放类，元数据，哈希码，GC分代年龄等 Java执行init方法 对象的内存布局HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头，实例数据和对齐填充 对象头：包括存储对象自身运行时的数据如哈希码，GC分代年龄，锁状态标志，线程持有的锁等，以及类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针确定这个对象是哪个类的实例，如果对象为Java数组，还需要在对象头有一块记录数组长度的数据，对象头在32位/64位机的长度是32位和64位 实例数据部分是对象真正存储的有效信息，也就是代码中定义的各种类型的字段内容，无论是父类继承的还是子类定义的，都会记录下来，它们的存储顺序受虚拟机分配策略参数和字段的影响 对齐填充：不是必然存在的，也没什么含义，只起占位符作用，由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，对象头又正好是8字节的倍数，因此当对象实例数据部分没有对齐时，需要对齐填充补全 对象的访问定位Java程序需要通过栈上的reference数据来操作堆上的具体对象，由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，而没有定义这个引用通过何种方式定位访问堆中对象的具体位置，所以对象访问方式取决于虚拟机实现，目前主流的是句柄和直接指针两种 句柄访问Java堆划分一块内存作为句柄池，reference中存储的是对象的句柄地址，句柄中包含对象实例数据和类型数据各自的具体地址信息 句柄访问的优点是reference存储的是稳定的句柄地址，对象被移动时（垃圾收集移动对象很普遍）只会改变句柄的实例数据指针，reference本身不需要修改 直接指针访问reference存储的直接就是对象地址，由Java堆对象考虑如放置访问类型数据的相关信息 直接指针访问好处是速度快，它节省了一次指针定位的时间开销，HotSpot使用的是直接指针访问]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java内存区域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多态]]></title>
    <url>%2F2019%2F05%2F14%2F%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[多态是什么wiki上对多态的定义是这样的： 在编程语言和类型论中，多型（英语：polymorphism）指为不同数据类型的实体提供统一的接口。 [1]多态类型（英语：polymorphic type）可以将自身所支持的操作套用到其它类型的值上。[2] 计算机程序執行時，相同的訊息可能會送給多個不同的類別之物件，而系統可依據物件所屬類別，引發對應類別的方法，而有不同的行為。簡單來說，所謂多型意指相同的訊息給予不同的物件會引發不同的動作。 多态也可定义为“一种将不同的特殊行为和单个泛化记号相关联的能力”。 多态可分为变量多态与函数多态。变量多态是指：基类型的变量（对于C++是引用或指针）可以被赋值基类型对象，也可以被赋值派生类型的对象。函数多态是指，相同的函数调用界面（函数名与实参表），传送给一个对象变量，可以有不同的行为，这视该对象变量所指向的对象类型而定。因此，变量多态是函数多态的基础。 为什么多态通过分离”做什么”和”怎么做”，从另一角度把接口和实现分离，改善代码的组织结构和可读性，创建可扩展的程序 怎么做前提： 继承关系 子类重写父类方法 父类引用指向子类（向上转型） 123456789101112131415class Animal &#123; int num = 10; static int age = 20; public void eat() &#123; System.out.println("动物吃饭"); &#125; public static void sleep() &#123; System.out.println("动物在睡觉"); &#125; public void run()&#123; System.out.println("动物在奔跑"); &#125;&#125; 123456789101112131415class Cat extends Animal &#123; int num = 80; static int age = 90; String name = "tomCat"; public void eat() &#123; System.out.println("猫吃饭"); &#125; public static void sleep() &#123; System.out.println("猫在睡觉"); &#125; public void catchMouse() &#123; System.out.println("猫在抓老鼠"); &#125;&#125; 123456789101112class Demo_Test1 &#123; public static void main(String[] args) &#123; Animal am = new Cat(); // 基类型指向子类对象 am.eat(); // 猫吃饭 am.sleep(); // 动物在睡觉 am.run(); // 动物在奔跑 am.catchMouse(); // 报错 System.out.println(am.name); // 报错 System.out.println(am.num); // 10 System.out.println(am.age); // 20 &#125;&#125; 成员变量：编译看父类，运行看父类成员方法：编译看父类，运行看子类（动态绑定）静态方法：编译看父类，运行看父类 弊端：多态不能使用子类特有的方法和属性 可以通过强制类型转换Cat cat = (Cat)am，这样，cat指向的是最开始在堆内存中创建的那个Cat类型的对象，这是多态的向下转型]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring01-Spring IOC容器]]></title>
    <url>%2F2019%2F05%2F14%2FSpring01-Spring%20IOC%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Spring1-Spring IOC容器源代码在这 IOC 控制反转，应用程序本身不负责依赖对象的创建和维护，而是由外部容器负责创建和维护 DI是其一种实现方式，指由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中 Bean：IOC容器中把所有对象都称为bean bean配置有基于xml配置和注解 比较基础的spring目录树如下 src内有main和test文件夹，main里面有java文件夹和resources文件夹，java保存java源代码，resources保存xml文件等，test文件夹里面是java文件夹，保存测试代码 单元测试的编写 maven导入junit依赖 创建UnitTestBase类，完成对Spring配置文件的加载，销毁 所有单元测试类继承自UnitTestBase，通过它的getBean方法获取想要的对象 子类加注解@RunWith(BlockJUnit4ClassRunner.class) 单元测试方法加注释@Test 右键要执行的单元测试方法执行，或者右键类的任意空位执行所有单元测试方法 UnitTestBase类的内容InitTestBase主要有构造器，getBean方法和带Before注解的方法和带After注解的方法 123456789101112131415161718192021222324252627282930313233343536373839public class UnitTestBase &#123; private ClassPathXmlApplicationContext context; private String springXmlPath; public UnitTestBase() &#123; &#125; public UnitTestBase(String springXmlPath) &#123; this.springXmlPath = springXmlPath; &#125; @Before public void before() &#123; if (StringUtils.isEmpty(springXmlPath)) &#123; springXmlPath = "classpath*:spring-*.xml"; &#125; try &#123; context = new ClassPathXmlApplicationContext(springXmlPath.split("[,\\s]+")); context.start(); &#125; catch (BeansException e) &#123; e.printStackTrace(); &#125; &#125; @After public void after() &#123; context.destroy(); &#125; @SuppressWarnings("unchecked") protected &lt;T&gt; T getBean(String beanId) &#123; return (T)context.getBean(beanId); &#125; protected &lt;T&gt; T getBean(Class&lt;T&gt; clazz) &#123; return context.getBean(clazz); &#125;&#125; 具体的测试类编写123456789101112131415161718// 指定使用的单元测试类@RunWith(BlockJUnit4ClassRunner.class)public class TestOneInterface extends UnitTestBase &#123; public TestOneInterface() &#123; // 把classpath作为参数，调用超类的构造函数 super("classpath*:spring-ioc.xml"); &#125; // 带Test注解的方法，在执行前会调用带有Before注解的方法，执行后调用带有After注解的方法（在超类中） @Test public void testHello() &#123; OneInterface oneInterface = super.getBean("oneInterface"); // 通过超类的getBean方法得到bean System.out.println(oneInterface.hello("我的输入参数")); &#125;&#125; Bean容器的初始化 Spring注入Spring注入指启动Spring容器加载bean配置的时候，完成对变量的赋值，有设值注入（getter，setter）和构造注入（构造注入是依赖构造器参数，bean要有构造函数）xml文件的bean配置为：&lt;bean&gt;&lt;constructor-arg name=”xxx” value(ref)=”xxx” /&gt;&lt;/bean&gt; Spring设值注入12345&lt;bean id="xxx" class="xxx"&gt; &lt;property name="" value="" /&gt; &lt;property name="" ref="" /&gt; &lt;!-- name是属性名，value是基础值，ref是指向某个对象 --&gt;&lt;/bean&gt; 对应的bean必须要有getter和setter 构造注入1234&lt;bean id="xxx" class="xxx"&gt; &lt;constructor-arg name="" ref="" /&gt; &lt;!-- name是属性名，value是基础值，ref是指向某个对象 --&gt;&lt;/bean&gt; 必须要有构造器 Bean的配置项 Id：唯一标识 Class：类 Scope：范围，作用域 Constructor：构造器参数 Properties：属性 Autowiring mode：自动装配 lazy-initialization mode：懒装载 Initialization/destruction method：初始化，销毁方法 Scope作用域singleton：单例，一个bean容器中只存在一份prototype：每次请求都创建新的实例，destroy方式不生效request：每次http请求都会创建一个实例且仅在当前request内有效session：每次http请求创建，当前session内有效 Bean生命周期 定义 初始化：在IOC容器启动后加载bean时调用 使用 销毁：在IOC容器销毁前调用 初始化两种方式 bean对应类实现org.springframework.beans.factory.InitializingBean接口，覆盖afterPropertiesSet方法 xml对应bean配置init-method：&lt;bean id=”” class=”” init-method=”” /&gt;，对应类中应有init-method指定的方法 实现接口方法模板 1234567public class MyBean implements InitializingBean &#123; @Override public void afterPropertiesSet() throws Exception &#123; // do something &#125;&#125; 销毁两种方法 bean对应类实现org.springframework.beans.factory.DisposableBean接口，覆盖destroy方法 xml对应bean配置destroy-method 全局初始化和销毁方法spring xml中配置 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd" default-init-method="xxx" default-destroy-method="xxx"&gt; &lt;!-- your bean here --&gt;&lt;/beans&gt; 当默认的，内部的和接口的初始化和销毁同时存在的时候，默认的初始化销毁方法被覆盖掉，不会执行，接口的初始化方法先于内部的初始化方法执行 Awarespring提供了一些以Aware结尾的接口，实现了Aware接口的bean在被初始化后，可以获取相应资源，通过Aware接口，可以对Spring相应资源进行操作 ApplicationContextAwareWhen an ApplicationContext creates an object instance that implements the org.springframework.context.ApplicationContextAware interface, the instance is provided with a reference to that ApplicationContext. 即实现了该接口的类，在容器初始化该类的时候，会调用setApplicationContext，把上下文注入到该类实例中 BeanNameAwareWhen an ApplicationContext creates a class that implements the org.springframework.beans.factory.BeanNameAware interface, the class is provided with a reference to the name defined in its associated object definition. 1234public interface BeanNameAware &#123; void setBeanName(String name) throws BeansException;&#125; The callback is invoked after population of normal bean properties but before an initialization callback such as InitializingBean afterPropertiesSet or a custom init-method.（在bean属性填充后但在初始化bean方法调用前调用） 1234public interface ApplicationContextAware &#123; void setApplicationContext(ApplicationContext applicationContext) throws BeansException;&#125; 小DEMO123456789101112131415public class MoocBeanName implements BeanNameAware, ApplicationContextAware &#123; private String beanName; @Override public void setBeanName(String name) &#123; this.beanName = name; System.out.println("MoocBeanName：" + name); &#125; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; System.out.println(applicationContext.getBean(beanName).hashCode()); &#125;&#125; 其他Aware接口见官方文档 自动装配在对应xml配置文件的beans的属性中，设置default-autowire=”xxx”，其中xxx为下面几项 no：不做任何操作 byName：根据属性名自动装配，此选项将检查容器并根据名字查找于属性完全一致的bean，将其与属性自动装配 byType：找属性类型相同的bean，与该属性自动装配，如果有多个该类型bean，就抛出异常 Constructor：与byType类似，它应用于构造器参数，在IOC容器中查找构造器参数的类型的bean，作为构造器参数传入，如果容器中没有找到与构造器参数类型一致的bean，就抛出异常 byNamexml中配置如下 12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd" default-autowire="byName"&gt; &lt;bean id="autoWiringService" class="com.mkl.autowiring.AutoWiringService" /&gt; &lt;bean id="autoWiringDAO" class="com.mkl.autowiring.AutoWiringDAO" /&gt;&lt;/beans&gt; 123456789101112public class AutoWiringService &#123; private AutoWiringDAO autoWiringDAO; public void setAutoWiringDAO(AutoWiringDAO autoWiringDAO) &#123; this.autoWiringDAO = autoWiringDAO; &#125; public void say(String word) &#123; this.autoWiringDAO.say(word); &#125;&#125; AutoWiringService中存在成员autoWiringDAO，设置了byName的自动装配后，会在IOC容器中寻找ID为autoWiringDAO的bean，把其实例作为setAutoWiringDAO的参数赋值给AutoWiringService的成员 Resources针对资源文件的统一接口，下面是实现了Resources接口的一些类 UrlResource：URL对应的资源，根据一个URL地址可构建 ClassPathResource:：获取类路径下的资源文件 FileSystemResource：获取文件系统里面的资源 ServletContextResource：ServletContext封装的资源，用于访问ServletContext环境下的资源 InputStreamResource：针对输入流封装的资源 ByteArrayResource：针对字节数组封装的资源 ResourceLoaderThe ResourceLoader interface is meant to be implemented by objects that can return (i.e. load) Resource instances. All application contexts implement the ResourceLoader interface, and therefore all application contexts may be used to obtain Resource instances. 12345public interface ResourceLoader &#123; Resource getResource(String location);&#125; When you call getResource() on a specific application context, and the location path specified doesn’t have a specific prefix, you will get back a Resource type that is appropriate to that particular application context.For example, assume the following snippet of code was executed against a ClassPathXmlApplicationContext instance:Resource template = ctx.getResource(&quot;some/resource/path/myTemplate.txt&quot;);What would be returned would be a ClassPathResource; 不使用前缀的时候，上下文调用getResource，返回的是实现了Resource接口的符合该特定应用程序上下文Resource类型，如对ClassPathXmlApplicationContext的实例调用getResource，返回的是ClassPathResource类型 使用特定前缀，可以返回特定的Resource类型（实现了Resource接口的特定类型），常见前缀如下 一个Resource的使用例子123456789101112131415public class MoocResource implements ApplicationContextAware &#123; private ApplicationContext applicationContext; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; &#125; public void resource() throws IOException &#123; Resource resource = applicationContext.getResource("classpath:config.txt"); System.out.println(resource.getFilename()); System.out.println(resource.contentLength()); &#125;&#125; 实现ApplicationContextAware接口，实现其setApplicationContext方法，得到上下文，通过该上下文的getResource方法得到Resource，然后调用resource方法输出其文件名和长度 单元测试和配置文件略 常见问题1.POM加入了依赖却找不到例如ClassPathXmlApplicationContext类解决：右键pom，maven，reimport]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>单元测试</tag>
        <tag>Aware</tag>
        <tag>Spring注入</tag>
        <tag>Bean</tag>
        <tag>Resources</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件管理]]></title>
    <url>%2F2019%2F05%2F11%2F%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[文件管理文件的相关基本概念数据项：文件系统中最低级的数据组织形式，分为基本数据项和组合数据项，基本数据项用于描述一个对象的某种属性的字符集，是可命名的最小逻辑数据单位，又称为字段，例如，用于描述学生的基本数据项有：学号，姓名等；组合数据项是若干基本数据项的组成；数据项还应有数据类型 记录：记录是一组相关数据项的集合，用于描述一个对象在某方面的属性，一个记录应包含哪些数据项取决于需要描述对象的哪个方面。例如，一个学生，当把他作为班上一个学生时，对他的描述为学号，姓名，年龄，所在系班，若把学生当作医疗对象则不同。唯一标识记录的数据项是关键字 文件：文件是由创建者所定义的，具有文件名的一组相关元素的集合，分为有结构文件和无结构文件，有结构文件中，文件由若干个相关记录组成，而无结构文件被看成是一个字符流，文件在文件系统是一个最大的数据单位，它描述了一个对象集，例如可以将一个班的学生记录作为一个文件 文件属性可以包括：文件类型，文件长度，文件的物理位置，文件的建立时间（最后一次的修改时间等） 文件类型文件类型按用途分类可分为系统文件，用户文件和库文件按文件中数据的形式分类可分为源文件，目标文件和可执行文件按存取控制属性分类可分为只执行文件，只读文件，读写文件按组织形式和处理方式分类可分为普通文件，目录文件和特殊文件 文件系统文件系统的模型是指文件和对文件进行操纵和管理的软件集合 分为三层：对象及属性，对文件进行操纵和管理的软件集合，文件系统接口 对象及其属性层文件管理系统管理的对象如下： 文件 目录 磁盘存储空间 对对象操纵和管理的软件集合层该层是文件管理系统的核心部分，文件系统的功能大多是这一层实现，其中包括对文件存储空间的管理，对文件目录的管理，用于将文件的逻辑地址转换为物理地址的机制，对文件的读写管理，对文件的共享保护等功能 一般把与文件系统有关的软件分为4个层次： I/O控制层：磁盘驱动程序等组成 基本文件系统层：内存与磁盘之间数据块的交换 基本I/O管理程序：完成与磁盘I/O有关的事务，如文件逻辑块号转换为物理块号等 逻辑文件系统：用于处理与记录和文件相关的操作，如允许用户使用符号文件名访问文件及记录等 文件系统接口文件系统提供了命令接口和程序接口 文件逻辑结构文件的逻辑结构是从用户观点出发所观察到的文件组织形式，即文件是由一系列逻辑记录组成的，是用户可以直接处理的数据及其结构，独立于文件的物理特性，又称为文件组织 文件的物理结构又称为文件的存储结构，是指系统将文件存储在外存上所形成的一种存储组织形式，用户是不能看见的 物理结构和逻辑结构都会影响对文件的检索速度 下图是文件结构类型的概述 逻辑结构的类型文件按有无结构分为有结构文件和无结构文件 有结构文件根据记录长度分为定长和不定长两类，定长指文件的所有记录长度都是相同的，所有记录的各数据项都处在记录中相同的位置，具有相同的顺序和长度，定长记录有效提高检索记录的速度和效率，方便对文件处理和修改，文件长度用记录数目来表示；变长记录指文件中各记录长度不相同 有结构文件按文件组织方式分为 顺序文件：由一系列记录按某种顺序排列形成的文件，记录通常是定长记录（变长记录查询速度慢，不支持随机访问和删除插入记录） 索引文件：可变长记录文件建立一张索引表，为每个记录设置一个表项，加速对记录的检索 索引顺序文件：顺序文件和索引文件的结合，在为每个文件建立一张索引表时，并不是为每个记录建立索引表项，而是为一组记录中的第一个记录建立一个索引表项 无结构文件是流式文件，信息管理系统和数据库系统中广泛采用了有结构的文件形式，而源程序，可执行文件，库函数等采用的就是无结构文件，长度是以字节为单位，可以把流式文件看作记录式文件的一个特例：一个记录仅有一个字节 顺序文件顺序文件可以按照串结构或顺序结构排列，串结构指按存入时间的先后进行排序，各记录之间的顺序与关键字无关，对串结构文件检索比较费时，顺序结构是由用户指定一个字段作为关键字，文件中所有记录可以按关键字排序，具有更高的检索速度 索引文件为变长记录建立一个索引表，对主文件的每个记录在索引表中设有一个相应表项，用于记录该记录的长度L，以及指向该记录的指针 索引文件是可以实现直接存取的，索引文件支持随机访问 索引顺序文件索引顺序文件保留了顺序文件的关键字顺序，又增加了文件索引表和溢出文件，溢出文件用来记录新增加的，删除的和修改的记录 一级索引顺序文件将变长记录顺序文件的所有记录分为若干组，为顺序文件建立一张索引表，并为每组的第一个记录，在索引表建立一个索引项，其中包含该记录的关键字和指向该记录的指针 对索引顺序文件检索时，先利用提供的关键字以及某种查找算法去检索索引表，找到该记录所在记录组第一个记录的表项，从中得到该记录组第一个记录在主文件的位置，然后再利用顺序查找法去查找主文件，从中找到所要求的记录 直接文件和哈希文件直接文件直接文件可以根据给定的关键字直接获得记录的物理地址，即关键字本身就决定了记录的物理地址，由关键字到记录物理地址的转换称为键值转换，而上述的索引文件实质是对关键字计算得到对应索引表表项的物理地址，由该物理地址得到指向对应记录的指针 哈希文件利用哈希函数将关键字转换为相应记录的地址 文件的物理结构物理结构是从实现的观点出发，文件在外存上的存放组织形式，有如下三种物理结构 连续结构 链接结构 索引结构 目录管理对目录管理的要求 实现”按名存取”：用户只须向系统提供所需访问的文件的名字，便能快速准确地找到指定文件在外存地存储位置，这是目录管理最基本地功能 提高对目录的检索速度 文件共享：允许多个用户共享一个文件，这样只须在外存中保留一份该文件副本供不同用户使用，节省存储空间，提高利用率 允许文件重名：允许不同用户对不同文件采取相同的名字 文件控制块FCB文件目录：文件控制块的有序集合，即一个文件控制块就是一个文件目录项，通常一个文件目录被看成是一个文件，称为目录文件 文件控制块：描述和控制文件的数据结构，文件与文件控制块一一对应，一个文件控制块就是一个文件目录项（文件目录是文件控制块的有序集合），包含基本信息，存取控制信息和使用信息，可以分为内存FCB和外存FCB 它们的关系：文件控制块与文件一一对应，而文件目录是有结构文件，其中的每一个记录都是一个文件控制块 检索过程：检索的时候，把文件目录调入内存，查找其目录项，找到与给定的文件名对应的文件名，读出其物理地址 基本信息类 文件名 文件物理位置 文件逻辑结构：流式还是有结构，记录数，定长记录还是变长记录等 文件物理结构：顺序还是链接还是索引 存取控制信息类文件主，核准用户和一般用户的存取权限 使用信息类 文件建立日期和时间 上一次修改的日期和时间 当前使用信息（已打开文件的进程数，是否被锁等等） 索引结点OS中每有一个目录，就有一个FCB 引入：文件目录占空间，检索目录文件过程中，要把存放目录文件的第一个盘块中的目录的调入内存，然后将用户所给定的文件名与目录项的文件名一一对应，若没有找到指定文件，还需要将下一盘块的目录项调入内存。检索过程中，只用到了文件名，而没有其他描述文件的信息，仅当找到一个目录项（即其中文件名与指定要查找的文件名相匹配）时，才需从该目录项中读出该文件的物理地址，而其他一些对该文件进行描述的信息在检索目录时一概不用。显然这些信息在检索目录的时候不需要调入内存，为此，采用把文件名与文件描述信息分开的方法，即使文件描述信息单独形成一个称为索引结点的数据结构 引入后，文件目录项就不是FCB了，而是文件名+索引结点，这样可以使每个盘块可以存更多的文件目录项，减少盘块数，从而减少盘块调入内存的次数 引入索引结点前的文件目录项（FCB） 引入索引结点后的文件目录项（文件名+索引结点） 例如上图，在没有引入索引结点的时候，FCB是上图一所示，每次检索目录的时候都要把FCB调入内存，而FCB又占用比较大的空间，这样系统开销会很多，采用了上图二的文件目录项后，一个目录项只占用很小的开销（UNIX为16个字节，14字节文件名，2字节为i结点指针），可以减少磁盘启动次数，节省系统开销 我对索引结点减少磁盘启动次数的理解前提：目录文件所占盘块数为N，则检索该文件目录时平均调入盘块次数为(N+1)/2次，检索一个文件要从第一个文件目录开始检索，直到最后一个文件目录 引入索引结点可以减少磁盘启动次数，节省系统开销，主要原因是调入内存是以盘块为单位和引入索引结点后文件目录项的大小比FCB的大小要小 e.g.在文件系统中，每个盘块为256字节，文件控制块占64个字节，其中文件名占8个字节。如果索引节点编号占2个字节，对一个存放在磁盘上的128个目录项的目录，试比较引入索引节点前后，为找到其中一个文件，平均启动磁盘的次数 在引入索引结点前，每个目录项中存放的是对应文件的FCB，故128个目录项的目录总共需要占用128X64／256=32个盘块。因此，在该目录中检索到一个文件，平均启动磁盘的次数为(1+32)/2=16.5次。引入索引结点后，每个目录项中只需存放文件名和索引结点的编号，因此128个目录项的目录总共需要占用128X(8+2)／256=5个盘块。因此，找到匹配的目录项平均需要启动(1+5)／2，即3次磁盘；而得到索引结点编号后，还需启动磁盘将对应文件的索引结点读入内存，故平均需要启动磁盘4次。可见，引入索引结点后，可大大减少启动磁盘的次数，从而有效地提高检索文件的速度。 引入索引结点后的索引过程 文件目标项只存放文件名和结点号，结点号存放FCB信息 查询只调入文件名部分和结点指针，找到后才调入对应i结点指向的内容 磁盘索引结点存放在磁盘的索引结点，每个文件有唯一的磁盘索引结点，包括如下内容： 文件主标识 文件类型（正规文件，目录文件，特殊文件） 文件存取权限 文件物理地址 文件长度 文件连接计数（本文件系统所有指向该文件名的指针计数，用于共享） 文件存取时间 内存索引结点存放在内存中的索引结点，当文件被打开时，要将磁盘索引结点拷贝到内存的索引结点中方便以后使用，增加了以下内容 索引结点编号 状态 访问计数 文件所属文件系统的逻辑设备号 链接指针 单级目录结构最简单的文件目录，在整个文件系统中只建立一张目录表，每个文件占一个目录项，目录项含文件名，文件扩展名，文件长度，文件类型，文件物理地址以及其他文件属性，状态位（是否空闲） 单级目录结构不允许重名，新建文件时要检查有无同名，删除时回收块并清楚占用目录项 两级目录结构 可以为每个用户再建立一个单独的用户文件目录UFD，这些文件目录由用户所有文件的文件控制块组成，在系统中再建立一个主文件目录MFD，MFD的每个目录项为用户的目录文件 两级目录结构允许重名，但不允许用户建立自己的子目录 树形结构目录一个目录文件中目录项可以为目录文件和数据文件，允许重名，便于实现文件共享 目录查询技术当用户要访问一个已经存在的文件时，系统首先利用用户提供的文件名对目录进行查询，找出该文件的FCB或对应索引结点，然后根据FCB或索引结点中记录的文件物理地址（盘块号），换算出文件在磁盘上的物理地址，最后再通过磁盘驱动程序将所需文件读入内存 常用的目录查询方式为线性检索法和Hash方法 线性检索法 查找过程如下： 系统先读入第一个文件分量名usr，用它与根目录文件中各目录项的文件名顺序的进行比较，找到匹配者，并得到索引结点号，再从索引结点号得知物理地址号（盘块号），将该盘块132号读入内存 系统再将路径名第二个分量ast读入，与存放在132号盘块的第二级目录文件各目录项的文件名顺序比较，以此类推直到找到mbox的索引结点和物理地址 Hash方法建立一张Hash索引文件目录，利用Hash方法查询，系统利用文件名变换为文件目录的索引值，再利用该索引值到目录去查找 文件共享两种共享方式：用户直接通过路径名来访问共享文件和对需要共享的文件进行链接 文件保护 存取控制机制防止人为因素造成文件不安全 磁盘容错技术防止磁盘故障造成文件不安全 后备系统防止自然因素造成的不安全性]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>文件管理</tag>
        <tag>FCB</tag>
        <tag>索引结点</tag>
        <tag>目录管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[磁盘存储器的管理]]></title>
    <url>%2F2019%2F05%2F11%2F%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[磁盘存储器的管理磁盘存储器管理的单位是盘块 外存的组织方式文件的物理结构直接与外存的组织方式有关，不同的外存组织方式形成不同的文件物理结构 连续组织方式：为每个文件分配连续的磁盘空间 链接组织方式：为每个文件分配不连续的磁盘空间，通过链接指针将文件的所有盘块链接在一起 索引组织方式 连续组织方式特点： 顺序访问容易，速度快（磁头移动距离小） 要求连续空间，一段时间后要整理磁盘消除碎片 必须事先知道长度，文件不易动态增长和删除 文件对应目录项包含：始址，总块数，最后一块字节数 链接组织方式特点： 消除磁盘外部碎片，提高外存利用率 对插入，删除和修改记录容易 适应文件的动态增长，无需事先知道文件大小 只能顺序存取 隐式链接文件目录的每个目录项都含有指向链接文件第一个盘块和最后一个盘块的指针，只适用于顺序访问，随机访问效率低 簇：包含多个块的单位，盘块分配时以簇为单位，可以成倍减小查找指定块的时间，增大内部碎片 显示链接把用于链接文件各物理块的指针显式地存放在内存的一张链接表中，该表在整个磁盘只设置一张 表的序号是物理块号，在每个表项中存放链接指针，即下一个盘块号，凡是属于某一文件的第一个盘块号，均作为文件地址被填入相应FCB的物理地址字段，查找是在内存进行的所以速度提升且减少磁盘访问次数，该表称为文件分配表FAT 索引组织方式打开某个文件时，只要把该文件占用的索引块号读入内存即可，无需把FAT调入内存，索引的优点是支持直接访问，当要读第i块盘块时，直接从该文件的索引块中找到该盘块号 单级索引：为每个文件分配一个索引块，文件较大时有利，较小时浪费外存空间，文件较大时索引块较多，需要建立多级索引 多级索引如下 混合分配方式UNIX采用混合分配方式，一，二，多级索引合用 i.addr(0)——i.addr(9)存放直接地址，i.addr(10)存放一次间接地址，i.addr(11)存放二次间接地址 文件组织策略 文件访问通常是顺序，文件较小，用连续分配 文件较大顺序访问，链接结构 文件较大随机访问，索引结构 分配策略的小习题 文件存储空间的管理设置一个磁盘分配表，用于记住可供分配的存储空间情况，还应提供对盘块分配和回收的手段，存储空间基本分配单位都是磁盘块而非字节 空闲表法空闲表属于连续分配方式，为每个文件分配一块连续的存储空间，即系统为外存上的所有空闲区建立一张空闲表，每个空闲区对应一个空闲表项，包括表项序号，第一个盘块号，空闲盘块数等信息 空闲链表法空闲盘块链将所有空闲空间以盘块为单位拉成一条链，工作效率低 空闲盘区链将磁盘所有空闲盘区拉成一条链，每个盘区包含若干个盘块，要有指明本盘块大小的信息 位示图法利用二进制的一位来表示磁盘一个盘块的使用情况，0为盘块空闲，1为已分配 位示图法盘块的分配 顺序扫描位示图，找出一个或一组值为0的二进制位 将找到的一个或一组二进制位转换位盘块号，假定找到值为0的二进制位位于位示图第i行j列，则盘块号按下式计算：b=n(i-1)+j 修改位示图，令map[i,j]=1 位示图的回收 将回收盘块号转换为位示图的行号列号i=(b-1)DIVn+1,j=(b-1)MODn+1 修改位示图，令map[i,j]=0 成组链接法UNIX采用的方法 基本思想（汤书P281解释更详细） 空闲盘块号栈存放当前可用的一组空闲盘块号及栈中尚有的空闲盘块号数，唯一存在于内存的栈 文件区的所有空闲盘块分为若干组 每一组含有盘块总数和所有的盘块号记入前一组最后一个盘块中 第一组盘块总数和所有盘块号记入空闲盘块号栈 最末一组只有N-1各盘块 S.free(0)是栈底 空闲盘块分配首先检查空闲盘块号栈是否上锁，如未上锁，便从栈顶取出一空闲盘块号，将与之对应的盘块分配给用户，然后将栈顶指针下移一格若该盘块号已是栈底，即S.free(0)，即最后一个可分配的盘块号。 须调用磁盘读过程，将栈底盘块号所对应盘块的内容读入栈中，作为新的空闲盘块号栈的内容，然后，把原栈底对应的盘块分配出去(其中的有用数据已读入栈中) 空闲盘块的回收将回收盘块的盘块号记入空闲盘块号栈的顶部，并执行空闲盘块数加1操作。当栈中空闲盘块号数目已达100时，表示栈已满，便将现有栈中的100个盘块号，记入新回收的盘块中，再将其盘块号作为新栈底 提高磁盘I/O速度的途径 磁盘高速缓存（数据交付，置换算法，周期性写回磁盘） 提前读 延迟写 优化物理块布局 虚拟盘 数据一致性控制事务：用于访问和修改各种数据项的一个程序单位，可以看作一系列相关的读写操作，被访问的数据可以分散地存放在同一文件的不同记录中，也可放在多个文件中。只有对分布在不同位置的同一数据所进行的读和写(含修改)操作全部完成时，才能再以托付操作(Commit Operation)来终止事务。只要有一个读、写或修改操作失败，便须执行夭折操作(Abort Operation)。读或写操作的失败可能是由于逻辑错误，也可能是系统故障所导致的 事务记录 事务名：用于标识该事务的惟一名字 数据项名：它是被修改数据项的惟一名字 旧值：修改前数据项的值 新值：修改后数据项将具有的值 恢复算法undo，把所有被事务Ti修改过的数据恢复修改前的值redo，把所有被事务Ti修改过的数据设置为新值 检查点作用：使对事务记录表中事务记录的清理工作经常化]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>磁盘存储器的管理</tag>
        <tag>位示图法</tag>
        <tag>成组链接法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设备管理]]></title>
    <url>%2F2019%2F05%2F10%2F%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[设备管理I/O系统管理的主要对象是I/O设备和相应的设备控制器，其主要任务是，完成用户提出的I/O请求，提高I/O速率，以及提高设备利用率，并为更高层的进程方便地使用这些设备提供手段 I/O系统的层次结构I/O软件组织分为4个层次 用户层I/O软件：提供库函数对I/O设备操作 设备独立性软件：实现用户程序与设备驱动器的统一接口，设备命名，保护和分配释放等 设备驱动软件：与硬件直接相关，用于具体实现系统对设备发出的操作指令 中断处理程序：用于保存被中断进程的CPU环境，转入相应的中断处理程序处理，处理完恢复现场 设备控制器设备并不是直接与CPU进行通信，而是与设备控制器通信，I/O设备应提供提供数据信号线，状态信号线和控制信号线给设备控制器 设备控制器主要功能是控制一个或多个I/O设备，实现I/O设备和计算机之间的数据交换，它是CPU与I/O设备之间的接口，接收从CPU发来的命令，去控制I/O设备工作 设备控制器基本功能 接收和识别命令 数据交换：数据总线实现CPU到控制器的交换，数据寄存器实现设备控制器到I/O设备的交换 标识和报告设备的状态 地址识别 数据缓冲区 差错控制 设备控制器的组成 设备控制器与处理机的接口：数据线地址线和控制线，实现CPU和设备控制器的通信，数据线通常与数据寄存器或者控制/状态寄存器连接，与数据寄存器连接的话是传输数据，与控制/状态寄存器连接的话是存放控制信息或设备状态信息 设备控制器与设备的接口：控制器由一个或多个设备接口，由数据，控制，状态三种信号组成 I/O逻辑：实现对设备控制，通过一组控制线与处理机交互，处理I/O命令，每当CPU启动一个设备，一方面启动命令发送给控制器，另一方面同时通过地址线把地址发送给控制器，由控制器的I/O逻辑对收到的地址译码，对所选设备控制 I/O通道引入目的：解脱CPU对I/O的组织，管理。虽然设备控制器可以减少CPU对I/O的干预，但当主机所配置的外设很多时，CPU负担仍很重，为此增加了I/O通道 I/O通道是一种特殊的执行I/O指令的处理机，与CPU共享内存，可以有自己的总线，它从CPU接收I/O指令，从内存取出要执行的通道执行程序，然后执行，完成规定I/O任务后，向CPU发中断信号 通道类型 字节多路通道：各通道以时间片轮转方式共享通道，适用于低，中速设备 数组选择通道：无子通道，仅一主通道，某时间由某设备独占，适用高速设备，利用率低 数组多路通道：多子通道按需分配，综合前面两种优点 I/O控制方式四个阶段：程序I/O——中断I/O——DMA控制——通道控制 趋势：减少CPU对I/O操作的干预，提高并行度 程序I/O控制方式：采用轮询的方式，CPU需要花代价不断查询I/O状态 中断I/O控制方式：CPU向I/O发命令然后做其他事，设备管理器按照该命令控制指定I/O，当I/O中断产生，CPU转去执行中断处理程序，CPU以字节为单位干预I/O DMA控制：由DMA控制器直接控制总线传递数据块，DMA控制器完成从I/O到内存，主要用在块设备中 通道控制：DMA控制对多离散块的读取仍需要多次中断，通道方式CPU只要给出通道程序首地址，要访问的I/O设备后，通道程序就会完成一组块操作 缓冲管理缓冲管理的目的是：组织管理，分配，释放buffer 引入： 缓和CPU与I/O设备速度不匹配的矛盾 减少对CPU的中断频率 提高CPU和I/O并行性 解决数据粒度不匹配问题（数据单元大小） 单缓冲 双缓冲 收发可双向同时传送 循环多缓冲 缓冲池 设备分配包括对设备，设备控制器和通道的分配 设备分配应考虑的若干因素 设备的固有属性：共享+虚拟，独享 分配算法：FIFO，优先权 安全性 设备独立性即设备无关性，指应用程序独立于具体使用的物理设备 设备可以分为逻辑设备和物理设备，逻辑设备名到物理设备名的映射由逻辑设备表LUT实现 分配流程：进程给出逻辑名——通过LUT得到物理设备及其driver入口 优点是设备分配更灵活，可以是多对多的映射关系，提供均衡性于容错性，提高共享性，易于实现I/O重定向（改变LUT表即可） 设备独立性软件设备独立性软件执行所有设备的公有操作，如分配回收，名字映射，保护，缓冲，差错控制等，并向用户层软件提供统一接口如read，write SPOOLING技术为了缓和CPU高速性和I/O设备低速性的矛盾，引入脱机输入，脱机输出技术，利用专门的外围控制机，将低速I/O设备上的数据，传送到高速磁盘上，或者相反。当系统引入多道程序技术后，完全可以利用其中一道程序来模拟脱机输入时外围控制机的功能，把低速I/O设备上的数据传送到高速磁盘上，再用另一道程序，模拟脱机输出时外围控制器的功能，将数据从磁盘传送到低速输出设备上，这样便可在主机的直接控制下，实现以前的脱机输入，脱机输出的功能，此时外围操作与CPU对数据的处理同时进行，我们把这种联机情况下实现的同时外围操作的技术，称为SPOOLing技术（Simultaneous Periphernal Operating Online）或称为假脱机技术 SPOOLing提供了I/O速度，将独占设备改造为共享设备，实现了虚拟设备的功能 设备处理设备驱动程序的功能： 接收I/O进程发来的命令和参数，将命令中的抽象要求转换为具体要求 检查用于I/O请求的合法性 发出I/O命令 及时响应由控制器或通道发来的中断请求，并根据中断类型调用相应的中断处理程序处理 自动构成通道程序 设备处理方式 为每一类设备设置一个进程，专门用于执行这类设备的I/O操作 整个系统设置一个I/O进程，用于执行系统中所有各类设备的I/O操作 不设置专门的设备处理进程，而为各类设备设置相应的设备处理程序，供用户或系统进程调用 磁盘存储器管理 磁盘的类型 固定头磁盘：每条磁道上都有一读/写磁头，所有磁头都被装在刚性磁臂中，通过这些磁头可访问所有磁道，并进行并行读/写，有效提高I/O速度 移动头磁盘：每一个盘面仅配一个磁头，也被装入磁臂中，该磁头能移动进行寻道，仅能串行方式读/写，I/O速度慢 磁盘访问时间 寻道时间Ts：磁臂（磁头）移动到指定磁道上所经历的时间，是启动磁臂时间s与磁头移动n条磁道所花费时间之和，Ts=m*n+s，m是常数，与磁盘驱动器速度有关 旋转延迟时间Tτ：扇区移动到磁头下面所经历的时间 传输时间Tt：把数据从磁盘读出或向磁盘写入数据所经历的时间Tt=b/rN，b是每次读/写的字节数，r是磁盘每秒转数，N是一条磁道上的字节数 当一次读/写的字节数相当于半条磁道上的字节数时，Tt与Tτ相同，可将访问时间Ta表示为Ta=Ts+1/2r+b/rN 磁盘调度先来先服务FCFS根据进程请求访问磁盘的先后次序调度 最短寻道时间优先SSTF该算法选择这样的进程，要求访问的磁道与当前磁头所在的磁道距离最近 扫描算法SCANSSTF实质是基于优先级的调度算法，可能会导致低优先级进程饥饿现象，因为只要不断有新进程请求到达，且所访问的磁道与磁头距离较近，则较远的进程饥饿，扫描算法不仅考虑访问磁道与当前磁道的距离，更优先考虑磁头当前的移动方向，例如当磁头自里向外移动，SCAN算法考虑的是当前磁道之外的，又是距离最近的，直到再无更外的磁道需要访问，就将磁臂换向改为自外向里，跟电梯运行很像，又称为电梯调度算法 磁盘高速缓存利用内存中的存储空间，来暂存从磁盘中读出的一系列盘块中的信息高速缓存逻辑上属于磁盘，物理上是内存高速缓存在内存中分为两种：第一种是内存中开辟单独的存储空间来作为磁盘高速缓存，大小是固定的，不会受应用程序多少的影响，第二种是把所有未利用的内存空间变为一个缓冲池，供请求分页系统和磁盘I/O（作为磁盘高速缓存）共享 数据交付方式系统可以采取两种方式，将数据交付给请求进程 数据交付：直接将高速缓存中的数据传送到请求者进程的内存工作区中 指针交付：只将指向高速缓存中某区域的指针交付给请求者进程 置换算法高速缓存的置换算法和请求分页系统有些区别，除了考虑最近最久未使用这一原则外，还考虑了访问频率，可预见性和数据的一致性 周期性写回磁盘UNIX系统专门增设一个修改程序，该程序周期性调用一个系统调用SYNC，主要功能是强制性将所有高速缓存中已修改的盘块数据写回磁盘，一般两次SYNC间隔30s]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>设备管理</tag>
        <tag>设备控制器</tag>
        <tag>通道</tag>
        <tag>SPOOLing</tag>
        <tag>缓冲</tag>
        <tag>磁盘存储器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟存储器]]></title>
    <url>%2F2019%2F05%2F10%2F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%2F</url>
    <content type="text"><![CDATA[虚拟存储器基本概念虚拟存储器的引入：常规存储器管理方式特征：一次性（全部装入），驻留性（驻留在内存不换出） 局部性原理： 时间局部性：如循环执行，某条指令被执行，不久以后可能会再次执行，数据被访问，不久后可能会再次被访问，原因是程序中存在大量循环操作 空间局部性：如顺序执行，一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址可能集中在一定范围之内 虚拟存储器的定义：具有请求调入功能和置换功能，能从逻辑上对内存容量进行扩充的一种存储系统实质：时间换空间，但时间牺牲不大 虚拟存储器特征：离散性（部分装入），多次性（局部装入，多次装入），对换性，虚拟性 虚拟存储器的实现方式虚拟存储器的实现，全都建立在离散分配存储管理方式的基础上 需要动态重定位 目前的虚拟存储器都是采用分页请求系统和分段请求系统的方式实现的，分页请求系统就是在分页系统的基础上增加了请求调页功能和页面置换功能，分段请求系统在分段系统的基础上加入了请求调段功能和分段置换功能 分页请求系统 以页为单位转换 需硬件： 请求分页的页表机制 缺页中断 地址变换机构 需实现请求分页机制的软件 请求分段系统 以段为单位转换 请求分段的段表结构 缺段中断 地址变换机构 需实现请求分段机制的软件 请求分页存储管理方式请求分页的页表机制在纯页表机制上增加若干项形成，主要作用还是将用户地址空间中的逻辑地址映射为内存空间中的物理地址，为了满足页面换出换进换出的需要，它增加了一些字段 状态位P：仅有一位，指示该页是否已经调入内存 访问字段A：记录本页在一段时间内被访问的次数或记录本页最近已有多长时间未被访问，作为置换算法换出页面时的参考 修改位M：标识该页在调入内存后是否被修改过，由于内存每一页在外存上都有一份副本，因此置换该页时，如果未被修改，就不需要将该页写回到外存 缺页中断请求分页系统中，每当所要访问的页面不在内存时，便产生一缺页中断，请求OS将所缺之页调入内存，它与一般中断相比有明显区别，主要表现如下： 在指令执行期间产生和处理信号。通常CPU都是在一条指令执行完后才检查是否有中断请求到达。然而缺页中断在指令执行期间，若发现所要访问的指令或数据不在内存时，便立即产生和处理缺页中断信号，以便及时将所缺的页面调入内存 一条指令在执行期间可能产生多次缺页中断。例如下图中，执行一条指令copy A to B，可能要产生6次缺页中断，因为指令本身跨了两个页面，A和B各自为一个数据块，它们也都跨了两个页面 地址变换机构在分页系统地址变换机构的基础上，为实现虚拟存储器，再增加了某些功能，比如产生和处理缺页中断，以及从内存中换出一页的功能等等 请求分页的内存分配为进程分配内存时涉及三个问题：第一，为保证进程能正常运行，所需要的最小物理块数的确定；第二，在为每个进程分配物理块时，应采取什么样的分配策略，即所分配的物理块是固定的，还是可变的；第三，为不同进程分配物理块数，是平均分配算法还是根据进程大小按比例分配 最小物理块数的确定最小物理块数指保证进程正常运行所需的最小物理块数，取决于计算机硬件结构和指令格式，比如单地址指令且直接寻址的机器，最小物理块数为2，一块存放指令的页面，一块存放数据的页面，而对于单地址指令间接寻址，至少需要3个物理块，如果指令长度两个或多个字节，且指令本身可跨两个页面，源地址目标地址所涉及区域也跨两个页面，则要为每个进程分配6个物理块以装入6个页面 内存分配策略可采用固定和可变分配策略，置换时也可采取全局置换和局部置换，组合出下面三种适用的策略，全局置换指产生缺页都获得新物理块，如果没有空闲物理块，就从内存中选择一页调出，该页可能是系统中任何一个进程的，局部置换指换出的页面只能是该进程的页面，而不能是其他进程的 固定分配局部置换：固定分配指为每个进程分配一组固定数目的物理块，在进程运行时间不再改变，局部置换指如果进程在运行中发现缺页，则只能从分配给该进程的n个页面中选一页换出，再调入一页，以保证分配给该进程内存空间不变，缺点是难以确定固定分配的页数，如果少，置换率高，如果多就浪费 可变分配全局置换：可变分配指先为每个进程分配一定数目的物理块，在进程运行器件可根据情况适当增加或减少。可变分配全局置换这可能是最易于实现的一种物理块分配和置换策略，已用于若干个OS中。在采用这种策略时，凡产生缺页（中断）的进程，都将获得新的物理块，仅当空闲物理块队列中的物理块用完时，OS才能从内存中选择一页调出。被选择调出的页可能是系统中任何一个进程中的页，因此这个被选中的进程拥有的物理块会减少，这将导致其缺页率增加 可变分配局部置换：当某进程发现缺页时，只允许从该进程在内存的页面中选择一页换出，这样不会影响到其它进程的运行，如果进程运行中频繁缺页中断，系统就为该进程分配若干附加的物理块，直到进程缺页率降到适当程度为止，反之如果缺页率比较低，就适当减少该进程物理块数 物理块分配算法 平均分配算法 考虑优先权分配算法 页面调入策略问题： 何时调入页面 预调页策略：将那些预计在不久后会被访问的页面预先调入内存 请求调页策略：在进程需要访问页面不在内存的数据和程序时才提出请求，费系统开销 从何处调入页面 对换区，快 文件区，慢，在缺少对换区空间时 UNIX方式：未运行过的页面都从文件区调入，运行过但被换出的页面从对换区调入 页面调入过程：在上面地址变换机构的图的左半部分就是页面调入过程 页面置换算法最佳置换算法OPT其所选择的被淘汰页面，将是以后永不使用的，或许是在最长时间内不再被访问的页面，因为人们目前无法预知，一个进程在内存的若干页面中哪一个是未来最长时间不再被访问的，因而该算法是无法实现的，用于评价其他算法 考虑先将7，0，1三个页面装入内存，当进程要访问页面2，就会产生缺页中断，这个时候就会把页面7淘汰，因为页面0是第5个被访问的页面，页面1是第14个被访问的页面，页面7是第18个被访问的页面，访问到页面3的时候，同理页面1被淘汰，以此类推 先进先出页面置换算法FIFO该算法总是淘汰最先进入内存的页面，即选择内存中驻留时间最久的页面淘汰，该算法实现只需要把 进程已调入内存的页面按先后次序链接成一个队列，并设置一个指针，称为替换指针，它总是指向最老的页面 最近最久未使用置换算法LRU根据页面调入内存后的使用情况做出决策，选择最近最久未使用的页面淘汰，每个页面一个访问字段，用来记录一个页面自上次被访问以来经历了多少时间t，当需要淘汰一个页面时，选择现有页面中t值最大的淘汰 需要移位寄存器R=Rn-1Rn-2…R2R1R0的支持，当访问某物理块时，就将移位寄存器Rn-1置1，定时器每隔一段时间将寄存器右移一位，具有最小数值的寄存器所对应的页面就是最近最久未使用的页面或者需要栈的支持，当进程访问某页面，将该页面号从栈移出，压入栈顶，栈底就是最近最久未使用的页面号 Clock置换算法，页面缓冲算法等考纲没说要考，再看下去我要挂科了 请求分页访问内存有效时间EAT=(1-p)t+pf其中p为缺页率，t为内存访问时间，f为缺页中断时间 请求分段存储管理方式请求分段的段表机制 存取方式：执行，只读，读/写 存在位P：是否已调入内存 增补位：本段在运行过程中是否做过动态增长 缺段中断机构 与缺页中断的区别主要是有空区拼接，形成一个合适的空区 地址变换机构 分段的共享与保护分段的优点是便于实现分段的共享与保护 共享段表 分段保护提供如下分段保护 越界检查 存取控制检查 环保护机构]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>虚拟存储器</tag>
        <tag>请求分页</tag>
        <tag>请求分段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[存储器管理]]></title>
    <url>%2F2019%2F05%2F09%2F%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[存储器管理存储器管理概述存储器的多层结构由于CPU与存储器的速度不匹配，需要对存储器进行分层，经典是三层结构：CPU寄存器，主存和辅存，目前比较高级的分层是六层：寄存器，高速缓存，主存储器，磁盘缓存，固定磁盘和可移动存储介质，层次越高，速度越快，但价格越高，存储容量越小 高速缓存常用SRAM，内存DRAM，SDRAM等，外存是软盘，硬盘，光盘等 各层次作用主存又称内存，用于保存进程运行的程序和数据，处理机都是从主存储器取指令和数据的，并把指令放入指令寄存器，数据放入数据寄存器，或者反过来把寄存器中的数据存入主存储器。 寄存器有与处理机相同的速度 高速缓存是介于寄存器和存储器之间的存储器，主要用于备份主存常用的数据，减少处理机对主存的访问次数，可以大幅度提高程序执行速度 磁盘缓存是为了缓和磁盘I/O速度和主存访问速度的不匹配，主要用于暂时存放频繁使用的一部分磁盘数据和信息，以减少访问磁盘的次数，它本身不是一种实际存在的存储器，而是利用主存中部分存储空间暂时存放从磁盘中读出或写入的信息 存储器管理功能存储器管理主要有如下功能 存储分配和回收：分配和和回收算法及相应的数据结构 地址变换 可执行文件生成中的链接技术 程序加载（装入）时的重定位技术 进程运行时硬件和软件的地址变换技术和机构 存储共享和保护 代码和数据共享 地址空间访问权限（读，写，执行） 存储器扩充 重定位概念重定位是实现逻辑地址（相对地址）到物理地址（绝对地址）的映射逻辑地址：应用程序的地址都是从0开始的物理地址：主存中一系列存储信息的物理单元的地址 程序的装入一个程序一般有5个过程，编辑，编译，链接，装入和运行 程序装入分为绝对装入和可重定位装入和动态运行时装入绝对装入指编译后，装入前已产生绝对地址，装入时不需要再作地址重定位，绝对地址由编译器或程序员编程完成可重定位装入指静态重定位，静态重定位指地址转换在装入时一次完成，缺点是不允许程序在运行中在内存中移动位置动态运行时装入在把装入模块装入内存后，并不立即把装入模块中的逻辑地址转换成物理地址，而是把这种地址转换推迟到程序真正要执行的时候才进行，因此，装入内存后的地址都是逻辑地址，需要一个重定位寄存器的支持 程序的链接源程序编译后得到一组目标模块，链接程序的功能是将这组目标模块以及它们所需要的库函数装配成一个完整的装入模块 静态链接：对相对地址进行修改，变换外部调用符号动态链接：便于修改和更新，便于实现对目标模块的共享运行时动态链接 连续分配管理方式为了能将用户程序装入内存，必须为它分配一定大小的内存空间，连续分配方式是最早出现的一种存储器分配方式 单一连续分配用于单用户单任务中，把内存分为系统区和用户区，应用程序装入到用户区，可使用用户区全部空间，优点是易于管理，缺点是对要求内存空间少的程序造成内存浪费，程序全部装入，很少使用的程序部分也会占用内存 固定分区特点：有n个分区，可同时装入n个作业/任务固定分区可以把分区划分为相等的跟不相等的，不相等的利用率更高 数据结构：分区使用表，将分区按大小排序，并将地址，分配标识符（是否已分配），大小作记录，由于每个分区的大小固定，必然会造成存储空间的浪费 可变式分区数据结构 空闲分区表：记录每个空闲分区的情况，每个空闲分区占一个表目，表目中包括分区号，分区大小和分区始址等。 空闲分区链：实现对空闲分区表的分配和链接，在每个分区的起始部分设置一些用于控制分区分配的信息，以及用于链接各分区所用的前向指针，在分区尾部设置一后向指针，通过前后向链接指针，可将所有空闲分区链接成一个双向链，分区尾部重复设置状态位和分区大小表目，当分区被分配出去后，状态位由”0”改为”1”，此时前后指针无意义 分配算法为把一个新作业装入内存，须按照一定的分配算法，从空闲分区表或空闲分区链中选一分区分配给该作业 分区分配操作分配内存利用某种分配算法，从空闲分区链（表）中找到所需大小的分区，设请求的分区大小是u.size，表中每个空闲分区的大小可表示为m.size，若m.size-u.size&lt;=size（size是事先规定的不再切割的剩余分区的大小）说明多余部分太小，可不再切割，将整个分区分配给请求者，并从分区链移除，否则从该分区中按请求的大小划分找出一块内存空间分配出去，余下的部分仍留在空闲分区链（表）中，然后将分配区的首地址返回给调用者 回收内存当进程运行完毕释放内存后，系统根据回收区的首地址，从空闲区链（表）中找到相应的插入点，此时可能出现下面四种情况 回收区与插入点前一个空闲分区F1相邻接，此时应将回收区与插入点前一分区合并，不必为回收区分配新表项，而只需修改前一分区F1的大小 回收区与插入点后一个空闲分区F2相邻接，此时将两分区合并，形成新的空闲分区，但用回收区的首地址作为新空闲区的首地址，大小为两者之和 回收区同时与插入点的前，后两个分区邻接，此时将三个分区合并，使用F1的表项和F1的首地址，取消F2的表项，大小为三者之和 回收区既不与F1邻接也不与F2邻接：新建表项，填入回收区首地址和大小，插入到空闲链适当位置 分配算法基于顺序搜索的动态分区分配算法 首次适应(first fit, FF)算法：空闲分区链以地址递增的次序链接，从链首开始顺序查找直到找到一个大小能满足要求的空闲分区为止，然后从该分区划出一块内存空间分配给请求者 循环首次适应(next fit, NF)算法：不再是每次都从链首开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找 最佳适应(best fit, BF)算法：每次为作业分配内存时，总是把能满足要求又是最小的空闲分区分配给作业，要求所有空闲分区按容量从大到小顺序形成一空闲分区链 最坏适应(worst fit, WF)算法：总是挑选最大的空闲区从中分割一部分存储空间给作业使用，要求将所有空闲分区按容量从大到小形成一空闲分区链，查找时只需看第一个分区是否满足作业要求 基于索引搜索的动态分区分配算法 快速适应(quick fit)算法：将空闲分区根据容量大小分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链，内存设立一张管理索引表，索引表项对应空闲分区类型，并记录该类型空闲分区链表表头的指针，根据进程常用空间大小划分，比如2KB，4KB，8KB等，7KB可以放在8KB也可以放在特殊的空闲分区链表中 伙伴系统：无论已分配分区或空闲分区，其大小均为2的k次幂，对于相同大小空闲分区单独设立一个空闲分区双向链表，不同大小的空闲分区形成了k个空闲分区链表，对于进程分配一个长度为n的存储空间时，计算i值，使2^(i-1) &lt; n &lt;= 2^i，先从2^i的空闲分区查找，若找到就分配，没有则从2^(i+1)的空闲分区查找，找到就分为相等的两个分区，称为一对伙伴，其中一个分区用于分配，另一个分区加入到2^i的空闲分区链表中 哈希算法，构造空闲分区大小为关键字的哈希表，每一个表项记录一个对应的空闲分区链表表头指针 动态可重定位分区分配 紧凑：连续分配方式的一个重要特点是：一个系统或用户程序必须被装入一片连续的内存空间中，当计算机运行一段时间后，它的内存空间会被划分为许多小的分区，而缺乏大的空闲空间，当有大作业要加入，因为小分区不邻接，无法分配内存给大作业，紧凑就是将内存中的所有作业进行移动，使它们全都相邻接，这样，原来分散的多个空闲小分区拼接成一个大分区，每次紧凑后，必须对移动了的程序或数据进行重定位 动态重定位：动态运行时装入的方式，作业装入内存后所有地址仍然是相对地址，而将相对地址转换成绝对地址的工作被推迟到程序指令要真正执行的时候进行，设一个重定位寄存器，用它存放程序（数据）在内存中的起始地址，程序执行时真正访问的地址是相对地址与重定位寄存器的地址相加而形成的 对换对换的引入：将阻塞进程，暂时不用的程序，数据换出，将具备运行条件的进程换入类型： 整体对换：进程对换，解决内存紧张 部分对换：页面对换/分段对换：提供虚存支持 对换空间的管理具有对换功能的OS中，常把磁盘空间分为文件区和对换区，对换区比文件区侧重于对换速度，因此对换区一般采用连续分配，采用数据结构和分配回收类似于可变化分区分配 进程的换出与换入当内存不足时，便调用对换进程，实现进程的换出和换入 进程的换出 选择被换出的进程：选择因素：优先级，驻留时间，进程状态 进程换出过程：共享段计数减一，如果是0就换出，修改PCB和MCB 进程的换入 选择换入进程：优先级，换出时间等 申请内存 换入 分页存储管理方式基本概念分页主要是将用户程序的地址空间划分为若干个固定大小的区域，称为”页”或”页面”，典型的页面大小为1kb，相应地，也将内存空间分为若干个物理块或页框，页和块的大小相同，这样可以将用户程序的任一页放入任一物理块中，实现离散分配（页是相对用户程序的地址而言，页框或者块是相对内存空间而言） 离散分配的引入：连续分配引起碎片，紧凑方式消耗系统开销 分页存储管理的基本方法地址结构 A：逻辑地址空间的地址 L：页面的大小 包含两部分内容：前一部分为页号P，后一部分为位（偏）移量W，即页内地址，图中的地址长度为32位，其中0——11位为页内地址，即每页大小4KB（页面大小），12——31位为页号，地址空间最多允许有1M页 页的计算例子 页表为了能在内存中找到每个页面对应的物理块，系统为每个进程建立一张页面映射表，为页表，在进程地址空间内的所有页(0——n)，依次在页表中有一页表项，其中记录了相应页在内存中对应的物理块号，实现从页号到物理块号的地址映射 地址变换机构为了能将用户地址空间中的逻辑地址转换成内存空间中的物理地址，系统中设立了地址变换机构，地址变换机构任务实际只是将逻辑地址中的页号转换为内存中的物理块号（页内地址与物理块内的地址是一样的，所以不需要变换），地址变换任务就是借助页表实现的 基本地址变换机构 越界保护 每个进程对应一页表，其信息（如长度，始址）放在PCB中，执行时将其首地址装入页表寄存器 页表是驻留在内存中的，当调度程序调度某程序的时候，才将PCB中的页表始址和页表长度装入页表寄存器（一个进程对应一个页表，所以对不同页表，需要有页表始址来区分） 地址变换过程当进程要访问某个逻辑地址的数据时，分页地址变换机构会自动地将有效地址（相对地址）分为页号和页内地址两部分，再以页号为索引区检索页表，查找操作由硬件执行。在检索之前，先将页号与页表长度比较，若大于或等于页表长度，则表示本次所访问的地址已超越进程的地址空间，产生一地址越界中断。若未出现越界错误，则将页表始址与页号和页表项长度的乘积相加，便得到该表项在页表中的位置，于是可从中得到该页的物理块号，将它装入物理地址寄存器，然后把页内地址送入物理地址寄存器的块内地址字段中，这样便完成了逻辑地址到物理地址的变换 我对将页表始址与页号和页表项长度的乘积相加地理解页表项长度应该就是页表项（即物理块）的地址的长度通过上述式子的计算，得到的是一个地址值（页表始址+页号*页表项长度（地址长度）），这个地址值应该是页表中该页表项的物理内存地址，访问这个物理内存地址，就得到这个物理块号了 需要考虑的问题直接映射的分页系统对系统效能不利，因为CPU需要访问两次主存才能得到所需要的数据，第一次访问是访问主存中的页表，从中找到指定页的物理块号再将块号与页内偏移量W拼接形成物理地址，第二次访问是从第一次所得地址中获得实际数据，为了解决这个问题，引入快表 具有快表的地址变换机构为了提高地址变换速度，在地址变换机构中增设一个具有并行查寻能力的特殊高速缓冲寄存器，又称为”联想寄存器”，或称为”快表”，或者TLB，用以存放当前访问的那些页表项，此时地址变换过程是这样的： 在CPU给出有效地址后，由地址变换机构自动地将页号P送入高速缓冲寄存器，并将此页号与高速缓存中地所有页号进行比较，若其中有与此相匹配的页号，便表示所要访问的页表项在快表中，于是，可直接从快表中读出该页所对应的物理块号，并送到物理地址寄存器，如在快表中没有找到对应的页表项，则还须再访问内存中的页表，找到后把从页表中读出的物理块号送往地址寄存器，同时，再将此页表项存入快表的一个寄存器单元中，如果快表满了，则OS找到一个老的且被认为不需要的页表项换出 访问内存的有效时间从进程发出指定逻辑地址的访问请求，经过地址变换，到在内存中找到对应的实际物理地址单元并取出数据，所需要花费的总时间，称为内存的有效访问时间（Effective Access Time, EAT)，有效访问时间分为第一次访问内存时间（即查找页表对应的页表项所耗费的时间t）与第二次访问内存时间（即将页表项的物理块与页内地址拼接成实际物理地址所耗费的时间t）之和 t：访问一次内存所需要的时间EAT=t+t=2*t 引入快表后，快表命中率a，查找快表需要的时间λ EAT=a(t+λ)+(1-a)(2t+λ)=2t+λ-t*a 两级和多级页表 两级页表的逻辑地址结构 以前面的32位逻辑地址空间为例，当页面大小为4KB的时候(12位)，采用两级页表结构时，再对页表进行分页，使每页包含2^10个页表项，或者说，外层页表中的外层页内地址P2为10位，外层页号P1也为10位 （通过外部页号得到P2的始址，然后P2和d就可以通过上面说过的地址变换过程获得物理地址了）外层页表的每个页表项中存放的是某页表分页的首地址，地址变换机构中同样要增加外层页表寄存器，用于存放外层页表的始址，并利用逻辑地址中的外层页号作为外层页表的索引，从中找到指定页表的始址（同上页表始址与页号和页表项长度乘积相加那个原理），再利用P2作为指定页表分页的索引，找到指定页表项，即含有该页在内存中的物理块号，用该块号P和页内地址d即可构成访问的内存物理地址 一个练习小例子 对题目的理解：页号是用户程序而言的，该用户程序有32页，每页2K，而物理块是针对内存空间而言的，内存有1M，第1题第2问中，因为物理空间有1M，每页2K，即每个物理块2K，所以内存中有512个物理块，这32页必须可以对应到这512个物理块中的每一块，物理块号为0#——511#，页表项是物理块的块号，所以页表项位数应该是511的二进制位数，即9位 对第二题，由逻辑地址算出页号和页内地址，通过页号找到物理块号，物理地址=物理块号*页面大小+业内地址 分段存储管理系统基本思想：按程序的逻辑结构，将程序的地址空间划分为若干段，各段大小可不相同，在进行存储分配时，以段为单位，这些段在内存中可以不相邻接为什么引入：一方面程序可分为若干个段，主程序段，子程序段A，子程序段B，数据段，栈段等，另一方面实现和满足信息共享，信息保护，动态链接以及信息的动态增长等需要 分段系统基本原理分段每个段定义了一组逻辑信息，分段地址的地址具有如下结构 段表 地址变换过程 设置了段表寄存器，用于存放段表始址和段表长度TL，在进行地址变换时，系统将逻辑地址中的段号和段表长度TL进行比较，若S&gt;TL，表示段号太大，访问越界，若未越界，则根据段表始址和段号，计算出该段对应段表项的位置（物理地址），从中读出该段在内存的起始地址，然后检查段内地址d是否超过该段段长SL，若超过，即d&gt;SL，同样发出越界中断，若未越界，则该段基址d与段内地址相加，即可得到要访问的内存物理地址 分段同样需要访问两次内存，同样由联想存储器用于保存最近常用的段表项 分页和分段主要区别 页是信息的物理单位，段是逻辑单位 页长度固定由系统决定，段长度不固定 分页用户程序地址空间是一维的，分段是二维的，既要给出段名又要给出段内地址 段页式存储管理方式]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>存储器管理</tag>
        <tag>分页</tag>
        <tag>分段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[处理机调度与死锁]]></title>
    <url>%2F2019%2F05%2F09%2F%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[处理机调度与死锁处理机调度基本概念处理机调度分为三个层次 高级调度：作业调度，调度对象是作业，根据某种算法，决定将外存上处于后备队列的哪几个作业调入内存，为它们创建进程，分配资源，并放入就绪队列，主要用在多道批处理系统，在分时和实时系统中不设置高级调度 低级调度：进程调度，根据某种算法，决定就绪队列中哪几个进程应获得处理机，并由分派程序将处理机分配给被选中的进程，最基本的调度 中级调度：内存调度，主要目的是提高内存利用率和系统吞吐量，把暂时不能运行的进程调至外存等待，此时进程状态称为就绪驻外存状态（或挂起状态），当进程具备运行条件且内存又有空闲时，由中级调度决定，把外存上已具备运行条件的就绪进程重新调入内存，并挂在就绪队列上等待，实际上中级调度是存储器管理的对换功能 调度的运行频率是低&gt;中&gt;高 调度队列模型仅有进程调度的调度队列模型 同时具有三级调度的调度队列模型 周转时间多道批处理系统中，用户提交的作业先存放到外存，排成一个后备队列，作业调度程序按一定算法从后备队列中选择若干作业调入内存，使他们共享CPU和系统资源，当程序A因I/O而暂停执行时，再调度另一道程序B运行，这样可以保持CPU处于忙碌状态 周转时间常用于批处理系统，指从作业被提交给系统开始，到作业完成的时间，分为 驻外等待调度时间 驻内等待调度时间 执行时间 阻塞时间 平均周转时间可以表示为 带权周转时间描述进程在其周转时间中，等待和执行时间的具体分配情况，W=T/Ts，T是周转时间，Ts是系统为它提供服务的时间平均带权周转时间表示为 调度算法先来先服务(FCFS)和短作业优先(SJF)调度算法它们都可以用于作业调度和进程调度 FCFS(first-come first-served)就不解释了，SJF（short job first)以作业长短计算优先级，作业越短优先级越高，作业长度以作业所要求的运行时间来衡量，SJF缺点是必须预知作业的运行时间，对长作业非常不利，人机无法交互，未考虑作业紧迫程度。 FCFS和SJF的比较 在SJF中，当A完成后，此时时间为4，B,C,D,E均已到达，因为D的作业最短，所以处理机先为D服务，然后为B，E，C服务 高优先权优先调度算法可以作为作业调度和进程调度 优先级调度算法（PSA，priority-scheduling algorithm）分为非抢占式优先权算法和抢占式优先权算法，抢占式实时性更好 优先权的类型分为 静态优先权：整个运行期不变 动态优先权：优先权随执行时间而下降，随等待时间而上升，响应比Pp=(等待时间+服务时间)/服务时间作为优先权，优点是长短兼顾，缺点是需要计算Rp 高响应比优先算法(HRRN,Highest Response Ratio Next)响应比Rp=(tw+ts)/ts，tw为等待时间，ts为服务时间 基于时间片的轮转调度算法(RR)进程调度算法，基于时间片的轮转(RR,round robin)让就绪队列上的每个进程每次仅运行一个时间片，每个进程每次大约都可获得1/n的处理机时间 进程切换时间 若一个时间片尚未用完，正在运行的进程已经完成，则激活调度程序，将它从就绪队列中删除，再调度就绪队列中队首的进程运行，并启动一个新的时间片 若时间片用完，计时器中断处理程序激活，调度程序把它送往就绪队列的队尾 时间片大小的确定若时间片太大，则退化为FCFS，若太小，则系统开销过大，时间片大小确定应考虑系统对响应时间的要求，就绪队列中进程的数目和系统的处理能力（应保证一个时间片处理完常用命令） 实时调度实时调度必须提供： 就需时间：某任务成为就绪的起始时间 开始/完成截止时间 处理时间 资源要求 优先级 非抢占式用时间片轮转，抢占式可以时钟中断或立即抢占（只要不在临界区就抢占） 常见的实时调度算法最早截止时间优先EDF根据任务的开始截止时间来确定任务优先级 最低松弛度优先LLF松弛（紧急）程度=完成截止时间-处理时间-当前时间 主要用于可抢占的调度方式 死锁死锁定义：如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件，那么该组进程是死锁的。 产生死锁的原因 竞争资源引起死锁：竞争不可抢占的资源或可消耗资源引起死锁 进程推进顺序不当 产生死锁必要条件 互斥条件：资源必须互斥 请求和保持条件：进程已经保持至少一个资源但又提出新的资源请求 不可抢占条件：资源不可抢占 循环等待条件：发生死锁时，必然存在一个进程——资源的循环链，即P0等待P1占用的资源，P1等待P2占用的资源，Pn等待P0占用的资源 解决死锁的方法 预防死锁 避免死锁 检测死锁 解除死锁 解决死锁的方法预防死锁预防死锁：破坏产生死锁的4个必要条件之一，互斥条件一般是不能破坏的，所以主要是破坏产生死锁的后三个条件，预防死锁有效，但资源利用率低 摒弃请求和保持条件：资源一次性分配摒弃不剥夺条件：新申请不能满足就释放已获得资源摒弃环路条件：资源有序分配，为资源编号，申请时按编号进行 避免死锁避免死锁是在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁，最经典的避免死锁的算法是银行家算法 银行家算法数据结构 可利用资源向量Available：含有m个元素的数组，每个元素代表一类可利用的资源数目，初始值是系统配置的该类全部可用资源的数目，Available[j]=K表示系统中现有Rj类资源的最大数目K个 最大需求矩阵Max：是一个n*m的矩阵，定义了系统中n个进程中每一个进程对m类资源的最大需求，如果Max[i, j]=K，则表示进程i需要Rj类资源的最大数目为K 分配矩阵Allocation：n*m矩阵，定义了系统中每一类资源当前已分配给每一进程的资源数，如果Allocation[i, j]=K，则表示进程i当前已分得Rj类资源的数目为K 需求矩阵Need：n*m矩阵，用来表示每一个进程尚需的各类资源数，如果Need[i, j]=K，表示进程i还需要Rj类资源K个 Need[i, j] = Max[i, j] - Allocation[i, j] 算法流程设Requesti是进程Pi的请求向量，如果Requesti[j]=K，则表示进程Pi需要K个Rj类的资源，当Pi发出资源请求后，系统按下述步骤进行检查 如果Requesti[j] &lt;= Need[i, j]，则转向步骤2，否则认为出错，因为它申请的资源大于它宣布的最大值 如果Requesti[j] &lt;= Available[j]，则转向步骤3，否则尚无足够资源，Pi需等待 系统试探把资源分配给进程Pi，并修改下面数据结构的数值 Available[j] = Available[j] - Requesti[j]; Allocation[i, j] = Allocation[i, j] + Requesti[j]; Need[i, j] = Need[i, j] - Requesti[j]; 系统执行安全性算法，检查此次资源分配后系统是否处于安全状态，若安全，才正式分配资源给Pi，否则本次试探分配作废，恢复原来的资源分配状态，让进程Pi等待 安全性算法如上面所述，安全性算法是试探性分配后（即修改了Available，Allocation，Need但未正式分配资源）进行的，若安全才正式分配，否则试探分配作废，算法如下 设置两个向量：工作向量Work，表示系统可提供给进程继续运行所需的各类资源数目，含有m个元素，执行安全算法开始时，Work=Available；Finish，它表示系统是否有足够资源分配给进程，使之运行完成。开始时Finish[i]=false，当有足够资源分配给进程时，再令Finish[i]=true 从进程集合中找到一个满足下述条件的进程：Finish[i]=false;Need[i, j] &lt;= Work[j];若找到，则转向步骤3，否则转向步骤4 假如进程Pi获得资源，则进程Pi可顺利执行，直到完成，并释放分配给它的资源，故应执行Work[j] = Work[j] + Allocation[i, j];Finish[i] = true;go to step 2; 如果所有进程的Finish[i]=true都满足，则表示系统处于安全状态，否则，系统处于不安全状态 银行家算法安全性检查的例子 一开始检查，发现p0不满足第2步的条件，p1满足，就把p1的资源释放，加到Work，然后继续检查，p2不满足，p3满足，则释放掉p3的资源，然后释放，最后所有的进程都释放了 P.S.解题的时候，画表，行是每个进程，列依次是Work,Need,Allocation,Work+Allocation,Finish 检测死锁资源分配图 资源分配图圆圈表示进程，方框表示资源，方框内点表示资源数，箭头由资源指向进程表示一个单位的资源分配给进程，进程指向资源表示进程请求一个单位的资源 死锁定理S为死锁状态的充分条件是当且仅当S状态的资源分配图是不可完全简化 资源分配图的简化找出既不阻塞又非独立的进程结点Pi，去掉所有分配边和请求边，若能去掉所有结点的所有分配边和请求边，则不会发生死锁，否则发生死锁 解除死锁主要方法 抢占资源：从一个或多个进程抢占足够资源分配给死锁进程 终止进程]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>调度</tag>
        <tag>死锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程管理]]></title>
    <url>%2F2019%2F05%2F08%2F%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[进程管理进程的定义，与程序的区别定义进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位，是程序的一次执行。 与程序的区别 进程 程序 程序是指令的集合，是静态的概念 进程是处理机上的一次执行过程，动态的概念 程序是长期存在的 进程有生命周期，有创建，活动和消亡 程序是指令的有序集合 进程由程序，PCB和数据组成 程序和进程并非一一对应，同一程序同时运行在若干不同数据集上，它将属于若干个不同进程 一个进程可以执行多个程序 进程的状态及其转换进程三种基本状态分别是 就绪状态 执行状态 阻塞状态 它们的转换关系如下 引入挂起状态（被换出内存的状态）后，进程的转换如下 挂起状态挂起状态是把进程从内存移出外存，不释放CPU 而阻塞状态是释放CPU，但不释放内存 引入挂起状态的原因是 终端用户请求 父进程请求 负荷调节需要 操作系统需要 进程控制块PCBPCB的作用PCB是进程的唯一标识，它常驻内存 它作为独立运行基本单位的标志 能实现间断性运行方式 提供进程管理所需要的信息 提供进程调度所需要的信息 实现与其他进程的同步和通信 PCB的信息PCB主要包括以下四个方面的信息 进程标识符：外部标识符（针对用户即进程），内部标识符（针对系统） 处理机状态：通用寄存器，指令计数器，用户栈指针，程序状态字等 进程调度信息：进程状态，进程优先级，进程调度其他信息（已等待CPU时间等），事件（阻塞原因） 进程控制信息：程序和数据地址，进程同步和通信机制，资源清单，链接指针（所在队列下一个进程PCB的首地址） 进程控制任务：对系统中所有进程从产生，存在到消亡的全过程实施有效的管理和控制 进程控制由内核中原语实现。 原语（Primitive）：由若干条指令组成，用于完成一定功能的一个过程，它们是原子操作，即所有动作要么全不做，要么全做，是不可分割的，不允许被中断的。原语由内核系统态执行，常驻内存。 常见的进程控制原语如下 创建 撤销 阻塞：执行-&gt;阻塞 唤醒：阻塞-&gt;就绪 挂起：活动-&gt;静止 激活：静止-&gt;活动 进程创建进程创建的过程如下 申请空白PCB 为新进程分配资源 初始化PCB 新进程插入到就绪队列 进程同步同步同步指并发进程在执行次序上的协调，以达到有效资源共享和相互合作，是程序执行有可再现性。 进程有两种形式的制约关系，分别是 资源共享关系：进程间接制约，需互斥地访问临界资源 相互合作关系：进程直接制约 临界资源：一次仅允许一个进程访问的资源 临界区：进程访问临界资源的那段代码 同步机制应遵循： 空闲让进 忙则等待 有限等待 让权等待：不能进入临界区的进程应放弃CPU执行权 信号量机制实现进程同步有许多方法，其中比较经典的是信号量机制 整型信号量整型信号量定义为用于表示资源数目的整型量S，它除初始化外，仅能通过两个原子操作wait(S)和signal(S)来访问，这两个操作一直被称为P，V操作，wait，signal操作描述如下 1234567wait(S) &#123; while (S &lt;= 0); S--;&#125;signal(S) &#123; S++;&#125; 这两个操作是原子操作，它们在执行的时候是不可中断的 记录型信号量整型信号量并没有实现让权等待，而是让进程处于忙等状态，这个时候就需要引入记录型信号量来实现 记录型信号量有一个整型变量value表示资源数目，还有一个进程链表指针list，用于链接上述所有等待进程，定义和PV操作描述如下 12345678910111213typedef struct &#123; int value; struct process_control_block *list;&#125; semaphore;wait(semaphore *S) &#123; S-&gt;value--; if (S-&gt;value &lt; 0) block(S-&gt;list); // block是阻塞原语，它的意思是把当前进程自我阻塞并插入到S-&gt;list中&#125;signal(semaphore *S) &#123; S-&gt;value++; if (S-&gt;value &lt;= 0) wakeup(S-&gt;list); // wakeup是唤醒原语&#125; S-&gt;value是系统中某类资源数目，对它每次wait，意味进程请求一个单位的该类资源，当S-&gt;value &lt; 0，表示该资源已分配完成，进程应调用block原语自我阻塞，并插入到信号量链表S-&gt;list中。当S-&gt;value &lt; 0，它的绝对值是链表中已阻塞进程的数目。对信号量每次signal操作表示执行进程释放一个单位资源，S-&gt;value++，若+1后S-&gt;value仍然&lt;=0，表示该信号量链表中仍有等待该资源的进程被阻塞，调用wakeup原语唤醒该进程.如果S-&gt;value初值为1，则只允许一个进程访问临界资源，此时信号量为互斥信号量。 AND型信号量AND同步机制基本思想是：将进程整个运行过程中需要的所有资源，一次性全部分配给进程，使用后一次性释放，原语为Swait(Simultaneous wait)和Swakeup 管程引入原因：为了避免凡要使用临界资源的进程都自备同步操作wait(s)和signal(s)，将同步操作的机制和临界资源结合到一起，形成管程 定义：一个数据结构和能为并发进程所执行的一组操作，包括局部于管程的共享变量，对该数据结构进程操作的一组过程，对局部管程数据设置初值 管程语法描述如下： 1234567891011121314Monitor monitor_name &#123; // 管程名 share variable declarations; // 共享变量 cond declarations; // 条件变量 void P1(...) &#123;...&#125; void P2(...) &#123;...&#125; ... void(....) &#123;...&#125; &#123; // 管程主体 initialization code; // 初始化代码 &#125;&#125; 条件变量用于进程的阻塞和挂起，形式为condition x, y，对条件变量的操作仅仅是wait和signal，每个条件变量保存一个链表，用于记录因该条件变量而阻塞的所有进程，同时提供两个操作x.wait和x.signal x.wait：正在调用管程的进程因x条件需要被阻塞或挂起，调用x.wait将自己插入到x条件的等待队列上，并释放管程x.signal：正在调用管程的进程发现x条件发生了变化，则调用它，重新启动一个因x条件而阻塞或挂起的进程 进程同步的经典问题生产者-消费者问题问题描述：一组生产者向一组消费者提供消息，它们共享一个包含n个缓冲区的有界缓冲池，生产者向其中投放消息，消费者从中取得消息 问题求解：互斥信号量mutex实现诸进程对缓冲池的互斥使用，信号量empty和full分别表示缓冲池中空缓冲区和满缓冲区的数量 1234567891011121314151617181920212223242526272829303132int in = 0, out = 0;item buffer[n];semaphore mutex = 1, empty = n, full = 0;void producer() &#123; do &#123; produce an item nextp; ... wait(empty); // 当空缓冲池数量为0，即缓冲池已满 wait(mutex); buffer[in] = nextp; in = (in + 1) % n; signal(mutex); signal(full); &#125; while (TRUE);&#125;void consumer() &#123; do &#123; wait(full); // 当满缓冲池为0，即缓冲池已空 wait(mutex); nextc = buffer[out]; out = (out + 1) % n; signal(mutex); signal(empty); consume the item in nextc; ... &#125; while (TRUE); &#125;void main() &#123; cobegin producer(); consumer(); coend&#125; P操作很重要，假如颠倒了生产者的P操作，先拥有了缓冲池的使用权，但此时无空缓冲池，则会进入死锁，V操作顺序则无关紧要，当缓冲区只有一个时，mutex可以省略 哲学家进餐问题 哲学家进餐应定义5个信号量表示5只筷子，且初值均为1，而不能定义1个信号量，因为5个筷子位置不同，哲学家并不是随意拿5个筷子的，他们只能拿他们左右最靠近他们的筷子，描述如下semaphore chopstick[5] = {1, 1, 1, 1, 1}; 第i个哲学家的活动可描述为 123456789101112do &#123; wait(chopstick[i]); wait(chopstick[(i + 1) % 5]); ... // eat ... signal(chopstick[i]); signal(chopstick[(i + 1) % 5]); ... // think ...&#125; while(TRUE) 哲学家问题出现死锁的可能是：五个哲学家同时饥饿而各自拿起左边的筷子，就会使5个信号量chopstick均为0，当他们再试图去拿右边的筷子时，会因没有筷子可拿而无限等待 解决方法有如下几个： 1.至多允许有4位哲学家同时拿左边筷子，方法：设置信号量sm初值为4 12345678910111213philopher(i) &#123; do &#123; wait(sm); wait(chopstick[i]); wait(chopstick[(i + 1) % 5]); eat; signal(sm); signal(chopstick[i]); signal(chopstick[(i + 1) % 5]); signal(sm); think; &#125; while (TRUE);&#125; 2.规定奇数号哲学家先拿他左手边的筷子，再拿右手边的筷子，偶数号哲学家相反 123456789101112131415161718philopher(i) &#123; do &#123; if (i % 2 == 0) &#123; wait(chopstick[i]); wait(chopstick[(i + 1) % 5]); eat; signal(chopstick[i]); signal(chopstick[(i + 1) % 5]); &#125; else &#123; wait(chopstick[(i + 1) % 5]); wait(chopstick[i]); eat; signal(chopstick[(i + 1) % 5]); signal(chopstick[i]); &#125; think; &#125; while (TRUE);&#125; 3.仅当左右手两只筷子均可用的时候，才拿起筷子进餐，利用AND信号量解决 12345678philopher(i) &#123; do &#123; Sswait(chopstick[i], chopstick[(i + 1) % 5]) eat; Ssignal(chopstick[i], chopstick[(i + 1) % 5]); think; &#125; while (TRUE);&#125; 读者-写者问题问题描述：读进程可共享同一对象，写进程不可共享同一对象 分析：整型变量readcount表示读者数，信号量rmutex互斥访问readcount，wmutex读写互斥，只要有一个进程在读，就不允许写进程去写 1234567891011121314151617181920212223242526272829semaphore rmutex = 1, wmutex = 1;int readcount = 0;void reader() &#123; do &#123; wait(rmutex); // readcount的互斥访问 if (readcount == 0) wait(wmutex); // 读写互斥，当该进程为第一个读进程，判断是否有写进程在写，有则阻塞，无则加锁 readcount++; signal(rmutex); ... perform read operation; ... wait(rmutex); readcount--; if (readcount == 0) signal(wmutex); signal(rmutex); &#125; while (TRUE);&#125;void writer() &#123; do &#123; wait(wmutex); perform write operation; signal(wmutex); &#125; while (TRUE);&#125;void main() &#123; cobegin reader(); writer(); coend&#125; 读-写问题的扩散——写者优先即当写进程到达后，后续的读进程必须等待 方法：增加信号量S（初值1），当写进程运行时上锁，封锁后续读者。增加信号量s后，当读进程读，先wait(s)，若后续读进程运行，都会进入s的阻塞队列，而不会在其他进程读的期间（上锁了s，没有上锁rmutex）进入wmutex的阻塞队列，当有写进程运行并进入s的阻塞队列，后续再有读进程进入s的阻塞队列，都排在写进程之后，当前面读进程释放s后，写进程就可以对s上锁，阻止后续读进程了 123456789101112131415161718192021222324252627282930313233semaphore rmutex = 1, wmutex = 1, s = 1;int readcount = 0;void reader() &#123; do &#123; wait(s); wait(rmutex); // readcount的互斥访问 if (readcount == 0) wait(wmutex); // 读写互斥，当该进程为第一个读进程，判断是否有写进程在写，有则阻塞，无则加锁 readcount++; signal(rmutex); signal(s); ... perform read operation; ... wait(rmutex); readcount--; if (readcount == 0) signal(wmutex); signal(rmutex); &#125; while (TRUE);&#125;void writer() &#123; do &#123; wait(s); wait(wmutex); perform write operation; signal(wmutex); signal(s); &#125; while (TRUE);&#125;void main() &#123; cobegin reader(); writer(); coend&#125; 进程通信进程通信实质是进程间的信息交换，有如下几种通信方式 信号量机制：低级，效率低，对用户不透明 共享存贮器：共享存储区等 消息传递系统：交换报文，由一组通信原语实现 管道通信：管道是连接一个读进程和一个写进程之间通信的共享文件 客户机-服务器系统：套接字等]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络之DNS服务]]></title>
    <url>%2F2019%2F04%2F10%2FDNS%2F</url>
    <content type="text"><![CDATA[DNSDNS是计算机网络应用层一个很重要的服务，了解它基本就了解了整个网络中域名到IP转换的过程。 DNS是什么在《计算机网络-自顶向下方法》中有这么一句话 DNS：因特网的目录服务 DNS（Domain Name System）其实就是一个目录，他的作用是通过用户给定域名，查出对应的IP地址。 而更为严格的定义就是：DNS是： 一个由分层的DNS服务器实现的分布式数据库 一个使得主机能够查询分布式数据库的应用层协议 或者说DNS是一个黑盒子，它提供了主机名到IP地址的转换，一个简便的DNS黑盒子过程如下： 同一台用户主机上运行着DNS应用的客户端 浏览器从URL中抽取出主机名，传给DNS应用的客户端 DNS客户向DNS服务器发送一个包含主机名的请求 DNS客户最终收到一份回答报文，其中含有对应该主机名的IP地址 一旦浏览器获得该地址，就可以向位于该IP地址的80端口的HTTP服务器进程发起一个TCP连接 DNS主要任务是主机名到IP地址转换的目录服务DNS除了有主机名到IP地址的转换服务外，还有如下服务： 主机别名 邮件服务器别名 负载分配 值得一提的是，DNS协议运行在UDP之上，使用53端口。 DNS分布式，层次数据库DNS是一个分布式，层次数据库，大致有三类：根DNS服务器，顶级域(TLD)DNS服务器和权威DNS服务器。还有一类是本地DNS服务器，每个ISP都有一台本地DNS服务器，本地DNS服务器起着代理的作用，将请求转发到DNS服务器的层次结构中。 在说服务器分层作用之前，先要说一下域名，常见的域名是例如www.example.com，但是它真正的域名是www.example.com.root，只是省略了后面的.root。.root称为根域名，.com，.net等等称为顶级域名(TLD)，.example称为次级域名，这个域名是用户可以注册的，再下一级是主机名(host)，比如www，又称为三级域名。 总结一下，域名的层级结构如下： 主机名(三级域名).次级域名.顶级域名.根域名 即host.sld.tld.root 根DNS服务器它将返回顶级域名的TLD服务器的IP地址，根域名服务器的NS记录和IP地址一般是不会变化的 顶级域DNS服务器它返回权威服务器的IP地址 权威DNS服务器它返回主机名(如www.amazon.com)的IP地址 本地DNS服务器严格上来说它不属于DNS层次结构，但它也很重要。本地DNS服务器由ISP提供，当主机发出DNS请求时，通常被发往到本地DNS服务器，由本地DNS服务器代理转发到DNS服务器层次结构 工作机理 以主机cis.poly.edu请求gaia.cs.umass.ude的IP地址为例，假设cis.poly.edu的本地DNS为dns.poly.edu，并且gaia.cs.umass.edu的权威DNS服务器为dns.umass.edu 主机cis.poly.edu首先向它的本地DNS服务器dns.poly.edu发送一个DNS查询报文 本地DNS服务器dns.poly.edu将报文转发到根DNS服务器，根DNS服务器注意到edu前缀并向本地DNS服务器返回负责edu的TLD的IP地址列表 该本地DNS服务器则再次向这些TLD服务器之一发送查询报文 该TLD服务器注意到umass.edu前缀，并用权威DNS服务器的IP地址进行响应 最后，本地DNS服务器直接向dns.umass.edu重发查询报文，dns.umass.edu将gaia.cs.umass.edu的IP地址进行响应 从请求主机到本地DNS服务器的查询是递归的，其余的查询是迭代的 DNS缓存为了改善时延性能并减少在因特网上到处传输的DNS报文数量，DNS广泛采用了缓存技术 它能够把回答中的信息缓存在本地存储器中，但该缓存不是永久的，由于主机和主机名与IP地址间的映射并不是永久的，所以DNS服务器一般在一段时间后（通常为2天）将丢弃缓存的信息。 DNS报文和记录DNS记录共同实现DNS分布式数据库的所有DNS服务器存储了资源记录（Resource Record，RR），RR提供了主机名到IP地址的映射。 RR是一个包含了下列字段的4元组：(Name, Value, Type, TTL) TTL是该记录的生存时间，它决定了资源记录应当从缓存中删除的时间 如果Type=A，则Name是主机名，Value是该主机名对应的IP地址 如果Type=NS，则Name是个域（如foo.com），Value是个知道如何获得该域中主机IP地址的权威DNS服务器的主机名。这个记录用于沿着查询链来路由DNS查询。（如(foo.com, dns.foo.com, NS)就是一个NS记录） 如果Type=CNAME，则Value是别名为Name的主机对应的规范主机名 如果Type=MX，则Value是个别名为Name的邮件服务器的规范主机名 如果一台DNS服务器是用于某特定主机名的权威DNS服务器，那么该DNS服务器会有一条包含该主机名的类型A记录如果服务器不是用于某主机名的权威服务器，那么该服务器将包含一条类型NS记录，该记录对应包含主机名的域；它还包括一条类型A记录，提供在NS记录的Value字段中的DNS的IP地址（比如edu TLD服务器不是主机gaia.cs.umass.edu的权威DNS服务器，则该服务器将包含一条包括主机cs.umass.edu的域记录，如(umass.edu, dns.umass.edu, NS)，该TLD服务器还将包含一条类型A记录，如(dns.umass.edu, 128.199.40.111, A)，该记录将名字dns.umass.edu映射为一个IP地址） DNS报文 对分级查询的进一步解释所谓”分级查询”，就是从根域名开始，依次查询每一级域名的NS记录，直到查到最终的IP地址，见下面的DNS记录可知 从”根域名服务器”查到”顶级域名服务器”的NS记录和A记录（IP地址） 从”顶级域名服务器”查到”次级域名服务器”的NS记录和A记录（IP地址） 从”次级域名服务器”查出”主机名”的IP地址 （根域名服务器的NS记录和IP地址一般是不会变化的，所以内置在DNS服务器中）]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript09-事件]]></title>
    <url>%2F2019%2F04%2F10%2FJavaScript09-%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[JavaScript09-事件事件流事件流描述的是从页面中接收事件的顺序。如果单击某个按钮，那么单击事件不仅仅发生在按钮上，同样发生在按钮的容器元素，甚至整个页面上。事件冒泡就是最具体的元素最先接收这个事件，然后逐级向上，事件捕获则相反。 事件冒泡事件冒泡是IE提出的，即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档） 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;aha&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="myDiv"&gt;Click Me&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 点击&lt;div&gt;元素，那么这个click事件就按照如下顺序传播： &lt;div&gt; &lt;body&gt; &lt;html&gt; document 事件捕获Netscape Communicator团队提出的另一种事件流。事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。仍以上面html代码为例，单击&lt;div&gt;元素就会以下列顺序触发click事件 document &lt;html&gt; &lt;body&gt; &lt;div&gt; 一般考虑到老版本，使用事件冒泡更多。 DOM事件流DOM2级事件规定的事件流包括三个阶段：事件捕获阶段，处于目标阶段和事件冒泡阶段。 事件处理程序事件处理程序名字以”on”开头，因此click事件的事件处理程序就是onclick，load事件的事件处理程序就是onload。 HTML事件处理程序123456&lt;script type="text/javascript"&gt; function showMessage() &#123; alert("Hello World!"); &#125;&lt;/script&gt;&lt;input type="button" value="Click Me" onclick="showMessage()" /&gt; 这样指定事件处理程序会创建一个封装着元素属性值的函数，这个函数中有一个局部变量event，也就是事件对象 &lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(event.type)&quot; /&gt; // &quot;click&quot; 通过event对象，可以直接访问事件对象，在这个函数内部，this值等于事件的目标元素 &lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(this.value)&quot; /&gt; // 返回元素的value属性，这里为&quot;Click Me&quot; 关于这个动态创建的函数，可以像访问局部变量一样访问document及该元素本身的成员，使用with像下面这样扩展： 1234567function() &#123; with(document) &#123; with(this) &#123; // 元素属性值 &#125; &#125;&#125; 如果当前元素是一个表单输入元素，则作用域还会包含访问表单元素的入口，如下： 123456789function() &#123; with(document) &#123; with(this.form) &#123; with(this) &#123; // 元素属性值 &#125; &#125; &#125;&#125; 扩展这个作用域的方式，主要是想让事件处理程序无需引用表单元素就能访问其他表单字段，例如： 1234&lt;form method="post"&gt; &lt;input type="text" name="username" value="" /&gt; &lt;input type="button" value="Echo Username" onclick="alert(username.value)"&gt;&lt;/form&gt; DOM0级事件处理程序通过JavaScript指定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性。如下 1234var btn = document.getElementById(&quot;myBtn&quot;);btn.onclick = function() &#123; alert(&quot;Clicked&quot;);&#125; 使用DOM0级方法执行的事件处理程序被认为是元素的方法，程序中的this引用的是当前元素。只需把属性值设置为null就可以删除事件处理程序 DOM2级事件处理程序DOM2级事件定义了两个方法，用于处理指定和删除事件处理程序的操作：addEventListener()和removeEventListener()。所有DOM节点都包含这两个方法，它们接收3个参数：要处理的事件名，作为事件处理程序的函数和一个布尔值。这个布尔值若为true，表示捕获阶段调用事件处理程序；如果是false，表示冒泡阶段调用事件处理程序。 DOM2级方法主要好处是可以添加多个事件处理程序，如下 123456789var btn = document.getElementById("myBtn");btn.addEventListener("click", function() &#123; alert("Hello World!");&#125;, false);btn.addEventListener("click", function()&#123; alert(this.id);&#125;, false); 通过addEventListener()添加的事件处理程序只能使用removeEventListener()来移除；移除时传入的参数要与添加处理程序时使用的参数相同，即添加的匿名参数无法移除。 大多数情况下，都是把事件处理程序添加到事件流的冒泡阶段，这样可以最大限度地兼容各种浏览器。最好只在需要在事件到达目标之前截获它的时候将事件处理程序添加到捕获阶段。如果不是特别需要，不建议在事件捕获阶段注册事件处理程序。 事件对象在触发DOM上某个事件时，会产生一个事件对象event，这个对象中包含所有与事件有关的信息，包括导致事件的元素，事件的类型以及其他与特定事件相关的信息。例如鼠标操作导致的鼠标位置的信息等。 DOM中的事件对象兼容DOM的浏览器会将一个event对象传入到事件处理程序中。 关于event的更多（比如其成员),可以看MDN的DOM Event接口 如果事件处理程序指定给目标元素，则this，currentTarget和target是相同的，事件处理程序内部，对象this始终等于currentTarget的值，如果事件处理程序存在于父节点中，则这些值是不同的，如下 123456var btn = document.getElementById("myBtn");document.body.onclick = function(event) &#123; alert(event.currentTarget == document.body); alert(document.body == this); alert(event.target == btn);&#125; 需要处理一个函数处理多个事件的时候，可以使用type属性，如下： 123456789101112131415161718var btn = document.getElementById("myBtn");var handler = function(event) &#123; switch(event.type) &#123; case "click" : alert("clicked"); break; case "mouseover" : event.target.style.backgroundColor = "red"; break; case "mouseout" : event.target.style.backgroundColor = ""; break; &#125;&#125;;btn.onclick = handler;btn.onmouseover = handler;btn.onmouseout = handler; 要阻止特定事件的默认行为，可以使用preventDefault()方法。例如，链接的默认行为就是在被单击的时候会导航到其href特性指定的URL。 1234var link = document.getElementById("myLink");link.onclick = function(event) &#123; event.preventDefault();&#125; 只有cancelable属性设置为true的事件，才可以使用preventDefault()方法来取消默认行为。 stopPropagation()方法用于立即停止事件在DOM层次中的传播，即取消进一步事件捕获或冒泡。例如，直接添加到一个按钮的事件处理程序可以调用stopPropagation()，从而避免触发注册在document.body上面的事件处理程序。 eventPhase属性可以用来确定事件当前位于事件流的哪个阶段。如果是在捕获阶段调用事件处理程序，那么eventPhase的值为1，如果事件处理程序在目标对象上，则eventPhase值为2，如果是在冒泡阶段调用的事件处理程序，eventPhase等于3。 跨浏览器的事件对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182var EventUtil = &#123; addHandler: function(element, type, handler) &#123; if (element.addEventListener) &#123; element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; // IE事件处理程序 element.attachEvent("on" + type, handler); &#125; else &#123; element["on" + type] = handler; &#125; &#125;, getEvent: function(event) &#123; return event ? event : window.event; &#125;, getTarget: function(event) &#123; return event.target || event.srcElement; &#125;, preventDefault: function(event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, removeHandler: function(element, type, handler) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if (element.detachEvent) &#123; element.detachEvent("on" + type, handler); &#125; else &#123; element["on" + type] = null; &#125; &#125;, stopPropagation: function(event) &#123; if (event.stopPropagation) &#123; event.stopPropagation(); &#125; else &#123; event.cancelBubble = true; &#125; &#125;, // 与mouseout，mouseover事件相关的属性，见下面 getRelatedTarget: function(event) &#123; if (event.relatedTarget) &#123; return event.relatedTarget; &#125; else if (event.toElement) &#123; // 兼容IE8 return event.toElement; &#125; else if (event.fromElement) &#123; return event.fromElement; &#125; else &#123; return null; &#125; &#125;, // 与mousedown，mouseout事件相关的鼠标属性 getButton: function(event) &#123; if (document.implementation.hasFeature("MouseEvents", "2.0")) &#123; return event.button; &#125; else &#123; switch(event.button) &#123; case 0: case 1: case 3: case 5: case 7: return 0; case 2: case 6: return 2; case 4: return 1; &#125; &#125; &#125;&#125;; 事件类型DOM3级事件规定了以下几类事件 UI事件：当用户与页面上的元素交互时触发； 焦点事件：当元素获得或失去焦点时触发； 鼠标事件：当用户通过鼠标在页面上执行操作时触发； 滚轮事件：当使用鼠标滚轮时触发； 文本事件：当在文档中输入文本时触发； 键盘事件：当用户通过键盘在页面上执行操作时触发； 合成事件：当为IME（输入法编辑器）输入字符时触发； 变动事件：当底层DOM结构发生变化时触发。 UI事件UI事件指的是那些不一定与用户操作有关的事件，有如下UI事件。 load：当页面完全加载后在window上触发，当所有框架都加载完毕时在框架集上触发，当图像加载完毕在&lt;img&gt;元素上触发，或者当嵌入的内容加载完毕时在&lt;object&gt;元素上触发。 unload：当页面完全卸载后在window上触发，当所有框架都卸载后在框架集上触发，或当嵌入的内容卸载后在&lt;object&gt;元素上触发。 abort：在用户停止下载过程时，如果浅入的内容没有加载完，则在&lt;object&gt;元素上触发。 error：当发生在JavaScript错误时在window上触发，当无法加载图像时在&lt;img&gt;上触发，当无法加载嵌入内容时在&lt;object&gt;上触发，或者当有一或多个框架无法加载时在框架集上触发。 select：当用户选择文本框（&lt;input&gt;或&lt;texterea&gt;）中的一或多个字符时触发。 resize：当窗口或框架大小变化时在window或框架上触发。 scroll：当用户滚动带滚动条的元素中的内容时，在该元素上触发。&lt;body&gt;元素中包含所加载页面的滚动条。 确定浏览器是否支持DOM2级事件规定的HTML事件，可以用如下代码 var isSupported = document.implementation.hasFeature(&quot;HTMLEvents&quot;, &quot;2.0&quot;); 确定浏览器是否支持DOM3级事件定义的事件，可以用如下代码 var isSupported = document.implementation.hasFeature(&quot;UIEvent&quot;, &quot;3.0&quot;); load事件当页面完全加载后（包括所有图像，JS文件，CSS等外部资源），就会触发window上的load事件。 有两种添加onload事件处理程序的方式，一个是使用上面的EventUtil，另一个就是给&lt;body&gt;元素添加onload特性。 123EventUtil.addHandler(window, "load", function(event) &#123; alert("loaded!");&#125;); &lt;body onload=&quot;alert(&#39;Loaded!&#39;)&quot;&gt;&lt;/body&gt; 一般来说，在window上面发生的任何事件都可以在&lt;body&gt;元素中通过相应的特性来指定。 对于&lt;img&gt;元素，可以为其指定一个事件处理程序，以便图像加载完毕后给出提示。此时，最重要的是要在指定的属性之前先加载指定事件。 123456789EventUtil.addHandler(window, "load", function(event) &#123; var image = document.createElement("img"); EventUtil.addHandler(image, "load", function(event) &#123; event = EventUtil.getEvent(event); alert(EventUtil.getTarget(event).src); &#125;); document.body.appendChild(image); image.src = "./a.jpg"; &#125;); 还有一些元素也以非标准方式支持load事件，&lt;script&gt;元素也会触发load事件，以便开发人员确定动态加载的JS文件是否加载完毕。 12345678EventUtil.addHandler(window, "load", function(event) &#123; var script = document.createElement("script"); EventUtil.addHandler(script, "load", function(event) &#123; alert("Loaded!"); &#125;); script.src = "example.js"; document.body.appendChild(script); &#125;); unload事件在文档被完全卸载后触发。只要用户从一个页面切换到另一个页面，就会发生unload事件。利用这个事件最多的情况就是清除引用，以避免内存泄漏。unload事件的对象同样是window。 resize事件当浏览器窗口被调整到一个新的高度或宽度的时候，就会触发resize事件。这个事件在window上触发。不同浏览器resize事件处理不同，有可能是变化了1像素就触发，然后随着变化不断重复触发，也有可能用户停止调整窗口大小的时候才触发。 scroll事件scroll事件同样是在window上发生的，尽管它实际表示的是页面中相应元素的变化。scroll事件在滚动期间重复被触发。 焦点事件焦点事件会在页面元素获得或失去焦点时触发。利用这些元素并与document.hasFocus()方法及document.activeElement属性配合，可以知晓用户在页面上的行踪。有以下6个焦点事件。 blur：在元素失去焦点时触发。这个事件不会冒泡。 focus：元素获得焦点的时候触发。不会冒泡。 focusin：元素获得焦点时触发，与HTML事件focus等价。 focusout：元素失去焦点时触发。 当焦点从页面中一个元素移动到另一个元素，会依次触发下列事件： focusout在失去焦点元素上触发。 focusin在获得焦点元素上触发。 blur focus 确定浏览器是否支持这些事件： var isSupported = document.implementation.hasFeature(&quot;FocusEvent&quot;, &quot;3.0&quot;); 鼠标与滚轮事件 click：用户单击主鼠标按钮或按下回车触发。 dblclick：用户双击主鼠标按钮触发。 mousedown：用户按下任意鼠标按钮触发。 mouseenter：鼠标光标从元素外部首次移动到元素范围之内时触发。这个事件不冒泡，在光标移动到后代元素上不会触发。 mouseleave：在位于元素上方的鼠标光标移动到元素范围之外时触发。这个事件不冒泡，光标移到后代元素上不会触发。 mousemove：鼠标指针在元素内部移动时重复触发。 mouseout：鼠标指针位于一个元素上方，然后用户将其移入到另一个元素时触发。另一个元素可以是该元素的外部元素或子元素。 mouseover：鼠标指针位于一个元素外部，首次移入另一个元素边界之内触发。 mouseup：用户释放鼠标按钮时触发。 检查是否支持上面事件可以使用如下代码 var isSupported = document.implementation.hasFeature(&quot;MouseEvent&quot;, &quot;3.0&quot;); alert(isSupported); 客户区坐标位置鼠标事件都是在浏览器视口中的特定位置上发生的，这个位置信息保存在事件对象的clientX和clientY属性中。视口坐标，页面坐标，屏幕坐标的区别可以看这个 12345var div = document.getElementById("myDiv");EventUtil.addHandler(div, "click", function(event) &#123; event = EventUtil.getEvent(event); alert("Client coordinates: " + event.clientX + "," + event.clientY);&#125;) 页面坐标位置通过客户区坐标位置能够知道鼠标是在视口中什么位置发生的，而页面坐标通过事件对象的pageX和pageY属性，告诉你事件是在页面中什么位置发生的。这两个属性表示鼠标光标在页面中的位置。坐标是从页面本身而非视口左边和顶边计算。 当页面没有滚动的的时候，页面坐标等于视口坐标，如果有滚动，页面坐标为滚动高度加上视口坐标。 12345var div = document.getElementById("myDiv");EventUtil.addHandler(div, "click", function(event) &#123; event = EventUtil.getEvent(event); alert("Page coordinates: " + event.pageX + "," + event.pageY);&#125;) 屏幕坐标位置屏幕坐标位置是相对于整个电脑屏幕的位置。属性为screenX和screenY。 12345var div = document.getElementById("myDiv");EventUtil.addHandler(div, "click", function(event) &#123; event = EventUtil.getEvent(event); alert("Screen coordinates: " + event.screenX + "," + event.screenY);&#125;) 修改键按下鼠标时键盘上的某些键的状态也可以影响到所要采取的操作。这些修改键是Shift，Ctrl，Alt和Meta（Windows的win键）。DOM为此规定了4个属性，表示这4个修改键的状态：shiftKey，ctrlKey，altKey和metaKey。这些属性中包含的都是布尔值，如果相应键按下，值为true，否则为false。 1234567891011121314151617181920212223var div = document.getElementById("myDiv");EventUtil.addHandler(div, "click", function(event) &#123; event = EventUtil.getEvent(event); var keys = new Array(); if (event.shiftKey) &#123; keys.push("shift"); &#125; if (event.ctrlKey) &#123; keys.push("ctrl"); &#125; if (event.altKey) &#123; keys.push("alt"); &#125; if (event.metaKey) &#123; keys.push("meta"); &#125; alert("Keys: " + keys.join(","));&#125;) 相关元素发生mouseover和mouseout事件时，还会涉及更多的元素。这两个事件都会涉及把鼠标指针从一个元素的边界之内移动到另一个元素的边界之内。对mouseover事件而言，事件的主目标是获得光标的元素，而相关元素是那个失去光标的元素。类似地，对mouseout事件而言，事件的主目标是失去光标的元素，而相关元素则是获得光标的元素。 DOM通过event对象的relatedTarget属性提供了相关元素的信息。这个属性只对mouseover和mouseout事件才包含值。 1234567var div = document.getElementById("myDiv");EventUtil.addHandler(div, "mouseout", function(event) &#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); var relatedTarget = EventUtil.getRelatedTarget(event); alert("Mouse out of " + target.tagName + " to " + relatedTarget.tagName);&#125;); 鼠标按钮只有在主鼠标按钮被单击（或键盘回车被按下）的时候才会触发click事件，因此检测按钮的信息并不是必要的。但对于mousedown和mouseup事件来说，在其event对象内存在一个button属性，表示按下或释放的按钮。DOM的button属性可能有如下3个值：0表示主鼠标按钮，1表示中间鼠标按钮（滚轮按钮），2表示次鼠标按钮。IE8之前的button属性与DOM有很大差异，不做表述。具体的兼容鼠标检测见上面EventUtil 更多的事件信息DOM2级事件规范在event事件中还提供了detail属性，用于给出有关事件的更多信息。对于鼠标事件来说，detail中包含一个数值，表示在给定位置上发生了多少次单击。同一元素上相继发生一次mousedown和一次mouseup事件算一次单击。detail属性从1开始计数，每次单击后递增。如果鼠标在mouseup和mousedown之间移动了位置，detail会被重置为0. 鼠标滚轮事件mousewheel事件，当用户通过鼠标滚轮与页面发生交互，在垂直方向上滚动页面时（无论向上向下），就会触发mousewheel事件。这个事件可以在任何元素上触发，最终冒泡到window对象。mousewheel事件包含一个特殊的wheelDelta属性。当用户向前滚动鼠标滚轮，wheelDelta是120的倍数，当用户向后滚动滚轮，wheelDelta是-120的倍数。 1234EventUtil.addHandler(document, "mousewheel", function(event) &#123; event = EventUtil.getEvent(event); alert(event.wheelDelta);&#125;) 跨浏览器的解决方案 1234567getWheelDelta: function(event) &#123; if (event.wheelDelta) &#123; return (client.engine.opera &amp;&amp; client.engine.opera &lt; 9.5 ? -event.wheelDelta : event.wheelDelta); &#125; else &#123; return -event.detail * 40; //兼容Firefox &#125;&#125; 键盘与文本事件有三个键盘事件，如下： keydown：当用户按下键盘上的任意键时触发，如果按住不放，则重复触发。 keypress：当用户按下键盘上的字符键时触发，如果按住不放会重复触发。 keyup：当用户释放键盘上的键时触发。 用户按下一个字符键时，首先触发keydown，其次是keypress，最后是keyup。键盘事件同样也有shiftKey，ctrlKey，altKey和metaKey。 键码在发生keydown和keyup事件时，event对象的keyCode属性会包含一个代码。对数字字母字符键，keyCode属性的值与ASCII中对应小写字母或数字的编码相同。其他keyCode值在这里！ 字符编码charCode属性只有在发生keypress事件时才包含值，而且这个值是按下的那个键所代表的字符的ASCII编码。此时keyCode通常等于0或者也可能等于所按键的键码。对于IE8及其之前版本和Opera，则用keyCode来保存字符的ASCII编码，跨浏览器获取字符编码如下： 1234567getCharCode: function(event) &#123; if(typeof event.charCode == "number") &#123; return event.charCode; &#125; else &#123; return event.keyCode; &#125;&#125; 在DOM3级事件中，不再有charCode属性，而是key和char属性。key属性是一个字符串，当按下字符键，他的值是字符键的值（如”A”，”k”），当按下非字符键，他的值是相应键的名（如”Shift”，”Down”）。char属性按下字符键时显示字符键的值，按下非字符键，显示null。（存在跨浏览器的问题，所以不推荐使用上面两个值，以及Chorme和Safari 5的KeyIdentifier） textInput事件DOM3级事件规范引入的一个新事件，当用户在可编辑区域输入字符时，就会触发这个事件。任何可以获得焦点的元素都可以触发keypress事件，但只有可编辑区域才会触发textInput事件。textInput只会在用户按下能够输入实际字符的键时才会被触发，而keypress事件则在按下那些能够影响文本显示的键时也会触发（比如退格）。 textInput事件有一个data属性，表示用户输入的字符。 变动事件DOM2级的变动事件能在DOM中某一部分发生变化时给出提示。为XML或HTML DOM设计。DOM2级定义了如下变动事件。 DOMSubtreeModified：在DOM结构中发生任何变化时触发。这个事件在其他任何事件触发后都会触发。 DOMNodeInserted：在一个结点作为子节点被插入到另一个节点中触发。 DOMNodeRemoved：在结点从其父节点中被移除时触发。 var isSupported = document.implementation.hasFeature(&quot;MutationEvents&quot;, &quot;2.0&quot;);检查是否支持变动事件。 MDN的mutation事件 设备事件与触摸手势事件主要用于智能手机和平板电脑]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码剖析-对String,StringBuilder,StringBuffer的区分]]></title>
    <url>%2F2019%2F03%2F25%2F%E5%AF%B9String%2CStringBuilder%2CStringBuffer%E7%9A%84%E5%8C%BA%E5%88%86(%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90)%2F</url>
    <content type="text"><![CDATA[源码剖析-对String,StringBuilder,StringBuffer的区分首先观察他们继承的类和接口 String：public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {}StringBuilder：public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, CharSequence {}StringBuffer：public final class StringBuffer extends AbstractStringBuilder implements java.io.Serializable, CharSequence {} 可以观察到，String对象继承了Serializable，Comparable，CharSequence接口StringBuilder与StringBuffer均继承自AbstractStringBuilder父类，Serializable，CharSequence接口 Serializable是序列化接口，它的作用是： Serializability of a class is enabled by the class implementing the java.io.Serializable interface. String 源码剖析123456789@Stableprivate final byte[] value;private final byte coder;public String() &#123; this.value = &quot;&quot;.value; this.coder = &quot;&quot;.coder;&#125; String由value和coder组成，coder应该是它的编码格式，value就是它的值了，注意value是final类型的，即String对象是不可变的 Comparable接口String实现了Comparable接口，即String对象可以通过调用compareTo()方法进行比较，这是String与StringBuilder和StringBuffer的第一个区别 12345678910public int compareTo(String anotherString) &#123; byte v1[] = value; byte v2[] = anotherString.value; if (coder() == anotherString.coder()) &#123; return isLatin1() ? StringLatin1.compareTo(v1, v2) : StringUTF16.compareTo(v1, v2); &#125; return isLatin1() ? StringLatin1.compareToUTF16(v1, v2) : StringUTF16.compareToLatin1(v1, v2); &#125; 他主要实现了在当前字符编码上对字符串的比较，判断字符串是否相等 StringBuilder与StringBufferAbstractStringBuilder注意到在这个抽象类中定义了 123byte[] value;byte coder;int count; 但注意到value不是final类型，即他是可变的，这个是与String的第二个区别 他主要有扩容方法和添加方法，添加方法的参数类型有很多，比如String类型的，AbstactStringBuilder的，StringBuffer的，CharSequence的等等，下面是其中一个例子 12345678910public AbstractStringBuilder append(String str) &#123; if (str == null) &#123; return appendNull(); &#125; int len = str.length(); ensureCapacityInternal(count + len); putStringAt(count, str); count += len; return this;&#125; 扩容方法如下 123456789101112131415161718192021private void ensureCapacityInternal(int minimumCapacity) &#123; // overflow-conscious code int oldCapacity = value.length &gt;&gt; coder; if (minimumCapacity - oldCapacity &gt; 0) &#123; value = Arrays.copyOf(value, newCapacity(minimumCapacity) &lt;&lt; coder); &#125;&#125;private int newCapacity(int minCapacity) &#123; // overflow-conscious code int oldCapacity = value.length &gt;&gt; coder; int newCapacity = (oldCapacity &lt;&lt; 1) + 2; if (newCapacity - minCapacity &lt; 0) &#123; newCapacity = minCapacity; &#125; int SAFE_BOUND = MAX_ARRAY_SIZE &gt;&gt; coder; return (newCapacity &lt;= 0 || SAFE_BOUND - newCapacity &lt; 0) ? hugeCapacity(minCapacity) : newCapacity;&#125; 上面代码大概是若为utf16编码，则容量*2再+2，若为latin1编码，则容量+2，且设置了安全上限保护 CharSequence StringBuilderStringBuilder继承自AbstractStringBuilder，大部分代码都已经由其实现，StringBuilder只需要在构造器中调用super()方法即可，包括append()方法，delete()方法，replace()方法，insert()方法，indexOf()方法，lastIndexOf()方法，reverse()方法也都是调用super()方法即可。 StringBuffer而StringBuffer则是在AbstractStringBuilder的方法上添加了synchronized的关键字，即它是线程安全的 总结 String是可以比较的，通过compareTo()方法，而StringBuilder和StringBuffer只能通过toString()方法后再调用compareTo()方法来比较。 String对象是不可变的，其值是final类型，而StringBuilder和StringBuffer对象可变，并没有final修饰。 String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。 对他们的使用，应该遵循下面原则： 操作少量的数据 = String 单线程操作字符串缓冲区下操作大量数据 = StringBuilder 多线程操作字符串缓冲区下操作大量数据 = StringBuffer]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>StringBuilder</tag>
        <tag>StringBuffer</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git快速入门]]></title>
    <url>%2F2019%2F03%2F17%2Fgit%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Git本地仓库创建版本库通过git init把当前目录变为Git可以管理的仓库 把文件放到Git仓库-add指令第一步,编写一个文件,放到该仓库目录下第二步,用命令git add yourFileName告诉git把文件添加到仓库 可以添加多个文件git add file1.txt file2.txt 提交到仓库-commit指令git add -m &quot;提本次提交的说明&quot;,用参数-m输入本次提交的说明 查看暂存区状态-status指令可以使用git status查看当前git状态 版本回退查看历史记录-log指令git log可以查看历史提交记录如果输出信息太多,可以加上--pretty=oneline参数 版本回退-reset指令git的当前版本用HEAD表示,上一个版本是HEAD^,上上个版本是HEAD^^,如果是上100个版本,可以表示为HEAD~100 git reset --hard HEAD^表示回退到上一个版本 如果后悔了,可以找到上面的命令行窗口,找到未来版本的commit id,比如当前版本最新ID为1094adb...,可以通过git reset --hard 1094a回到未来(可以不指定完整的id,git会自动寻找) 记录命令-reflog指令可以通过git reflog查询执行过的命令,并依此找到版本号,这样就可以通过git reset --hard 版本号回到任何版本 工作区和暂存区工作区就是电脑可以看到的目录工作区有一个目录.git，是Git的版本库，里面存了很多东西，其中有称为stage(或者叫index)的暂存区，还有Git自动创建的第一个分支master，以及指向master的一个指针叫HEAD。git add实际是把文件修改添加到暂存区 git commit实际是把暂存区的所有内容提交到当前分支 查看工作区和版本库区别-diff指令git diff HEAD -- youFile.txt：可以查看工作区和版本库最新版本的区别 撤销修改丢弃工作区的修改-checkout可以使用git checkout -- &lt;file&gt;把工作区中file的修改全部撤销 把暂存区的修改放回到工作区-resetgit reset HEAD &lt;file&gt;把暂存区的修改撤销掉,重新放回工作区，然后使用git checkout -- &lt;file&gt;即可撤销修改 删除文件在Git中,删除文件也是一个修改操作 删除暂存区文件-rm在Linux中,对于已经通过add添加到暂存区的文件，如果使用rm删除了文件,删错的情况下,可以git checkout -- &lt;file&gt;恢复文件如果确定删除，git rm &lt;file&gt;删掉，然后git commit提交对于在工作区的文件，使用rm删除无法恢复。 远程仓库添加远程仓库1.在GitHub上create a new repo新建一个仓库，填写仓库名后其他默认（不要生成readme，生成后不是空远程库了，手动在本地库添加上传即可）2.本地仓库与之关联，关联后远程库的名字是origin3.把本地库内容推送到远程（实际是把master分支推送到远程） 远程库关联本地库-remote add根据GitHub上的提示，在本地git bash上git remote add origin https://github.com/youGithubName/youRepo.git 即可关联，若取消关联git remote remove origin 本地库推送到远程-push第一次推送的时候git push -u origin master-u不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 后续推送只需要git push origin master 从远程库克隆克隆远程库到本地-clonegit clone git@github.com:otherName/otherRepo.git 使用ssh克隆git clone https://github.com/otherName/otherRepo.git 使用https克隆 分支管理创建与合并分支每次提交时，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点： 每次提交时，master分支都会向前移动一步。 当我们创建分支的时候，例如dev时，Git会新建一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上： 从现在开始，对工作区任何修改和提交都是针对dev分支了，新提交一次后，dev和HEAD往前一步，master不变： 假如我们在dev上的工作完成了，就可以把dev合并到master上，把master指向dev当前的提交即可： 合并完分支后，甚至可以删除dev分支： 创建分支-branchgit branch dev创建dev分支 切换分支-checkoutgit checkout dev切换到dev分支 创建并切换分支-checkout -bgit checkout -b dev可以新建dev分支并切换到dev分支它相当于下面两条指令git branch dev创建dev分支git checkout dev切换到dev分支 现在，对git进行add和commit操作都是针对dev分支而言 修改完后git checkout master可以切换回master分支，此时，所有针对dev分支进行的改变都是不可见的 注意！暂存区对所有分支来说都是可见的！ 查看所有分支-branchgit branch可以查看所有分支，当前分支前会有 * 指示出来 合并分支-mergegit merge dev把dev分支合并到当前分支上 删除分支-branch -dgit branch -d dev可以删除分支dev，删除前提是当前分支不是dev（即HEAD指针不是指向dev） 解决冲突当两个分支修改的地方有冲突的时候，执行merge就会报错合并冲突，可以使用git stauts查看。冲突发生时分支如下： 打开冲突的文件，可以看到大概类似下面的东西 12345&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADxxxxxx=============XXXXXX&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1 这里xxxxxx是HEAD分支修改的内容，XXXXXX是dev分支修改的内容 只要把这一部分修改成想要的内容，再git add xxx.txtgit commit -m &quot;conflict fixed即可 此时分支如下：（使用下一小节的命令可以查看图形化的分支） (P.S:对这样的分支树进行版本回退，他会退回到master的上一个版本而不是feature1） 然后删除feature1分支即可 也可以选择git merge --abort放弃合并 查看分支合并情况-log –graphgit log --graph --pretty=oneline --abbrev-commit可以以图形的信息查看分支情况 分支策略管理通常，合并分支的时候，Git会用Fast forward模式，在这种模式下，删除分支后，会丢掉分支信息。 如果强制禁用Fast forward，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 禁用fast forward-merge –no-ffe.g.1.创建一个分支git checkout -b dev2.修改readme.txt并提交一个commitgit add readme.txt，git commit -m &quot;add merge&quot;3.切换到master，git checkout master4.合并dev分支，git merge --no-ff -m &quot;merge with no-ff&quot; dev 然后用git log可以看到merge的信息，使用 在fast forward模式下，log里是看不到merge的信息的，即 禁用fast forward的图示执行git merge --no-ff -m &quot;merge with no-ff&quot; dev合并后，禁用fast forward时，在合并分支后，git log的图示如下 可以看到是有一条merge的log的。 删除dev分支之前的git log --graph --pretty=oneline --abbrev-commit 此时虽然执行了merge操作，但dev和master并不指向同一目标，此时master指向的是在master分支下执行merge操作的log，而不是在dev分支下执行commit操作的log 对比下面是执行git merge dev的图示 git log如下： git log --graph --pretty=oneline --abbrev-commit如下： 可以看到并没有merge操作的log，而只有commit操作的log，非fast forward下的合并，仅仅是把master指针指向dev 分支策略实际开发应该遵循下面的基本原则进行分支管理：首先，master分支是非常稳定的，仅仅用来发布新版本，平时不能在上面干活；干活都在dev分支上，dev分支是不稳定的，到某个时候，比如发布1.0版本时，再把dev分支合并到master分支上，在master分支上发布1.0版本多人开发时，每个人都有自己的分支，时不时往dev分支上合并就可以，如下图所示 Bug分支每次出现Bug的时候，都可以新建一个临时分支来修复，修复后合并分支，然后删除临时分支，但如果出现BUG的时候当前手头工作未完成时，Git可以把当前工作现场保存，然后去修改BUG，再恢复现场继续工作 保存工作现场-stashgit stash可以保存当前工作现场，它大概就是，在工作区修改的文件，还没上传到暂存区，则保存工作区修改过的文件，或者已经上传到暂存区的文件，但还没有commit，则保存该文件，然后把工作区置干净(git status查看是干净的)，此时就可以放心创建分支来修复bug。如果没有stash，切换到master分支上修改bug的时候，会发现在dev分支修改的东西还存在，但因为还没写完，所以修改完bug之后commit的话，没写完的东西也会commit上去，这明显是错误的，stash就是为此而生，它把工作区暂存区的东西保存下来，然后让工作区干净，这样在dev上正在工作的，未完成的东西就不会出现了，也不会因为修改bug而提交到master了，然后创建分支修改完bug之后再切换回dev分支恢复现场即可。 注意！！，如果要在master分支上修复bug，则必须先切换到master分支，再新建一个分支！修改完分支后，切换回master分支并合并，然后删除bug分支即可 此时修复完bug，切换回工作分支，然后恢复刚刚stash的内容 查看stash内容-stash listgit stash list可以查看stash内容 恢复工作现场-stash applygit stash apply恢复工作现场，然后git stash drop删除stash内容 多次stash的时候，先用git stash list查看，然后恢复指定的stashgit stash apply stash@{0} 恢复工作现场-stash popgit stash pop恢复工作现场同时把stash内容删除 Feature分支软件开发中，当要添加新功能时，可以新建一个feature分支来实现。 强制删除分支—branch -D如果新功能要舍弃，分支还没合并就要删除，可以通过git branch -D &lt;name&gt;来删除参数-D是强制删除 多人协作当从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin 查看远程库的信息-remotegit remote可以查看远程库的信息git remote -v可以显示更详细的信息，显示了可以抓取和推送的origin地址，如果没有推送权限，则看不到push地址 推送分支git push origin master 如果要推送其他分支，比如dev，就改成git push origin dev 下面是分支的简介 master分支是主分支，时刻与远程同步 dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步 bug分支只用于本地修复bug，一般不需要推送到远程 feature分支是否推送到远程，取决于是否合作开发 抓取分支当另外一个人从远程库克隆的时候，默认情况下，他只能看到本地的master分支，如果要在dev分支上开发，就必须创建远程origin的dev分支到本地。 创建远程分支到本地git checkout -b dev origin/dev pullgit pull命令用于从另一个存储库或本地分支获取并集成，它的作用是：取回远程主机某个分支的更新，再与本地指定分支合并。 常见格式是git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;若与当前分支合并，则冒号和之后的内容不需要 多人协作的工作模式 首先，可以试图用git push origin &lt;branch-name&gt;推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin &lt;branch-name&gt;推送就能成功！ 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;。 Rebasegit rebase：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了 标签管理它是版本的一个快照，发布一个版本时，先在版本库中打一个标签，然后将来某个时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。 实质上标签就是指向某个commit的指针（和分支很像，但它不能移动） 创建标签创建标签-tag首先切换到需要打标签的分支上然后输入git tag v1.0即可打上v1.0的标签 可以用命令git tag查看所有标签 默认标签是打在最新提交的commit上的，如果要打历史版本的标签，只需要找到历史提交的commit id，然后打上即可git tag v0.9 &lt;commit ID&gt; 还可以指定带有说明的标签，参数-a表示标签名，-m表示说明文字git tag -a v0.1 -m &quot;version 0.1 released&quot; &lt;commit ID&gt; git show &lt;tagname&gt;可以看到说明文字 操作标签删除标签-tag -dgit tag -d v0.1可以删除这个标签 推送标签到远程git push origin &lt;tagname&gt; 一次性推送全部标签git push origin --tags 删除远程标签 git tag -d &lt;tagname&gt;删除本地标签 git push origin :refs/tags/&lt;tagname&gt;删除远程标签 使用GitHub 点击Fork可以在自己账号下的远程仓库克隆一个别人的远程仓库 从自己账号下clone：git clone git@github.com:makloao/xxx.git，一定要克隆自己远程仓库到本地仓库，否则不能推送修改 如果想把自己的修改推送到官方，可以在GitHub上发起一个pull request 自定义Gitgit config --global.user.name &quot;Your name&quot;git config --global user.email &quot;email@example.com&quot;指定用户名和Email git config --global color.ui true让Git显示颜色 忽略特殊文件有些时候要把某些文件放到Git工作目录但又不能提交它们，比如保存了数据密码的配置文件等等只需要在Git工作区的目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去即可，如何写可以看GitHub的.gitignore文件写法 忽略文件的原则 忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 如果想强行添加被.gitignore忽略的文件git add -f xxx.class即可 .gitignore本身要放到版本库中，并且可以对其做版本管理 配置别名可以给命令配置别名git config --global alias.st status：把git status配置别名成git st，同理可以配置其他 一些比较推荐的别名1234567git config --global alias.st statusgit config --global alias.co checkoutgit config --global alias.ci commitgit config --global alias.br branchgit config --global alias.unstage &apos;reset HEAD&apos;git config --global alias.last &apos;log -1&apos; 显示最后一次提交git config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot; 设置log的显示颜色 配置文件配置文件都放在.git/config文件中 而当前用户的Git配置文件放在用户主目录的.gitconfig中 搭建Git服务器如果不想公开代码，又不想给GitHub交保护费 教程在这]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构03-排序基础]]></title>
    <url>%2F2018%2F11%2F29%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403-%E6%8E%92%E5%BA%8F%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[数据结构03-排序基础本章主要讲了几种基本的排序方法，分别为直接插入排序，希尔排序和基数排序，快排和归并排序由于用到了递归的思想，所以放在了后面递归章节来说。 排序的概念与分类含有多个数据项的数据元素称为记录。用作记录唯一标识的数据项称为关键字域，其值为关键字。若关键字唯一标识一个记录，则称为主关键字，否则为次关键字，记录类型定义如下： 12345typedef int KeyType;typedef struct &#123; KeyType key; ...&#125; RecordType, RcdType; 排序就是将无序的记录按关键字调整为有序记录序列的一种操作。一般排序都是对存储记录的顺序表排序。顺序表的0号单元留作它用。记录顺序表类型定义如下： 12345typedef struct &#123; RcdType *rcd; int length; int size;&#125; RcdSqList; 直接插入排序直接插入排序的思想是：每次将无序区的第一个记录按关键字插入到有序区的合适位置，并将有序区长度加1。 具体代码如下： 123456789101112void InsertSort(RcdSqList &amp;L) &#123; int i, j; for (i = 1; i &lt; L.length; i++) &#123; if (L.rcd[i+1].key &lt; L.rcd[i].key) &#123; // 需将L.rcd[i+1]插入到有序序列 L.rcd[0] = L.rcd[i+1]; // 把记录L.rcd[i+1]保存在空闲的0号单元 j = i+1; // j为要后移的记录后移之前的位置 do &#123; j--; L.rcd[j+1] = L.rcd[j] // 记录后移 &#125; while (L.rcd[0].key &lt; L.rcd[j-1].key) // 判断是否需要继续移动 L.rcd[j] = L.rcd[0]; &#125; &#125;&#125; 代码分析这里的插排的做法是：无序区的第一个记录是i+1号记录，把它放到0号位置（即哨兵），然后依次比较0号记录与有序区记录的大小，对有序区中比0号位置记录要大的元素依次后移（第i个位置的记录为有序区的最大记录，若比无序区第一个记录i+1对应的值要大，就把它的值直接放到i+1的位置，然后依次后移），并用 j 记录要后移的记录后移之前的位置，最后把0号位置的记录放到j号位置即可。 插入排序最好情况下比较次数n-1次，移动记录次数为0。最坏情况下，需要比较(n+2)(n-1)/2次，移动记录(n+4)(n-1)/2次，事件复杂度为O(n^2)，空间复杂度为O(1)。 希尔排序希尔排序的思想是：把整个待排记录序列(R1,R2,R3,…,Rn)按增量d划分为d个子序列，其中第i(1&lt;=i&lt;=d)个子序列为(Ri,R(i+d),R(i+2d),…,R(i+kd)，并分别对各子序列进行直接插入排序，不断减小增量d，直到d减小到1，对整个序列进行一次直接插入排序。 插入排序每次只对相邻记录进行比较，记录最多只移动一个位置，希尔排序每次对相隔较远距离的记录进行比较，使得记录移动时能跨过多个记录，实现宏观上的调整。 具体实现如下： 1234567891011121314151617void ShellInsert(RcdSqList &amp;L, int dk) &#123; // 对顺序表L进行一次希尔排序，增量为dk int i, j; for (i = 1; i &lt;= L.length-dk; ++i) if (L.rcd[i+dk].key &lt; L.rcd[i].dk) &#123; // 需将L.rcd[i+dk]插入有序序列 L.rcd[0] = L.rcd[i+dk]; j = i + dk; do &#123;j -= dkl L.rcd[j+dk] = L.rcd[j]; &#125; while (j - dk &gt; 0 &amp;&amp; L.rcd[0].key &lt; L.rcd[j-dk].key); L.rcd[j] = L.rcd[0]; &#125;&#125;void ShellSort(RcdSqList &amp;L, int d[], int t) &#123; // 按增量序列d[0..t-1]对顺序表L作希尔排序 int k; for (k = 0; k &lt; t; k++) ShellInsert(L, d[k]);&#125; 代码分析代码解释这里希尔排序的做法是：给定一个增量序列（该序列应该是递减的，并且最后的一个值是1），依次取值作为增量dk，把记录按增量dk划分为dk个序列，依次对每个序列进行插入排序 时间复杂度希尔排序的时间复杂度是所取增量序列的函数。当增量序列为d[k]=2^(t-k+1)-1时（t为排序趟数，1&lt;=k&lt;=t&lt;=log2(n+1)），事件复杂度为O(n^1.5)。 稳定性若待排序列存在两个或以上关键字相等的记录，则排序结果不唯一。假设ki = kj（1&lt;=i&lt;=n,1&lt;=j&lt;=n,i≠j），且在排序前序列ki领先于kj，若在排序后序列ki仍领先于kj，则该排序方法稳定，反之不稳定。希尔排序是不稳定的排序方法。 基数排序前面2种排序都是基于关键字比较，而基数排序不需要比较关键字，它借鉴了多关键字排序的思想，把单一关键字看成是多个关键字复合而成。 一般情况下，多关键字排序的定义为，假设含有n个记录的序列为(r1,r2,…,rn)。每个记录ri中含有m个关键字(ki(0),ki(1),…,ki(m-1))，如果对序列中任意两个记录ri和rj(1&lt;=i&lt;=j&lt;=n)都满足下列有序关系:(ki(0),ki(1),…,ki(m-1))&lt;(kj(0),kj(1),…,kj(m-1))则称记录对这m个关键字有序。其中k0被称为最主位关键字，k(m-1)被称为最次位关键字。 实现多关键字排序有两种策略，MSD(高位优先排序)和LSD(低位优先排序)。 MSD的思路为先按最主位关键字k0进行排序，得到若干子序列，其中每个子序列中的记录都含有相同个k0值，之后分别对每个子序列按关键字k1进行排序，使得k1值相同的记录构成长度更短的子序列，依次重复直到对每个子序列按k(m-1)从小到大排序，最后所得序列就是排序结果 LSD的思路为先按最低位关键字进行排序，接着按依次低位关键字实施排序，最后按最主位关键字进行排序，与MSD不同，其排序过程不产生子序列，每次都是对整个序列排序。 基数排序基本思路：先将所有关键字统一为相同的位数，位数少的前面补0，然后从最低位开始依次进行排序，直到按最高位排序完成。 下面说的是以顺序存储的基数排序的LSD实现 基数排序定义的数据类型123456789101112typedef struct &#123; KeysType *keys; // 关键字 ... // 其他数据项&#125; KeysRcdType;typedef struct &#123; KeysRcdType *rcd; // 0号位置作为哨兵 int length; // 顺序表长度 int size; // 顺序表容量 int digitNum; // 关键字位数，即rcd.keys每个值的长度 int radix; // 关键字基数，即关键字取值范围的长度，十进制为10，字母为26&#125; KeysSqList; 实现基数排序，需要引入3个数组，其中，数组count用于统计关键字的r种取值，pos数组用于确定各子序列的起始位置，rcd1数组与rcd一样，各趟收集中，第一趟从数组rcd收集到数组rcd1，第二趟从rcd1收集到rcd，如此交替进行，若总趟数为奇数，最后要排序结果从rcd1复制回rcd。 基数排序的过程与关键步骤基数排序有3个关键步骤，分别为计数，计算位置和收集。如下 计数计数是统计第i个关键字中取值范围内每个数的个数 12for(j = 0; j &lt; L.radix; ++j) count[j] = 0;for(k = 1; k &lt;= n; k++) count[rcd[k].keys[i]]++; 计算位置计算位置是计算第i个关键字中取值范围内每个值应该存放(收集)的位置。 12pos[0] = 1;for(j = 1; j &lt; radix; j++) pos[j] = count[j-1] + pos[j-1]; 收集收集是把依次把k(k=1直到n)个记录存放到正确的位置。 1234for(k = 1; k &lt;= n; k++) &#123; j = rcd[k].keys[i]; rcd1[pos[j]++] = rcd[k];&#125; 完整的基数排序代码1234567891011121314151617181920212223242526272829303132333435Status RadixSort(KeysSqList &amp;L) &#123; KeysRcdType *rcd1; int i = 0, j; int *count, *pos; count = (int*)malloc(sizeof(int)*L.radix); pos = (int*)malloc(sizeof(int)*L.radix); rcd1 = (KeysRcdType*)malloc(sizeof(KeysRcdType)*(L.length+1)); if(NULL == count || NULL == pos || NULL == rcd1) return OVERFLOW; while(i &lt; L.digitNum) &#123; for(j = 0; j &lt; L.radix; ++j) count[j] = 0; if(0 == i%2) RadixPass(L.rcd, rcd1, L.length, i++, count, pos, L.radix); else RadixPass(rcd1, L.rcd, L.length, i++, count, pos, L.radix); &#125; if(1 == L.digitNum%2) for(j = 1; j &lt;= L.length; ++j) L.rcd[j] = rcd1[j]; free(count); free(pos); free(rcd1); return OK;&#125;void RadixPass(KeysRcdType rcd[], KeysRcdType rcd1[], int n, int i, int count[], int pos[], int radix) &#123; int k, j; for(k = 1; k &lt;= n; k++) count[rcd[k].keys[i]]++; // count键为关键字基数，值为该基数的个数 pos[0] = 1; // 第j个关键字的起始位置为第j-1个关键字的起始位置加上j-1个关键字的个数 for(j = 1; j &lt; radix; j++) pos[j] = count[j-1] + pos[j-1]; for(k = 1; k &lt;= n; k++) &#123; // 收集过程 // k为第k个记录，j为第k个记录的第i个关键字的值 j = rcd[k].keys[i]; // pos[j]的定义是：关键字j的起始位置，这里把位置k的记录放到位置pos[j]处 // 并令pos[j]++，使下一个关键字收集到正确的位置 rcd1[pos[j]++] = rcd[k]; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>插入排序</tag>
        <tag>希尔排序</tag>
        <tag>基数排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构02-线性数据结构]]></title>
    <url>%2F2018%2F11%2F22%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8402-%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[数据结构02-线性数据结构栈栈是一种后入先出的数据结构 顺序栈顺序栈类型定义如下 123456typedef struct &#123; ElemType *elem; // 存储空间基址 int top; // 栈顶元素下一位标 int size; // 当前分配的存储容量 int increment; // 扩容时，增加的存储容量&#125; SqStack; 顺序栈常用操作如下 1234567Status InitStack_Sq(SqStack &amp;S, int size, int inc);Status DestroyStack_Sq(SqStack &amp;S);Status StackEmpty_Sq(SqStack S);void ClearStack_Sq(SqStack &amp;S);Status Push_Sq(SqStack &amp;S, ElemType e);Status Pop_Sq(SqStack &amp;S, ElemType &amp;e);Status GetTop_Sq(SqStack S, ElemType &amp;e); 顺序栈的部分操作初始化123456789Status InitStack_Sq(SqStack &amp;S, int size, int inc)&#123; S = (ElemType*)malloc(size*sizeof(ElemType)); if(S == NULL) return OVERFLOW; S.top = 0; S.size = size; S.increment = inc; return OK;&#125; 入栈123456789101112Status Push_Sq(SqStack &amp;S, ElemType e)&#123; ElemType* newbase; if(S.top &gt;= S.size) &#123; newbase = (ElemType*)realloc(S.elem, (S.size+S.increment)*sizeof(ElemType)); if(NULL == newbase) return OVERFLOW; S.elem = newbase; S.size += S.increment; &#125; S.elem[S.top++] = e; return OK;&#125; 出栈123456789101112Status Pop_Sq(SqStack &amp;S, ElemType e) &#123; if(S.top &gt; 0) &#123; e = S.elem[--S.top]; return OK; &#125; else &#123; return ERROR; &#125;&#125; 判空12345Status StackEmpty_Sq(SqStack S)&#123; if(S.top == 0) return TRUE; return FALSE;&#125; 取栈顶元素123456789101112Status GetTop(SqStack S, ElemType &amp;e)&#123; if (S.top &gt; 0) &#123; e = S.elem(S.top - 1); return OK; &#125; else &#123; return ERROR; &#125;&#125; 顺序栈的部分习题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/**********【题目】若顺序栈的类型重新定义如下。试编写算法，构建初始容量和扩容增量分别为size和inc的空顺序栈S。typedef struct &#123; ElemType *elem; // 存储空间的基址 ElemType *top; // 栈顶元素的下一个位置 int size; // 当前分配的存储容量 int increment; // 扩容时，增加的存储容量&#125; SqStack2;***********/Status InitStack_Sq2(SqStack2 &amp;S, int size, int inc)/* 构建初始容量和扩容增量分别为size和inc的空顺序栈S。*/ /* 若成功，则返回OK；否则返回ERROR。 */&#123; S.elem = (ElemType*)malloc(size * sizeof(ElemType)); if(NULL == S.elem) return OVERFLOW; if (size &lt;= 0 || inc &lt;= 0) return ERROR; S.top = S.elem+1; S.size = size; S.increment = inc; return OK;&#125;/**********【题目】若顺序栈的类型重新定义如下。试编写算法，实现顺序栈的判空操作。typedef struct &#123; ElemType *elem; // 存储空间的基址 ElemType *top; // 栈顶元素的下一个位置 int size; // 当前分配的存储容量 int increment; // 扩容时，增加的存储容量&#125; SqStack2;***********/Status StackEmpty_Sq2(SqStack2 S)/* 对顺序栈S判空。 */ /* 若S是空栈，则返回TRUE；否则返回FALSE */&#123; if (S.top == S.elem) return TRUE; return FALSE;&#125;/**********【题目】若顺序栈的类型重新定义如下。试编写算法，实现顺序栈的入栈操作。typedef struct &#123; ElemType *elem; // 存储空间的基址 ElemType *top; // 栈顶元素的下一个位置 int size; // 当前分配的存储容量 int increment; // 扩容时，增加的存储容量&#125; SqStack2;***********/Status Push_Sq2(SqStack2 &amp;S, ElemType e)/* 若顺序栈S是满的，则扩容，若失败则返回ERROR。*//* 将e压入S，返回OK。 */&#123; ElemType* newbase; if((S.top - S.elem) / sizeof(ElemType) &gt; S.size) &#123; newbase = (ElemType*)realloc(S.elem, (S.size+S.increment)*sizeof(ElemType)); if(NULL == newbase) return OVERFLOW; S.elem = newbase; S.size += S.increment; &#125; *S.top++ = e; return OK; &#125;/**********【题目】若顺序栈的类型重新定义如下。试编写算法，实现顺序栈的入栈操作。typedef struct &#123; ElemType *elem; // 存储空间的基址 ElemType *top; // 栈顶元素的下一个位置 int size; // 当前分配的存储容量 int increment; // 扩容时，增加的存储容量&#125; SqStack2;***********/Status Push_Sq2(SqStack2 &amp;S, ElemType e)/* 若顺序栈S是满的，则扩容，若失败则返回ERROR。*//* 将e压入S，返回OK。 */&#123; ElemType* newbase; if((S.top - S.elem) / sizeof(ElemType) &gt; S.size) &#123; newbase = (ElemType*)realloc(S.elem, (S.size+S.increment)*sizeof(ElemType)); if(NULL == newbase) return OVERFLOW; S.elem = newbase; S.size += S.increment; &#125; *S.top++ = e; return OK; &#125;/**********【题目】试写一算法，借助辅助栈，复制顺序栈S1得到S2。顺序栈的类型定义为：typedef struct &#123; ElemType *elem; // 存储空间的基址 int top; // 栈顶元素的下一个位置，简称栈顶位标 int size; // 当前分配的存储容量 int increment; // 扩容时，增加的存储容量&#125; SqStack; // 顺序栈可调用顺序栈接口中下列函数：Status InitStack_Sq(SqStack &amp;S, int size, int inc); // 初始化顺序栈SStatus DestroyStack_Sq(SqStack &amp;S); // 销毁顺序栈SStatus StackEmpty_Sq(SqStack S); // 栈S判空，若空则返回TRUE，否则FALSEStatus Push_Sq(SqStack &amp;S, ElemType e); // 将元素e压入栈SStatus Pop_Sq(SqStack &amp;S, ElemType &amp;e); // 栈S的栈顶元素出栈到e***********/Status CopyStack_Sq(SqStack S1, SqStack &amp;S2) /* 借助辅助栈，复制顺序栈S1得到S2。 */ /* 若复制成功，则返回TRUE；否则FALSE。 */&#123; InitStack_Sq(S2, S1.size, S1.increment); if(NULL == S2.elem) return FALSE; for(int i = 0; i &lt; S1.top; i++) &#123; Push_Sq(S2, S1.elem[i]); &#125; return TRUE;&#125; 链栈链栈类型定义如下： 1234typedef struct LSNode &#123; ElemType data; struct LSNode *next;&#125; LSNode, *LStack; 接口定义如下： 123456void InitStack_LS(LStack &amp;S);void DestroyStack_LS(LStack &amp;S);Status StackEmpty_LS(LStack S);Status Push_LS(LStack &amp;S, ElemType e);Status Pop_LS(LStack &amp;S, &amp;ElemType e);Status GetTop_LS(LStack S, ElemType &amp;e); 入栈操作123456789Status Push_LS(LStack &amp;S, ElemType e) &#123; LSNode *t; t = (LSNode*)malloc(sizeof(LSNode)); if (NULL == t) return OVERFLOW; t-&gt;data = e; t-&gt;next = S; S = t; return OK;&#125; 出栈操作12345678Status Pop_LS(LStack &amp;S, ElemType &amp;e) &#123; LSNode *t = S; if (NULL == S) return ERROR; e = S-&gt;data; S = S-&gt;next; free(t); return OK;&#125; 部分习题12345678910111213141516171819202122232425262728293031/**********【题目】试写一算法，实现链栈的判空操作。链栈的类型定义为：typedef struct LSNode &#123; ElemType data; // 数据域 struct LSNode *next; // 指针域&#125; LSNode, *LStack; // 结点和链栈类型***********/Status StackEmpty_L(LStack S)/* 对链栈S判空。若S是空栈，则返回TRUE；否则返回FALSE */&#123; if(S == NULL) return TRUE; return FALSE;&#125;/**********【题目】试写一算法，实现链栈的取栈顶元素操作。链栈的类型定义为：typedef struct LSNode &#123; ElemType data; // 数据域 struct LSNode *next; // 指针域&#125; LSNode, *LStack; // 结点和链栈类型***********/Status GetTop_L(LStack S, ElemType &amp;e) /* 取链栈S的栈顶元素到e，并返回OK; *//* 若S是空栈，则失败，返回ERROR。 */&#123; if(S == NULL) return ERROR; e = S-&gt;data; return OK;&#125; 队列循环队列定义如下 123456typedef struct &#123; ElemType *elem; int front; int rear; // 队尾位标，表示队尾元素的下一位置 int maxSize;&#125; SqQueue; 循环队列是把队列看成首尾相连的顺序队列。有如下基本操作接口 12345678Status InitQueue_Sq(SqQueue &amp;Q);Status DestroyQueue_Sq(SqQueue &amp;Q);void ClearQueue_Sq(SqQueue &amp;Q);Status QueueEmpty_Sq(SqQueue Q)int QueueLength_Sq(SqQueue Q);Status GetHead_Sq(SqQueue Q, ElemType &amp;e); Status EnQueue_Sq(SqQueue &amp;Q, ElemType e);Status DeQueue_Sq(SqQueue &amp;Q, ElemType &amp;e); 循环队列的实现入队时，对队尾循环加一，如下 Q.rear = (Q.rear+1)%Q.maxSize; 出队时同样操作 对于队空队满的判断可以有如下判断方法 设一标志域标识队列的空或满 设一长度域记录队列中元素的个数 少用一个元素空间，一旦Q.front==(Q.rear+1)%Q.maxSize则队满 循环队列部分操作初始化操作1234567Status InitQueue_Sq(SqQueue &amp;Q, int size) &#123; Q.elem = (ElemType*)malloc(size*sizeof(ElemType)) if (Q.elem == NULL) return OVERFLOW; Q.maxSize = size; Q.front = Q.rear = 0; return OK;&#125; 出队操作123456Status DeQueue_Sq(SqQueue &amp;Q, ElemType &amp;e) &#123; if (Q.front == Q.rear) return ERROR; e = Q.elem[Q.front]; Q.front = (Q.front + 1) % Q.maxSize; return OK;&#125; 入队操作123456Status EnQueue_Sq(SqQueue &amp;Q, ElemType e) &#123; if (Q.front == (Q.rear + 1) % Q.maxSize) return ERROR; Q.elem[Q.rear] = e; Q.rear = (Q.rear + 1) % Q.maxSize; return OK;&#125; 循环队列的部分习题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151/**********【题目】试写一算法，求循环队列的长度。循环队列的类型定义为：typedef struct &#123; ElemType *base; // 存储空间的基址 int front; // 队头位标 int rear; // 队尾位标，指示队尾元素的下一位置 int maxSize; // 最大长度&#125; SqQueue;***********/int QueueLength_Sq(SqQueue Q)/* 返回队列Q中元素个数，即队列的长度。 */ &#123; if(Q.front &lt;= Q.rear) return Q.rear - Q.front; else return Q.maxSize + Q.rear - Q.front;&#125;/**********【题目】如果希望循环队列中的元素都能得到利用，则可设置一个标志域tag，并以tag值为0或1来区分尾指针和头指针值相同时的队列状态是"空"还是"满"。试编写与此结构相应的入队列和出队列的算法。本题的循环队列CTagQueue的类型定义如下：typedef struct &#123; ElemType elem[MAXQSIZE]; int tag; int front; int rear;&#125; CTagQueue;**********/Status EnCQueue(CTagQueue &amp;Q, ElemType x)/* 将元素x加入队列Q，并返回OK；*//* 若失败，则返回ERROR。 */&#123; if(Q.front == Q.rear &amp;&amp; Q.tag == 1) return ERROR; Q.elem[Q.rear] = x; Q.rear = (Q.rear+1)%MAXQSIZE; if(Q.rear == Q.front) Q.tag = 1; return OK; &#125;Status DeCQueue(CTagQueue &amp;Q, ElemType &amp;x)/* 将队列Q的队头元素退队到x，并返回OK；*//* 若失败，则返回ERROR。 */&#123; if(Q.front == Q.rear &amp;&amp; Q.tag == 0) return ERROR; x = Q.elem[Q.front]; Q.front=(Q.front+1)%MAXQSIZE; if(Q.front == Q.rear) Q.tag = 0; return OK;&#125;/**********【题目】假设将循环队列定义为：以域变量rear和length分别指示循环队列中队尾元素的位置和内含元素的个数。试给出此循环队列的队满条件，并写出相应的入队列和出队列的算法（在出队列的算法中要返回队头元素）。本题的循环队列CLenQueue的类型定义如下：typedef struct &#123; ElemType elem[MAXQSIZE]; int length; int rear;&#125; CLenQueue;**********/Status EnCQueue(CLenQueue &amp;Q, ElemType x) /* 将元素x加入队列Q，并返回OK；*/ /* 若失败，则返回ERROR。 */&#123; if (Q.length == MAXQSIZE) return ERROR; Q.rear = (Q.rear+1)%MAXQSIZE; Q.elem[Q.rear] = x; Q.length++; return OK;&#125;Status DeCQueue(CLenQueue &amp;Q, ElemType &amp;x) /* 将队列Q的队头元素退队到x，并返回OK；*/ /* 若失败，则返回ERROR。 */&#123; if (Q.length == 0) return ERROR; x = Q.elem[(MAXQSIZE + Q.rear - Q.length + 1)%MAXQSIZE]; Q.length--; return OK;&#125;/**********【题目】已知k阶斐波那契序列的定义为: f0=0, f1=0, …, fk-2=0, fk-1=1; fn=fn-1+fn-2+…+fn-k, n=k,k+1,…试利用循环队列编写求k阶斐波那契序列中第n+1项fn的算法。本题的循环队列的类型定义如下：typedef struct &#123; ElemType *base; // 存储空间的基址 int front; // 队头位标 int rear; // 队尾位标，指示队尾元素的下一位置 int maxSize; // 最大长度&#125; SqQueue;**********/// 想着构造一个maxSize为n+1的循环队列来计算，但是没做出来。。。long Fib(int k, int n)/* 求k阶斐波那契序列的第n+1项fn */&#123; struct SqQueue q; q.front = 0; q.rear = 0; q.maxSize = n+1; q.base = (ElemType*)malloc((n+1)*sizeof(ElemType)); if(q.base == NULL) return OVERFLOW; int i, j, t; for(i = 0; i &lt; k - 1; i++) &#123; q.base[i] = 0; &#125; q.base[i++] = 1; for(t = i; t &lt; n+1; t++) &#123; for(j = t-1; j &gt;= t-k; j--) &#123; q.base[t] += q.base[j]; &#125; &#125; return q.base[n]; &#125;// 下面这种做法时间复杂度O(n2)，空间复杂度O(n)/* struct SqQueue q; q.front = 0; q.rear = 0; q.maxSize = n+1; q.base = (ElemType*)malloc((n+1)*sizeof(ElemType)); if(q.base == NULL) return OVERFLOW; int i, j, t; for(i = 0; i &lt; k - 1; i++) &#123; q.base[i] = 0; &#125; q.base[i++] = 1; for(t = i; t &lt; n+1; t++) &#123; for(j = t-1; j &gt;= t-k; j--) &#123; q.base[t] += q.base[j]; &#125; &#125; return q.base[n]; */ 链队列类型定义如下： 123456789typedef struct LQNode &#123; ElemType data; struct LQNode *next;&#125; LQNode, *QueuePtr;typedef struct &#123; QueuePtr front; QueuePtr rear;&#125; LQueue; 接口如下 1234567void InitQueue_LQ(LQueue &amp;Q);void DestroyQueue_LQ(LQueue &amp;Q);Status QueueEmpty_LQ(LQueue Q);int QueueLength_LQ(LQueue Q);Status GetHead_LQ(LQueue Q, ElemType &amp;e);Status EnQueue_LQ(LQueue &amp;Q, ElemType e);Status DeQueue_LQ(LQueue &amp;Q, ElemType &amp;e); 入队操作1234567891011Status EnQueue_LQ(LQueue &amp;Q, ElemType e) &#123; LQNode *p; p = (LQNode*)malloc(sizeof(LQNode)); if (NULL == p) return OVERFLOW; p-&gt;data = e; p-&gt;next = NULL; if (NULL == Q.front) Q.front = p; else Q.rear-&gt;next = p; Q.rear = p; return OK;&#125; 出队操作12345678910Status DeQuquq_LQ(LQueue &amp;Q, ElemType &amp;e) &#123; LQNode *p; if (NULL == Q.front) return ERROR; p = Q.front; e = p-&gt;data; Q.front = p-&gt;next; if (Q.rear == p) Q.rear = NULL; free(p); return OK;&#125; 部分习题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/**********【题目】试写一算法，实现链队列的判空操作。链队列的类型定义为：typedef struct LQNode &#123; ElemType data; struct LQNode *next; &#125; LQNode, *QueuePtr; // 结点和结点指针类型typedef struct &#123; QueuePtr front; // 队头指针 QueuePtr rear; // 队尾指针&#125; LQueue; // 链队列类型***********/Status QueueEmpty_LQ(LQueue Q)/* 判定链队列Q是否为空队列。 *//* 若Q是空队列，则返回TRUE，否则FALSE。*/&#123; if(Q.front == NULL &amp;&amp; Q.rear == NULL) return TRUE; return FALSE;&#125;/**********【题目】试写一算法，实现链队列的求队列长度操作。链队列的类型定义为：typedef struct LQNode &#123; ElemType data; struct LQNode *next; &#125; LQNode, *QueuePtr; // 结点和结点指针类型typedef struct &#123; QueuePtr front; // 队头指针 QueuePtr rear; // 队尾指针&#125; LQueue; // 链队列类型***********/int QueueLength_LQ(LQueue Q)/* 求链队列Q的长度并返回其值 */&#123; int length=0; LQNode *pt; pt=Q.front; while(pt != Q.rear-&gt;next)&#123; length++; pt=pt-&gt;next; &#125; free(pt); return length;&#125;/**********【题目】假设以带头结点的循环链表表示队列，并且只设一个指针指向队尾元素结点(注意不设头指针)，试编写相应的队列初始化、入队列和出队列的算法。带头结点循环链队列CLQueue的类型定义为：typedef struct LQNode &#123; ElemType data; struct LQNode *next;&#125; LQNode, *CLQueue;**********/Status InitCLQueue(CLQueue &amp;rear) // 初始化空队列&#123; if(NULL==(rear=(LQNode*)malloc(sizeof(LQNode)))) return OVERFLOW; rear-&gt;next = rear; return OK;&#125;Status EnCLQueue(CLQueue &amp;rear, ElemType x) // 入队&#123; LQNode* oldRear = rear; LQNode* head=rear-&gt;next; if(NULL==(rear=(LQNode*)malloc(sizeof(LQNode)))) return OVERFLOW; rear-&gt;next = head; rear-&gt;data = x; oldRear-&gt;next = rear; return OK;&#125;Status DeCLQueue(CLQueue &amp;rear, ElemType &amp;x) // 出队&#123; if(rear-&gt;next == rear) return ERROR; LQNode* head = rear-&gt;next; LQNode* headNext = head-&gt;next; x = headNext-&gt;data; head-&gt;next = headNext-&gt;next; free(headNext); return OK;&#125; 线性表顺序表采用顺序存储结构表示的线性表为顺序表。存储位置相邻表示位序相继的两个元素之间的前驱和后继关系。因顺序表的结构，在表中插入或删除元素不方便，所以只考虑表尾插入和删除元素，这样的顺序表也可称为栈表，类型定义如下。 123456typedef struct &#123; ElemType *elem; int length; int size; int increment;&#125; SqList; 基本接口如下 1234567891011Status InitList_Sq(SqList &amp;L, int size, int inc);Status DestroyList_Sq(SqList &amp;L);Status ClearList_Sq(SqList &amp;L);Status ListEmpty_Sq(SqList L);int ListLength_Sq(SqList L);Status GetElem_Sq(SqList L, int i, ElemType &amp;e);int Search_Sq(SqList L, ElemType e); // 顺序表中查找元素e，返回e出现第一个的位置，否则返回-1Status ListTraverse_Sq(SqList L, Status (*visit)(ElemType e)); // 遍历顺序表L，依次对每个元素调用visit()Status PutElem_Sq(SqList &amp;L, int i, ElemType e);Status Append_Sq(SqList &amp;L, ElemType e);Status DeleteLast_Sq(SqList &amp;L, ElemType &amp;e); 删除表尾元素12345Status DeleteLast_Sq(SqList &amp;L, ElemType &amp;e) &#123; if (L.length == 0) return ERROR; e = L.elem[--L.length]; return OK;&#125; 顺序查找123456int Search_Sq(SqList L, ElemType e) &#123; int i = 0; while(i&lt;L.length &amp;&amp; L.elem[i] != e) i++; if(i &lt; L.length) return i; else return -1;&#125; 有序顺序表的归并123456789101112131415161718192021222324252627void MergeList_Sq(SqList La, SqList Lb, SqList &amp;Lc) &#123; // 已知有序顺序表La和Lb中的数据元素按值非递减排序 // 归并La和Lb得到新的有序顺序表Lc，Lc的数据元素也按值非递减排列 int i = 0, j = 0, size, increment = 10; ElemType ai, bj; size = La.length + Lb.length; InitList_Sq(Lc, size, increment); while (i &lt; La.length &amp;&amp; j &lt; Lb.length) &#123; GetElem_Sq(La, i, ai); GetElem_Sq(Lb, j, bj); if (ai &lt;= bj) &#123; Append_Sq(Lc, ai); i++; &#125; else &#123; Append_Sq(Lc, bj); j++; &#125; &#125; while (i &lt; La.length) &#123; GetElem_Sq(La, i++, ai); Append_Sq(Lc, ai); &#125; while (j &lt; Lb.length) &#123; GetElem_Sq(Lb, j++, bj); Append_Sq(Lc, bj); &#125;&#125; 部分习题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126/**********【题目】设A=(a1,…,am)和B=(b1,…,bn)均为有序顺序表，A'和B'分别为A和B中除去最大共同前缀后的子表（例如，A=(x,y,y,z,x,z)，B=(x,y,y,z,y,x,x,z)，则两者中最大的共同前缀为(x,y,y,z)， 在两表中除去最大共同前缀后的子表分别为A'=(x,z)和B'=(y,x,x,z)）。若A'=B'=空表，则A=B；若A'=空表，而B'≠ 空表，或者两者均不为空表，且A'的首元小于B'的首元，则A&lt;B；否则A&gt;B。试写一个比较A和B大小的算法。（注意：在算法中，不要破坏原表A和B，也不一定先求得A'和B'才进行比较）。顺序表类型定义如下：typedef struct &#123; ElemType *elem; int length; int size; int increment;&#125; SqList;**********/char Compare(SqList A, SqList B)/* 比较顺序表A和B, *//* 返回'&lt;', 若A&lt;B; *//* '=', 若A=B; *//* '&gt;', 若A&gt;B */&#123; int min = (A.length&lt;=B.length)?A.length:B.length; int i; for(i = 0; i &lt; min; i++) &#123; if(A.elem[i] == B.elem[i]) continue; else if(A.elem[i] &lt; B.elem[i]) return '&lt;'; else if(A.elem[i] &gt; B.elem[i]) return '&gt;'; &#125; if(i == A.length &amp;&amp; i == B.length) return '='; else if(i == A.length) return '&lt;'; else return '&gt;';&#125;/**********【题目】试写一算法，实现顺序表的就地逆置，即利用原表的存储空间将线性表(a1,a2,…,an)逆置为(an,an-1,…,a1)。顺序表类型定义如下：typedef struct &#123; ElemType *elem; int length; int size; int increment;&#125; SqList;**********/void Inverse(SqList &amp;L)&#123; ElemType temp; for(int i = 0; i &lt; L.length/2; i++) &#123; temp = L.elem[i]; L.elem[i] = L.elem[L.length-i-1]; L.elem[L.length-i-1] = temp; &#125;&#125;/**********【题目】试对一元稀疏多项式Pn(x)采用存储量同多项式项数m成正比的顺序存储结构，编写求Pn(x0)的算法（x0为给定值）。一元稀疏多项式的顺序存储结构:typedef struct &#123; int coef; // 系数 int exp; // 指数&#125; Term;typedef struct &#123; Term *elem; // 存储空间基址 int length; // 长度（项数）&#125; Poly;**********/float Evaluate(Poly P, float x)/* P.elem[i].coef 存放ai， *//* P.elem[i].exp存放ei (i=1,2,...,m) *//* 本算法计算并返回多项式的值。不判别溢出。 *//* 入口时要求0≤e1&lt;e2&lt;...&lt;em，算法内不对此再作验证 */&#123; float temp = 1.0; float result = 0; int exexp = 0; int j; for(int i = 0;i &lt; P.length; i++) &#123; for(j = exexp; j &lt; P.elem[i].exp; j++) temp *= x; result += temp * P.elem[i].coef; exexp = P.elem[i].exp; &#125; return result;&#125;/**********【题目】假设有两个集合A和B分别用两个线性表LA和LB表示(即：线性表中的数据元素即为集合中的成员），试写一算法，求并集A＝A∪B。顺序表类型定义如下typedef struct &#123; ElemType *elem; // 存储空间的基址 int length; // 当前长度 int size; // 存储容量 int increment; // 空间不够增加空间大小&#125; SqList; // 顺序表可调用顺序表的以下接口函数： Status InitList_Sq(SqList &amp;L, int size, int inc); // 初始化顺序表Lint ListLength_Sq(SqList L); // 返回顺序表L中元素个数Status GetElem_Sq(SqList L, int i, ElemType &amp;e); // 用e返回顺序表L中第i个元素的值int Search_Sq(SqList L, ElemType e); // 在顺序表L顺序查找元素e，成功时返回该元素在表中第一次出现的位置，否则返回-1Status Append_Sq(SqList &amp;L, ElemType e); // 在顺序表L表尾添加元素e**********/void Union(SqList &amp;La, SqList Lb)&#123; ElemType data; for(int i = 1; i &lt;= ListLength_Sq(Lb); i++) &#123; GetElem_Sq(Lb, i, data); if(Search_Sq(La, data) == -1) Append_Sq(La, data); &#125;&#125; 单链表链表和单链栈的结构体定义是一样的，它们的区别是性质和操作，链栈是一个栈，它的操作接口有入栈，出栈，取栈顶元素等，而链表是一个表，是有结构的数据的集合，它的操作有插入，删除，遍历等。 1234typedef struct LNode &#123; ElemType data; struct LNode *next;&#125; LNode, *LinkList; 基本操作接口如下： 1234567891011Status InitList_L(LinkList &amp;L);Status DestroyList_L(LinkList &amp;L);Status ClearList_L(LinkList &amp;L);Status ListEmpty_L(LinkList L);init ListLength_L(LinkList L);LNode* Search_L(LinkList L, ElemType e);LNode* NextElem_L(LNode *p); // 返回p结点的直接后继LNode* MakeNode_L(ElemType e); // 构造元素e的结点，返回指向该结点指针Status InsertAfter_L(LNode *p, LNode *q); // 结点p后插入结点qStatus DeleteAfter_L(LNode *p, ElemType &amp;e); // 删除p结点的直接后继结点，用e返回结点值void ListTraverse_L(LinkList L, Status (*visit)(ElemType e)); // 遍历单链表L 单链表初始化123456Status InitList_L(LinkList &amp;L) &#123; if(NULL==(LNode*)malloc(sizeof(LNode))) return OVERFLOW; L-&gt;next = NULL; return OK;&#125; 查找元素操作12345678LNode* Search_L(LinkList L, ElemType e) &#123; LNode *p; if (NULL == L) return ERROR; p = L-&gt;next; // 带头结点 while(p-&gt;data != e &amp;&amp; p != NULL) p = p-&gt;next; return p;&#125; 求直接后继操作1234LNode* NextElem_L(LNode *p) &#123; if (p == NULL) return NULL; return p-&gt;next;&#125; 构造结点操作123456789LNode *MakeNode_L(ElemType e) &#123; LNode *p; p = (LNode*)malloc(sizeof(LNode)); if (NULL != p) &#123; p-&gt;next = NULL; p-&gt;data = e; &#125; return p;&#125; 插入直接后继结点操作123456Status InsertAfter_L(LNode *p, LNode *q) &#123; if (NULL == p || NULL == q) return ERROR; q-&gt;next = p-&gt;next; p-&gt;next = q; return OK;&#125; 删除直接后继结点操作123456789Status DeleteAfter_L(LNode *p, ElemType &amp;e) &#123; LNode *q; if (p == NULL || p-&gt;next == NULL) return ERROR; q = p-&gt;next; p-&gt;next = q-&gt;next; e = q-&gt;data; free(q); return OK;&#125; 单链表的逆置1234567891011void InverseList(LinkList L) &#123; LNode *q, *p; if(NULL == L-&gt;next || NULL == L-&gt;next-&gt;next) return; p = L-&gt;next; L-&gt;next = NULL; while(p != NULL) &#123; q = p-&gt;next; InsertAfter_L(L, p); p = q; &#125;&#125; 部分习题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319/**********【题目】试写一算法，实现带头结点单链表的判空操作。单链表的类型定义为：typedef struct LNode &#123; ElemType data; struct LNode *next; &#125; LNode, *LinkList; // 结点和结点指针类型***********/Status ListEmpty_L(LinkList L)/* 判定带头结点单链表L是否为空链表。 *//* 若L是空链表，则返回TRUE，否则FALSE。*/&#123; if(L-&gt;next == NULL) return TRUE; // 带头结点，头结点保存了一些信息 return FALSE;&#125;/**********【题目】试写一算法，实现带头结点单链表的销毁操作。单链表的类型定义为：typedef struct LNode &#123; ElemType data; struct LNode *next; &#125; LNode, *LinkList; // 结点和结点指针类型***********/Status DestroyList_L(LinkList &amp;L)/* 销毁带头结点单链表L，并返回OK。*/&#123; LNode* n = L; while((n=n-&gt;next) != NULL) free(n); free(L); return OK;&#125;/**********【题目】试写一算法，实现带头结点单链表的清空操作。单链表的类型定义为：typedef struct LNode &#123; ElemType data; struct LNode *next; &#125; LNode, *LinkList; // 结点和结点指针类型***********/Status ClearList_L(LinkList &amp;L)/* 将带头结点单链表L置为空表，并返回OK。*//* 若L不是带头结点单链表，则返回ERROR。 */&#123; if(L == NULL) return ERROR; LNode* n = L; while((n=n-&gt;next)!=NULL) free(n); L-&gt;next = NULL; // 释放完内存后，L-&gt;next仍然指向之前分配的，尽管那片空间已经被释放 return OK; &#125;/**********【题目】试写一算法，实现带头结点单链表的求表长度操作。单链表的类型定义为：typedef struct LNode &#123; ElemType data; struct LNode *next; &#125; LNode, *LinkList; // 结点和结点指针类型***********/int ListLength_L(LinkList L)/* 求带头结点单链表L的长度，并返回长度值。*//* 若L不是带头结点单链表，则返回-1。 */&#123; if(L == NULL) return -1; int length = 0; LNode* p = L; while((p=p-&gt;next)!=NULL) length++; return length; &#125;/**********【题目】试写一算法，在带头结点单链表L插入第i元素e。带头结点单链表的类型定义为：typedef struct LNode &#123; ElemType data; struct LNode *next;&#125; LNode, *LinkList;**********/Status Insert_L(LinkList L, int i, ElemType e)/* 在带头结点单链表L插入第i元素e，并返回OK。*//* 若参数不合理，则返回ERROR。 */&#123; // i为第i个位置 // 不能插入到0号位置头结点处 int c; LNode *p=L, *q; if(i&lt;=0) return ERROR; if(L==NULL) return ERROR; if((q=(LNode*)malloc(sizeof(LNode)))==NULL) return OVERFLOW; for(c=1,p=L; c&lt;i; c++) &#123; p = p-&gt;next; if(p == NULL) return ERROR; &#125; q-&gt;data = e; q-&gt;next = p-&gt;next; p-&gt;next = q; return OK;&#125;/**********【题目】试写一算法，在带头结点单链表删除第i元素到e。带头结点单链表的类型定义为：typedef struct LNode &#123; ElemType data; struct LNode *next;&#125; LNode, *LinkList;**********/Status Delete_L(LinkList L, int i, ElemType &amp;e)/* 在带头结点单链表L删除第i元素到e，并返回OK。*//* 若参数不合理，则返回ERROR。 */&#123; // p是第i个结点的前一个结点，q是第i个结点 // 执行删除操作，要确保q结点不是NULL int c; LNode *p=L, *q; if(L==NULL || p-&gt;next == NULL) return ERROR; if(i &lt;= 0) return ERROR; for(c=1,p=L; c&lt;i; c++) &#123; p = p-&gt;next; if(p-&gt;next == NULL) return ERROR; &#125; q = p-&gt;next; e = q-&gt;data; p-&gt;next = q-&gt;next; p-&gt;next = q-&gt;next; free(q); return OK;&#125;/**********【题目】试写一算法，在带头结点单链表的第i元素起的所有元素从链表移除，并构成一个带头结点的新链表。带头结点单链表的类型定义为：typedef struct LNode &#123; ElemType data; struct LNode *next;&#125; LNode, *LinkList;**********/Status Split_L(LinkList L, LinkList &amp;Li, int i)/* 在带头结点单链表L的第i元素起的所有元素 *//* 移除，并构成带头结点链表Li，返回OK。 *//* 若参数不合理，则Li为NULL，返回ERROR。 */&#123; if(i &lt;= 0) &#123; Li = NULL; return ERROR; &#125; LNode* p = L; LNode *t1, *t2; Li = (LNode*)malloc(sizeof(LNode)); // 到最后的时候，t2为L的尾指针，t3为Li的尾指针 int c; for(c = 0; c &lt; i-1; c++) p = p-&gt;next; // 此时p为i-1个元素 t2 = p; p = p-&gt;next; // 此时p为Li的头指针 if(p == NULL) &#123; Li = NULL; return ERROR; &#125; Li-&gt;next = p; t2-&gt;next = NULL; return OK;&#125;/**********【题目】试写一算法，在带头结点单链表删除第i元素起的所有元素。带头结点单链表的类型定义为：typedef struct LNode &#123; ElemType data; struct LNode *next;&#125; LNode, *LinkList;**********/Status Cut_L(LinkList L, int i)/* 在带头结点单链表L删除第i元素起的所有元素，并返回OK。*//* 若参数不合理，则返回ERROR。 */&#123; if(i &lt;= 0) return ERROR; LNode* p = L; LNode* t1; // 用于释放内存 LNode* t2; // 用于保存第i-1个元素，删除后继节点后，使它的next为NULL int c; for(c = 0; c &lt; i-1; c++) p = p-&gt;next; // 此时p为i-1个元素 t2 = p; p = p-&gt;next; if(p == NULL) return ERROR; while(p) &#123; t1 = p; p = p-&gt;next; free(t1); &#125; t2-&gt;next = NULL; return OK; &#125;/**********【题目】试写一算法，删除带头结点单链表中所有值为x的元素，并释放被删结点空间。单链表类型定义如下：typedef struct LNode &#123; ElemType data; struct LNode *next;&#125; LNode, *LinkList;**********/Status DeleteX_L(LinkList L, ElemType x)/* 删除带头结点单链表L中所有值为x的元素， *//* 并释放被删结点空间，返回实际删除的元素个数。*/&#123; /*LNode* p = L; LNode* temp; int count=0; while(p-&gt;next != NULL) &#123; while(p-&gt;next-&gt;data == x) &#123; temp = p-&gt;next; p-&gt;next = p-&gt;next-&gt;next; free(temp); count++; &#125; p = p-&gt;next; &#125; return count; */ LNode *p1, *p2, *p3; int j = 0; p1=p2=L; if(NULL==p1) return j; while(p2!=NULL) &#123; p2=p1-&gt;next; if(p2-&gt;data == x &amp;&amp; p2 != NULL) &#123; p3 = p2; p2 = p3-&gt;next; p1-&gt;next = p2; free(p3); j++; &#125; else if(p2-&gt;data != x) &#123; p1 = p2; p2 = p1-&gt;next; &#125; &#125; return j;&#125;/**********【题目】试写一算法，删除带头结点单链表中所有值小于x的元素，并释放被删结点空间。单链表类型定义如下：typedef struct LNode &#123; ElemType data; struct LNode *next;&#125; LNode, *LinkList;**********/Status DeleteSome_L(LinkList L, ElemType x)/* 删除带头结点单链表L中所有值小于x的元素， *//* 并释放被删结点空间，返回实际删除的元素个数。*/&#123; LNode* p = L; LNode* temp; int count = 0; while(p-&gt;next != NULL) &#123; /* 下面的while如果不加p-&gt;next!=NULL就报错 * 到底为什么会这样我也不清楚，写blog的时候就用下面注释的代码吧 * 猜测是p-&gt;next = p-&gt;next-&gt;next; p = p-&gt;next; * 当p-&gt;next-&gt;next为NULL的时候，p=p-&gt;next就为NULL了，但此时p-&gt;next不为NULL */ while(p-&gt;next-&gt;data &lt; x &amp;&amp; p-&gt;next != NULL) &#123; temp = p-&gt;next; p-&gt;next = p-&gt;next-&gt;next; free(temp); count++; &#125; p = p-&gt;next; &#125; return count; /* LNode *p1, *p2, *p3; int j = 0; p1=p2=L; if(NULL==p1) return j; while(p2!=NULL) &#123; p2=p1-&gt;next; if(p2-&gt;data &lt; x &amp;&amp; p2 != NULL) &#123; p3 = p2; p2 = p3-&gt;next; p1-&gt;next = p2; free(p3); j++; &#125; else if(p2-&gt;data &gt;= x) &#123; p1 = p2; p2 = p1-&gt;next; &#125; &#125; return j;*/&#125; 双向链表双向链表可以访问结点的直接前驱，定义如下： 1234typedef struct DuLNode &#123; ElemType data; struct DuLNode *prior, *next;&#125; DuLNode, *DuLinkList; 操作接口如下： 12345678910111213Status InitList_DuL(DuLinkList &amp;L);Status DestroyList_DuL(DuLinkList &amp;L);Status ClearList_DuL(DuLinkList &amp;L);Status ListEmpty_DuL(DuLinkList L);int ListLength_DuL(DuLinkList L);DuLNode* Search_DuL(DuLinkList L, ElemType e);DuLNode* PriorElem_DuL(DuLNode *p); // 返回p结点的直接前驱结点指针DuLNode* NextElem_DuL(DuLNode *p);DuLNode* MakeNode_DuL(ElemType e);Status InsertBefore_DuL(DuLNode *p, DuLNode *q);Status InsertAfter_DuL(DuLNode *p, DuLNode *q);Status Delete_DuL(DuLNode *p, ElemType &amp;e);void ListTraverse_DuL(DuLinkList L, Status (*visit)(ElemType e)); 插入前驱结点操作123456789Status InsertBefore_DuL(DuLNode *p, DuLNode *q) &#123; if (NULL == p || NULL == q || NULL == p-&gt;prior) return ERROR; q-&gt;prior = p-&gt;prior; q-&gt;next = p; q-&gt;prior-&gt;next = q; p-&gt;prior = q; return OK;&#125; 删除结点操作12345678Status Delete_DuL(DuLNode *p, ElemType &amp;e) &#123; if (NULL == p || NULL == p-&gt;prior) return ERROR; if (p-&gt;next != NULL) p-&gt;next-&gt;prior = p-&gt;prior; p-&gt;prior-&gt;next = p-&gt;next; e = p-&gt;data; free(p); return OK;&#125; 循环链表单循环链表单循环链表特点是尾元结点指针域指向头结点，类型和接口定义与单链表相似。 1typedef LinkList CirLinkList; 双向循环链表双向链表中，若令尾元结点next指针域指向头结点，头结点prior指针域指向尾元结点，就构成双向循环链表。 1typedef DuLinkList DuCirLinkList;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
        <tag>队列</tag>
        <tag>链表</tag>
        <tag>顺序表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript08-DOM扩展]]></title>
    <url>%2F2018%2F11%2F09%2FJavaScript08-DOM%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[JavaScript08-DOM扩展对JavaScript的两个主要扩展主要是Selectors API和HTML5 选择符API根据CSS选择符选择与某个模式匹配的DOM元素。jQuery的核心就是通过CSS选择符查询DOM文档取得元素的引用，从而抛开了getElementById()和getElementsByTagName()，它有两个核心方法：querySelector()和querySelectorAll()，可以通过Document及Element类型的实例调用它们。 querySelector()方法它接收一个CSS选择符，返回与该模式匹配的第一个元素，如果没有就返回null。 1234567891011// 取得body元素var body = document.querySelector("body");// 取得ID为myDiv的元素var myDiv = document.querySelector("#myDiv");// 取得类为"selected"的第一个元素var selected = document.querySelector(".selected");// 取得类为"button"的第一个图像元素var img = document.body.querySelector("img.button"); querySelectorAll()方法querySelectorAll()方法接收的参数和上面一样，都是一个CSS选择符，但返回的是所有匹配的元素，是一个NodeList实例。 元素遍历Chrome Version 70.0.3538.77不支持 Element Travelsal API为DOM元素添加以下5个属性，用于预防元素间空格造成的childNodes和firstChild等属性不一致的差异。 childElementCount：返回子元素（不包括文本节点和注释）的个数 firstElementChild：指向第一个元素 lastElementChild：指向最后一个元素 previousElementSibling：指向前一个同辈元素 nextElementSibling：指向后一个同辈元素 HTML5与类相关的扩充getElementsByClassName()方法可以通过document对象以及所有HTML元素调用该方法，它接收一个参数，即一个包含一个或多个类名的字符串，返回带有指定类的所有元素的NodeList。 取得所有类中包含”username”和”current”的元素，类先后无所谓var allCurrentUsernames = document.getElementByClassName(&quot;username current&quot;); 取得ID为myDiv的元素中带有类名”selected”的所有元素var selected = document.getElementById(&quot;myDiv&quot;).getElementsByClassName(&quot;selected&quot;); classList属性操作类名的时候，可以使用classList属性，classList属性是DOMTokenList的实例，他有一个表示自己包含多少元素的length属性，要取得每个元素，可以使用item()方法，也可以使用方括号。如下： &lt;div class=&quot;bd user disabled&quot;&gt;&lt;/div&gt; classList属性有三个值分别是bd user和disabled。 这个属性还定义了下面方法 add(value)：将给定的字符串值添加到列表中。 contains(value)：表示列表中是否存在给定的值，存在返回true。 remove(value)：删除value toggle(value)：如果列表中存在给定值，就删除它，如果不存在，就添加它。 这样，就可以通过上述方法操控className了，如下 div.classList.remove(&quot;user&quot;); // 删除user类 焦点管理HTML5添加了辅助管理DOM焦点的功能。document.activeElement属性始终会引用DOM中当前获得焦点的元素。元素获得焦点方式有页面加载，用户输入和在代码中调用focus()方法 123456&lt;body&gt; &lt;button type="button" id="myButton"&gt;Click Me!&lt;/button&gt; &lt;p&gt;&lt;/p&gt; &lt;button type="button" onclick="focusMethod()"&gt;Click me to focus on the button!&lt;/button&gt; &lt;script type="text/javascript" src="./aha.js"&gt;&lt;/script&gt; &lt;/body&gt; 1234focusMethod = function getFocus() &#123; document.getElementById("myButton").focus(); alert(document.activeElement == document.getElementById("myButton")); &#125; 文档刚刚加载完，document.activeElement中保存的是document.body元素的引用。 document.hasFocus()用于确定文档是否获得了焦点。 HTMLDocument的变化HTML5扩展了HTMLDocument，增加了新功能。 readyState属性Document的readyState属性可能有两个值 loading：正在加载文档 complete：已经加载完文档 基本用法如下 123if(document.readyState == "complete") &#123; // 执行操作&#125; head属性作为对document.body引用文档&lt;body&gt;元素的补充，HTML5新增了document.head属性，引用文档的&lt;head&gt;元素。 var head = document.head || document.getElementsByTagName(&quot;head&quot;)[0]; 字符集属性charset属性表示文档中实际使用的字符集，也可以用来指定新字符集，可以通过&lt;meta&gt;元素，响应头部或直接设置charset属性修改这个值。 document.charset = &quot;UTF-8&quot;; 自定义数据属性HTML5可以为元素添加非标准的属性，但要添加前缀data-，目的是为元素提供与渲染无关的信息，或提供语义信息。可以通过元素dataset属性访问这些自定义属性的值。dataset是一个DOMStringMap的实例，键为非标准属性名减去data-前缀（比如自定义属性是data-myname，映射对应属性就是myname） &lt;div id=&quot;myDiv&quot; data-appid=&quot;12345&quot; data-myname=&quot;Nicholas&quot;&gt;&lt;/div&gt; 123456var div = document.getElementById("myDiv");var appId = div.dataset.appid;var myName = div.dataset.myname;alert(appId); 插入标记innerHTML属性在读模式下，innerHTML属性返回与调用元素的所有子节点（包括元素，注释和文本节点）对应的HTML标记。写模式下，innerHTML会根据指定的值创建新的DOM树，然后用这个DOM树完全替换调用元素原先的所有子节点。 写模式下，innerHTML的值会被解析为DOM子树，替换调用元素原来的所有子节点。因为它的值被认为是HTML，所以其中的所有标签都会按照浏览器处理HTML的标准方式转换为元素。设置了innerHTML之后，可以像访问文档中其他节点一样访问新创建的节点。 对下面代码的div块调用innerHTML，会返回其内部子元素（字符串形式） 12345678&lt;div id="content"&gt; &lt;p&gt;This is a &lt;strong&gt;paragraph&lt;/strong&gt; with a list following it.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 下面元素不支持innerHTML属性：&lt;col&gt;,&lt;colgroup&gt;,&lt;frameset&gt;,&lt;head&gt;,&lt;html&gt;,&lt;style&gt;,&lt;table&gt;,&lt;tbody&gt;,&lt;thead&gt;,&lt;tfoot&gt;和&lt;tr&gt; outerHTML属性在读模式下，outerHTML返回调用它的元素及所有子节点的HTML标签。写模式下，outerHTML会根据指定的HTML字符串创建新的DOM子树，然后用这个DOM子树完全替换调用元素。 对上面代码div块调用outerHTML，会返回上面相同的代码，包括div本身。 div.outerHTML = &quot;&lt;p&gt;This is a paragraph.&lt;/p&gt;&quot;; 对上面代码的调用，等价于下面的代码 123var p = document.createElement("p");p.appendChild(document.createTextNode("This is a paragraph."));div.parentNode.replaceChild(p, div); insertAdjacentHTML()方法它接收两个参数，插入位置和要插入的HTML文本。第一个参数必须是下列值之一： beforebegin：当前元素之前插入一个紧邻的同辈元素 afterbegin：当前元素之下插入一个新的子元素或在第一个子元素之前再插入新的子元素 beforeend：当前元素之下插入一个新的子元素或再最后一个子元素之后再插入一个新的子元素 afterend：当前元素之后插入一个紧邻的同辈元素 内存与性能问题使用上面2个属性1个方法之前，最好先手工删除要被替换的元素的所有时间处理程序和JavaScript对象属性。 对上面2个属性，最佳做法是单独构建一个字符串，然后一次性把结果字符串赋值给innerHTML（或outerHTML），这样可以减少访问属性的开支。 scrollIntoView()方法可以在所有HTML元素上调用，通过滚动浏览器窗口或某个容器元素，调用元素就可以出现在视口中，传入true作为参数，或者不传入参数，则窗口滚动之后会让调用元素的顶部与视口顶部尽可能平齐。传入false，调用元素会尽可能出现在视口中（可能的话，调用元素底部会与视口底部平齐） Chrome不支持。。。 专有扩展children属性这个属性是HTMLCollection的实例，只包含元素中同样还是元素的子节点。children属性与childNodes没什么区别 contains()方法调用contains()方法的应该是祖先节点，这个方法接收一个参数，就是要检测的后代节点。如果被检测的节点是后代节点，就返回true。 插入文本innerText属性通过这个属性可以操作元素中包含的所有文本内容，包括子文档树中的文本。在通过innerText读取值时，它会按照由浅入深顺序将子文档中所有文本拼接起来。在通过innerText写值时，结果会删除元素的所有子节点。插入包含相应文本值的文本节点。 outerText属性作用范围扩大到了包含调用它的节点，写操作下会替换整个元素（包括子节点）。 滚动 scrollIntoViewIfNeeded(alignCenter)：只在当前元素在视口中不可见的情况下，才滚动浏览器窗口或容器元素，最终让它可见。如果参数为true，尽量让元素显示在视口中部。 scrollByLines(lineCount)：元素内容滚动指定的行高，可以正或负值。 scrollByPages(pageCount)：元素内容滚动指定的页面高度。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构01-前言]]></title>
    <url>%2F2018%2F11%2F06%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8401-%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[数据结构01-前言一些预定义123456#define TRUE 1#define FALSE 0#define OK 1#define ERROR 0#define OVERFLOW -1typedef int Status; // 用作函数值类型，表示函数结果状态 ElemType代表数值的类型。一般是int，可以作下面定义typedef int ElemType; 时间复杂度T(n) = O(f(n)) 常见时间复杂度 类 符号 举例 常数 O(1) 返回数组第一个元素 对数 O(logn) 对有序数组折半查找 线性 O(n) 对数组顺序查找 nlogn O(nlogn) 归并排序 平方 O(n²) 选择排序 立方 O(n^3) 传统矩阵相乘 指数 O(2n) 汉诺塔 空间复杂度S(n) = O(f(n))]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSCript07-DOM]]></title>
    <url>%2F2018%2F11%2F01%2FJavaScript07-DOM%2F</url>
    <content type="text"><![CDATA[JavaScript07-DOM节点层次DOM将任何HTML文档描绘成一个多层节点构成的结构。根节点为文档节点，文档节点下一般有一个子节点&lt;html&gt;元素，称为文档元素。 Node类型DOM定义了一个Node接口，由DOM中所有节点类型实现。每个节点都有一个nodeType属性，用于表明节点的类型，该属性有如下12个数值常量 Node.ELEMENT_NODE(1); Node.ATTRIBUTE_NODE(2); Node.TEXT_NODE(3); Node.CDATA_SECTION_NODE(4); Node.ENTITY_REFERENCE_NODE(5); Node.ENTITY_NODE(6); Node.PROCESSING_INSTRUCTION_NODE(7); Node.COMMENT_NODE(8); Node.DOCUMENT_NODE(9); Node.DOCUMENT_TYPE_NODE(10); Node.DOCUMENT_FRAGMENT_NODE(11); Node.NOTATION_NODE(12); nodeName和nodeValue属性要了解节点具体信息，可以使用这两个属性。 if (someNode.nodeType==1){ value = someNode.nodeName; } 对于元素节点，nodeName始终保存元素标签名，nodeValue始终为null 节点关系每个节点都有一个childNodes属性，其中保存着一个NodeList对象，它是一个类数组对象，用于保存一组有序的节点，也有length属性，但它是基于DOM结构动态执行查询的结果，因此DOM结构的变化能够自动反映在NodeList对象中。 可以通过下面方法访问保存在NodeList中的节点 123var firstChild = someNode.childNodes[0];var secondChild = someNode.childNodes.item(1);var count = somNode.childNodes.length; 每个节点都有一个parentNode属性，该属性指向文档树中的父节点。包含在childNodes列表中的所有节点都具有相同的父节点。此外，包含在childNodes列表中的每个节点相互之间都是同胞节点。使用列表中每个节点的previousSibling和nextSibling属性，可以访问同一列表的其他节点。父节点与其第一个和最后一个子节点之间也有关系，使用父节点的firstChild和lastChild属性分别指向childNodes列表的抵押给和最后一个节点。 所有节点都有最后一个属性是ownerDocument，该属性指向表示整个文档的文档节点。 操作节点appendChild()可以通过appendChild()方法向childNodes列表末尾添加一个节点，如下 1var returndNode = someNode.appendChild(newNode); 如果传入到appendChild()的节点已经是文档的一部分，那结果是将该节点从原来位置转移到新位置。DOM树可以看成是一系列指针连接起来的，但任何DOM节点不能同时出现在文档中的多个位置上。 insertBefore()可以使用insertBefore()方法把节点放在childNodes的某个特定位置上，接收两个参数，要插入的节点和作为参考的节点。插入节点后，被插入的节点会变成参考节点的前一个同胞节点，然后被该方法返回。 1returnedNode = someNode.insertBefore(newNode, null); // 插入到最后 replaceChild()它接收两个参数：要插入的节点和要替换的节点，然后把插入的节点返回。 removeChild()接收一个参数：要移除的节点。然后该节点被该方法返回。 其他方法#####cloneNode() cloneNode()接收一个布尔值参数，表示是否执行深复制。如果为true，则复制节点及其整个子节点树，如果为false，只复制节点本身。 Document类型Document类型表示文档，在浏览器中，document对象是HTMLDocument的一个实例，表示整个HTML页面。而且document类型是window对象的一个属性，有下列特征： nodeType为9； nodeName为”#document”； nodeValue为null； parentNode为null； ownerDucument为null; 文档的子节点有一个documentElement属性，始终指向HTML页面的&lt;html&gt;元素，另外还有一个childNodes列表访问文档元素。 document还提供了body，doctype属性访问对于的标签var body = document.body; 文档信息titledocument对象作为HTMLDocument的一个实例，还有一些其他属性表现网页的一些信息，其中一个是title属性 1234// 一个修改title的例子var originalTitle = document.title;document.title = "New page title"; URL,domain和referrerURL属性包含页面完整的URL，domain属性只包含域名，而referrer属性中则保存链接到当前页面的那个页面的URL，这些属性都保存在HTTP头部，JS提供了这些属性访问它们。 这三个属性中只有domain可以设置，但只能设置成URL包含的域，否则报错，这个属性可以用于跨页面通信，比如一个页面加载自www.wrox.com，包含一个内嵌框架加载自p2p.wrox.com。只需要把它们的document.domain都设置成wrox.com，就可以实现两者的通信。注意一旦设置为wrox.com后，就不能设置回p2p.wrox.com了 查找元素Document类型提供了两个方法查找元素，分别为getElementById()和getElementByTagName()。 getElementById()getElementById()接收一个参数：要取得的元素的ID，区分大小写,返回该元素。 &lt;div id=&quot;myDiv&quot;&gt;&lt;/div&gt;var div = document.getElementById(&quot;myDiv&quot;); getElementsByTagName()getElementByTagName()接收一个参数：要取得的元素的标签名，返回的是包含零个或多个元素的NodeList。在HTML文档中，这个方法返回一个HTMLCollection对象，作为一个动态集合。 var images = document.getElementsByTagName(&quot;img&quot;); 可以通过images.item(i).src取得第i个images对象的src属性 HTMLCollection对象还有一个方法nameItem()，可以通过元素的name特性取得集合中的项。 &lt;img src=&quot;xxx.gif&quot; name=&quot;myImage&quot;&gt;var myImage = images.namedItem(&quot;myImage&quot;);这与直接用方括号语法等效var myImage = images[&quot;myImage&quot;]; 要取得文档所有元素，可以传入参数”*” var allElements = document.getElementsByTagName(&quot;*&quot;); getElementsByName()这是只有HTMLDocument类型才有的方法，它返回带有给定name特性的所有元素。通常用于取得单选按钮，如下 1234567891011&lt;fieldset&gt; &lt;legend&gt;Which color do you prefer?&lt;/legend&gt; &lt;ul&gt; &lt;li&gt;&lt;input type="radio" value="red" name="color" id="colorRed"&gt; &lt;label for="colorRed"&gt;Red&lt;/label&gt;&lt;/li&gt; &lt;li&gt;&lt;input type="radio" value="green" name="color" id="colorGreen"&gt; &lt;label for="colorGreen"&gt;Green&lt;/label&gt;&lt;/li&gt; &lt;li&gt;&lt;input type="radio" value="blue" name="color" id="colorBlue"&gt; &lt;label for="colorBlue"&gt;Blue&lt;/label&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/fieldset&gt; 在这里，所有单选按钮的name属性都是”color”，但他们的ID可以不同，ID的作用是把&lt;label&gt;元素应用到每个单选按钮，而name特性则用以确保三个值中只有一个被发送到浏览器，这样就可以用下面代码取得所有单选按钮 var radios = document.getElementByName(&quot;color&quot;); 特殊集合document对象还有一些特殊的集合。这些集合都是HTMLCollection对象。 document.anchors,包含文档中所有带name特性的&lt;a&gt;元素 document.forms,包含所有&lt;form&gt;元素 documents.images,包含所有&lt;img&gt;元素 document.links,包含所有带href的&lt;a&gt;元素 文档写入document有四个方法可以写入:write(),writeln(),open()和close() 123&lt;script type="text/javascript"&gt; document.write((new Date()).toString()); &lt;/script&gt; Element类型Element类型提供了对元素标签名，子节点以及特性的访问。有如下特征： nodeType值为1 nodeName值为元素的标签名 nodeValue值为null parentNode可能是Document或Element 其子结点可能是Element,Text,Comment等等 要访问元素的标签名，可以使用nodeName属性也可以使用tagName属性。 HTML元素所有HTML元素都由HTMLElement类型及其子类型表示，HTMLElement类型直接继承Element并添加了一些属性 id:元素在文档中的唯一标识符 className:元素的class特性对应，即为元素指定的CSS类 这些属性都是可修改的，直接复制即可 取得特性操作特性有三个方法，分别为getAttribute(),setAttribute()和removeAttribute()。这三个方法可以针对任何特性使用。 getAttribute()也可以取得自定义特性（HTML5中，自定义特性应该加上data-前缀） 123var div = document.getElementById(&quot;myDiv&quot;);alert(div.getAttribute(&quot;class&quot;));alert(div.getAttribute(&quot;data-yourData&quot;); 通常更建议直接使用对象的属性，只有在取得自定义特性的情况下才使用getAttribute()方法 设置特性setAttribute()接收两个参数：要设置的特性名和值，如果特性已经存在，他就会替换现有的值，若不存在，就创建该属性并设置值。 attributes属性Element类型是使用attributes属性的唯一一个DOM节点类型。attributes属性中包含一个NamedNodeMap，与NodeList类似，也是一个动态集合。元素的每一个特性都由一个Attr节点表示，每个节点都保存在NamedNodeMap对象中。它有下列方法： getNamedItem(name):返回nodeName属性等于name的节点 removeNamedItem(name):从列表中移除nodeName属性等于name的节点 setNamedItem(node):向列表中添加节点，以节点的nodeName属性为索引 item(pos):返回数字pos位置的节点 attributes包含一系列节点，每个节点的nodeName是特性名，nodeValue为特性值 var id = element.attributes.getNamedItem(&quot;id&quot;).nodeValue; // 取得element节点特性id的值 等效于 var id = element.attributes[&quot;id&quot;].nodeValue; 创建元素使用document.createElement()方法可以创建新元素 var div = document.createElement(&quot;div&quot;); 创建的同时也指定了其ownerDocument属性。 新创建的元素还没加入文档树 document.body.appendChild(div); 可以把它加入到body元素中 元素的子节点childNodes属性包含了它的所有子节点，这些子节点可能是元素，文本节点，注释或处理指令，可以通过element.childNodes[i].nodeType == 1来作检测 Text类型文本节点可以是字面解释的纯文本内容，也可以是包含转义后的HTML字符，但不能包含HTML代码。 nodeType=3 nodeName=”#text” nodeValue为节点所包含的文本 parentNode是一个Element 不支持子节点 可以通过nodeValue属性或data属性访问节点中包含的文本。使用下列方法可以操作节点中的文本 appendData(text)：把text添加到节点末尾 deleteData(offset, count)：从offset指定的位置开始删除count个字符 insertData(offset, text)：在offset指定位置插入text replaceData(offset, count, text)：用text替换从offset指定的位置开始到offset+count位置的文本 splitText(offset)：从offset指定的位置将当前文本分开两个文本节点 substringData(offset, count)：提取从offset指定的位置开始到offset+count为止处的字符串 &lt;div&gt;Hello World!&lt;/div&gt; 上述文本子节点可以通过var textNode = div.firstChild访问 创建文本节点可以使用document.createTextNode()创建新文本节点，接收一个参数：要插入节点的文本。 一个创建新节点并插入创建文本的例子 1234567var element = document.createElement("div");element.className = "message";var textNode = document.createTextNode("Hello World!");element.appendChild(textNode);document.body.appendChild(element); 一般情况下每个元素只有一个文本子节点，但也可以同时有多个文本子节点，当他们是相邻的同胞节点，那么这两个节点就会连起来显示，中间不会有空格。 规范化文本节点DOM文档中存在相邻的同胞文本节点很容易导致混乱，因为分不清哪个文本节点表示哪个字符串。DOM文档中出现相邻文本节点的情况也不在少数，于是催生了一个能够将相邻文本节点合并的方法，为normalize()，它把所有文本节点合并成一个子节点，结果节点的nodeValue为合并前每个文本节点nodeValue拼接起来的值。 分割文本节点splitText()可以用于分割文本节点。 Comment类型注释在DOM中是通过Comment类型来表示的，有如下特征： nodeType值为8 nodeName值为”#comment” nodeValue值为注释的内容 parentNode可能是Document或Element 不支持子节点 Comment类型与Text类型继承自相同的基类，因此它拥有除splitText()之外的所有字符串操作方法，也可以通过nodeValue或data属性来取得注释的内容。 注释节点可以通过其父节点来访问 1234567&lt;div id="myDiv"&gt;&lt;!-- TODO: do what? --&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var div = document.getElementById("myDiv"); var comment = div.firstChild; alert(comment.data); &lt;/script&gt; 另外，使用createComment()方法也可以创建注释节点 CDATASection类型只针对基于XML的文档，表示的CDATA区域 DocumentType类型DocumentFragment类型Attr类型元素的特性在DOM中以Attr类型来表示，在所有浏览器中都可以访问Attr类型的构造函数和原型，有下列特征 nodeType=2 nodeName是特性的名称 nodeValue是特性的值 parentNode是null HTML中不支持子节点 要取得特性，通常用getAttribute(),setAttribute()和removeAttribute()方法，很少直接引用特性节点 Attr有三个属性，name，value和specified，其中specified是一个布尔值，用于区分特性是在代码中指定还是默认的。 可以使用document.createAttribute()方法并传入特性的名称来创建新的特性节点。 DOM操作技术动态脚本页面加载时不存在，但将来某一时刻通过修改DOM动态添加的脚本。 动态加载外部JS文件123456function loadScript(url) &#123; var script = document.createElement("script"); script.type = "text/javascript"; script.src = url; document.body.appendChild(script);&#125; 动态添加行内JS代码123456789101112function loadScriptString(code) &#123; var script = document.createElement("script"); script.type = "text/javascript"; try &#123; script.appendChild(document.createTextNode(code)); &#125; catch (ex) &#123; script.text = code; &#125; document.body.appendChild(script);&#125;loadScriptString("function sayHi()&#123; alert('hi'); &#125;"); 动态样式加载外部CSS 12345678function loadStyles(url) &#123; var link = document.createElement("link"); link.rel = "stylesheet"; link.type = "text/css"; link.href = url; var head = document.getElementsByTagName("head")[0]; head.appendChild(link);&#125; 操作表格对于一个表格 123456789101112&lt;table border="1" width="100%"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Cell 1,1&lt;/td&gt; &lt;td&gt;Cell 2,1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Cell 1,2&lt;/td&gt; &lt;td&gt;Cell 2,2&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 要创建的节点太多了，所以DOM为&lt;table&gt;,&lt;tbody&gt;和&lt;tr&gt;元素添加了一些属性和方法 &lt;table&gt;的属性和方法如下： caption：保存对&lt;caption&gt;元素的指针 tBodies：是一个&lt;tbody&gt;元素的HTMLCollection tFoot：保存对&lt;tfoot&gt;元素的指针 tHead：保存对&lt;thead&gt;元素的指针 rows：一个表格中所有行的HTMLCollection createTHead()：创建&lt;thead&gt;元素，将其放到表格中，返回引用 createTFoot()：创建&lt;tfoot&gt;元素，同上 createCaption()：创建&lt;caption&gt;元素，同上 deleteCaption() deleteTHead() deleteCaption() deleteRow(pos)：删除指定位置的行 insertRow(pos)：向rows集合中指定位置插入一行 &lt;tbody&gt;元素的属性和方法如下： rows：保存&lt;tbody&gt;元素中行的HTMLCollection deleteRow(pos)：删除指定位置的行 insertRow(pos)：向rows集合中的指定位置插入一行，返回对新插入行的引用 &lt;tr&gt;元素添加的属性和方法如下： cells：保存&lt;tr&gt;元素中单元格的HTMLCollection deleteCell(pos)：删除指定位置的单元格 insertCell(pos)：向cells集合中指定位置插入一个单元格，返回对新插入单元格的引用 1234567891011121314151617181920var table = document.createElement("table");table.border = 1;table.width = "100%";var tbody = document.createElement("tbody");table.appendChild(tbody);tbody.insertRow(0);tbody.rows[0].insertCell(0);tbody.rows[0].cells[0].appendChild(document.createTextNode("Cell 1,1"));tbody.rows[0].insertCell(1);tbody.rows[0].cells[1].appendChild(document.createTextNode("Cell 2,1"));tbody.insertRow(1);tbody.rows[1].insertCell(0);tbody.rows[1].cells[0].appendChild(document.createTextNode("Cell 1,2"));tbody.rows[1].insertCell(1);tbody.rows[1].cells[1].appendChild(document.createTextNode("Cell 2,2"));document.body.appendChild(table);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSCript05-函数表达式]]></title>
    <url>%2F2018%2F10%2F26%2FJavaScript05-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[JavaScript函数表达式递归递归更好的建议是使用arguments.callee，这是一个指向正在执行的函数的指针 12345678function factorial(num) &#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num-1); &#125;&#125; 通过arguments.callee代替函数名，可以确保无论怎么样调用函数都不会出问题。 闭包闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包常见方法，就是在一个函数内部创建另一个函数 1234567891011121314function createComparisonFunction(propertyName) &#123; return function(object1, object2) &#123; var value1 = object1[propertyName]; var value2 = object2[propertyName]; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125; &#125;&#125; 注意到在内部函数访问了外部函数中的变量propertyName，即使这个内部函数被返回了，而且在其他地方被调用了，它仍然可以访问变量propertyName。 在另一个函数内部定义的函数会将包含函数的活动对象添加到它的作用域链中，这样，匿名函数就可以访问其包含函数中定义的所有变量。即使包含函数被执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象。换句话说，包含函数返回后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中，直到匿名函数被销毁。 闭包与变量上述作用域链的机制引出了一个副作用，就是闭包只能取得包含函数中任何变量的最后一个值，闭包所保存的是整个变量对象，而不是某个特殊的变量。 12345678910function createFunctions() &#123; var result = new Array(); for(var i = 0; i &lt; 10; i++) &#123; result[i] = function() &#123; return i; &#125;; &#125; return result;&#125; 这里的结果是每个函数都返回10，因为每个匿名函数都引用了外部变量i，而i最后的值为10. 可以作如下调整 123456789101112function createFunctions() &#123; var result = new Array(); for(var i = 0; i &lt; 10; i++) &#123; result[i] = function(num) &#123; return function() &#123; return num; &#125;; &#125;(i); &#125; return result;&#125; 关于this对象闭包中使用this，需要注意匿名函数的执行环境具有全局性，因此其this对象通常指向window。 12345678910111213var name = "Thie Window";var object = &#123; name : "My Object", getNameFunc : function() &#123; return function() &#123; return this.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); // "The Window" 可以作如下修改 1234567891011121314var name = "Thie Window";var object = &#123; name : "My Object", getNameFunc : function() &#123; var that = this; return function() &#123; return that.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); // "My Object" 模仿块级作用域在JavaScript中没有块级作用域的概念。这意味着在块语句中定义的变量，实际上是在包含语句中而非语句中创建的。 123456function outputNumbers(count) &#123; for(var i = 0; i &lt; count; i++) &#123; alert(i); &#125; alert(i);&#125; 在这里，JS仍然可以访问i，而不同于Java，C++。 可以用匿名函数来模仿块级作用域，语法如下(function(){ //code here })();以上代码定义并立即调用了一个匿名函数 私有变量JavaScript中没有私有成员的概念，所有对象属性都是公有的。不过有一个私有变量的概念，任何在函数中定义的变量，都可以认为是私有变量。如果在函数内部创建一个闭包，那么闭包通过自己的作用域链可以访问这些变量，利用这一点就可以创建用于访问私有变量的公有方法，这种方法成为特权方法。 123456789101112131415function Person(name) &#123; this.getName = function() &#123; return name; &#125;; this.setName = function(value) &#123; name = value; &#125;;&#125;var person = new Person("Nicholas");alert(person.getName());person.setName("Greg");alert(person.getName()); 静态私有变量123456789101112131415161718192021(function() &#123; // 私有变量和私有函数 var name = ""; // 构造函数 Person = function(value) &#123; name = value; &#125; Person.prototype.getName = function() &#123; return name; &#125;; Person.prototype.setName = function(value) &#123; name = value; &#125;;&#125;)();var person1 = new Person("Nicholas");// 测试代码 注意name是静态变量，是所有实例共享的。 模块模式模块模式用于只有一个实例的对象，JS用对象字面量方式创建单例对象，如下 1234567891011121314151617181920var application = function() &#123; //私有 var components = new Array(); //初始化 components.push(new BaseComponent()); //公有 return &#123; getComponentCount : function() &#123; return components.length; &#125;; registerComponent : function(component) &#123; if (typeof component == "object") &#123; components.push(component); &#125; &#125; &#125;&#125; 增强的模块模式增强模块模式适合单例必须是某种类型的实例，同时还必须添加某些属性和方法对其加以增强的情况 12345678910111213141516171819202122var application = function() &#123; //私有 var components = new Array(); //初始化 components.push(new BaseComponent()); //创建application的一个局部副本 var app = new BaseComponent(); //公有 app.getComponentCount : function() &#123; return components.length; &#125;; app.registerComponent : function(component) &#123; if (typeof component == "object") &#123; components.push(component); &#125; &#125;; return app;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>JS函数表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSCript06-BOM]]></title>
    <url>%2F2018%2F10%2F26%2FJavaScript06-BOM%2F</url>
    <content type="text"><![CDATA[JavaScript06-BOMBOM是浏览器对象模型，它提供了很多用于访问浏览器的功能。 window对象window对象表示浏览器的一个实例，它既是通过JavaScript访问浏览器的一个接口，又是ECMAScript规定的Global对象。这意味着在网页中定义的任何一个对象，变量和函数，都以window作为其Global对象，因此有权访问parseInt等方法。 全局作用域所有在全局作用域中声明的变量，函数都会变成window对象的属性和方法，但注意，定义全局变量与在window对象直接定义还是有一点差别：全局变量不能通过delete操作符删除，而直接在window对象上定义的属性可以 123456var age = 29;window.color = "red";delete window.age; // return falsedelete window.color; // return true 可以通过window对象查询变量是否存在 123var newValue = oldValue; // error,oldValue not definedvar newValue = window.oldValue; // OK,newValue is undefined 窗口位置IE，Safari，Opera，Chrome提供了screenLeft，screenTop属性表示窗口相对于屏幕左边和上边的位置。Firefox提供了screenX和screenY属性。 123// 获取窗口左边和上边的位置var leftPos = (typeof window.screenLeft == "number")?window.screenLeft:window.screenX;var topPos = (typeof winodw.screenTop == "number")?window.screenTop:window.screenY; 可以使用moveTo()和moveBy()将窗口精确移动到某个位置moveTo()接收的是新位置的x和y坐标，而moveBy()接收的是在水平和锤石方向上移动的像素数 12345// 将窗口移动到屏幕左上角window.moveTo(0,0);// 将窗口向左移动50像素window.moveBy(-50,0); 需要注意这两个方法可能会被浏览器禁用 窗口大小IE9+,Firefox,Safari,Opera和Chrome提供4个属性：innerWidth,innerHeight,outerWidth,outerHeight。在Chrome中，outer和inner返回的是相同的值，都是viewport大小而非浏览器窗口大小。在Firefox中，outer返回的是浏览器窗口本身的尺寸，inner返回的是该容器中页面视图区的大小（减去边框宽度）。 下面方法可以获得viewport大小 123456789101112var pageWidth = window.innerWidth, pageHeight = window.innerHeight;if(typeof pageWidth != "number") &#123; if(document.compatMode == "CSS1Compat") &#123; pageWidth = document.documentElement.clientWidth; pageHeight = document.documentElement.clientHeight; &#125; else &#123; pageWidth = document.body.clientWidth; pageHeight = document.body.clientHeight; &#125;&#125; 可以使用resizeTo()和resizeBy()方法来调整浏览器窗口大小。 12345// 调整到100*100window.resizeTo(100,100); // 调整到200*150window.resizeBy(100,50); 同样的，部分浏览器可能禁用这两个方法 导航和打开窗口使用window.open()方法既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口。这个方法接收4个参数：要加载的URL，窗口目标，一个特性字符串以及一个表示新页面是否取代浏览器历史纪录中当前加载页面的布尔值。如果传递第二个参数，而且该参数是已有窗口或框架的名称，那么就会在具有该名称的窗口或框架中加载第一个参数指定的URL。看下面例子 12// 等同于&lt;a href="http://www.wrox.com" target="topFrame"&gt;&lt;/a&gt;window.open("http://www.wrox.com", "topFrame"); 如果有topFrame的窗口，就会在该窗口加载URL，否则创建一个新窗口并命名为topFrame,第二个参数也可以是下列特殊名称:_self,_parent,_top或_blank。 弹出窗口若第二个参数并不是一个已经存在的窗口或框架，那么该方法就会根据在第三个参数位置上传入的参数创建一个新窗口或新标签页。第三个参数是一个逗号分隔的设置字符串，表示在新窗口中都显示哪些特性。 设置 值 说明 height num 窗口高度，不能小于100 left num 窗口左坐标，不能小于0 location yes or no 显示地址栏，不同浏览器默认值不同 menubar yes or no 默认no，显示菜单栏 resizable yes or no 是否可以通过拖动浏览器窗口边框改变其大小 scrollbars yes or no 内容在视口显示不下，是否运训滚动，默认no status yes or no 状态栏，默认no toolbar yes or no 工具栏，默认no top num 上坐标 width num 新窗口宽度 window.open(&quot;http://www.wrox.com/&quot;,&quot;wroxWindow&quot;,&quot;height=400,width=400,top=10,resizable=yes&quot;); 通过window.open()新创建的窗口可以使用resizeTo或moveTo等方法，并且其有一个属性opener保存着打开它的原始窗口对象chrome会在独立进程中运行每个标签页，当一个标签页打开另一个标签页时，如果两个window对象之间需要彼此通信，那么新标签页就不能运行在独立的进程中。在chrome中，把新创建的标签页的opener属性设置为null，即表示在单独的进程中运行新标签页，即告诉浏览器新创建的标签页不需要与打开它的标签页通信，因此可以在独立进程中运行。 弹出窗口屏蔽程序大多数浏览器都内置弹出窗口屏蔽程序，如下所示可以检测是否被屏蔽 1234567891011121314var blocked = false;try &#123; var wroxWin = window.open("http://www.wrox.com", "_blank"); if(wroxWin == null) &#123; blocked = true; &#125;&#125; catch (ex）&#123; blocked = true;&#125;if (blocked) &#123; alert("The popup was blocked!");&#125; 间歇调用和超时调用JS是单线程语言，但它允许通过设置超时值和间歇时间来调度代码在特定时刻执行。 超时调用超时调用需要使用window对象的setTimeout()方法，它接收两个参数，要运行的代码和毫秒表示的时间（执行代码之前需要等待的毫秒数），第一个参数可以是包含JS代码的字符串，也可以是一个函数（更推荐用函数） 123setTimeout(function() &#123; alert("Hello World!");&#125;, 1000); 注意上述代码经过1000ms不一定会执行，因为JS是一个单线程的解释器。调用setTimeout后，该方法会返回一个数值ID，表示超时调用。可以通过这个ID取消超时调用，如下 12345var itmeoutId = setTimeout(function() &#123; alert("Hello World!");&#125;, 1000);clearTimeout(timeoutId); 间歇调用按照指定的时间间隔重复执行代码，调用的方法是setInterval()，调用方法与上面setTimeout差不多，只不过第二个参数为每次执行之前要等待的毫秒数，同样可以通过clearInterval()方法传入间歇调用ID取消间歇调用尽量不要使用间歇调用，因为后一个间歇调用可能在前一个间歇调用停止之前启动下面是一个用超时调用实现间歇调用的例子，不会出现上述问题 123456789101112var num = 0;var max = 10;function incrementNumber() &#123; if (num &lt; max) &#123; setTimeout(incrementNumber, 500); &#125; else &#123; alert("Done"); &#125;&#125;setTimeout(incrementNumber, 500); 系统对话框浏览器通过alert(),confirm()和prompt()方法可以调用系统对话框，注意系统对话框都是同步和拟态的，即显示这些对话框的时候代码回停止执行，直到关掉对话框 alert()alert()显示的对话框包括文本和一个OK按钮 confirm()confirm()除了文本和OK按钮，还有一个取消按钮，可以通过检查confirm()方法返回的布尔值来确定用户点了哪个按钮 prompt()prompt()方法除了显示OK和Cancel按钮，还会显示一个文本输入框，接收两个参数，要显示给用户的文本提示和和文本输入域的默认值（可以为空字符串）。如果点击OK，该方法返回输入域的值，点击Cancel或其他，该方法返回null location对象location提供了与当前窗口加载的文档有关的信息，它既是window对象的属性，也是document对象的属性，location对象有如下属性 属性名 例子 说明 hash “#contents” 返回URL中的hash（#号后跟0个或多个字符） host “www.wrox.com:80&quot; 返回服务器名称和端口号 hostname “www.wrox.com&quot; 返回不带端口号的服务器名称 href “http:/www.wrox.com&quot; 完整URL，与location.toString()方法返回值一样 pathname “/WileyCDA/“ URL中目录和文件名 port “8080” 端口号 protocol “http:” 页面协议 search “?q=javascript” URL的查询字符串，以问号开头 查询字符串参数一个查询字符串参数的例子，注意字符串参数是被编码过的，需要通过decodeURIComponent解码 1234567891011121314151617181920function getQueryStringArgs() &#123; var qs = (location.search.length &gt; 0 ? location.search.substring(1) : "" ), args = &#123;&#125;, items = qs.length ? qs.split("&amp;") : [], item = null, name = null, value = null, i = 0, length = items.length; for (i = 0; i &lt; len; i++) &#123; item = items[i].split("="); name = decodeURIComponent(item[0]); value = decodeURIComponent(item[1]); if (name.length) &#123; args[name] = value; &#125; &#125; &#125; 位置操作可以通过修改上面的属性（直接赋值）来改变当前加载的页面，也可以通过location.assign(&quot;http://www.wrox.com&quot;)来改变，这样的改变会在浏览器的历史记录中生成一条新纪录，用户通过后退按钮都会导航到前一个页面，如果不想在历史记录中生成新纪录，则可以通过调用location.replace(&quot;http://www.wrox.com/&quot;)reload()方法会重新加载当前页面，如果不传递参数，页面会以最有效的方式重新加载，有可能是从缓存中加载，如果强制从服务器加载，则传入参数true即可 navigator对象navigator对象主要用来检测客户端浏览器，其主要属性和方法可以参考w3c的navigator对象 检测插件对于非IE浏览器，可以使用plugins数组来达到检测插件的目的，该数组每一项都有下列属性 name:插件的名字 description:插件的描述 filename:插件的文件名 length:插件所处理的MIME类型数量 123456789101112function hasPlugin(name) &#123; name = name.toLowerCase(); for (var i = 0; i &lt; navigator.length; i++) &#123; if (navigator.plugins[i].name.toLowerCase().indexOf(name) &gt; -1) &#123; return true; &#125; &#125;&#125;alert(hasPlugin("Flash"));alert(hasPlugin("QucikTime")); history对象history对象保存用户的上网记录，无法得知具体的URL，但是可以通过go()方法来实现用户历史记录的任意跳转，这个方法接收一个参数，表示向后或向前的页面书的一个整数，也可以传入字符串参数，浏览器会跳转到历史纪录中包含该字符串的第一个位置，可能前进也可能后退。 12345history.go(-1); // 后退一页history.go(1); // 前进一页history("wrox.com"); 另外还可以用history.back()和history.forward()方法前进或后退此外还有一个length属性表示历史纪录数量。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>BOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet06-JSTL-强大的定制标记]]></title>
    <url>%2F2018%2F10%2F09%2FServlet06-JSTL%2F</url>
    <content type="text"><![CDATA[Servlet06-JSTL-强大的定制标记有时只是EL或标准动作还不够，需要用到JSTL，使用JSTL之前，要把jstl.jar与standard.jar放在WEB应用的lib目录里 &lt;c:out&gt;显示表达式&lt;c:out&gt;作用与脚本的&lt;%=%&gt;作用相似，但是&lt;c:out&gt;可以直接通过”.”操作符来访问属性。 语法格式如下&lt;c:out value=&quot;&lt;string&gt;&quot; default=&quot;&lt;string&gt;&quot; escapeXml=&quot;&lt;true|false&gt;&quot;/&gt; 属性 描述 value 要输出的内容，必要，可以设置为${class:function}输出函数的结果 default 输出的默认值，非必要 escapeXml 设置是否忽略XML特殊字符，默认为true，设置为false则输出HTML内容 &lt;c:forEach&gt;实现循环可以在JSP中使用&lt;c:forEach&gt;实现循环，例子如下 e.g. 1234567&lt;table&gt; &lt;c:forEach var="movie" items="$&#123;movieList&#125;" &gt; &lt;tr&gt; &lt;td&gt;$&#123;movie&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/table&gt; 对应脚本如下 12345String[] items = (String[]) request.getAttribute("movieList");for (int i = 0; i &lt; items.length; i++) &#123; String movie = items[i]; out.println(movie);&#125; &lt;c:forEach&gt;属性如下 属性 描述 items 要被循环的信息 begin 开始的元素，0为索引起点 end 最后一个元素 step 迭代的步长 var 代表当前条目的变量名称 varStatus 代表循环状态的变量名称 varStatus建立一个新变量，保存javax.servlet.jsp.jstl.core.LoopTagStatus的一个实例，可以通过在&lt;c:forEach ... varStatus=&quot;movieLoopCount&quot;&gt;内嵌中添加${movieLoopCount.count}得到一个循环计数器，每迭代一次就自增1并输出 嵌套&lt;c:forEach&gt;12345&lt;c:forEach var="listElement" ...&gt; &lt;c:forEach ... items="$&#123;listElement&#125;"&gt; ... &lt;/c:forEach&gt;&lt;/c:forEach&gt; &lt;c:if&gt;实现判断语法格式 123&lt;c:if test="&lt;boolean&gt;" var="&lt;string&gt;" scope="&lt;string&gt;"&gt; ...&lt;/c:if&gt; 属性 描述 test 条件，必要 var 用于存储条件结果的变量，不必要 scope var属性的作用域 e.g. 123&lt;c:if test="$&#123;userType eq 'member'&#125;" &gt; &lt;jsp:include page="xxx.jsp" /&gt;&lt;/c:if&gt; &lt;c:choose&gt;实现if-else效果&lt;c:choose&gt;是&lt;c:when&gt;与&lt;c:otherwise&gt;的父标签，通过这三个标签可以实现if-else或者switch效果 语法格式 12345678910111213&lt;c:choose&gt; &lt;c:when test="&lt;boolean&gt;"&gt; ... &lt;/c:when&gt; &lt;c:when test="&lt;boolean&gt;"&gt; ... &lt;/c:when&gt; ... ... &lt;c:otherwise&gt; ... &lt;/c:otherwise&gt;&lt;/c:choose&gt; &lt;c:set&gt;设置变量和对象属性语法格式 123456&lt;c:set var="&lt;string&gt;" value="&lt;string&gt;" target="&lt;string&gt;" property="&lt;string&gt;" scope="&lt;string&gt;"/&gt; 属性 描述 value 要存储的值 target 要修改的属性所属的对象 property 要修改的属性 var 存储信息的变量 scope var属性的作用域 使用&lt;c:set&gt;设置属性变量var1.没有体&lt;c:set var=&quot;userLevel&quot; scope=&quot;session&quot; value=&quot;Cowboy&quot; /&gt; 2.有体&lt;c:set var=&quot;userLevel&quot; scope=&quot;session&quot; &gt;Sheriff, Bartender, Cowgirl&lt;/c:set&gt; 有体的情况下，会计算体并作为变量的值，如果值计算为null，变量会被删除 对bean和Map使用&lt;c:set&gt;这一类&lt;c:set&gt;只能用来设置bean属性和Map值，不能用它来向列表或数组增加元素 1.没有体&lt;c:set target=&quot;${PetMap}&quot; property=&quot;dogName&quot; value=&quot;Clover&quot;&gt; 如果target是一个bean，则property为属性，如果target是一个Map，则property为键。 2.有体&lt;c:set target=&quot;${person}&quot; property=&quot;name&quot; &gt;${foo.name}&lt;/c:set&gt; 体可以是一个String或表达式 &lt;c:set&gt;要点和技巧 &lt;c:set&gt;不能同时有var和target属性 scope是可选的，默认为page作用域 如果value为null，var指定的属性将被删除 target必须放入一个能解析为实际对象的表达式，不能为String &lt;c:remove&gt;删除元素语法格式&lt;c:remove var=&quot;&lt;string&gt;&quot; scope=&quot;&lt;string&gt;&quot; var为要删除的变量名，scope为变量的作用域var属性必须是一个String直接量，不能是表达式 1&lt;c:remove var="userState" scoper="request" /&gt; &lt;c:import&gt;包含内容语法格式 1234567&lt;c:import url="&lt;string&gt;" var="&lt;string&gt;" scope="&lt;string&gt;" varReader="&lt;string&gt;" context="&lt;string&gt;" charEncoding="&lt;string&gt;"/&gt; 属性 描述 url 待导入资源的URL，可以是相对路径或绝对路径 context 当使用相对路径访问外部context时，context指定了这个资源的名字 charEncoding 所引入的数据的字符编码集 var 用于存储所引入的文本的变量 scope var属性的作用域 varReader 可选的用于提供java.io.Reader对象的变量 三种包含内容方法的区别1.include指令&nbsp;&nbsp;&nbsp;&nbsp;&lt;%@ include file=&quot;Header.html&quot; %&gt;&nbsp;&nbsp;&nbsp;&nbsp;静态导入，在转换时将file指定的文件内容加入到当前页面 2.&lt;jsp:include&gt;标准动作&nbsp;&nbsp;&nbsp;&nbsp;动态，在请求时将page属性指定的内容添加到当前页面 3.&lt;c:import&gt;JSTL标记&nbsp;&nbsp;&nbsp;&nbsp;动态，与标准动作相似但更强大更灵活。 引用WEB应用之外的内容&lt;c:import&gt;可以加载WEB应用之外的内容，只需指定url即可，如下 123456&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;&lt;html&gt;&lt;body&gt; &lt;c:import url="http://www.wickedlysmart.com/skyler/horse.html" /&gt;&lt;/body&gt;&lt;/html&gt; 注意！导入的horse.html应该是一个HTML片段，而不是一个有开始和结束标记的完整页面！ &lt;c:param&gt;定制包含的内容语法格式 &lt;c:param name=&quot;&lt;string&gt;&quot; value=&quot;&lt;string&gt;&quot;/&gt; name：URL中要设置的参数的名称 value：参数的值 使用&lt;c:param&gt;实现子标题上一节中我们使用&lt;jsp:param&gt;实现了页眉的子标题，&lt;c:param&gt;也能实现同样的效果 使用&lt;jsp:import&gt;的JSP 1234567&lt;html&gt;&lt;body&gt; &lt;c:import url="Header.jsp" &gt; &lt;c:param name="subTitle" value="this is a subtitle name"/&gt; &lt;/c:import&gt;&lt;/body&gt;&lt;/html&gt; 所包含的文件Header.jsp 12&lt;!-- some html --&gt;&lt;p&gt;$&#123;param.subTitle&#125;&lt;/p&gt; &lt;c:url&gt;满足所有超链接需求语法格式 12345&lt;c:url var="&lt;string&gt;" scope="&lt;string&gt;" value="&lt;string&gt;" context="&lt;string&gt;"/&gt; value是基本url，context是本地网络应用名，var是代表URL的变量名，scope是var的作用域。 对URL编码，可以把用户的jsessionid追加到特定的 URL最后，具体编码方法如下 在servlet中 123public void doGet(...) &#123; out.println(response.encodeURL("/BeerTest.do"));&#125; 在JSP中 1&lt;a href="&lt;c:url value='/xxx.jsp' /&gt;"&gt;click here&lt;/a&gt; GET请求需要在URL中传入参数，而参数有时有空格的时候需要对URL编码 e.g. 1234&lt;c:set var="last" value="Hidden Cursor" /&gt;&lt;c:set var="first" value="Crouching Pixels" /&gt;&lt;c:url value="/inputComments.jsp?first=$&#123;first&#125;&amp;last=$&#123;last&#125;" var="inputURL" /&gt; 在&lt;c:url&gt;中使用&lt;c:param&gt;可以解决编码的问题 1234567&lt;c:set var="last" value="Hidden Cursor" /&gt;&lt;c:set var="first" value="Crouching Pixels" /&gt;&lt;c:url value="/inputComments.jsp" var="inputURL" &gt; &lt;c:param name="firstName" value="$&#123;first&#125;" /&gt; &lt;c:param name="lastName" value="$&#123;last&#125;" /&gt;&lt;/c:url&gt; 使用参数编码后，URL如下所示/inputComments.jsp?firstName=Crouching+Pixels&amp;lastName=Hidden+Cursor 建立自己的错误页面指定错误页面errorPage.jsp 1234567&lt;%@ page isErrorPage="true" %&gt;&lt;html&gt;&lt;body&gt; ...&lt;/body&gt;&lt;/html&gt; 抛出异常坏页面的普通页面 1&lt;%@ page errorPage="errorPage.jsp" %&gt; 使用&lt;error-page&gt;DD标记可以在DD中为整个WEB应用声明错误页面，甚至可以为不同异常或HTTP错误码类型（404,500等）配置不同的错误页面。如下： 声明一个普遍型错误页面，在DD中 1234&lt;error-page&gt; &lt;exception-type&gt;java.lang.Throwable&lt;/exception-type&gt; &lt;location&gt;/errorPage.jsp&lt;/location&gt;&lt;/error-page&gt; 为更明确的异常声明一个错误页面 1234&lt;error-page&gt; &lt;exception-type&gt;java.lang.ArithmeticExcption&lt;/exception-type&gt; &lt;location&gt;/arithmeticError.jsp&lt;/location&gt;&lt;/error-page&gt; 根据一个HTTP状态码声明错误页面 1234&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/notFoundError.jsp&lt;/location&gt;&lt;/error-page&gt; exception对象错误页面提供一个exception对象，可以使用隐式对象exception也可以使用${pageContext.exception}得到，这个对象的类型是java.lang.Throwable注意，该隐式对象仅对有声明isErrorPage=&quot;true&quot;的页面可用 &lt;c:catch&gt;实现try/catch&lt;c:catch&gt;&lt;/c:catch&gt;体内元素相当于JAVA的try/catch，可以使用属性var保存该异常放在页面作用域，并按var值命名 1234567&lt;c:catch var="myException"&gt; &lt;% int x = 10/0; %&gt;&lt;/c:catch&gt;&lt;c:if test="$&#123;myException != null&#125;"&gt; exception is $&#123;myException.message&#125;&lt;/c:if&gt; 理解TLDTLD配置文件TLD描述了两个主要内容：定制标记和EL函数，上一章曾经用过只有一个&lt;function&gt;元素的TLD，这节还要用到&lt;tag&gt;元素，如下 123456789101112131415161718&lt;tlib-version&gt;1.2&lt;/tlib-version&gt;&lt;short-name&gt;RandomTags&lt;/short-name&gt;&lt;uri&gt;randomThings&lt;/uri&gt;&lt;tag&gt; &lt;description&gt;random advice&lt;/description&gt; &lt;name&gt;advice&lt;/name&gt; &lt;tag-class&gt;foo.AdvisorTagHandler&lt;/tag-class&gt; &lt;body-content&gt;empty&lt;/body-content&gt; &lt;attribute&gt; &lt;name&gt;user&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt; &lt;/attribute&gt;&lt;/tag&gt; 解释TLDTLD解释如下:&lt;tlib-version&gt;必要，声明标记库版本&lt;short-name&gt;必要，主要由工具使用&lt;uri&gt;taglib指令使用的唯一名&lt;description&gt;不解释&lt;name&gt;必要，标记中使用的就是这个名（冒号右边）&lt;tag-class&gt;必要，在JSP使用这个标记要调用什么&lt;body-content&gt;必要，说明体内不可以有任何内容&lt;attribute&gt;用来设置属性，rtexprvalue指定该属性是否可以是一个表达式，如果设置为false或者没有设置，则不能使用类似&quot;${userName}&quot;这样的表达式 如何使用定制标记使用这个标记的JSP如下 123&lt;%@ taglib prefix="mine" uri="randomThings" %&gt;&lt;mine:advice user="$&#123;userName&#125;" /&gt;&gt; 定制标记处理器1234567891011public class AdvisorTagHandler extends SimpleTagSupport &#123; public void doTag() throws JspException, IOException &#123; ... &#125; // 这里的XXX对应的是标记的属性 public void setXXX(String xxx) &#123; ...; &#125;&#125; 容器对TLD的查找容器会在4个地方查找TLD WEB-INF WEB-INF的子目录 WEB-INF/lib下一个JAR文件的META-INF WEB-INF/lib下一个JAR文件的META-INF目录的子目录]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>JSP</tag>
        <tag>JSTL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript03-引用类型]]></title>
    <url>%2F2018%2F09%2F03%2FJavaScript03-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[JavaScript03-引用类型Object类型引用类型的值是引用类型的一个实例，注意引用类型虽然常被称为类，但它与传统面向对象语言的类不一样，ECMAScript没有类和接口等基本结构，ECMAScript的引用类型有时候也称为对象定义，因为它们描述的是一类对象所具有的属性和方法。 两种构造Object实例的方法构造函数123var person = new Object();person.name = "Nicholas";person.age = 29; 对面字面量表示法1234var person = &#123; name : "Nicholas", age : 29&#125;; 访问对象属性1234alert(person.name); // "Nicholas"alert(person["name"]); // "Nicholas"var propertyName = "name";alert(person[propertyName]); // "Nicholas" Array类型与其他语言不一样的是，ECMAScript数组的每一项可以保存任何类型的数据，而且ECMAScript的大小是可以动态调整的。 创建Array的基本方式Array构造函数1234var colors1 = new Array();var colors2 = new Array(20); // 指定Array的长度为20，注意，这里并不是让colors2的第一个元素是20，而是指定其长度20var colors3 = new Array("red", "blue", "green"); 字面量表示法12var colors = ["red", "blue", "green"];var names = []; Arrays.length由于ECMAScript的数组是可以动态调整的，因此其属性length不是只读的，可以为其赋值达到调整数组长度的效果，也可以12var colors = [ some colors ];colors[colors.length] = "other-color"; 为Array添加新元素 一些Array的属性检测数组Array.isArray(value)判断Array是否为数组 转换方法toLocaleString() 返回逗号分割开的字符串，但是调用的是toLocaleString()方法toString() 返回用逗号分割开的数组的每个元素valueOf() 返回数组本身join(param) 用param分割开数组的每个元素 栈方法push(param1,param2,...,paramn)可以接收任意数量参数，按顺序逐个入栈，并返回修改后数组的长度pop()出栈并返回 队列方法shift()删除第一个元素并返回push()同上栈方法的push()unshift(param)数组前端添加任意个项并返回数组的长度 重排序方法reverse()sort()默认的sort()会调用toString()然后比较其字符串的大小来排序，在很多情况下这样排序都不是最佳方案，如下123var values = [0, 1, 5, 10, 15];values.sort();alert(values); // 0,1,10,15,5 可以通过重排序方法接收一个比较函数作为参数来排序比较函数接收两个参数，如果第一个参数应位于第二个参数之前则返回一个负数，相等返回0,否则返回正数，以下为一个简单的比较函数123456789101112function compare(value1, value2) &#123; if(value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125;&#125;var values = [0, 1, 5, 10, 15];values.sort(compare);alert(values); // 0,1,5,10,15 对于数值类型或者valueOf()方法会返回数值的类型，只要123function compare(value1, value2) &#123; return value2-value1;&#125; 操作方法cancat()会创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组，如果没有参数，则只是复制当前数组并返回副本slice()切片，接收1个或2个参数，即要返回项的起始和结束位置。 splice()： 删除：接收2个参数，删除的第一项的位置和要删除的项数 插入：三个参数，起始位置，0（要删除的项数），要插入的项，如果要插入多项，可以传递3个以上的参数 替换：三个参数，起始位置，要删除的项，要插入的任意数量的项 它始终返回一个数组，包含从原始数组中删除的项。 位置方法indexOf()lastIndexOf()接收2个参数，要查找的项和表示查找起点位置的索引，indexOf()从起点开始往后查找，lastIndexOf()从起点开始往前查找，返回要查找的项在数组中的位置，没找到则返回-1注意位置方法必须严格相等12345var person = &#123; name : "Nicholas" &#125;;var errPeople = [&#123; name : "Nicholas" &#125;];var corPeoole = [person];alert(errPeople.indexOf(person)); // -1alert(corPeople.indexOf(person)); // 0 迭代方法ECMAScript的迭代方法接收2个参数，要在每一项上运行的函数和（可选）运行该函数的作用域对象，传入的函数接收三个参数，数组项的值，该项在数组的位置和数组对象本身。every()对数组的每一项运行给定函数，如果该函数对每一项都返回true，则返回truefilter()对数组的每一项运行给定函数，返回该函数会返回true的项组成的数组forEach()对数组每一项运行给定函数，这个方法没有返回值map()对数组每一项运行给定函数，返回每次函数调用的结果组成的数组some()对数组每一项运行给定函数，如果该函数对任一项返回true，则返回true123456789var numbers = [1,2,3,4,5,4,3,2,1];var everyResult = numbers.every(function(item,index,array)&#123;return (item&gt;2)&#125;);alert(everyResule); // falsevar mapResult = numbers.map(function(item, index, array)&#123;return item * 2;&#125;);alert(mapResult); // [2,4,6,8,10,8,6,4,2]numbers.forEach(function(item, index, array)&#123; /* do something on item */ &#125;); 归并方法reduce()reduceRight()迭代数组的所有项，然后构建一个最终返回的值，reduce()从第一项开始迭代，reduceRight()从最后一项开始，接收两个参数，一个在每一项上调用的函数和（可选）作为归并基础的初始值，传入的函数接收4个参数，前一个值，当前值，项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项1234// e.g. 求和var values = [1,2,3,4,5];var sum = values.reduce(function(prev, cur, index, array)&#123;return prev + cur;&#125;);alert(sum); // 15 Date类型ECMAScript的Date类型类似于java.util.Date类，使用自UTC 1970年1月1日午夜开始经过的毫秒数来保存日期创建一个日期对象可以var now = new Date()可以为构造函数传递毫秒来构建Date对象 Date.parse()接收一个表示日期的字符串参数，转换为毫秒数地区为美国的浏览器接收下列日期格式： “月/日/年”，如6/13/2004; “英文月名 日,年”，如January 12,2004 “英文星期几 英文月名 日 年 时:分:秒 时区”，如 Tue May 25 2004 00:00:00 GMT-0700 ISO 8601扩展格式 YYYY-MM-DDTHH:mm:ss.sssz(如2004-05-25T00:00:00) e.g. 构建2004/5/24的日期对象 var someDate = new Date(Date.parse(&quot;May 25, 2004&quot;));实际上var someDate = new Date(&quot;May 25, 2004&quot;);会自动调用parse Date.UTC()Date.UTC()参数为年份，基于0的月份，月中的日，小时，分钟，秒以及毫秒，年和月是必须的，其他可选，返回对应的毫秒数 e.g. var y2k = new Date(2000, 0);构建2000年1月1日0时的时间 Date.now()返回调用这个函数的时间的毫秒数 继承的方法toLocaleString()可能时间格式会有AM或PMtoString()带有时区信息的日期和时间valueOf()返回毫秒 日期格式化方法 toDateString()——以特定于实现的格式显示星期几，月，日，年 toTimeString()——以特定于实现的格式显示时，分，秒和时区 toLocaleDateString()——以特定于地区的格式显示 toLocaleTimeString()——同上 toUTCString()——以特定于实现的格式完整的UTC日期 其他日期/时间组件方法w3school列出的Date对象方法 RegExp类型ECMAScript通过RegExp类型来支持正则表达式,由于之前学Python的时候有认真的学过正则，但是一段时间没用就忘得差不多了，所以在没有用到的时候就先不学了，摆个链接在需要的时候再去看w3school RegExp对象 Function类型函数是对象，因此函数名实际上是一个指向函数对象的指针，不会与某个函数绑定由于函数名是指针,所以ECMAScript也没有函数重载的概念 函数声明与函数表达式看下面例子1234alert(sum(10, 10));function sum(num1, num2) &#123; return num1 + num2;&#125; 以上代码完全可以执行,因为在代码开始执行之前,解析器会通过一个名为函数声明提升的过程,读取并将函数声明添加到执行环境中,对代码求值时,JavaScript引擎在第一遍会声明函数并将它们放到源代码树的顶部,所以即使先调用函数再定义也不会出错,而像下面的例子就会报错1234alert(sum(10, 10));var sum = function(num1, num2) &#123; return num1 + num2;&#125; 原因在于函数位于一个初始化语句中,而不是一个函数声明 同样的,由于函数为对象,它可以作为另一个函数的参数或返回值. 函数内部属性arguments及其属性callee函数内部有两个特殊的对象:arguments和this,arguments保存传入函数中的所有参数,arguments还有一个属性名为callee,该属性是一个指针,指向拥有这个arguments对象的函数请看下面例子1234567function factorial(num) &#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * factorial(num-1); &#125;&#125; 上面例子中,如果函数名字不会发生改变,那么这样定义是没有问题的,但如果函数名字改变了,则会发生错误,可以用下面的例子来解决1234567function factorial(num) &#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num-1); &#125;&#125; thisthis与Java的this类似,引用的是函数执行的环境对象(当在网页的全局作用域中调用函数时,this对象引用的就是window)1234567891011window.color = "red";var o = &#123; color: "blue" &#125;;function sayColor() &#123; alert(this.color);&#125;sayColor(); // "red" 引用this对象为windowo.sayColor = sayColor;o.sayColor(); // "blue" caller这个属性保存调用当前函数的函数的引用,若在全局作用域中调用当前函数,则它的值为null123456789function outer() &#123; inner();&#125;function inner() &#123; alert(inner.caller); // 返回outer的源码&#125;outer(); 函数属性和方法lengthlength属性表示函数希望接收的命名参数的个数 prototype保存实例方法,不可枚举 call()与apply()在特定的作用域中调用函数,call()接收第一个参数为运行函数的作用域,后面多个参数为函数的参数,allpy()接收2个参数,第一个为运行函数的作用域,第二个为参数数组或arguments,它们可以用于扩充函数的作用域123456789101112window.color = "red";var o = &#123; color: "blue" &#125;;function sayColor() &#123; alert(this.color);&#125;sayColor(); //redsayColor.call(this); //redsayColor.call(window); //redsayColor.call(o); //blue bind()创建一个函数的实例,并将该实例的this绑定在bind()的参数上123456789window.color = "red";var o = &#123; color: "blue" &#125;;function sayColor() &#123; alert(this.color);&#125;var objectSayColor = sayColor.bind(o);objectSayColor(); //blue 基本包装类型–特殊的引用类型引用类型与基本包装类型最大的区别是对象的生命周期,使用new创建的引用类型的实例,在执行流离开当前作用域之前都一直保存在内存中,而自动创建的基本包装类型的对象,则只存在于一行代码的执行瞬间,然后就会销毁. Boolean建议不适用Boolean对象,而是使用布尔值 Number重写了valueOf(),toLocaleString()和toString(),toString()可以传入参数显示返回几进制数值,除了继承的方法,Number类型还提供了一些用于将数值格式化为字符串的方法num.toFixed(2) // 仅显示小数点后两位,四舍五入num.toExponential(1) // 小数位数为1的指数表示法(e表示法)num.toPrecision() // 返回自适应格式,参数为小数位显示 String字符方法stringValue.charAt(num);stringValue[num];stringValue.charCodeAt(num); // 返回num所在的字符的字符编码 字符串操作方法stringValue.concat(otherString);stringValue.substring();stringValue.slice();stringValue.substr(); // 第一个参数开始位置，第二个为字符串长传入负数后它们的行为不一样，不详述 字符串位置方法stringValue.indexOf()stringValue.lastIndexOf()stringValue.trim() // 删除前置后缀所有空格并返回 字符串大小写转换方法stringValue.toLocaleUpperCase(); // 和下面那个一样，不过一般用这个比较多stringValue.toUpperCase();stringValue.toLocaleLowerCase();stringValue.toLowerCase(); 字符串模式匹配方法stringValue.match()stringValue.search()涉及到正则，偷懒就不写了 localeCompare()比较两个字符串，根据结果返回-1,0,1 单体内置对象由ECMAScript实现提供的，不依赖于寄主环境的对象，在ECMAScript程序执行之前就已经存在了 Global对象偷懒，很多前面都有写，不重复了，书本P131 window对象同上 Math对象提供了数学公式和信息 Math.E 自然对数 Math.LN10 10为底的自然对数 Math.PI π Math.LOG10E 10为底e的对数 Math.SQRT2 2的平方根 等等其他值 舍入方法 Math.ceil() 向上舍入 Math.floor() 向下舍入 Math.round() 四舍五入 random()返回0-1的随机数 其他方法 Math.abs() Math.exp() Math.log() 等等]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>JS引用类型</tag>
        <tag>JS包装类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript02-变量，作用域和内存问题]]></title>
    <url>%2F2018%2F09%2F02%2FJavaScript02-%E5%8F%98%E9%87%8F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[JavaScript02-变量，作用域和内存问题变量JavaScript变量只是在特定时间用于保存特定值的一个名字，不存在定义某个变量就必须保存何种数据类型值的规则，变量的值及其数据类型可以在脚本的生命周期内改变。 基本类型和引用类型的值ECMAScript规定基本类型值指的是简单的数据段，而引用数据值指那些可能由多个值构成的对象，在JavaScript中，Undefined,Null,Boolean,Number,String都是基本数据类型，都是按值访问的。而引用类型的值是保存在内存中的对象，只有Object类型是引用数据类型。 动态的属性123var person = new Object();person.name = "PersonName";alert(person.name); // "PersonName" 以上代码我们创建了一个对象并将其值保存在person中，然后为该对象添加了一个名为name的属性，而对基本数据类型，虽然为其添加属性不会报错，但访问该属性的时候并不能成功访问。 复制变量值对于基本数据类型，12var num1 = 5;var num2 = num1; 两个变量之间不会相互影响。 而对于引用数据类型1234var obj1 = new Object();var obj2 = obj1;obj1.name = "objName";alert(obj2.name); // "objName" obj1和obj2引用的都是同一个对象 传递参数基本类型值的传递就如同基本类型变量的复制一样，而引用类型值的传递，也如同引用类型变量的复制一样。 执行环境及作用域执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为，每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中，解析器在处理数据时会在后台使用它。全局执行环境是最外围的一个执行环境。根据ECMAScript实现所在宿主环境不同，表示环境的对象也不同，在WEB浏览器中，全局执行环境被认为是window对象。每个函数都有自己的执行环境，当执行流进入一个函数的时候，函数的环境会进入环境栈，函数执行完毕后栈将其环境弹出，把控制权交还给之前的执行环境。当代码在一个环境中执行，会创建变量对象的一个作用域链。作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前段始终是当前执行代码所在环境的变量对象，如果这个环境是函数，则将其活动对象作为变量对象，该活动最开始时只有一个变量arguments对象。作用域链的下一对象来自包含的环境，再下一个变量对象来自下一个包含环境，一直到全局执行环境。标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，逐级往后回溯，直至找到标识符为止。其实跟Java的作用域在表现上差不多。 延长作用域链以下两个语句都会在作用域链的前端添加一个变量对象。 try-catch语句的catch块 with语句 没有块级作用域123456789if (true) &#123; var color = "blue";&#125;alert(color); // "blue"for (var i = 0; i &lt; 10; i++) &#123; doSomeThing(i);&#125;alert(i); // 10 在JavaScript中，if和for中创建的变量依旧存在于外部的执行环境中。 垃圾收集JavaScript具有自动垃圾收集机制，执行环境会负责管理代码执行过程中使用的内存。 标记清除垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而再次之后再被加上标记的变量将被视为准备删除的变量。 引用计数跟踪记录每个值被引用的次数，当引用次数变为0的时候，就回收其占用的内存空间，循环引用问题无法解决，很少使用。 管理内存对于全局变量，当确定不再使用的时候，可以为其赋值null，让值脱离执行环境，以便垃圾收集器下次运行时将其回收。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>JS作用域链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSCript04-面向对象的程序设计]]></title>
    <url>%2F2018%2F09%2F01%2FJavaScript04-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[JavaSCript04-面向对象的程序设计理解对象可以通过以下方式初始化一个对象 123456789var person = &#123; name: "Nicholas", age: 29, job: "Software Engineer", sayName: function() &#123; alert(this.name); &#125;&#125; 属性类型数据属性数据属性包含一个数据值的位置，在这个位置可以读取和写入值，数据属性有4个描述其行为的特性 Configurable: 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性改为访问器属性，默认为true Enumerable: 表示能否通过for-in循环返回属性，默认为true Writable: 表示能否修改属性的值，默认为true Value: 包含这个属性的数据值，默认为undefined 可以通过Object.defineProperty()方法修改默认的特性，接收三个参数：属性所在的对象，属性名和一个描述符对象e.g. 12345678var person = &#123;&#125;;Object.defineProperty(person, "name", &#123; writable: false, value: "Nicholas"&#125;);alert(person.name); // "Nicholas"person.name = "Greg";alert(person.name); // "Nicholas" 在调用Object.defineProperty()方法修改同一个属性时，如果不指定，configurable、enumerable、writable特性的默认值都为false 访问器属性访问器属性不包含数据值，它们包含一对getter函数和setter函数，在读取访问器属性时会调用getter函数，这个函数负责返回有效的值，在写入访问器属性时调用setter函数，这个函数负责决定如何处理数据，访问器属性有如下4个特性 Configurable: 同上 Enumerable: 同上 Get: 在读取属性时调用的函数，默认为undefined Set: 在写入属性时调用的函数，默认为undefined 访问器属性不能直接定义，必须使用Object.defineProperty()来定义 e.g. 12345678910111213141516171819var book = &#123; _year: 2004, edition: 1&#125;;Object.defineProperty(book, "year" &#123; get: function() &#123; return this._year; &#125;, set: function(newValue) &#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125;&#125;);book.year = 2005;alert(book.edition); // 2 若没有指定getter，则属性不能读，若没有指定setter，则属性不能写 定义多个属性ECMAScript5定义了一个Object.defineProperties()方法，可以通过描述符一次定义多个属性，这个方法接收2个对象参数，第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应 e.g. 123456789101112131415161718192021222324var book = &#123;&#125;;Object.defineProperties(book, &#123; _year: &#123; writable: true, value: 2004 &#125;, edition: &#123; writable: true, value: 1 &#125;, year: &#123; get: function() &#123; return this._year; &#125;, set: function() &#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125; &#125;&#125;); 可以使用Object.getOwnPropertyDescriptor()来获取对象的特性值 123456789var descriptor = Object.getOwnPropertyDescriptor(book, "_year");alert(descriptor.value); // 2004alert(descriptor.configurable); // falsealert(typeof descriptor.get); // undefinedvar descriptor = Object.getOwnPropertyDescriptor(book, "year");alert(descriptor.value); // undefinedalert(descriptor.enumerable); // falsealert(typeof descriptor.get); // "function" 创建对象工厂模式工厂模式抽象了创建具体对象的过程e.g. 123456789101112function createPerson(name, age, job) &#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function() &#123; alert(this.name); &#125; return o;&#125;var person1 = createPerson("Nicholas", 29, "Software Engineer"); 构造函数模式类似Object，Array都有原生的构造函数，此外还可以创建自定义构造函数，从而定义自定义对象类型的属性和方法e.g. 1234567891011function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; o.sayName = function() &#123; alert(this.name); &#125;&#125;var person1 = new Person("Nicholas", 29, "Software Engineer");var person2 = new Person("Greg", 27, "Doctor"); 构造函数的问题使用构造函数模式的缺点就是每个方法都要在每个实例上重新创建一遍在前面例子中，person1和person2的sayName()方法不是同一个Function的实例。每个Person对象的实例都包含一个不同的Function实例alert(person1.sayName == person2.sayName); // false可以通过把函数定义转移到构造函数外部解决这个问题 1234567891011121314function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; o.sayName = sayName; &#125;&#125;function sayName() &#123; alert(this.name);&#125;var person1 = new Person("Nicholas", 29, "Software Engineer");var person2 = new Person("Greg", 27, "Doctor"); 原型模式我们创建的每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。按字面意思理解，prototype就是通过调用构造函数创建的那个对象实例的原型对象。使用原型对象好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中，如下例子 123456789101112131415function Person() &#123; &#125;Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function() &#123; alert(this.name);&#125;;var person1 = new Person();person1.sayName(); // "Nicholas"var person2 = new Person();alert(person1.sayName == person2.sayName); // true 与构造函数模式不同，新对象的这些属性和方法是由所有实例共享的。 虽然可以通过对象实例访问保存在原型中的值，但不能通过对象实例重写原型中的值，如果我们在实例中添加一个与原型中一个属性同名的属性，那我们就在实例中创建该属性，并屏蔽原型中的那个属性。通过delete可以重新获取来自原型的属性 1234var person1 = new Person();person1.name = "Greg";delete person1.name;alert(person1.name); // "Nicholas" 理解原型对象无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性是一个指向prototype属性所在函数的指针，关系如下图。 更简单的原型语法12345678910function Person() &#123; &#125;Person.prototype = &#123; name : "Nicholas", age : 29, job : "Software Engineer", sayName : function() &#123; alert(this.name); &#125;&#125;; 但是使用对象字面量重写prototype的问题是constructor属性不再指向Person了，可以通过Object.defineProperty()方法解决 1234Object.defineProperty(Person.prototype, "constructor", &#123; enumerable: false, value: Person&#125;); 原型的动态性尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果是重写整个原型对象，那么情况就不一样了。把原型修改为另一个对象就等于切断了构造函数与最初原型之间的联系，看下面例子 1234567891011121314function Person() &#123; &#125;var friend = new Person();Person.prototype = &#123; constructor : Person, age : 29, job : "Software Engineer", sayName : function() &#123; alert(this.name); &#125;&#125;;friend.sayName(); // error!!! 下图揭示了上述代码整个过程的内幕 原型对象的问题原型对象最大的问题就是它共享的本性，对于包含引用类型值的属性来说，问题就比较突出了，见下面例子 1234567891011121314151617181920function Person() &#123; &#125;Person.prototype = &#123; constructor : Person, name : "Nicholas", age : 29, job : "Software Engineer", friends : ["Shelby", "Court"], sayName : function() &#123; alert(this.name); &#125;&#125;;var person1 = new Person();var person2 = new Person();person1.frineds.push("Van");alert(person2.friends); // "Shelby","Court","Van"alert(person1.friends == person2.friends) // true 组合使用构造函数模式和原型模式构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都有自己的一份实例属性，同时又共享着对方法的引用，最大限度节省了内存。 123456789101112131415function Person(name ,age, job) &#123; this.name = name; this.job = hob; this.age = age; this.friends = ["Shelby", "Court"];&#125;Person.prototype = &#123; constructor : Person, sayName : function() &#123; alert(this.name); &#125;&#125;// 测试代码 动态原型模式它把所有信息都封装在构造函数中，而通过在构造函数中初始化原型，又保持了同时使用构造函数和原型的优点。 1234567891011function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; if (typeof this.sayName != "function") &#123; Person.prototype.sayName = function() &#123; alert(this.name); &#125;; &#125;&#125; 判断语句if那里，只在sayName()不存在的情况下才将它添加到原型中。这段代码只会在初次调用构造函数时才会执行，其中，if语句检查的可以是初始化之后应该存在的任何属性和方法，不必用一大堆if语句检查每个属性和方法。 继承ECMAScript只支持实现继承，主要依靠原型链来实现的 原型链原型链的基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。假如我们让原型对象等于另一个类型的实例，此时的原型对象将包含一个指向另一个原型的指针，响应，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。 123456789101112131415161718192021function SuperType() &#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function() &#123; return this.property;&#125;;function SubType() &#123; this.subproperty = false;&#125;// 继承SuperTypeSubType.prototype = new SuperType();SubType.prototype.getSubValue = function() &#123; return this.subproperty;&#125;;var instance = new SubType();alert(instance.getSuperType()); // true 别忘记默认的原型所有引用类型默认都继承了Object，这个继承也是通过原型链实现的，下图为完整的原型链 原型链要注意的事项 子类型有时候要覆盖超类型中的某个方法，或者需要添加超类型中不存在的某个方法，但不管怎么样，给原型添加方法的代码一定要放在替换原型的语句之后 通过原型链实现继承时，不能使用对象字面量创建原型方法，因为这样做会重写原型链 原型链的问题原型链主要的问题仍然是包含引用类型值的原型。通过原型来实现继承时，原型实际上会变成另一个类型的实例，于是，原先的实例属性也就变成现在的原型属性了。 1234567891011121314function SuperType() &#123; this.colors = ["red", "blue", "green"];&#125;function SubType() &#123; &#125;SubType.prototype = new SuperType();var instance1 = new SubType();instance1.colors.push("black");alert(instance1.colors); // "red","blue","green","black"var instance2 = new SubType();alert(instance2.colors); // "red","blue","green","black" 第二个问题是创建子类型的实例时，不能向超类型的构造函数传递参数。鉴于这两个问题，下面介绍的方法更加实用 借用构造函数在子类型的构造函数的内部调用超类型构造函数，如下 1234567function SuperType() &#123; this.colors = ["red", "blue", "green"];&#125;function SubType() &#123; SuperType.call(this);&#125; 传递参数12345678function SuperType(name) &#123; this.name = name;&#125;function SubType() &#123; SuperType.call(this, "Nicholas"); this.age = 29;&#125; 借用构造函数的问题 方法都在构造函数中定义，函数复用无从谈起 超类型的原型中定义的方法，对子类型而言不可见 组合继承（伪经典继承）把原型链和借用构造函数的技术组合到一起，使用原型链对原型属性和方法继承，借用构造函数对实例属性的继承。 123456789101112131415161718192021function SuperType(name) &#123; this.name = name; this.colors = ["red", "blue", "green"];&#125;SuperType.prototype.sayName = function() &#123; alert(this.name);&#125;function SubType(name, age) &#123; // 继承属性 SuperType.call(this.name); this.age = age;&#125;// 继承方法SubType.prototype = new SuperType();SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function()&#123; alert(this.age);&#125;; 寄生组合式继承组合继承的问题就在于无论什么情况下，都会调用两次超类型构造函数，一次是在创建子类型原型的时候，另一次是在子类型构造函数内部，第一次调用的时候，SubType.prototype会得到两个属性：name和colors，当调用SubType构造函数的时候，又会调用一次SuperType构造函数，这一次又在新对象上创建了实例属性name和colors（与SubType原型一样的属性），于是这两个属性就屏蔽了原型中同名的两个属性。 所谓寄生组合式继承，就是通过借用构造函数来继承属性，通过原型链混成形式继承方法，其背后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型的原型的一个副本而已，这样，子类型的原型就不会有重复多余的超类型继承得来的属性了（因为超类型的原型没有这些属性）。 1234567891011121314151617181920212223242526272829303132function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;function inheritPrototype(subType, superType) &#123; var prototype = object(superType.prototype); prototype.constructor = subType; subType.prototype = prototype;&#125;function SuperType(name) &#123; this.name = name; this.colors = ["red", "blue", "green"];&#125;SuperType.prototype.sayName = function() &#123; alert(this.name);&#125;function SubType(name, age) &#123; // 继承属性 SuperType.call(this.name); this.age = age;&#125;inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function() &#123; alert(this.age);&#125; 这种继承方法高效率体现在它只调用了一次SuperType构造函数，因此避免了在SubType.prototype上创建不必要的，多余的属性。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>JS面向对象</tag>
        <tag>JS原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript01-语法]]></title>
    <url>%2F2018%2F09%2F01%2FJavaScript01-%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[JavaScript01-语法在HTML中嵌入JavaScript有两种方法，第一种是内嵌在&lt;head&gt;标签的&lt;script&gt;标签之间123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Example&lt;/title&gt; &lt;script&gt; JavaScript goes here... &lt;/script&gt; &lt;body&gt; Mark-up goes here... &lt;/body&gt;&lt;/html&gt; 另一种更好的方法是存在.js文件中，利用&lt;script&gt;标签的src属性指向该文件12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Example&lt;/title&gt; &lt;script src="file.js"&gt;&lt;/script&gt; &lt;body&gt; Mark-up goes here... &lt;/body&gt;&lt;/html&gt; Script标签元素详解有如下6个属性 async: 可选，表示立即下载脚本，但不应妨碍页面其他操作，只对外部脚本有效。 charset: 可选，基本不用。 defer: 可选，表示脚本可以延迟到文档完全被解析和显示后再执行。只对外部脚本有效。 src: 可选，表示包含要执行代码的外部文件。 type: 可选，使用脚的脚本语言的内容类型，目前用的比较多的还是 text/javascript Script标签的位置最好的做法就是把&lt;script&gt;标签放在HTML文档的最后，&lt;body&gt;标签的前面12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Example&lt;/title&gt; &lt;body&gt; Mark-up goes here... &lt;script src="file.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; JavaScript数据类型JS有6种数据类型，可以通过关键词typeof检测。 Undefined类型 只有一个值undefined。 Null类型 只有一个值null，undefined派生于null，typeof null检测null会返回boject。 Boolean类型 只有true与false。 Number类型 NaN(Not a number)是一个特殊的数值，表示一个本来要返回数值的操作数未返回数值的情况。 String类型 与Python类似，用双引号或者单引号都OK。 Object类型 ECMAScript的对象其实就是一组数据和功能的集合，可以通过new操作符创建，后续会讲到。 JavaScript语句JS很多语句都和Java类似，这里就只列举JS独有的语句 for-in语句1234for(var propName in window) &#123; document.write(propName);&#125;// 枚举BOM中window对象的所有属性，顺序不可预测 for-in语句是一种精准的迭代语句，可以用来枚举对象的属性。 label语句与Java类似，在代码中添加标签以便将来使用，多用于for语句等循环语句1234start: for (var i=0; i &lt; count; i++)&#123; alert(i); &#125;// start标签可以在将来由break或continue语句引用 with语句将代码的作用于设置到一个特定的对象中123var qs = location.search.substring(1);var hostName = location.hostname;var url = location.href; 等价于下面代码12345with(location) &#123; var qs = search.substring(1); var hostName = hostname; var url = href;&#125; JavaScript函数123function functionName(arg0, arg1, arg2, ... ,argN) &#123; statements;&#125; 理解参数ECMAScript函数的参数与大多数其他语言函数的参数不同，ECMAScript函数不介意传递进来多少个参数，也不在乎传进来参数是什么类型的。即使你定义的函数只接受两个参数，在调用这个函数的时候传递多少个也没问题，原因是ECMAScript中参数在内部是用一个数组来表示的，函数接受到的始终都是这个数组，实际上可以在函数体内通过arguments对象来访问这个数组，从而获取传递给函数的每一个参数。 ECMAScript所有参数传递都是值传递，不可能通过引用传递参数，对于引用数据类型，其值就是其引用 没有重载对于同一名字的多个函数，该名字只属于最后定义的]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet04-JSP]]></title>
    <url>%2F2018%2F09%2F01%2FServlet04-JSP%2F</url>
    <content type="text"><![CDATA[Servlet04-JSP基本指令page使用page指令导入包&lt;%@ page import=&quot;foo.*&quot; %&gt;&lt;%@ page import=&quot;foo.*,java.util.*&quot; %&gt; page指令的属性 taglibtaglib定义JSP可用的标记库&lt;%@ taglib tagdir=&quot;/WEB-INF/tags/cool&quot; prefix=&quot;cool&quot; %&gt; includeinclude定义在转换时增加到当前页面的文本和代码&lt;%@ include file=&quot;xxx.html&quot; %&gt;使用此指令允许你建立可重用的块（如标准页面标题或导航栏），这些可重用的块能增加到各个页面上，而不用每个JSP都重复写这些代码 表达式对于&lt;% out.println(Counter.getCount()); %&gt;可以用&lt;%= Counter.getCount() %&gt;代替，不需要分号，表达式内的内容为out.print的参数 声明&lt;%! int count = 0; %&gt;声明该JSP所生成的servlet类的成员 初始化JSP在配置文件中如下配置 12345678910&lt;web-app ...&gt; &lt;servlet&gt; &lt;servlet-name&gt;name&lt;/servlet-name&gt; &lt;jsp-file&gt;/directory/xxx.jsp&lt;/jsp-file&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;name&lt;/servlet-name&gt; &lt;url-pattern&gt;/xxx&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 覆盖jspInit()只要在.jsp文件中实现了jspInit()方法，在JSP页面成为servlet的最开始容器就会调用这个方法，这个方法由servlet的init()方法调用，所以在运行jspInit()方法时，已经有一个ServletConfig和ServletContext可供servlet使用，可以在jspInit()中调用getServletConfig()和getServletContext() 123456&lt;%! public void jspInit() &#123; ServletConfig sConfig = getServletConfig(); // do something &#125;%&gt; 同理jspDestroy()也可以覆盖 JSP的属性除了Servlet拥有的请求，会话和上下文这三个属性，JSP还拥有页面作用域pageContext（隐式对象），常用于开发定制标记 使用PageContext得到属性可以在PageContext引用得到任意作用域的属性 同理使用&lt;% pageContext.setAttribute(&quot;foo&quot;, &quot;attr&quot;, PageContext.SESSION_SCOPE); %&gt;等同于&lt;% session.setAttribute(&quot;foo&quot;, &quot;attr&quot;); %&gt; 使用&lt;%= pageContext.findAttribute(&quot;foo&quot;) %&gt;可以在不知道作用域的情况下查找一个属性 EL预热EL(Expression Language)是无脚本JSP，可以允许开发人员在JSP中不适用Java也能达到同样的效果 为什么使用EL？ 不应该要求WEB页面设计人员必须懂Java JSP中的Java代码很难修改和维护 开启无脚本JSP在配置文件web.xml中 123456789101112&lt;web-app ...&gt; ... &lt;jsp-config&gt; &lt;jsp-property-group&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;scripting-invalid&gt; true &lt;/scripting-invalid&gt; &lt;/jsp-property-group&gt; &lt;/jsp-config&gt; ...&lt;/web-app&gt; 选择忽略EL123456789101112&lt;web-app ...&gt; ... &lt;jsp-config&gt; &lt;jsp-property-group&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;el-ignored&gt; true &lt;/el-ignored&gt; &lt;/jsp-property-group&gt; &lt;/jsp-config&gt; ...&lt;/web-app&gt;]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>JSP</tag>
        <tag>EL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet03-会话状态]]></title>
    <url>%2F2018%2F09%2F01%2FServlet03-%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%2F</url>
    <content type="text"><![CDATA[Servlet03-会话状态前言：这部分涉及到http cookie相关的知识，这里不再赘述 HttpSession一个HttpSession的例子代码摘自runoob，原网站为runoob的Session教程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869@WebServlet("/SessionTrack")public class SessionTrack extends HttpServlet &#123; private static final long serialVersionUID = 1L; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 如果不存在 session 会话，则创建一个 session 对象 HttpSession session = request.getSession(true); // 获取 session 创建时间 Date createTime = new Date(session.getCreationTime()); // 获取该网页的最后一次访问时间 Date lastAccessTime = new Date(session.getLastAccessedTime()); //设置日期输出的格式 SimpleDateFormat df=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String title = "Servlet Session 实例 - 菜鸟教程"; Integer visitCount = new Integer(0); String visitCountKey = new String("visitCount"); String userIDKey = new String("userID"); String userID = new String("Runoob"); // 检查网页上是否有新的访问者 if (session.isNew())&#123; title = "Servlet Session 实例 - 菜鸟教程"; session.setAttribute(userIDKey, userID); &#125; else &#123; visitCount = (Integer)session.getAttribute(visitCountKey); visitCount = visitCount + 1; userID = (String)session.getAttribute(userIDKey); &#125; session.setAttribute(visitCountKey, visitCount); // 设置响应内容类型 response.setContentType("text/html;charset=UTF-8"); PrintWriter out = response.getWriter(); String docType = "&lt;!DOCTYPE html&gt;\n"; out.println(docType + "&lt;html&gt;\n" + "&lt;head&gt;&lt;title&gt;" + title + "&lt;/title&gt;&lt;/head&gt;\n" + "&lt;body bgcolor=\"#f0f0f0\"&gt;\n" + "&lt;h1 align=\"center\"&gt;" + title + "&lt;/h1&gt;\n" + "&lt;h2 align=\"center\"&gt;Session 信息&lt;/h2&gt;\n" + "&lt;table border=\"1\" align=\"center\"&gt;\n" + "&lt;tr bgcolor=\"#949494\"&gt;\n" + " &lt;th&gt;Session 信息&lt;/th&gt;&lt;th&gt;值&lt;/th&gt;&lt;/tr&gt;\n" + "&lt;tr&gt;\n" + " &lt;td&gt;id&lt;/td&gt;\n" + " &lt;td&gt;" + session.getId() + "&lt;/td&gt;&lt;/tr&gt;\n" + "&lt;tr&gt;\n" + " &lt;td&gt;创建时间&lt;/td&gt;\n" + " &lt;td&gt;" + df.format(createTime) + " &lt;/td&gt;&lt;/tr&gt;\n" + "&lt;tr&gt;\n" + " &lt;td&gt;最后访问时间&lt;/td&gt;\n" + " &lt;td&gt;" + df.format(lastAccessTime) + " &lt;/td&gt;&lt;/tr&gt;\n" + "&lt;tr&gt;\n" + " &lt;td&gt;用户 ID&lt;/td&gt;\n" + " &lt;td&gt;" + userID + " &lt;/td&gt;&lt;/tr&gt;\n" + "&lt;tr&gt;\n" + " &lt;td&gt;访问统计：&lt;/td&gt;\n" + " &lt;td&gt;" + visitCount + "&lt;/td&gt;&lt;/tr&gt;\n" + "&lt;/table&gt;\n" + "&lt;/body&gt;&lt;/html&gt;"); &#125;&#125; 配置好web.xml即可 对这段代码的解释以及补充request.getSession()以及其重构方法request.getSession(false)HttpSession session = request.getSession(boolean create)返回当前reqeust中的HttpSession，如果当前reqeust中的HttpSession为null，当create为true，就创建一个新的Session，否则返回null 当向Session中存取登录信息时，一般建议：HttpSession session =request.getSession(); 当从Session中获取登录信息时，一般建议：HttpSession session =request.getSession(false); session.isNew() - 判断是否为新的用户12345if(session.isNew()) &#123; // do something with new user&#125; else &#123; // do something&#125; session.getId() - 获取当前用户的sessionID其他HttpSession API 禁用cookie的解决方法-URL重写您可以在每个 URL 末尾追加一些额外的数据来标识 session 会话，服务器会把该 session 会话标识符与已存储的有关 session 会话的数据相关联。 例如，http://w3cschool.cc/file.htm;sessionid=12345，session 会话标识符被附加为 sessionid=12345，标识符可被 Web 服务器访问以识别客户端。 URL 重写是一种更好的维持 session 会话的方式，它在浏览器不支持 cookie 时能够很好地工作，但是它的缺点是会动态生成每个 URL 来为页面分配一个 session 会话 ID，即使是在很简单的静态HTML页面中也会如此。 对URL重写，必须要先对URL进行编码可以通过以下两种方法对URL进行编码 jsp中添加&lt;% response.encodeURL(&quot;hello.jsp&quot;); %&gt; Servlet中使用response.encodeRedirectURL()与sendRedirect()，见下面 12345678910@Overrideprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; HttpSession session = request.getSession(); //下面请求重定向的路径。 String path = response.encodeRedirectURL("/BeerTest.do"); String sessionId = request.getSession().getId(); request.setAttribute("sessionId",sessionId); response.sendRedirect(path);&#125; 设置会话超时在web.xml中配置,下面例子是设置15分钟超时 123456&lt;web-app ...&gt; &lt;servlet&gt; ... &lt;/servlet&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt;&lt;/web-app&gt; 设置特定会话的会话超时session.setMaxInactiveInterval(20*60); // 设置20分钟没有做任何请求就超时 Cookie创建一个新CookieCookie cookie = new Cookie(&quot;username&quot;, name);设置cookie在客户端存活时间cookie.setMaxAge(30*60); // 30min把cookie发送给客户response.addCookie(cookie);从客户请求得到cookie 123456789Cookie[] cookies = request.getCookies();for (int i = 0; i &lt; cookies.length; i++) &#123; Cookie cookie = cookies[i]; if (cookie.getName().equals("username")) &#123; String userName = cookie.getValue(); out.println("Hello " + userName); break; &#125; 简单的cookie示例login.jsp设置表单提交账号密码，如果账号为test，则点击index.jsp的提交按钮可以显示其密码可以在F12 Application Cookies可以看到cookie web.xml 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"&gt; &lt;servlet&gt; &lt;servlet-name&gt;cookieTest&lt;/servlet-name&gt; &lt;servlet-class&gt;ServletCookie&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;cookieTest&lt;/servlet-name&gt; &lt;url-pattern&gt;/sv.html&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;cookieTest2&lt;/servlet-name&gt; &lt;servlet-class&gt;CheckCookie&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;cookieTest2&lt;/servlet-name&gt; &lt;url-pattern&gt;/result.html&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; login.jsp 1234567891011121314&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="sv.html" method="post"&gt; &lt;input type="text" name="username" /&gt; &lt;input type="password" name="password" /&gt; &lt;input type="submit" value="提交" /&gt;&lt;/form&gt;&lt;/body&gt; index.jsp 1234567891011&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="result.html" method="post"&gt; &lt;input type="submit" value="提交" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html ServletCookie.java 12345678910111213141516171819202122232425import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(name = "ServletCookie")public class ServletCookie extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String username = request.getParameter("username"); String password = request.getParameter("password"); //定义一个名为username，值为Tom的cookie Cookie cookie = new Cookie(username, password); response.addCookie(cookie); request.getRequestDispatcher("index.jsp").forward(request, response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125;&#125; CheckCookie.java 1234567891011121314151617181920212223242526272829303132import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@WebServlet(name = "CheckCookie")public class CheckCookie extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html"); PrintWriter out = response.getWriter(); Cookie[] cookies = request.getCookies(); if (cookies != null) &#123; for (Cookie cookie : cookies) &#123; if(cookie.getName().equals("test")) &#123; String userName = cookie.getValue(); out.println(userName); break; &#125; &#125; &#125; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125;&#125; HttpSessionBindingListener]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>HttpSession</tag>
        <tag>Cookie</tag>
        <tag>HttpSessionBindingListener</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet05-无脚本JSP]]></title>
    <url>%2F2018%2F09%2F01%2FServlet05-%E6%97%A0%E8%84%9A%E6%9C%ACJSP%2F</url>
    <content type="text"><![CDATA[Servlet05-无脚本JSPbean法则-使用bean的规范 必须有一个无参数的公共构造函数 必须按命名规范来命名公共的getter和setter setter的参数类型和getter的返回类型必须一致 性质名和类型是由setter和getter得出，而不得来自于类中的一个成员 结合JSP使用时，性质类型必须是String或其他基本类型 使用EL对于model Person，它是一个JavaBean，所以我们要使用与bean相关的标准动作 使用脚本： 123456&lt;html&gt;&lt;body&gt;&lt;% foo.Person p = (foo.Person) request.getAttribute("person"); %&gt;Person is : &lt;%= p.getName() %&gt;&lt;/body&gt;&lt;/html&gt; 使用标准动作： 123456&lt;html&gt;&lt;body&gt;&lt;jsp:useBean id="person" class="foo.Person" scope="request" /&gt;Person created by servlet: &lt;jsp:getProperty name="person" property="name" /&gt;&lt;/body&gt;&lt;/html&gt; 分析&lt;jsp:useBean&gt;和&lt;jsp:getProperty&gt;&lt;jsp:useBean&gt;用 &lt;jsp:useBean&gt; 声明和初始化一个bean属性，id为声明bean对象的标识符，对应于servlet的request.setAttribute(&quot;person&quot;, p)，class为声明的对象的类类型，scope标识这个bean对象的属性作用域 &lt;jsp:useBean&gt;还可以创建一个bean，如果它找不到一个名为”person”的属性对象，它就会建一个 &lt;jsp:getProperty&gt;用 &lt;jsp:getProperty&gt;得到bean属性的性质值，name标识具体的bean对象，与&lt;jsp:useBean&gt;的id属性相匹配，property标识属性中的性质名(也就是与bean类中getter和setter对应的性质) &lt;jsp:setProperty&gt;&lt;jsp:setProperty&gt;是第三个（也是最后一个）bean标准动作，具体使用如下 &lt;jsp:setProperty name=&quot;person&quot; property=&quot;name&quot; value=&quot;yourNameVal&quot; /&gt; &lt;jsp:useBean&gt;可以有体如果把设置方法代码&lt;jsp:setProperty&gt;放在&lt;jsp:useBean&gt;的体中，就可以有条件地设置性质，只有创建新bean时才设置性质值 123&lt;jsp:useBean id="person" class="foo.Person" scope="page" &gt; &lt;jsp:setProperty name="person" property="name" value="yourNameVal" /&gt;&lt;/jsp:useBean&gt; 多态bean引用 &lt;jsp:useBean&gt;的type属性可以用&lt;jsp:useBean&gt;的type属性实现引用类型不同于具体的对象类型，假设新对象的类型为Employee，引用类型是Person &lt;jsp:useBean id=&quot;person&quot; type=&quot;foo.Person&quot; class=&quot;foo.Employee&quot; scope=&quot;page&quot;&gt; 可以实现效果，生成的servlet代码大概如下 12345foo.Person person = null;// 得到person属性的代码if (person == null) &#123; person = new foo.Employee();&#125; type可以是class类型，抽象类型或者是一个接口，class必须是type的一个子类或具体实现，type是声明的类型，而class是要实例化的类 直接从表单请求到JSP - param属性可以通过设置name一致达到直接从请求到JSP的效果，不需要途中经过servlet 假设表单是这样的： 123456789&lt;html&gt; &lt;body&gt; &lt;form action="TestBean.jsp"&gt; name: &lt;input type="text" name="userName"&gt; ID#: &lt;input type="text" name="userID"&gt; &lt;input type="submit"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 在TestBean.jsp中 123&lt;jsp:useBean id="person" type="foo.Person" class="foo.Employee"&gt; &lt;jsp:setProperty name="person" property="name" param="userName" /&gt;&lt;/jsp:useBean&gt; 利用param属性，可以把bean的性质值设置为一个请求参数的值，只需指定请求参数 甚至不需要param属性只要把表单内的内容设置与bean的性质一致，甚至可以不需要param属性，如下 123456789&lt;html&gt; &lt;body&gt; &lt;form action="TestBean.jsp"&gt; name: &lt;input type="text" name="name"&gt; ID#: &lt;input type="text" name="userID"&gt; &lt;input type="submit"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 在TestBean.jsp中 123&lt;jsp:useBean id="person" type="foo.Person" class="foo.Employee"&gt; &lt;jsp:setProperty name="person" property="name" /&gt;&lt;/jsp:useBean&gt; 如果设置表单中所有请求参数名都与bean性质名匹配，那么甚至连property都可以省略 如下 123456789&lt;html&gt; &lt;body&gt; &lt;form action="TestBean.jsp"&gt; name: &lt;input type="text" name="name"&gt; ID#: &lt;input type="text" name="empID"&gt; &lt;input type="submit"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 在TestBean.jsp中 123&lt;jsp:useBean id="person" type="foo.Person" class="foo.Employee"&gt; &lt;jsp:setProperty name="*" property="name" /&gt;&lt;/jsp:useBean&gt; 性质是引用类型的情况假如Person有一个Dog “dog”性质，Dog有一个String “name”性质，如果想打印Person的dog的name，可以用到EL，如下 123&lt;html&gt;&lt;body&gt;Dog's name is : $&#123;person.dog.name&#125;&lt;/body&gt;&lt;/html&gt; 对${person.dog.name}的解释${person.dog.name} 等同于 &lt;%= ((foo.Person) request.getAttribute(&quot;person&quot;)).getDog().getName() %&gt; 使用点号(.)可以访问性质和映射值 使用中括号[]，更好的点号点号右边是一个bean性质或映射键的时候，点号操作符才能正常工作，但[]操作符就强大很多，它既可以完成点号操作符能完成的工作，也可以当左边变量是一个数组或者List或者右边不遵循正常的Java命名规范的时候仍然可以正常工作 EL中的隐式对象param与paramValuesHTML表单中 12345678&lt;form action="TestBean.jsp"&gt; name: &lt;input type="text" name="name"&gt; ID#: &lt;input type="text" name="empID"&gt; First food: &lt;input type="text" name="food"&gt; Second food: &lt;input type="text" name="food"&gt; &lt;input type="submit"&gt;&lt;/form&gt; 对于单个值，可以在JSP中${param.name}获取表单的name对于多个值，可以在JSP中${paramValues.food[0]}获取多个值中的一个 EL的其他隐式对象得到”host”首部${header[&quot;host&quot;]}或${header.host} 得到Cookie打印”userName” Cookie的值 使用脚本： 12345678&lt;% Cookie[] cookies = request.getCookies();for (int i = 0; i &lt; cookies.length; i++) &#123; if ((cookies[i].getName()).equals("userName")) &#123; out.println(cookies[i].getValue()); &#125;&#125;%&gt; 使用EL： ${cookie.uesrName.value} 上下文参数在web.xml中 1234&lt;context-param&gt; &lt;param-name&gt;mainEmail&lt;/param-name&gt; &lt;param-value&gt;12345@outlook.com&lt;/param-value&gt;&lt;/context-param&gt; 使用脚本：&lt;%= application.getInitParameter(&quot;mainEmail&quot;) %&gt; 使用EL：${initParam.mainEmail} EL函数使用EL函数有如下四步骤 编写一个有公共静态方法的Java类 编写一个标记库描述文件(.tld) 在JSP中放一个taglib指令 使用EL调用函数 编写一个有公共静态方法的Java类1234567package com.xhj.web;public class DiceRoller &#123; public static int rollDice() &#123; return (int) ((Math.random() * 6) + 1); &#125;&#125; 编写一个标记库描述文件IDEA中在web目录右键new -&gt; xml configuration file -&gt; JSP tag library descriptor 重命名为*.tld 123456789101112131415161718&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;&lt;taglib xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-jsptaglibrary_2_1.xsd" version="2.1"&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;uri&gt;DiceFunctions&lt;/uri&gt; &lt;function&gt; &lt;name&gt;rollIt&lt;/name&gt; &lt;function-class&gt;com.xhj.web.DiceRoller&lt;/function-class&gt; &lt;function-signature&gt;int rollDice()&lt;/function-signature&gt; &lt;/function&gt; &lt;!-- Invoke 'Generate' action to add tags or functions --&gt;&lt;/taglib&gt; 在JSP中放一个taglib指令&lt;%@ taglib prefix=&quot;mine&quot; uri=&quot;DiceFunctions&quot; %&gt; 使用EL调用函数正文添加${mine:rollIt()} 对TLD文件的解释 TLD中的uri对应JSP中taglib指令的uri属性 TLD中function里的name标签的值对应EL表达式中冒号右边使用的函数 TLD中function-class标签对应.class TLD中function-signature标签的值对应.class里的公共静态方法及其返回值 taglib指令中的prefix属性的值对应EL表达式冒号左边的值 *.tld文件可以放在WEB-INF目录或者其某个子目录中 EL处理null对于找不到表达式中指定的属性/性质/键，也会显示页面，在算术表达式中，EL把null值看做是0，在逻辑表达式中，EL把null看做是false 可复用的模板部件对于网站上每个页面的页眉和页脚都一样的情况下，每个JSP反复编写同样的页眉页脚，会显得效率低下，这个时候可以使用include指令把相同的页面放在不同网页对应的位置上 &lt;include&gt;指令用法：&lt;%@ include file=&quot;*.jsp&quot; %&gt; &lt;jsp:include&gt;标准动作用法&lt;jsp:include page=&quot;*.jsp&quot; /&gt; &lt;include&gt;与&lt;jsp:include&gt;的区别include指令在转换时发生，&lt;jsp:include&gt;标准动作在运行时发生include指令相当于复制代码粘贴，标准动作则根据页面属性创建一个RequestDispatcher，并应用include()方法。 注意！不需要把&lt;html&gt;和&lt;body&gt;标签放到可复用部件中 &lt;jsp:param&gt;定制包含的内容假设我们已经有了一个页眉，但是如果我们想要定制页眉的某一部分，比如我希望在页眉上有一个与上下文相关的子标题，它要依页面而定，如下 在对应的jsp文件中 1234567&lt;html&gt;&lt;body&gt;&lt;jsp:include page="Header.jsp"&gt; &lt;jsp:param name="subTitle" value="aha!this is a sub title." /&gt;&lt;/jsp:include&gt;&lt;/body&gt;&lt;/html&gt; 在Header.jsp中 12&lt;img src="directory/images/xxx.png"&gt;&lt;em&gt;&lt;strong&gt;$&#123;param.subTitle&#125;&lt;/strong&gt;&lt;/em&gt; &lt;jsp:forward&gt;转发可以从一个JSP转发到另一个JSP，或者从一个JSP转发到一个servlet，还可以从一个JSP转发到WEB应用中任何其他资源。比如客户访问页面，如果没有登录，就转向另一个页面 123&lt;% if (request.getParameter("userName") == null) &#123; &gt; &lt;jsp:forward page="xx.jsp" /&gt;&lt;% &#125; %&gt;]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>JSP</tag>
        <tag>EL</tag>
        <tag>bean</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet之WEB应用体系与MVC]]></title>
    <url>%2F2018%2F09%2F01%2FServlet01-WEB%E5%BA%94%E7%94%A8%E4%BD%93%E7%B3%BB%E4%B8%8E%E5%88%9D%E7%AA%A5MVC%2F</url>
    <content type="text"><![CDATA[#Servlet之WEB应用体系与MVC ##WEB应用体系 ###TOMCAT容器的作用 通信支持容器可以让servlet与WEB容器对话，创建ServerSocket，监听端口，创建流等生命周期管理容器控制着servlet的生命周期，负责加载类，实例化，初始化servlet，调用servlet方法，垃圾回收等多线程支持每次接收到用户servlet请求，就会创建一个新的Java线程，声明方式实现安全使用XML部署描述文件配置安全性JSP支持容器负责把JSP翻译成Java ###容器处理请求 用户点击一个链接，指向一个servlet 容器看出来这个请求要的是一个servlet，创建两个对象，分别为HttpServletResponse，HttpServletRequest 容器根据请求的URL找到对应的servlet，为这个请求分配一个线程，并把请求和响应对象传递给这个servlet线程 容器调用service的service()方法，根据请求的不同类型，service()方法会调用doGet()或doPost()方法 doGet()方法生成动态页面，塞到响应对象里 线程结束，容器把响应对象转换为一个HTTP响应，把它发回给客户，然后删除请求和响应对象 ###servlet的映射方式通过配置部署描述文件web.xml可以配置servlet名对应的URL路径一般的web.xml内容如下1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"&gt; &lt;servlet&gt; &lt;servlet-name&gt;yourDefinedName&lt;/servlet-name&gt; &lt;servlet-class&gt;yourServletClassName&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;yourDefinedName&lt;/servlet-name&gt; &lt;url-pattern&gt;/yourUrl&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; &lt;servlet&gt;元素告诉容器有哪个类文件&lt;servlet-name&gt;元素用于把一个&lt;servlet&gt;元素与一个特定的&lt;servlet-mapping&gt;元素绑定，最终用户看不到这个名字，这个名字只在这个部署文件的其他部分使用&lt;servlet-class&gt;类的完全限定名，但不要加上.class后缀&lt;servlet-mapping&gt;请求到来时，容器会在运行时使用这个元素，来调用对应的servlet&lt;url-pattern&gt;URL的路径 客户知道的URL名对应的是&lt;url-pattern&gt;的值，部署人员知道的秘密的内部名对应的是&lt;servlet-name&gt;的值，实际的文件名对应的是&lt;servlet-class&gt;的值 ##初窥MVCMVC分别为model，view，controller，MVC的关键是业务逻辑与表示分离，实际上，业务逻辑甚至根本不知道有表示存在 ###Model实际的业务逻辑和状态放在模型中，系统中只有这部分与数据库通信 ###Controller从请求获得用户输入，并明确输入对模型的影响，告诉模型自行更新，并让视图得到新的模型状态，一个servlet实际上就是一个控制器 ###View负责表示，它从控制器得到模型的状态，还要获得用户输入，交给控制器，一个JSP文件其实就是一个View ##一个简单的MVC应用目录树如下其中，com.example.web.BeerSelect为控制器，com.example.model.BeerExpert为模型，result.jsp为view web.xml内容如下1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"&gt; &lt;servlet&gt; &lt;servlet-name&gt;Ch3 Beer&lt;/servlet-name&gt; &lt;servlet-class&gt;com.example.web.BeerSelect&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;Ch3 Beer&lt;/servlet-name&gt; &lt;url-pattern&gt;/SelectBeer.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; form.html如下123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;form test&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="css/form.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 align="center"&gt;Beer Selection Page&lt;/h1&gt; &lt;div id="formT"&gt; &lt;form method="POST" action="SelectBeer.do"&gt; &lt;p&gt;Color: &lt;select name="color"&gt; &lt;option name="light"&gt;light&lt;/option&gt; &lt;option name="dark"&gt;dark&lt;/option&gt; &lt;/select&gt; &lt;p&gt; &lt;input type="submit"&gt; &lt;/p&gt; &lt;/p&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; result.jsp123456789101112131415161718192021&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;%@ page import="java.util.*" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 align="center"&gt;Bear Recommendations JSP&lt;/h1&gt; &lt;p&gt; &lt;% List styles = (List)request.getAttribute("styles"); Iterator it = styles.iterator(); while (it.hasNext()) &#123; out.print("try: " + it.next()); &#125; %&gt; &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 模型BeerExpert.java如下12345678910111213141516171819package com.example.model;import java.util.ArrayList;import java.util.List;public class BeerExpert &#123; public List getBrands(String color) &#123; List brands = new ArrayList(); if (color.equals("light")) &#123; brands.add("light a"); brands.add("light b"); &#125; else &#123; brands.add("dark1"); brands.add("dark2"); &#125; return brands; &#125;&#125; 控制器BeelSelect如下1234567891011121314151617181920212223242526272829package com.example.web;import com.example.model.BeerExpert;import javax.servlet.RequestDispatcher;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.List;@WebServlet(name = "BeerSelect")public class BeerSelect extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String c = request.getParameter("color"); BeerExpert be = new BeerExpert(); List result = be.getBrands(c); request.setAttribute("styles", result); RequestDispatcher view = request.getRequestDispatcher("result.jsp"); view.forward(request, response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125;&#125; ##作为Servlet在上述代码中，Servlet作为控制器有如下功能 获得html页面中参数color的值 创建一个模型，通过参数获得模型对应的属性 设置请求的属性并设置对应值为从模型得到的结果（键-值对应） 创建一个请求分派器对象，获得result.jsp页面 通过view.forward(request,response)把请求和响应发送给该view，view通过request.getAttribute(“key”)来得到模型发送来的结果 ###Servlet生命周期 WEB容器加载servlet类 实例化servlet（构造函数运行） init() service()调用doGet(),doPost()等等 destroy() ###HttpServletRequest API ###HttpServletResponse API ###输出字符或字节对于输出，可以选择输出字符或者字节输出字符的时候12PrintWriter writer = response.getWriter();writer.println("some text or HTML"); 输出字节的时候12ServletOutputStream out = response.getOutputStream();out.write(aByteArray); ####使用响应完成I/Oe.g.Servlet处理下载JAR文件1234567891011121314151617181920public class CodeReutrn extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123; response.setContentType("application/jar"); // 对于这里的ContentType，还有很多其他的，具体可以自行Google ServletContext ctx = getServletContext(); InputStream is = ctx.getResourceAsStream("/directory/xxx.jar"); int read = 0; byte[] bytes = new byte[1024]; OutputStream os = response.getOutputStream(); while((read = is.read(bytes)) != -1) &#123; os.write(bytes, 0, read); &#125; os.flush(); os.close(); &#125;&#125;]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>MVC</tag>
        <tag>TOMCAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet02-ServletConfig,ServletContext与监听器]]></title>
    <url>%2F2018%2F09%2F01%2FServlet02-ServletConfig%2CServletContext%E4%B8%8E%E7%9B%91%E5%90%AC%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Servlet02-ServletConfig,ServletContext与监听器通过web.xml可以初始化参数，避免了硬编码改变了源码与重新编译的麻烦，如下：12345678&lt;servlet&gt; &lt;init-param&gt; &lt;param-name&gt;name&lt;/param-name&gt; &lt;param-value&gt;value&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet-name&gt; 在servlet代码中通过1234567来获取该值或者通过下面例子处理```Java Enumeration e = getServletConfig().getInitParameterNames(); while(e.hasMoreElements()) &#123; // do something with e.nextElement(); &#125; 但ServletConfig仅仅能在该servlet中使用，对于想要在全局使用的参数实在不方便，ServletContext可以很好的解决这个问题 ServletContext在web.xml中添加1234&lt;context-param&gt; &lt;param-name&gt;adminEmail&lt;/param-name&gt; &lt;param-value&gt;231232@oaiw.com&lt;/param-value&gt;&lt;/context-param&gt; Servlet中通过getServletContext().getInitParameter(&quot;adminEmail&quot;);来获取 ServletConfig与ServletContext的区别 在部署文件中，上下文初始化参数是在&lt;web-app&gt;中的，而Servlet初始化参数是在servlet中的 ServletConfig的作用域为每个servlet，而ServletContext的作用域为整个WEB应用 ServletContextListener由于ServletContext在初始化的时候只能保存字符串，若要保存一个对象或在应用启动之前利用该字符串做一些准备工作（比如打开数据库），则需要监听器的帮助。ServletContextListener接口可以监听一个上下文初始化事件，得到上下文初始化参数，并在应用为客户提供服务之前运行一些代码，要实现该接口，就要实现下面两个方法public void contextInitialized(ServletContextEvent event)public void contextDestroyed(ServletContextEvent event) 建立一个上下文监听者 创建一个监听者类 把编译后的类*.class放入WEB-INF/classes 在web.xml部署描述文件放一个&lt;listener&gt;元素，如下12345&lt;listener&gt; &lt;listener-class&gt; com.example.MyServletContextListener &lt;/listener-class&gt;&lt;/listener&gt; 一个监听器的例子web.xml中先注册该Listener，然后设置好对应的servlet以及context-param，如下12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"&gt; &lt;servlet&gt; &lt;servlet-name&gt;ListenerTester&lt;/servlet-name&gt; &lt;servlet-class&gt;com.example.web.ListenerTester&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ListenerTester&lt;/servlet-name&gt; &lt;url-pattern&gt;/listen.ht&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;context-param&gt; &lt;param-name&gt;breed&lt;/param-name&gt; &lt;param-value&gt;Great Dane&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;com.example.web.MyServletContextListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt; 监听器的工作是得到该ServletContext的初始值，然后创建一个Dog对象，把该值作为参数传入对象构造函数，并构造一个ServletContext对象，设置该Dog对象作为新的ServletContext的属性。123456789101112131415161718192021package com.example.web;import com.example.model.Dog;import javax.servlet.ServletContext;import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;public class MyServletContextListener implements ServletContextListener &#123; public void contextInitialized(ServletContextEvent event) &#123; ServletContext sc = event.getServletContext(); String dogBreed = sc.getInitParameter("breed"); Dog d = new Dog(dogBreed); sc.setAttribute("dog", d); &#125; public void contextDestroyed(ServletContextEvent event) &#123; &#125;&#125; Dog对象如下1234567891011121314package com.example.model;public class Dog &#123; private String breed; public Dog(String breed) &#123; this.breed = breed; &#125; public String getBreed() &#123; return breed; &#125;&#125; Servlet通过getServletContext().getAttribute(&quot;dog&quot;)得到ServletContext的属性值来获取该Dog对象，这样就可以通过ServletContext对象来获取String以外的值了。 123456789101112131415161718192021222324252627282930package com.example.web;import com.example.model.Dog;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@WebServlet(name = "ListenerTester")public class ListenerTester extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html"); PrintWriter out = response.getWriter(); out.println("test context attributes set by listener&lt;br&gt;"); out.println("&lt;br&gt;"); Dog dog = (Dog) getServletContext().getAttribute("dog"); out.println("Dog's breed is : " + dog.getBreed()); &#125;&#125; 其他监听者 属性API与属性安全 上下文属性无法确保线程安全，要对上下文加锁。 请求属性和请求分派1234request.setAttribute("attrName", attrValue);RequestDispatcher view = request.getRequestDispatcher("*.jsp");view.forward(request, response); 通过从ServletRequest（或ServletContext）得到RequestDispatcher对象，调用forward()把请求转交给JSP处理 注意！如果已经提交了响应，就不能转发请求，否则会报IllegalStateException，os.flush()等方法都是提交响应]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>ServletConfig</tag>
        <tag>ServletContext</tag>
        <tag>Listener</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础之初窥反射]]></title>
    <url>%2F2018%2F06%2F19%2FJava%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%9D%E7%AA%A5%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[前言:之前写安卓的时候有遇到过反射,但是当时怎么都不理解,现在正好借此机会初步了解一下反射 什么是反射 Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.The API accommodates applications that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class. It also allows programs to suppress default reflective access control. 简单来说,反射能够分析类能力,他可以做以下几件事: 在运行时分析类的能力 在运行时查看对象,例如,写一个toString方法供所有类使用 实现通用的数组操作代码 利用Method对象(类比C中的函数指针) 获得对象的Class类反射比较重要的一点是获得对象的类,对象的类是一个Class对象(但不是所有Class对象都是一种类,例如int也是Class对象) 以下是三种获得Class类的方法1234// 第一种:通过对象.getClass()获得Employee e;...Class cl = e.getClass(); 1234567// 第二种:通过Class类的静态方法forName()获得try &#123; String className = "java.util.Random"; Class cl = Class.forName(className);&#125; catch (Execption e) &#123; e.printStackTrace();&#125; 1234// 第三种:通过T.class获得(T是任意Java类型)Class cl1 = Random.class;Class cl2 = int.class;Class cl3 = Double[].class; Class类的一些常用方法getName() Returns the name of the entity (class, interface, array class, primitive type, or void) represented by this Class object, as a String. 123Employee e;...System.out.println(e.getClass().getName()); newInstance() Creates a new instance of the class represented by this Class object. 123Employee e;e.getClass().newInstance();// 调用默认的构造函数,如果要传参,请使用Constructor类的newInstance(Objcet[] args)方法 getMethod() Modifier and Type Method and Description Method getMethod(String name, Class&lt;?&gt;… parameterTypes) &nbsp; Returns a Method object that reflects the specified public member method of the class or interface represented by this Class object. e.g. 获得Employee的raiseSalary方法 Method m1 = Employee.class.getMethod(&quot;raiseSalary&quot;, double.class); getDeclaredFields() Returns an array of Field objects reflecting all the fields declared by the class or interface represented by this Class object. getDeclaredMethods() Returns an array containing Method objects reflecting all the declared methods of the class or interface represented by this Class object, including public, protected, default (package) access, and private methods, but excluding inherited methods. getDeclaredConsstructors() Returns an array of Constructor objects reflecting all the constructors declared by the class represented by this Class object. getDeclaredFields()与getFields()的区别getFields()返回一个包含Field对象的数组,这些对象记录了这个类或其超类的公有域,而getDeclaredFields()的对象记录了这个类的全部域类比Methods与Constructors 反射包中重要类的简单描述在java.lang.reflect包中有三个类Field,Method,和Constructor分别用于描述类的域,方法和构造器 FieldField用于描述类的域,常见的方法有 Modifier and Type Method and Description Object get(Object obj) &nbsp; Returns the value of the field represented by this Field, on the specified object. void set(Object obj, Object value) &nbsp; Sets the field represented by this Field object on the specified object argument to the specified new value. int getModifiers() &nbsp; Returns the Java language modifiers for the field represented by this Field object, as an integer. Class&lt;?&gt; getType() &nbsp; Returns a Class object that identifies the declared type for the field represented by this Field object. String getName() &nbsp; Returns the name of the field represented by this Field object. Method Modifier and Type Method and Description String getName() &nbsp; Returns the name of the method represented by this Method object, as a String. Class&lt;?&gt; getReturnType() &nbsp; Returns a Class object that represents the formal return type of the method represented by this Method object. int getModifiers() &nbsp; Returns the Java language modifiers for the field represented by this Field object, as an integer. Class&lt;?&gt;[] getParameterTypes() &nbsp; Returns an array of Class objects that represent the formal parameter types, in declaration order, of the executable represented by this object. Object invoke(Object obj, Object… args) &nbsp; Invokes the underlying method represented by this Method object, on the specified object with the specified parameters. Constructor Modifier and Type Method and Description String getName() &nbsp; Returns the name of this constructor, as a string. Class&lt;?&gt;[] getParameterTypes() &nbsp; Returns an array of Class objects that represent the formal parameter types, in declaration order, of the executable represented by this object. int getModifiers() &nbsp; Returns the Java language modifiers for the field represented by this Field object, as an integer. 利用反射分析类的能力12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class ReflectionTest &#123; public static void main(String[] args) &#123; String name; if (args.length &gt; 0) name = args[0]; else &#123; Scanner in = new Scanner(System.in); System.out.println("Enter class name (e.g. java.util.Date):"); name = in.next(); &#125; try &#123; Class cl = Class.forName(name); Class supercl = cl.getSuperclass(); String modifiers = Modifier.toString(cl.getModifiers()); if (modifiers.length() &gt; 0) System.out.print(modifiers + " "); System.out.print("class " + name); if (supercl != null &amp;&amp; supercl != Object.class) System.out.print(" extends " + supercl.getName()); System.out.print("\n&#123;\n"); printConstructors(cl); System.out.println(); printMethods(cl); System.out.println(); printFields(cl); System.out.println("&#125;"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.exit(0); &#125; public static void printConstructors(Class cl) &#123; Constructor[] constructors = cl.getDeclaredConstructors(); for (Constructor c : constructors) &#123; String name = c.getName(); System.out.print(" "); String modifiers = Modifier.toString(c.getModifiers()); if (modifiers.length() &gt; 0) System.out.print(modifiers + " "); System.out.print(name + "("); Class[] paramTypes = c.getParameterTypes(); // 构造器的参数是Class类型 for (int j = 0; j &lt; paramTypes.length; j++) &#123; if (j &gt; 0) System.out.print(", "); System.out.print(paramTypes[j].getName()); &#125; System.out.println(");"); &#125; &#125; public static void printMethods(Class cl) &#123; Method[] methods = cl.getDeclaredMethods(); for (Method m : methods) &#123; Class retType = m.getReturnType(); // 方法的返回值是Class类型,注意:int等基本数据类型也是Class类型 String name = m.getName(); System.out.print(" "); String modifiers = Modifier.toString(m.getModifiers()); if (modifiers.length() &gt; 0) System.out.print(modifiers + " "); System.out.print(retType.getName() + " " + name + "("); // 这里返回了int, boolean等 Class[] paramTypes = m.getParameterTypes(); for (int j = 0; j &lt; paramTypes.length; j++) &#123; if (j &gt; 0) System.out.print(", "); System.out.print(paramTypes[j].getName()); &#125; System.out.println(");"); &#125; &#125; public static void printFields(Class cl) &#123; Field[] fields = cl.getDeclaredFields(); for (Field f : fields) &#123; Class type = f.getType(); // Returns a Class object that identifies the declared type for the field represented by this Field object. String name = f.getName(); System.out.print(" "); String modifiers = Modifier.toString(f.getModifiers()); if (modifiers.length() &gt; 0) System.out.print(modifiers + " "); System.out.println(type.getName() + " " + name + ";"); &#125; &#125;&#125; 在运行时使用反射分析对象上面讲的是如何查看任意对象的数据域名称和类型,这次进一步查看数据域的实际内容12345Employee harry = new Employee("Harry Hacker", 35000, 10, 1 1989);Class cl = harry.getClass();Field f = cl.getDeclaredField("name");f.setAccessible(true);Object v = f.get(harry) // the value of v is "Harry Hacker" 上面是一个获得对象域的例子,注意反射机制默认受限于Java的访问控制,可以通过以下方法覆盖访问控制 f.setAccessible(true) Field继承自AccessibleObject,可通过其父类方法setAccessible()设置权限 AccessibleObject.setAccessible(fields, true) 调用静态方法对fields设置权限(见下面代码) 下面是一个通用的toString方法12345678910111213141516public class ObjectAnalyzerTest &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; squares = new ArrayList&lt;&gt;(); String[] ss = &#123;"a", "b", "c"&#125;; for (int i = 1; i &lt;= 5; i++) &#123; squares.add(i * i); &#125; ObjectAnalyzer objectAnalyzer = new ObjectAnalyzer();// System.out.println(objectAnalyzer.toString(ss)); System.out.println(objectAnalyzer.toString(squares));// System.out.println(new ObjectAnalyzer().toString(12345));// System.out.println(new ObjectAnalyzer().toString("test"));// System.out.println(new ObjectAnalyzer().toString(null)); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class ObjectAnalyzer &#123; private ArrayList&lt;Object&gt; visited = new ArrayList&lt;&gt;(); // 循环引用可能导致无限递归 public String toString(Object obj) &#123; if (obj == null) return "null"; if (visited.contains(obj)) return "..."; visited.add(obj); Class cl = obj.getClass(); if (cl == String.class) return (String)obj; if (cl.isArray()) &#123; String r = cl.getComponentType() + "[]&#123;"; // getComponentType() Returns the Class representing the component type of an array. for (int i = 0; i &lt; Array.getLength(obj); i++) &#123; if (i &gt; 0) r += ","; Object val = Array.get(obj, i); if (cl.getComponentType().isPrimitive()) r += val; else r += toString(val); &#125; return r + "&#125;"; &#125; String r = cl.getName(); do &#123; r += "["; Field[] fields = cl.getDeclaredFields(); AccessibleObject.setAccessible(fields, true); for (Field f : fields) &#123; if (!Modifier.isStatic((f.getModifiers()))) &#123; // 静态域舍弃 if (!r.endsWith("[")) r += ","; r += f.getName() + "="; try &#123; Class t = f.getType(); Object val = f.get(obj); if (t.isPrimitive()) r += val; // 如果为原始数据类型则直接添加 else r += toString(val); // 否则递归调用 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; r += "]"; cl = cl.getSuperclass(); &#125; while (cl != null); return r; &#125;&#125; 使用反射编写泛型数组代码123456789101112131415161718192021222324252627282930public class CopyOfTest &#123; public static void main(String[] args) &#123; int[] a = &#123; 1, 2, 3 &#125;; a = (int[]) goodCopyOf(a, 10); System.out.println(Arrays.toString(a)); String[] b = &#123; "Tom", "Dick", "Harry" &#125;; b = (String[]) goodCopyOf(b, 10); System.out.println(Arrays.toString(b)); &#125; // int[]无法转换为Object[] public static Object[] badCopyOf(Object[] a, int newLength) &#123; Object[] newArray = new Object[newLength]; System.arraycopy(a, 0, newArray, 0, Math.min(a.length, newLength)); return newArray; &#125; public static Object goodCopyOf(Object a, int newLength) &#123; Class cl = a.getClass(); if (!cl.isArray()) return null; Class componentType = cl.getComponentType(); // Returns the Class representing the component type of an array. int length = Array.getLength(a); Object newArray = Array.newInstance(componentType, newLength); System.arraycopy(a, 0, newArray, 0, Math.min(length, newLength)); return newArray; &#125;&#125; 注意getComponentType()是Class的方法而不是Array的方法Array.newInstance()返回Object对象 调用任意方法类似C语言的函数指针,通过Java的反射机制可以调用任意方法 Object invoke(Object obj, Object... args)第一个参数是隐式参数,其余的对象提供了显示参数,对于静态方法,第一个参数可以被忽略,即设置为null,e.g. ml是一个Method,代表Employee的getName方法,harry是一个Employee对象String n = (String) ml.invoke(harry) // 调用harry的getName()方法method.invoke(a, s); // 调用a的method方法,参数为smethod.invoke(null, s); // 调用静态method方法,参数为s注意invoke返回的是Object 而获得方法可以通过Class cl = harry.getClass()cl.getMethod(String name, Class&lt;?&gt;... parameterTypes) 一个使用invoke的例子123456789101112131415161718192021222324252627282930public class MethodTableTest &#123; public static void main(String[] args) &#123; try &#123; Method square = MethodTableTest.class.getMethod("square", double.class); Method sqrt = Math.class.getMethod("sqrt", double.class); printTable(1, 10, 10, square); printTable(1, 10, 10, sqrt); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static double square(double x) &#123; return x * x; &#125; public static void printTable(double from, double to, int n, Method f) &#123; System.out.println(f); double dx = (to - from) / (n - 1); for (double x = from; x &lt;= to; x += dx) &#123; try &#123; double y = (Double) f.invoke(null, x); System.out.printf("%10.4f | %10.4f%n", x, y); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 后言:这次仅仅是跟着课本尝试了一下反射,以后有了相应的基础后会深入理解反射的机制]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object,所有类的超类]]></title>
    <url>%2F2018%2F06%2F03%2FObject-%E6%89%80%E6%9C%89%E7%B1%BB%E7%9A%84%E8%B6%85%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Object类是Java中所有类的超类,在Java中每个类都由它扩展而来Object类的方法如下 其中最为关键的3个方法为equals(),hashCode()和toString() equals方法官方文档 在文档中说到,equals用于检测一个对象是否等于另一个对象,该方法必须有以下5个特性: 自反性:对任意非空引用x,&nbsp;&nbsp;&nbsp;x.equals(x)&nbsp;&nbsp;必须返回true 对称性:对任意非空引用x,y,&nbsp;&nbsp;x.equals(y)&nbsp;&nbsp;返回true当且仅当&nbsp;&nbsp;y.equals(x)&nbsp;&nbsp;返回true 传递性:对任意非空引用x,y,z,如果&nbsp;&nbsp;x.equals(y)&nbsp;&nbsp;返回true并且&nbsp;&nbsp;y.equals(x)&nbsp;&nbsp;返回true,则&nbsp;&nbsp;x.equals(z)&nbsp;&nbsp;返回true 一致性:如果x和y引用的对象没有发生变化,反复调用&nbsp;&nbsp;x.equals(y)&nbsp;&nbsp;应该返回同样的结果 对于任意非空引用x,&nbsp;&nbsp;x.equals(y)&nbsp;&nbsp;应该返回false Object类的equals方法而Object类中的默认的equals方法如下123public boolean equals(Object obj) &#123; return (this == obj);&#125; 自定义类的equals方法如果两个对象具有相同的引用,则返回true,否则返回false,这是最经济的符合以上5个特性的equals方法了,但是很多时候这种判断并没有什么意义,更多时候我们要判断对象是否相等,需要检测他们状态的相等性,如果两个对象的状态相等,则认为他们是相等的,比如有一个雇员Employee类,如果两个雇员对象的姓名,薪水和雇佣日期都相等,则认为他们是相等的,那么雇员类的equals方法可以如下(完整的Employee类请见最后)1234567891011121314 public boolean equals(Object otherObject) &#123; if (this == otherObject) return true; // 先判断这两个对象是否具有相同的引用 if (otherObject == null) return false; // 然后判断otherObject是否为null if (getClass() != otherObject.getClass()) return false; // 使用getClass()判断是否为同一类 Employee other = (Employee) otherObject; // 把Object类转换成Employee类 return Objects.equals(name, other.name) // 详细比较他们的域 &amp;&amp; salary == other.salary &amp;&amp; Objects.equals(hireDay, other.hireDay); &#125;&#125; Employee类的equals方法代码解释代码中使用&nbsp;Objects.equals(name, other.name)&nbsp;是为了防备name和hireDay可能为null的情况,下面是Objects类的equals方法,当对象a和b都是null,则返回true,如果其中一个是null则返回false,否则调用a.equals(b)123public static boolean equals(Object a, Object b) &#123; return (a == b) || (a != null &amp;&amp; a.equals(b));&#125; 在是否为同一类的比较中,,除了&nbsp;&nbsp;if (getClass() != otherObject.getClass()) return false;&nbsp;&nbsp;这个判断外,还可以使用&nbsp;&nbsp;if (!(otherObject instanceof Employee)) return false;&nbsp;&nbsp;来判断,但是使用instanceof判断没有解决otherObject是子类的情况(&nbsp;子类引用 instanceof 父类&nbsp;返回true,但反过来则返回false,不符合对称性)所以,使用getClass()与instanceof可以根据下面情况判断: 如果子类能够拥有自己的相等概念,则对称性需求将强制性采用getClass进行检测 如果由超类决定相等的概念(比如Employee与其子类Manager中使用Employee类的成员ID来判断是否相等),那么就可以使用instanceof进行检测 完美的equals方法 显示参数命名为otherObject,稍后强制类型转换为变量other 检测this与ohetObject是否引用同一对象 检测ohterObject是否为null,如果为null返回false 比较this与otherObject是否属于同一类,根据相等概念由父类还是子类决定用getClass()还是instanceof检测 将ohterObject转换为相应的类类型变量 开始对需要比较的域进行比较,对于对象的比较,用Objects.equals(field, other.field) 子类中的equals方法12345public boolean equals(Object otherObject) &#123; if (!super.equals(otherObject)) return false; Manager other = (Manager) otherObject; return bonus == other.bonus; &#125; 先调用super.equals(otherObject)检测父类元素是否相等,然后再比较子类的域 其他对于数组类型的域,使用静态方法Arrays.equals方法判断 hashCode方法散列码hashCode是由对象导出的一个整型值,不同的对象散列码一般不会相同 官方文档根据说明我们可以得知: 只要在Java应用程序执行过程中多次调用同一对象时，hashCode方法就必须始终返回相同的整数，前提是未修改对象的等同比较中使用的信息。 该整数不需要从应用程序的一次执行到同一应用程序的另一次执行保持一致。 如果两个对象由equals方法得到的结果为true，则对这两个对象中的每个对象调用hashCode方法必须产生相同的整数结果。 根据equals方法，如果两个对象不相等，则不要求对两个对象中的每一个调用hashCode方法都必须生成不同的整数结果。 但是，程序员应该意识到，为不相等的对象生成不同的整数结果可能会提高散列表的性能。 Object类中的hashCode方法在源码中,hashCode()不是由Java代码生成的,它返回的值为对象的存储地址,这里就不赘述了 自定义类的hashCode方法如果要重新定义equals方法,则必须重新定义hashCode方法equals方法与什么成员有关,hashCode也必须与该成员有关e.g:如果equals方法与Employee类的salary,hireDay,name相关,则Employee的hashCode方法可以定义如下 123456public int hashCode() &#123; return 7 * Objects.hashCode(name) + 11 * Double.hashCode(salary) + 13 * Objects.hashCode(hireDay);// 如果成员为数组,则使用Arrays.hashCode()&#125; 或者使用Objects.hash(Object… values)123public int hashCode() &#123; return Objects.hash(name, salary, hireDay);&#125; Objects.hashCode(Object o)是null安全的,当参数为null则返回0,否则返回对参数调用Object.hashCode()的结果注意:只有一个参数的时候不要使用Objects.hash(),而是Objects.hashCode(Object o)或者Doubles.hashCode(Double d) Objects.hash(Object… values)源码123public static int hash(Object... values) &#123; return Arrays.hashCode(values);&#125; Arrays.hashCode(Object a[])源码1234567891011public static int hashCode(Object a[]) &#123; if (a == null) return 0; int result = 1; for (Object element : a) result = 31 * result + (element == null ? 0 : element.hashCode()); return result; &#125; toString方法toString()方法返回表示对象值的字符串 官方文档 Object类的toString方法123public String toString() &#123; return getClass().getName() + "@" + Integer.toHexString(hashCode());&#125; 他返回 getClass().getName() + &#39;@&#39; + Integer.toHexString(hashCode()) toString()为什么随处可见只要对象与一个字符串通过操作符”+”连接起来,Java编译就会自动调用toString方法 数组的toString方法数组继承了Object类的toString,仍会像Object类那样输出字符串,大概输出如下[I@1a46e30]这不符合我们的预期,修正方法如下: Arrays.toString()调用静态方法Arrays.toString(),返回对象大概为[2,3,5,7,11,13]如果想要打印多维数组,调用 Arrays.deepToString() 测试类Employee与Manager的源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.time.LocalDate;import java.util.Objects;public class Employee &#123; private String name; private double salary; private LocalDate hireDay; public Employee(String n, double s, int year, int month, int day) &#123; name = n; salary = s; hireDay = LocalDate.of(year, month, day); &#125; public String getName() &#123; return name; &#125; public double getSalary() &#123; return salary; &#125; public LocalDate getHireDay() &#123; return hireDay; &#125; public void raiseSalary(double byPercent) &#123; double raise = salary * byPercent / 100; salary += raise; &#125; public boolean equals(Object otherObject) &#123; if (this == otherObject) return true; if (otherObject == null) return false; if (getClass() != otherObject.getClass()) return false; Employee other = (Employee) otherObject; return Objects.equals(name, other.name) &amp;&amp; salary == other.salary &amp;&amp; Objects.equals(hireDay, other.hireDay); &#125; public int hashCode() &#123; return 7 * Objects.hashCode(name) + 11 * Double.hashCode(salary) + 13 * Objects.hashCode(hireDay); &#125; /* public int hashCode() &#123; * return Objects.hash(name, salary, hireDay); * &#125; * */ public String toString() &#123; return getClass().getName() + "[name = " + name + ",salary = " + salary + ",hireDay = " + hireDay + "]"; &#125;&#125; 1234567891011121314151617181920212223242526272829303132public class Manager extends Employee &#123; private double bonus; public Manager(String n, double s, int year, int month, int day) &#123; super(n, s, year, month, day); bonus = 0; &#125; public double getSalary() &#123; double baseSalary = super.getSalary(); return baseSalary + bonus; &#125; public void setBonus(double b) &#123; bonus = b; &#125; public boolean equals(Object otherObject) &#123; if (!super.equals(otherObject)) return false; Manager other = (Manager) otherObject; return bonus == other.bonus; &#125; public int hashCode() &#123; return super.hashCode() + 17 * Double.hashCode(bonus); &#125; public String toString() &#123; return super.toString() + "[bonus = " + bonus + "]"; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java继承之子类访问父类的私有域]]></title>
    <url>%2F2018%2F06%2F01%2FJava%E7%BB%A7%E6%89%BF%E4%B9%8B%E5%AD%90%E7%B1%BB%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[在类的继承中,子类可以访问父类的公有方法和域,但对于父类的私有成员则不能访问,但很多情况下,子类也应当拥有父类的私有属性,例如一个雇员Employee有名字,薪资,雇佣时间等属性,经理Manager也属于雇员,那么经理也应当有名字,薪资,雇佣时间等,那么问题就来了,子类如何才能使用父类的私有成员?请看下面代码123456789101112131415161718public class Father &#123; private int a; // 默认构造方法,如果没有此方法,子类构造器第一句必须调用super() public Father() &#123; &#125; public Father(int a) &#123; this.a = a; &#125; public int getA() &#123; return a; &#125; public void setA(int a) &#123; this.a = a; &#125;&#125; 1234567891011121314151617public class Son extends Father&#123; public Son() &#123; // 如果子类没有显式调用super(),则自动调用父类默认(没有参数)的构造器,如果父类没有默认构造器,则报错 &#125; public Son(int a) &#123; super(a); // super()必须是子类构造器的第一句 &#125; public static void main(String[] args) &#123; Son son1 = new Son(); son1.setA(123); // 第一种给父类成员赋值的方法,调用setter() Son son2 = new Son(234); // 第二种给父类成员赋值的方法,构造器初始化 System.out.println(son.getA()); // 调用getter()获取父类成员 &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找]]></title>
    <url>%2F2018%2F06%2F01%2F%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%E7%9A%84%E6%80%9D%E6%83%B3%E4%B8%8E%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[折半查找的思想与作用折半查找又称二分查找，是适用于有序表的查找，它的查找时间复杂度是O(logn)，代码如下： 12345678910111213int Binary_Search(SeqList L, ElemType key) &#123; int low = 0, high = L.length - 1, mid; while (low &lt;= high) &#123; mid = (low + high) / 2; if (L.elem[mid] == key) return mid; else if (L.elem[mid] &gt; key) high = mid - 1; else low = mid + 1; &#125; return -1;&#125; 对二分查找的应用，不仅仅是在有序表中找到key那么简单，它还有很多的变通，最让我印象深刻的是leetcode上的Longest Common Prefix，使用二分查找对第0个字符串进行二分，然后判断mid之前的子串是否为共同子串，如果是则high=mid+1，如果不是则low=mid-1，最后返回substring(0,(low+high)/2) 需要注意的是，二分查找查找失败时low和high的值，high为有序表中待查元素的直接前驱，low为待查元素的直接后驱，这个结论用处很多。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让类实现for-each loop:Iterable与Iterator接口]]></title>
    <url>%2F2018%2F06%2F01%2FIterable%E4%B8%8EIterator%2F</url>
    <content type="text"><![CDATA[Interface Iterable&lt;T&gt;根据Java API上写: Implementing this interface allows an object to be the target of the “for-each loop” statement. 也就是说,实现该接口可以让类实现for循环阅读Iterable源码,该接口有3个方法 Modifier,Type and Method Description public interface Iterable&lt;T&gt; &nbsp; default void forEach(Consumer action) Performs the given action for each element of the Iterable until all elements have been processed or the action throws an exception. Iterator&lt;T&gt; iterator() Returns an iterator over elements of type T. default Spliterator spliterator() Creates a Spliterator over the elements described by this Iterable. 可以知道,实现该接口,我们只需要实现Iterator iterator()由API: Iterator iterator()Returns an iterator over elements of type T.Returns:an Iterator. 我们只需要返回一个Iterator对象就可以了 Interface IteratorJava API中说到: An iterator over a collection. Iterator takes the place of Enumeration in the Java Collections Framework. Iterators differ from enumerations in two ways:Iterators allow the caller to remove elements from the underlying collection during the iteration with well-defined semantics.Method names have been improved. 其实就是一个迭代器啦… Modifier,Type and Method Description public interface Iterator&lt;E&gt; &nbsp; default void forEachRemaining(Consumer action) Performs the given action for each remaining element until all elements have been processed or the action throws an exception. boolean hasNext() Returns true if the iteration has more elements. E next() Returns the next element in the iteration. default void remove() Removes from the underlying collection the last element returned by this iterator (optional operation). 可以知道,实现该接口,只要实现next()与hasNext(),当有remove()需求时,也要实现该方法. 下面是具体实现1.类名中加上implements Iterable1public class ClassName&lt;E&gt; implements Iterable&lt;E&gt; 2.实现Iterator iterator(),返回Iterator对象1public Iterator&lt;E&gt; iterator() &#123; return new MyIterator&lt;E&gt;(); &#125; 3.实现内部类MyIterator1234567891011121314private class MyIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123; public boolean hasNext() &#123; //return true if the iteration has more elements &#125; public E next() &#123; if (!hasNext()) throw NoSuchElementException(); // returns the next element in the iteration &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125;&#125; 对Iterator的next()与remove()方法的解释Java的迭代器认为是位于两个元素之间的,当调用next()的时候,迭代器就会越过下一个元素,并返回越过的元素的引用 即如果要用remove()连续删除2个相邻的元素1234Iterator&lt;String&gt; it = instance.iterator(); // 假设instance是实现了Iterable接口的类的实例,泛型指定为Stringit.next();it.remove();it.remove(); // error! 上面的是不行的,因为Java的迭代器并不像C++根据数组索引建模的,在Java迭代器中,查找操作与位置变更是紧密相连的,查找一个元素的唯一方法是调用next(),而执行查找操作的同时,迭代器的位置随之向前移动12345Iterator&lt;String&gt; it = instance.iterator(); // 假设instance是实现了Iterable接口的类的实例,泛型指定为Stringit.next();it.remove();it.next();it.remove(); // OK 调用next()的过程见下图]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Iterable</tag>
        <tag>Iterator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaDoc与Jar]]></title>
    <url>%2F2018%2F06%2F01%2FJavaDoc%E4%B8%8EJar%2F</url>
    <content type="text"><![CDATA[使用JavaDoc生成文档1javadoc -d 目录名 -encoding UTF-8 -charset UTF-8 xxx.java java内格式： /** 文档内容 / @author : 对类的说明，表明开发该类模块的作者 @version : 对类的说明，表明该模块版本 @see : 对类，属性，方法的说明，参考转向，也就是相关主题 @param : 对方法的说明，对方法中某参数的说明 @return : 对方法的说明，对方法返回值的说明 @exception : 对方法的说明，对方法可能抛出的异常进行说明 下为《算法》中StdRandom.java源码的注释与文档效果 使用jar打包（1）编译 javac A.java （2）打包 jar cvfm A.jar A.man A.class ——c表示创建(create)，v表示显示详情(verbose)，f表示指定文件名，m表示清单文件（3）运行 java -jar A.jar 其中A.man是清单文件（manifest），内容如下：·Manifest-Version：1.0Class-Path：.Main-Class：A]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JavaDoc</tag>
        <tag>Jar</tag>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
