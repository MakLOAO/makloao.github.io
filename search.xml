<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Servlet05-无脚本JSP]]></title>
    <url>%2F2018%2F09%2F01%2FServlet05-%E6%97%A0%E8%84%9A%E6%9C%ACJSP%2F</url>
    <content type="text"><![CDATA[Servlet05-无脚本JSPbean法则-使用bean的规范 必须有一个无参数的公共构造函数 必须按命名规范来命名公共的getter和setter setter的参数类型和getter的返回类型必须一致 性质名和类型是由setter和getter得出，而不得来自于类中的一个成员 结合JSP使用时，性质类型必须是String或其他基本类型 使用EL对于model Person，它是一个JavaBean，所以我们要使用与bean相关的标准动作 使用脚本： 123456&lt;html&gt;&lt;body&gt;&lt;% foo.Person p = (foo.Person) request.getAttribute("person"); %&gt;Person is : &lt;%= p.getName() %&gt;&lt;/body&gt;&lt;/html&gt; 使用标准动作： 123456&lt;html&gt;&lt;body&gt;&lt;jsp:useBean id="person" class="foo.Person" scope="request" /&gt;Person created by servlet: &lt;jsp:getProperty name="person" property="name" /&gt;&lt;/body&gt;&lt;/html&gt; 分析&lt;jsp:useBean&gt;和&lt;jsp:getProperty&gt;&lt;jsp:useBean&gt;用 &lt;jsp:useBean&gt; 声明和初始化一个bean属性，id为声明bean对象的标识符，对应于servlet的request.setAttribute(&quot;person&quot;, p)，class为声明的对象的类类型，scope标识这个bean对象的属性作用域 &lt;jsp:useBean&gt;还可以创建一个bean，如果它找不到一个名为”person”的属性对象，它就会建一个 &lt;jsp:getProperty&gt;用 &lt;jsp:getProperty&gt;得到bean属性的性质值，name标识具体的bean对象，与&lt;jsp:useBean&gt;的id属性相匹配，property标识属性中的性质名(也就是与bean类中getter和setter对应的性质) &lt;jsp:setProperty&gt;&lt;jsp:setProperty&gt;是第三个（也是最后一个）bean标准动作，具体使用如下 &lt;jsp:setProperty name=&quot;person&quot; property=&quot;name&quot; value=&quot;yourNameVal&quot; /&gt; &lt;jsp:useBean&gt;可以有体如果把设置方法代码&lt;jsp:setProperty&gt;放在&lt;jsp:useBean&gt;的体中，就可以有条件地设置性质，只有创建新bean时才设置性质值 123&lt;jsp:useBean id="person" class="foo.Person" scope="page" &gt; &lt;jsp:setProperty name="person" property="name" value="yourNameVal" /&gt;&lt;/jsp:useBean&gt; 多态bean引用 &lt;jsp:useBean&gt;的type属性可以用&lt;jsp:useBean&gt;的type属性实现引用类型不同于具体的对象类型，假设新对象的类型为Employee，引用类型是Person &lt;jsp:useBean id=&quot;person&quot; type=&quot;foo.Person&quot; class=&quot;foo.Employee&quot; scope=&quot;page&quot;&gt; 可以实现效果，生成的servlet代码大概如下 12345foo.Person person = null;// 得到person属性的代码if (person == null) &#123; person = new foo.Employee();&#125; type可以是class类型，抽象类型或者是一个接口，class必须是type的一个子类或具体实现，type是声明的类型，而class是要实例化的类 直接从表单请求到JSP - param属性可以通过设置name一致达到直接从请求到JSP的效果，不需要途中经过servlet 假设表单是这样的： 123456789&lt;html&gt; &lt;body&gt; &lt;form action="TestBean.jsp"&gt; name: &lt;input type="text" name="userName"&gt; ID#: &lt;input type="text" name="userID"&gt; &lt;input type="submit"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 在TestBean.jsp中 123&lt;jsp:useBean id="person" type="foo.Person" class="foo.Employee"&gt; &lt;jsp:setProperty name="person" property="name" param="userName" /&gt;&lt;/jsp:useBean&gt; 利用param属性，可以把bean的性质值设置为一个请求参数的值，只需指定请求参数 甚至不需要param属性只要把表单内的内容设置与bean的性质一致，甚至可以不需要param属性，如下 123456789&lt;html&gt; &lt;body&gt; &lt;form action="TestBean.jsp"&gt; name: &lt;input type="text" name="name"&gt; ID#: &lt;input type="text" name="userID"&gt; &lt;input type="submit"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 在TestBean.jsp中 123&lt;jsp:useBean id="person" type="foo.Person" class="foo.Employee"&gt; &lt;jsp:setProperty name="person" property="name" /&gt;&lt;/jsp:useBean&gt; 如果设置表单中所有请求参数名都与bean性质名匹配，那么甚至连property都可以省略 如下 123456789&lt;html&gt; &lt;body&gt; &lt;form action="TestBean.jsp"&gt; name: &lt;input type="text" name="name"&gt; ID#: &lt;input type="text" name="empID"&gt; &lt;input type="submit"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 在TestBean.jsp中 123&lt;jsp:useBean id="person" type="foo.Person" class="foo.Employee"&gt; &lt;jsp:setProperty name="*" property="name" /&gt;&lt;/jsp:useBean&gt; 性质是引用类型的情况假如Person有一个Dog “dog”性质，Dog有一个String “name”性质，如果想打印Person的dog的name，可以用到EL，如下 123&lt;html&gt;&lt;body&gt;Dog's name is : $&#123;person.dog.name&#125;&lt;/body&gt;&lt;/html&gt; 对${person.dog.name}的解释${person.dog.name} 等同于 &lt;%= ((foo.Person) request.getAttribute(&quot;person&quot;)).getDog().getName() %&gt; 使用点号(.)可以访问性质和映射值 使用中括号[]，更好的点号点号右边是一个bean性质或映射键的时候，点号操作符才能正常工作，但[]操作符就强大很多，它既可以完成点号操作符能完成的工作，也可以当左边变量是一个数组或者List或者右边不遵循正常的Java命名规范的时候仍然可以正常工作 EL中的隐式对象param与paramValuesHTML表单中 12345678&lt;form action="TestBean.jsp"&gt; name: &lt;input type="text" name="name"&gt; ID#: &lt;input type="text" name="empID"&gt; First food: &lt;input type="text" name="food"&gt; Second food: &lt;input type="text" name="food"&gt; &lt;input type="submit"&gt;&lt;/form&gt; 对于单个值，可以在JSP中${param.name}获取表单的name对于多个值，可以在JSP中${paramValues.food[0]}获取多个值中的一个 EL的其他隐式对象得到”host”首部${header[&quot;host&quot;]}或${header.host} 得到Cookie打印”userName” Cookie的值 使用脚本： 12345678&lt;% Cookie[] cookies = request.getCookies();for (int i = 0; i &lt; cookies.length; i++) &#123; if ((cookies[i].getName()).equals("userName")) &#123; out.println(cookies[i].getValue()); &#125;&#125;%&gt; 使用EL： ${cookie.uesrName.value} 上下文参数在web.xml中 1234&lt;context-param&gt; &lt;param-name&gt;mainEmail&lt;/param-name&gt; &lt;param-value&gt;12345@outlook.com&lt;/param-value&gt;&lt;/context-param&gt; 使用脚本：&lt;%= application.getInitParameter(&quot;mainEmail&quot;) %&gt; 使用EL：${initParam.mainEmail} EL函数使用EL函数有如下四步骤 编写一个有公共静态方法的Java类 编写一个标记库描述文件(.tld) 在JSP中放一个taglib指令 使用EL调用函数 编写一个有公共静态方法的Java类1234567package com.xhj.web;public class DiceRoller &#123; public static int rollDice() &#123; return (int) ((Math.random() * 6) + 1); &#125;&#125; 编写一个标记库描述文件IDEA中在web目录右键new -&gt; xml configuration file -&gt; JSP tag library descriptor 重命名为*.tld 123456789101112131415161718&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;&lt;taglib xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-jsptaglibrary_2_1.xsd" version="2.1"&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;uri&gt;DiceFunctions&lt;/uri&gt; &lt;function&gt; &lt;name&gt;rollIt&lt;/name&gt; &lt;function-class&gt;com.xhj.web.DiceRoller&lt;/function-class&gt; &lt;function-signature&gt;int rollDice()&lt;/function-signature&gt; &lt;/function&gt; &lt;!-- Invoke 'Generate' action to add tags or functions --&gt;&lt;/taglib&gt; 在JSP中放一个taglib指令&lt;%@ taglib prefix=&quot;mine&quot; uri=&quot;DiceFunctions&quot; %&gt; 使用EL调用函数正文添加${mine:rollIt()} 对TLD文件的解释 TLD中的uri对应JSP中taglib指令的uri属性 TLD中function里的name标签的值对应EL表达式中冒号右边使用的函数 TLD中function-class标签对应.class TLD中function-signature标签的值对应.class里的公共静态方法及其返回值 taglib指令中的prefix属性的值对应EL表达式冒号左边的值 *.tld文件可以放在WEB-INF目录或者其某个子目录中 EL处理null对于找不到表达式中指定的属性/性质/键，也会显示页面，在算术表达式中，EL把null值看做是0，在逻辑表达式中，EL把null看做是false 可复用的模板部件对于网站上每个页面的页眉和页脚都一样的情况下，每个JSP反复编写同样的页眉页脚，会显得效率低下，这个时候可以使用include指令把相同的页面放在不同网页对应的位置上 &lt;include&gt;指令用法：&lt;%@ include file=&quot;*.jsp&quot; %&gt; &lt;jsp:include&gt;标准动作用法&lt;jsp:include page=&quot;*.jsp&quot; /&gt; &lt;include&gt;与&lt;jsp:include&gt;的区别include指令在转换时发生，&lt;jsp:include&gt;标准动作在运行时发生include指令相当于复制代码粘贴，标准动作则根据页面属性创建一个RequestDispatcher，并应用include()方法。 注意！不需要把&lt;html&gt;和&lt;body&gt;标签放到可复用部件中 &lt;jsp:param&gt;定制包含的内容假设我们已经有了一个页眉，但是如果我们想要定制页眉的某一部分，比如我希望在页眉上有一个与上下文相关的子标题，它要依页面而定，如下 在对应的jsp文件中 1234567&lt;html&gt;&lt;body&gt;&lt;jsp:include page="Header.jsp"&gt; &lt;jsp:param name="subTitle" value="aha!this is a sub title." /&gt;&lt;/jsp:include&gt;&lt;/body&gt;&lt;/html&gt; 在Header.jsp中 12&lt;img src="directory/images/xxx.png"&gt;&lt;em&gt;&lt;strong&gt;$&#123;param.subTitle&#125;&lt;/strong&gt;&lt;/em&gt; &lt;jsp:forward&gt;转发可以从一个JSP转发到另一个JSP，或者从一个JSP转发到一个servlet，还可以从一个JSP转发到WEB应用中任何其他资源。比如客户访问页面，如果没有登录，就转向另一个页面 123&lt;% if (request.getParameter("userName") == null) &#123; &gt; &lt;jsp:forward page="xx.jsp" /&gt;&lt;% &#125; %&gt;]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>JSP</tag>
        <tag>EL</tag>
        <tag>bean</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSCript04-面向对象的程序设计]]></title>
    <url>%2F2018%2F09%2F01%2FJavaScript04-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[JavaSCript04-面向对象的程序设计理解对象可以通过以下方式初始化一个对象 123456789var person = &#123; name: "Nicholas", age: 29, job: "Software Engineer", sayName: function() &#123; alert(this.name); &#125;&#125; 属性类型数据属性数据属性包含一个数据值的位置，在这个位置可以读取和写入值，数据属性有4个描述其行为的特性 Configurable: 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性改为访问器属性，默认为true Enumerable: 表示能否通过for-in循环返回属性，默认为true Writable: 表示能否修改属性的值，默认为true Value: 包含这个属性的数据值，默认为undefined 可以通过Object.defineProperty()方法修改默认的特性，接收三个参数：属性所在的对象，属性名和一个描述符对象e.g. 12345678var person = &#123;&#125;;Object.defineProperty(person, "name", &#123; writable: false, value: "Nicholas"&#125;);alert(person.name); // "Nicholas"person.name = "Greg";alert(person.name); // "Nicholas" 在调用Object.defineProperty()方法修改同一个属性时，如果不指定，configurable、enumerable、writable特性的默认值都为false 访问器属性访问器属性不包含数据值，它们包含一对getter函数和setter函数，在读取访问器属性时会调用getter函数，这个函数负责返回有效的值，在写入访问器属性时调用setter函数，这个函数负责决定如何处理数据，访问器属性有如下4个特性 Configurable: 同上 Enumerable: 同上 Get: 在读取属性时调用的函数，默认为undefined Set: 在写入属性时调用的函数，默认为undefined 访问器属性不能直接定义，必须使用Object.defineProperty()来定义 e.g. 12345678910111213141516171819var book = &#123; _year: 2004, edition: 1&#125;;Object.defineProperty(book, "year" &#123; get: function() &#123; return this._year; &#125;, set: function(newValue) &#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125;&#125;);book.year = 2005;alert(book.edition); // 2 若没有指定getter，则属性不能读，若没有指定setter，则属性不能写 定义多个属性ECMAScript5定义了一个Object.defineProperties()方法，可以通过描述符一次定义多个属性，这个方法接收2个对象参数，第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应 e.g. 123456789101112131415161718192021222324var book = &#123;&#125;;Object.defineProperties(book, &#123; _year: &#123; writable: true, value: 2004 &#125;, edition: &#123; writable: true, value: 1 &#125;, year: &#123; get: function() &#123; return this._year; &#125;, set: function() &#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125; &#125;&#125;); 可以使用Object.getOwnPropertyDescriptor()来获取对象的特性值 123456789var descriptor = Object.getOwnPropertyDescriptor(book, "_year");alert(descriptor.value); // 2004alert(descriptor.configurable); // falsealert(typeof descriptor.get); // undefinedvar descriptor = Object.getOwnPropertyDescriptor(book, "year");alert(descriptor.value); // undefinedalert(descriptor.enumerable); // falsealert(typeof descriptor.get); // "function" 创建对象工厂模式工厂模式抽象了创建具体对象的过程e.g. 123456789101112function createPerson(name, age, job) &#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function() &#123; alert(this.name); &#125; return o;&#125;var person1 = createPerson("Nicholas", 29, "Software Engineer"); 构造函数模式类似Object，Array都有原生的构造函数，此外还可以创建自定义构造函数，从而定义自定义对象类型的属性和方法e.g. 1234567891011function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; o.sayName = function() &#123; alert(this.name); &#125;&#125;var person1 = new Person("Nicholas", 29, "Software Engineer");var person2 = new Person("Greg", 27, "Doctor"); 构造函数的问题使用构造函数模式的缺点就是每个方法都要在每个实例上重新创建一遍在前面例子中，person1和person2的sayName()方法不是同一个Function的实例。每个Person对象的实例都包含一个不同的Function实例alert(person1.sayName == person2.sayName); // false可以通过把函数定义转移到构造函数外部解决这个问题 1234567891011121314function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; o.sayName = sayName; &#125;&#125;function sayName() &#123; alert(this.name);&#125;var person1 = new Person("Nicholas", 29, "Software Engineer");var person2 = new Person("Greg", 27, "Doctor"); 原型模式我们创建的每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。按字面意思理解，prototype就是通过调用构造函数创建的那个对象实例的原型对象。使用原型对象好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中，如下例子 123456789101112131415function Person() &#123; &#125;Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function() &#123; alert(this.name);&#125;;var person1 = new Person();person1.sayName(); // "Nicholas"var person2 = new Person();alert(person1.sayName == person2.sayName); // true 与构造函数模式不同，新对象的这些属性和方法是由所有实例共享的。 虽然可以通过对象实例访问保存在原型中的值，但不能通过对象实例重写原型中的值，如果我们在实例中添加一个与原型中一个属性同名的属性，那我们就在实例中创建该属性，并屏蔽原型中的那个属性。通过delete可以重新获取来自原型的属性 1234var person1 = new Person();person1.name = "Greg";delete person1.name;alert(person1.name); // "Nicholas" 理解原型对象无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性是一个指向prototype属性所在函数的指针，关系如下图。 更简单的原型语法12345678910function Person() &#123; &#125;Person.prototype = &#123; name : "Nicholas", age : 29, job : "Software Engineer", sayName : function() &#123; alert(this.name); &#125;&#125;; 但是使用对象字面量重写prototype的问题是constructor属性不再指向Person了，可以通过Object.defineProperty()方法解决 1234Object.defineProperty(Person.prototype, "constructor", &#123; enumerable: false, value: Person&#125;); 原型的动态性尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果是重写整个原型对象，那么情况就不一样了。把原型修改为另一个对象就等于切断了构造函数与最初原型之间的联系，看下面例子 1234567891011121314function Person() &#123; &#125;var friend = new Person();Person.prototype = &#123; constructor : Person, age : 29, job : "Software Engineer", sayName : function() &#123; alert(this.name); &#125;&#125;;friend.sayName(); // error!!! 下图揭示了上述代码整个过程的内幕 原型对象的问题原型对象最大的问题就是它共享的本性，对于包含引用类型值的属性来说，问题就比较突出了，见下面例子 1234567891011121314151617181920function Person() &#123; &#125;Person.prototype = &#123; constructor : Person, name : "Nicholas", age : 29, job : "Software Engineer", friends : ["Shelby", "Court"], sayName : function() &#123; alert(this.name); &#125;&#125;;var person1 = new Person();var person2 = new Person();person1.frineds.push("Van");alert(person2.friends); // "Shelby","Court","Van"alert(person1.friends == person2.friends) // true 组合使用构造函数模式和原型模式构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都有自己的一份实例属性，同时又共享着对方法的引用，最大限度节省了内存。 123456789101112131415function Person(name ,age, job) &#123; this.name = name; this.job = hob; this.age = age; this.friends = ["Shelby", "Court"];&#125;Person.prototype = &#123; constructor : Person, sayName : function() &#123; alert(this.name); &#125;&#125;// 测试代码 动态原型模式它把所有信息都封装在构造函数中，而通过在构造函数中初始化原型，又保持了同时使用构造函数和原型的优点。 1234567891011function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; if (typeof this.sayName != "function") &#123; Person.prototype.sayName = function() &#123; alert(this.name); &#125;; &#125;&#125; 判断语句if那里，只在sayName()不存在的情况下才将它添加到原型中。这段代码只会在初次调用构造函数时才会执行，其中，if语句检查的可以是初始化之后应该存在的任何属性和方法，不必用一大堆if语句检查每个属性和方法。 继承ECMAScript只支持实现继承，主要依靠原型链来实现的 原型链原型链的基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。假如我们让原型对象等于另一个类型的实例，此时的原型对象将包含一个指向另一个原型的指针，响应，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。 123456789101112131415161718192021function SuperType() &#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function() &#123; return this.property;&#125;;function SubType() &#123; this.subproperty = false;&#125;// 继承SuperTypeSubType.prototype = new SuperType();SubType.prototype.getSubValue = function() &#123; return this.subproperty;&#125;;var instance = new SubType();alert(instance.getSuperType()); // true 别忘记默认的原型所有引用类型默认都继承了Object，这个继承也是通过原型链实现的，下图为完整的原型链 原型链要注意的事项 子类型有时候要覆盖超类型中的某个方法，或者需要添加超类型中不存在的某个方法，但不管怎么样，给原型添加方法的代码一定要放在替换原型的语句之后 通过原型链实现继承时，不能使用对象字面量创建原型方法，因为这样做会重写原型链 原型链的问题原型链主要的问题仍然是包含引用类型值的原型。通过原型来实现继承时，原型实际上会变成另一个类型的实例，于是，原先的实例属性也就变成现在的原型属性了。 1234567891011121314function SuperType() &#123; this.colors = ["red", "blue", "green"];&#125;function SubType() &#123; &#125;SubType.prototype = new SuperType();var instance1 = new SubType();instance1.colors.push("black");alert(instance1.colors); // "red","blue","green","black"var instance2 = new SubType();alert(instance2.colors); // "red","blue","green","black" 第二个问题是创建子类型的实例时，不能向超类型的构造函数传递参数。鉴于这两个问题，下面介绍的方法更加实用 借用构造函数在子类型的构造函数的内部调用超类型构造函数，如下 1234567function SuperType() &#123; this.colors = ["red", "blue", "green"];&#125;function SubType() &#123; SuperType.call(this);&#125; 传递参数12345678function SuperType(name) &#123; this.name = name;&#125;function SubType() &#123; SuperType.call(this, "Nicholas"); this.age = 29;&#125; 借用构造函数的问题 方法都在构造函数中定义，函数复用无从谈起 超类型的原型中定义的方法，对子类型而言不可见 组合继承（伪经典继承）把原型链和借用构造函数的技术组合到一起，使用原型链对原型属性和方法继承，借用构造函数对实例属性的继承。 123456789101112131415161718192021function SuperType(name) &#123; this.name = name; this.colors = ["red", "blue", "green"];&#125;SuperType.prototype.sayName = function() &#123; alert(this.name);&#125;function SubType(name, age) &#123; // 继承属性 SuperType.call(this.name); this.age = age;&#125;// 继承方法SubType.prototype = new SuperType();SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function()&#123; alert(this.age);&#125;; 寄生组合式继承组合继承的问题就在于无论什么情况下，都会调用两次超类型构造函数，一次是在创建子类型原型的时候，另一次是在子类型构造函数内部，第一次调用的时候，SubType.prototype会得到两个属性：name和colors，当调用SubType构造函数的时候，又会调用一次SuperType构造函数，这一次又在新对象上创建了实例属性name和colors（与SubType原型一样的属性），于是这两个属性就屏蔽了原型中同名的两个属性。 所谓寄生组合式继承，就是通过借用构造函数来继承属性，通过原型链混成形式继承方法，其背后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型的原型的一个副本而已，这样，子类型的原型就不会有重复多余的超类型继承得来的属性了（因为超类型的原型没有这些属性）。 1234567891011121314151617181920212223242526272829303132function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;function inheritPrototype(subType, superType) &#123; var prototype = object(superType.prototype); prototype.constructor = subType; subType.prototype = prototype;&#125;function SuperType(name) &#123; this.name = name; this.colors = ["red", "blue", "green"];&#125;SuperType.prototype.sayName = function() &#123; alert(this.name);&#125;function SubType(name, age) &#123; // 继承属性 SuperType.call(this.name); this.age = age;&#125;inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function() &#123; alert(this.age);&#125; 这种继承方法高效率体现在它只调用了一次SuperType构造函数，因此避免了在SubType.prototype上创建不必要的，多余的属性。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>JS面向对象</tag>
        <tag>JS原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript03-引用类型]]></title>
    <url>%2F2018%2F09%2F01%2FJavaScript03-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[JavaScript03-引用类型Object类型引用类型的值是引用类型的一个实例，注意引用类型虽然常被称为类，但它与传统面向对象语言的类不一样，ECMAScript没有类和接口等基本结构，ECMAScript的引用类型有时候也称为对象定义，因为它们描述的是一类对象所具有的属性和方法。 两种构造Object实例的方法构造函数123var person = new Object();person.name = "Nicholas";person.age = 29; 对面字面量表示法1234var person = &#123; name : "Nicholas", age : 29&#125;; 访问对象属性1234alert(person.name); // "Nicholas"alert(person["name"]); // "Nicholas"var propertyName = "name";alert(person[propertyName]); // "Nicholas" Array类型与其他语言不一样的是，ECMAScript数组的每一项可以保存任何类型的数据，而且ECMAScript的大小是可以动态调整的。 创建Array的基本方式Array构造函数1234var colors1 = new Array();var colors2 = new Array(20); // 指定Array的长度为20，注意，这里并不是让colors2的第一个元素是20，而是指定其长度20var colors3 = new Array("red", "blue", "green"); 字面量表示法12var colors = ["red", "blue", "green"];var names = []; Arrays.length由于ECMAScript的数组是可以动态调整的，因此其属性length不是只读的，可以为其赋值达到调整数组长度的效果，也可以12var colors = [ some colors ];colors[colors.length] = "other-color"; 为Array添加新元素 一些Array的属性检测数组Array.isArray(value)判断Array是否为数组 转换方法toLocaleString() 返回逗号分割开的字符串，但是调用的是toLocaleString()方法toString() 返回用逗号分割开的数组的每个元素valueOf() 返回数组本身join(param) 用param分割开数组的每个元素 栈方法push(param1,param2,...,paramn)可以接收任意数量参数，按顺序逐个入栈，并返回修改后数组的长度pop()出栈并返回 队列方法shift()删除第一个元素并返回push()同上栈方法的push()unshift(param)数组前端添加任意个项并返回数组的长度 重排序方法reverse()sort()默认的sort()会调用toString()然后比较其字符串的大小来排序，在很多情况下这样排序都不是最佳方案，如下123var values = [0, 1, 5, 10, 15];values.sort();alert(values); // 0,1,10,15,5 可以通过重排序方法接收一个比较函数作为参数来排序比较函数接收两个参数，如果第一个参数应位于第二个参数之前则返回一个负数，相等返回0,否则返回正数，以下为一个简单的比较函数123456789101112function compare(value1, value2) &#123; if(value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125;&#125;var values = [0, 1, 5, 10, 15];values.sort(compare);alert(values); // 0,1,5,10,15 对于数值类型或者valueOf()方法会返回数值的类型，只要123function compare(value1, value2) &#123; return value2-value1;&#125; 操作方法cancat()会创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组，如果没有参数，则只是复制当前数组并返回副本slice()切片，接收1个或2个参数，即要返回项的起始和结束位置。 splice()： 删除：接收2个参数，删除的第一项的位置和要删除的项数 插入：三个参数，起始位置，0（要删除的项数），要插入的项，如果要插入多项，可以传递3个以上的参数 替换：三个参数，起始位置，要删除的项，要插入的任意数量的项 它始终返回一个数组，包含从原始数组中删除的项。 位置方法indexOf()lastIndexOf()接收2个参数，要查找的项和表示查找起点位置的索引，indexOf()从起点开始往后查找，lastIndexOf()从起点开始往前查找，返回要查找的项在数组中的位置，没找到则返回-1注意位置方法必须严格相等12345var person = &#123; name : "Nicholas" &#125;;var errPeople = [&#123; name : "Nicholas" &#125;];var corPeoole = [person];alert(errPeople.indexOf(person)); // -1alert(corPeople.indexOf(person)); // 0 迭代方法ECMAScript的迭代方法接收2个参数，要在每一项上运行的函数和（可选）运行该函数的作用域对象，传入的函数接收三个参数，数组项的值，该项在数组的位置和数组对象本身。every()对数组的每一项运行给定函数，如果该函数对每一项都返回true，则返回truefilter()对数组的每一项运行给定函数，返回该函数会返回true的项组成的数组forEach()对数组每一项运行给定函数，这个方法没有返回值map()对数组每一项运行给定函数，返回每次函数调用的结果组成的数组some()对数组每一项运行给定函数，如果该函数对任一项返回true，则返回true123456789var numbers = [1,2,3,4,5,4,3,2,1];var everyResult = numbers.every(function(item,index,array)&#123;return (item&gt;2)&#125;);alert(everyResule); // falsevar mapResult = numbers.map(function(item, index, array)&#123;return item * 2;&#125;);alert(mapResult); // [2,4,6,8,10,8,6,4,2]numbers.forEach(function(item, index, array)&#123; /* do something on item */ &#125;); 归并方法reduce()reduceRight()迭代数组的所有项，然后构建一个最终返回的值，reduce()从第一项开始迭代，reduceRight()从最后一项开始，接收两个参数，一个在每一项上调用的函数和（可选）作为归并基础的初始值，传入的函数接收4个参数，前一个值，当前值，项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项1234// e.g. 求和var values = [1,2,3,4,5];var sum = values.reduce(function(prev, cur, index, array)&#123;return prev + cur;&#125;);alert(sum); // 15 Date类型ECMAScript的Date类型类似于java.util.Date类，使用自UTC 1970年1月1日午夜开始经过的毫秒数来保存日期创建一个日期对象可以var now = new Date()可以为构造函数传递毫秒来构建Date对象 Date.parse()接收一个表示日期的字符串参数，转换为毫秒数地区为美国的浏览器接收下列日期格式： “月/日/年”，如6/13/2004; “英文月名 日,年”，如January 12,2004 “英文星期几 英文月名 日 年 时:分:秒 时区”，如 Tue May 25 2004 00:00:00 GMT-0700 ISO 8601扩展格式 YYYY-MM-DDTHH:mm:ss.sssz(如2004-05-25T00:00:00) e.g. 构建2004/5/24的日期对象 var someDate = new Date(Date.parse(&quot;May 25, 2004&quot;));实际上var someDate = new Date(&quot;May 25, 2004&quot;);会自动调用parse Date.UTC()Date.UTC()参数为年份，基于0的月份，月中的日，小时，分钟，秒以及毫秒，年和月是必须的，其他可选，返回对应的毫秒数 e.g. var y2k = new Date(2000, 0);构建2000年1月1日0时的时间 Date.now()返回调用这个函数的时间的毫秒数 继承的方法toLocaleString()可能时间格式会有AM或PMtoString()带有时区信息的日期和时间valueOf()返回毫秒 日期格式化方法 toDateString()——以特定于实现的格式显示星期几，月，日，年 toTimeString()——以特定于实现的格式显示时，分，秒和时区 toLocaleDateString()——以特定于地区的格式显示 toLocaleTimeString()——同上 toUTCString()——以特定于实现的格式完整的UTC日期 其他日期/时间组件方法w3school列出的Date对象方法 RegExp类型ECMAScript通过RegExp类型来支持正则表达式,由于之前学Python的时候有认真的学过正则，但是一段时间没用就忘得差不多了，所以在没有用到的时候就先不学了，摆个链接在需要的时候再去看w3school RegExp对象 Function类型函数是对象，因此函数名实际上是一个指向函数对象的指针，不会与某个函数绑定由于函数名是指针,所以ECMAScript也没有函数重载的概念 函数声明与函数表达式看下面例子1234alert(sum(10, 10));function sum(num1, num2) &#123; return num1 + num2;&#125; 以上代码完全可以执行,因为在代码开始执行之前,解析器会通过一个名为函数声明提升的过程,读取并将函数声明添加到执行环境中,对代码求值时,JavaScript引擎在第一遍会声明函数并将它们放到源代码树的顶部,所以即使先调用函数再定义也不会出错,而像下面的例子就会报错1234alert(sum(10, 10));var sum = function(num1, num2) &#123; return num1 + num2;&#125; 原因在于函数位于一个初始化语句中,而不是一个函数声明 同样的,由于函数为对象,它可以作为另一个函数的参数或返回值. 函数内部属性arguments及其属性callee函数内部有两个特殊的对象:arguments和this,arguments保存传入函数中的所有参数,arguments还有一个属性名为callee,该属性是一个指针,指向拥有这个arguments对象的函数请看下面例子1234567function factorial(num) &#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * factorial(num-1); &#125;&#125; 上面例子中,如果函数名字不会发生改变,那么这样定义是没有问题的,但如果函数名字改变了,则会发生错误,可以用下面的例子来解决1234567function factorial(num) &#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num-1); &#125;&#125; thisthis与Java的this类似,引用的是函数执行的环境对象(当在网页的全局作用域中调用函数时,this对象引用的就是window)1234567891011window.color = "red";var o = &#123; color: "blue" &#125;;function sayColor() &#123; alert(this.color);&#125;sayColor(); // "red" 引用this对象为windowo.sayColor = sayColor;o.sayColor(); // "blue" caller这个属性保存调用当前函数的函数的引用,若在全局作用域中调用当前函数,则它的值为null123456789function outer() &#123; inner();&#125;function inner() &#123; alert(inner.caller); // 返回outer的源码&#125;outer(); 函数属性和方法lengthlength属性表示函数希望接收的命名参数的个数 prototype保存实例方法,不可枚举 call()与apply()在特定的作用域中调用函数,call()接收第一个参数为运行函数的作用域,后面多个参数为函数的参数,allpy()接收2个参数,第一个为运行函数的作用域,第二个为参数数组或arguments,它们可以用于扩充函数的作用域123456789101112window.color = "red";var o = &#123; color: "blue" &#125;;function sayColor() &#123; alert(this.color);&#125;sayColor(); //redsayColor.call(this); //redsayColor.call(window); //redsayColor.call(o); //blue bind()创建一个函数的实例,并将该实例的this绑定在bind()的参数上123456789window.color = "red";var o = &#123; color: "blue" &#125;;function sayColor() &#123; alert(this.color);&#125;var objectSayColor = sayColor.bind(o);objectSayColor(); //blue 基本包装类型–特殊的引用类型引用类型与基本包装类型最大的区别是对象的生命周期,使用new创建的引用类型的实例,在执行流离开当前作用域之前都一直保存在内存中,而自动创建的基本包装类型的对象,则只存在于一行代码的执行瞬间,然后就会销毁. Boolean建议不适用Boolean对象,而是使用布尔值 Number重写了valueOf(),toLocaleString()和toString(),toString()可以传入参数显示返回几进制数值,除了继承的方法,Number类型还提供了一些用于将数值格式化为字符串的方法num.toFixed(2) // 仅显示小数点后两位,四舍五入num.toExponential(1) // 小数位数为1的指数表示法(e表示法)num.toPrecision() // 返回自适应格式,参数为小数位显示 String字符方法stringValue.charAt(num);stringValue[num];stringValue.charCodeAt(num); // 返回num所在的字符的字符编码 字符串操作方法stringValue.concat(otherString);stringValue.substring();stringValue.slice();stringValue.substr(); // 第一个参数开始位置，第二个为字符串长传入负数后它们的行为不一样，不详述 字符串位置方法stringValue.indexOf()stringValue.lastIndexOf()stringValue.trim() // 删除前置后缀所有空格并返回 字符串大小写转换方法stringValue.toLocaleUpperCase(); // 和下面那个一样，不过一般用这个比较多stringValue.toUpperCase();stringValue.toLocaleLowerCase();stringValue.toLowerCase(); 字符串模式匹配方法stringValue.match()stringValue.search()涉及到正则，偷懒就不写了 localeCompare()比较两个字符串，根据结果返回-1,0,1 单体内置对象由ECMAScript实现提供的，不依赖于寄主环境的对象，在ECMAScript程序执行之前就已经存在了 Global对象偷懒，很多前面都有写，不重复了，书本P131 window对象同上 Math对象提供了数学公式和信息 Math.E 自然对数 Math.LN10 10为底的自然对数 Math.PI π Math.LOG10E 10为底e的对数 Math.SQRT2 2的平方根 等等其他值 舍入方法 Math.ceil() 向上舍入 Math.floor() 向下舍入 Math.round() 四舍五入 random()返回0-1的随机数 其他方法 Math.abs() Math.exp() Math.log() 等等]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>JS引用类型</tag>
        <tag>JS包装类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet02-ServletConfig,ServletContext与监听器]]></title>
    <url>%2F2018%2F09%2F01%2FServlet02-ServletConfig%2CServletContext%E4%B8%8E%E7%9B%91%E5%90%AC%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Servlet02-ServletConfig,ServletContext与监听器通过web.xml可以初始化参数，避免了硬编码改变了源码与重新编译的麻烦，如下：12345678&lt;servlet&gt; &lt;init-param&gt; &lt;param-name&gt;name&lt;/param-name&gt; &lt;param-value&gt;value&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet-name&gt; 在servlet代码中通过1234567来获取该值或者通过下面例子处理```Java Enumeration e = getServletConfig().getInitParameterNames(); while(e.hasMoreElements()) &#123; // do something with e.nextElement(); &#125; 但ServletConfig仅仅能在该servlet中使用，对于想要在全局使用的参数实在不方便，ServletContext可以很好的解决这个问题 ServletContext在web.xml中添加1234&lt;context-param&gt; &lt;param-name&gt;adminEmail&lt;/param-name&gt; &lt;param-value&gt;231232@oaiw.com&lt;/param-value&gt;&lt;/context-param&gt; Servlet中通过getServletContext().getInitParameter(&quot;adminEmail&quot;);来获取 ServletConfig与ServletContext的区别 在部署文件中，上下文初始化参数是在&lt;web-app&gt;中的，而Servlet初始化参数是在servlet中的 ServletConfig的作用域为每个servlet，而ServletContext的作用域为整个WEB应用 ServletContextListener由于ServletContext在初始化的时候只能保存字符串，若要保存一个对象或在应用启动之前利用该字符串做一些准备工作（比如打开数据库），则需要监听器的帮助。ServletContextListener接口可以监听一个上下文初始化事件，得到上下文初始化参数，并在应用为客户提供服务之前运行一些代码，要实现该接口，就要实现下面两个方法public void contextInitialized(ServletContextEvent event)public void contextDestroyed(ServletContextEvent event) 建立一个上下文监听者 创建一个监听者类 把编译后的类*.class放入WEB-INF/classes 在web.xml部署描述文件放一个&lt;listener&gt;元素，如下12345&lt;listener&gt; &lt;listener-class&gt; com.example.MyServletContextListener &lt;/listener-class&gt;&lt;/listener&gt; 一个监听器的例子web.xml中先注册该Listener，然后设置好对应的servlet以及context-param，如下12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"&gt; &lt;servlet&gt; &lt;servlet-name&gt;ListenerTester&lt;/servlet-name&gt; &lt;servlet-class&gt;com.example.web.ListenerTester&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ListenerTester&lt;/servlet-name&gt; &lt;url-pattern&gt;/listen.ht&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;context-param&gt; &lt;param-name&gt;breed&lt;/param-name&gt; &lt;param-value&gt;Great Dane&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;com.example.web.MyServletContextListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt; 监听器的工作是得到该ServletContext的初始值，然后创建一个Dog对象，把该值作为参数传入对象构造函数，并构造一个ServletContext对象，设置该Dog对象作为新的ServletContext的属性。123456789101112131415161718192021package com.example.web;import com.example.model.Dog;import javax.servlet.ServletContext;import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;public class MyServletContextListener implements ServletContextListener &#123; public void contextInitialized(ServletContextEvent event) &#123; ServletContext sc = event.getServletContext(); String dogBreed = sc.getInitParameter("breed"); Dog d = new Dog(dogBreed); sc.setAttribute("dog", d); &#125; public void contextDestroyed(ServletContextEvent event) &#123; &#125;&#125; Dog对象如下1234567891011121314package com.example.model;public class Dog &#123; private String breed; public Dog(String breed) &#123; this.breed = breed; &#125; public String getBreed() &#123; return breed; &#125;&#125; Servlet通过getServletContext().getAttribute(&quot;dog&quot;)得到ServletContext的属性值来获取该Dog对象，这样就可以通过ServletContext对象来获取String以外的值了。 123456789101112131415161718192021222324252627282930package com.example.web;import com.example.model.Dog;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@WebServlet(name = "ListenerTester")public class ListenerTester extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html"); PrintWriter out = response.getWriter(); out.println("test context attributes set by listener&lt;br&gt;"); out.println("&lt;br&gt;"); Dog dog = (Dog) getServletContext().getAttribute("dog"); out.println("Dog's breed is : " + dog.getBreed()); &#125;&#125; 其他监听者 属性API与属性安全 上下文属性无法确保线程安全，要对上下文加锁。 请求属性和请求分派1234request.setAttribute("attrName", attrValue);RequestDispatcher view = request.getRequestDispatcher("*.jsp");view.forward(request, response); 通过从ServletRequest（或ServletContext）得到RequestDispatcher对象，调用forward()把请求转交给JSP处理 注意！如果已经提交了响应，就不能转发请求，否则会报IllegalStateException，os.flush()等方法都是提交响应]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>ServletConfig</tag>
        <tag>ServletContext</tag>
        <tag>Listener</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet04-JSP]]></title>
    <url>%2F2018%2F09%2F01%2FServlet04-JSP%2F</url>
    <content type="text"><![CDATA[Servlet04-JSP基本指令page使用page指令导入包&lt;%@ page import=&quot;foo.*&quot; %&gt;&lt;%@ page import=&quot;foo.*,java.util.*&quot; %&gt; page指令的属性 taglibtaglib定义JSP可用的标记库&lt;%@ taglib tagdir=&quot;/WEB-INF/tags/cool&quot; prefix=&quot;cool&quot; %&gt; includeinclude定义在转换时增加到当前页面的文本和代码&lt;%@ include file=&quot;xxx.html&quot; %&gt;使用此指令允许你建立可重用的块（如标准页面标题或导航栏），这些可重用的块能增加到各个页面上，而不用每个JSP都重复写这些代码 表达式对于&lt;% out.println(Counter.getCount()); %&gt;可以用&lt;%= Counter.getCount() %&gt;代替，不需要分号，表达式内的内容为out.print的参数 声明&lt;%! int count = 0; %&gt;声明该JSP所生成的servlet类的成员 初始化JSP在配置文件中如下配置 12345678910&lt;web-app ...&gt; &lt;servlet&gt; &lt;servlet-name&gt;name&lt;/servlet-name&gt; &lt;jsp-file&gt;/directory/xxx.jsp&lt;/jsp-file&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;name&lt;/servlet-name&gt; &lt;url-pattern&gt;/xxx&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 覆盖jspInit()只要在.jsp文件中实现了jspInit()方法，在JSP页面成为servlet的最开始容器就会调用这个方法，这个方法由servlet的init()方法调用，所以在运行jspInit()方法时，已经有一个ServletConfig和ServletContext可供servlet使用，可以在jspInit()中调用getServletConfig()和getServletContext() 123456&lt;%! public void jspInit() &#123; ServletConfig sConfig = getServletConfig(); // do something &#125;%&gt; 同理jspDestroy()也可以覆盖 JSP的属性除了Servlet拥有的请求，会话和上下文这三个属性，JSP还拥有页面作用域pageContext（隐式对象），常用于开发定制标记 使用PageContext得到属性可以在PageContext引用得到任意作用域的属性 同理使用&lt;% pageContext.setAttribute(&quot;foo&quot;, &quot;attr&quot;, PageContext.SESSION_SCOPE); %&gt;等同于&lt;% session.setAttribute(&quot;foo&quot;, &quot;attr&quot;); %&gt; 使用&lt;%= pageContext.findAttribute(&quot;foo&quot;) %&gt;可以在不知道作用域的情况下查找一个属性 EL预热EL(Expression Language)是无脚本JSP，可以允许开发人员在JSP中不适用Java也能达到同样的效果 为什么使用EL？ 不应该要求WEB页面设计人员必须懂Java JSP中的Java代码很难修改和维护 开启无脚本JSP在配置文件web.xml中 123456789101112&lt;web-app ...&gt; ... &lt;jsp-config&gt; &lt;jsp-property-group&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;scripting-invalid&gt; true &lt;/scripting-invalid&gt; &lt;/jsp-property-group&gt; &lt;/jsp-config&gt; ...&lt;/web-app&gt; 选择忽略EL123456789101112&lt;web-app ...&gt; ... &lt;jsp-config&gt; &lt;jsp-property-group&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;el-ignored&gt; true &lt;/el-ignored&gt; &lt;/jsp-property-group&gt; &lt;/jsp-config&gt; ...&lt;/web-app&gt;]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>JSP</tag>
        <tag>EL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript02-变量，作用域和内存问题]]></title>
    <url>%2F2018%2F09%2F01%2FJavaScript02-%E5%8F%98%E9%87%8F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[JavaScript02-变量，作用域和内存问题变量JavaScript变量只是在特定时间用于保存特定值的一个名字，不存在定义某个变量就必须保存何种数据类型值的规则，变量的值及其数据类型可以在脚本的生命周期内改变。 基本类型和引用类型的值ECMAScript规定基本类型值指的是简单的数据段，而引用数据值指那些可能由多个值构成的对象，在JavaScript中，Undefined,Null,Boolean,Number,String都是基本数据类型，都是按值访问的。而引用类型的值是保存在内存中的对象，只有Object类型是引用数据类型。 动态的属性123var person = new Object();person.name = "PersonName";alert(person.name); // "PersonName" 以上代码我们创建了一个对象并将其值保存在person中，然后为该对象添加了一个名为name的属性，而对基本数据类型，虽然为其添加属性不会报错，但访问该属性的时候并不能成功访问。 复制变量值对于基本数据类型，12var num1 = 5;var num2 = num1; 两个变量之间不会相互影响。 而对于引用数据类型1234var obj1 = new Object();var obj2 = obj1;obj1.name = "objName";alert(obj2.name); // "objName" obj1和obj2引用的都是同一个对象 传递参数基本类型值的传递就如同基本类型变量的复制一样，而引用类型值的传递，也如同引用类型变量的复制一样。 执行环境及作用域执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为，每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中，解析器在处理数据时会在后台使用它。全局执行环境是最外围的一个执行环境。根据ECMAScript实现所在宿主环境不同，表示环境的对象也不同，在WEB浏览器中，全局执行环境被认为是window对象。每个函数都有自己的执行环境，当执行流进入一个函数的时候，函数的环境会进入环境栈，函数执行完毕后栈将其环境弹出，把控制权交还给之前的执行环境。当代码在一个环境中执行，会创建变量对象的一个作用域链。作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前段始终是当前执行代码所在环境的变量对象，如果这个环境是函数，则将其活动对象作为变量对象，该活动最开始时只有一个变量arguments对象。作用域链的下一对象来自包含的环境，再下一个变量对象来自下一个包含环境，一直到全局执行环境。标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，逐级往后回溯，直至找到标识符为止。其实跟Java的作用域在表现上差不多。 延长作用域链以下两个语句都会在作用域链的前端添加一个变量对象。 try-catch语句的catch块 with语句 没有块级作用域123456789if (true) &#123; var color = "blue";&#125;alert(color); // "blue"for (var i = 0; i &lt; 10; i++) &#123; doSomeThing(i);&#125;alert(i); // 10 在JavaScript中，if和for中创建的变量依旧存在于外部的执行环境中。 垃圾收集JavaScript具有自动垃圾收集机制，执行环境会负责管理代码执行过程中使用的内存。 标记清除垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而再次之后再被加上标记的变量将被视为准备删除的变量。 引用计数跟踪记录每个值被引用的次数，当引用次数变为0的时候，就回收其占用的内存空间，循环引用问题无法解决，很少使用。 管理内存对于全局变量，当确定不再使用的时候，可以为其赋值null，让值脱离执行环境，以便垃圾收集器下次运行时将其回收。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>JS作用域链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet之WEB应用体系与MVC]]></title>
    <url>%2F2018%2F09%2F01%2FServlet01-WEB%E5%BA%94%E7%94%A8%E4%BD%93%E7%B3%BB%E4%B8%8E%E5%88%9D%E7%AA%A5MVC%2F</url>
    <content type="text"><![CDATA[#Servlet之WEB应用体系与MVC ##WEB应用体系 ###TOMCAT容器的作用 通信支持容器可以让servlet与WEB容器对话，创建ServerSocket，监听端口，创建流等生命周期管理容器控制着servlet的生命周期，负责加载类，实例化，初始化servlet，调用servlet方法，垃圾回收等多线程支持每次接收到用户servlet请求，就会创建一个新的Java线程，声明方式实现安全使用XML部署描述文件配置安全性JSP支持容器负责把JSP翻译成Java ###容器处理请求 用户点击一个链接，指向一个servlet 容器看出来这个请求要的是一个servlet，创建两个对象，分别为HttpServletResponse，HttpServletRequest 容器根据请求的URL找到对应的servlet，为这个请求分配一个线程，并把请求和响应对象传递给这个servlet线程 容器调用service的service()方法，根据请求的不同类型，service()方法会调用doGet()或doPost()方法 doGet()方法生成动态页面，塞到响应对象里 线程结束，容器把响应对象转换为一个HTTP响应，把它发回给客户，然后删除请求和响应对象 ###servlet的映射方式通过配置部署描述文件web.xml可以配置servlet名对应的URL路径一般的web.xml内容如下1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"&gt; &lt;servlet&gt; &lt;servlet-name&gt;yourDefinedName&lt;/servlet-name&gt; &lt;servlet-class&gt;yourServletClassName&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;yourDefinedName&lt;/servlet-name&gt; &lt;url-pattern&gt;/yourUrl&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; &lt;servlet&gt;元素告诉容器有哪个类文件&lt;servlet-name&gt;元素用于把一个&lt;servlet&gt;元素与一个特定的&lt;servlet-mapping&gt;元素绑定，最终用户看不到这个名字，这个名字只在这个部署文件的其他部分使用&lt;servlet-class&gt;类的完全限定名，但不要加上.class后缀&lt;servlet-mapping&gt;请求到来时，容器会在运行时使用这个元素，来调用对应的servlet&lt;url-pattern&gt;URL的路径 客户知道的URL名对应的是&lt;url-pattern&gt;的值，部署人员知道的秘密的内部名对应的是&lt;servlet-name&gt;的值，实际的文件名对应的是&lt;servlet-class&gt;的值 ##初窥MVCMVC分别为model，view，controller，MVC的关键是业务逻辑与表示分离，实际上，业务逻辑甚至根本不知道有表示存在 ###Model实际的业务逻辑和状态放在模型中，系统中只有这部分与数据库通信 ###Controller从请求获得用户输入，并明确输入对模型的影响，告诉模型自行更新，并让视图得到新的模型状态，一个servlet实际上就是一个控制器 ###View负责表示，它从控制器得到模型的状态，还要获得用户输入，交给控制器，一个JSP文件其实就是一个View ##一个简单的MVC应用目录树如下其中，com.example.web.BeerSelect为控制器，com.example.model.BeerExpert为模型，result.jsp为view web.xml内容如下1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"&gt; &lt;servlet&gt; &lt;servlet-name&gt;Ch3 Beer&lt;/servlet-name&gt; &lt;servlet-class&gt;com.example.web.BeerSelect&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;Ch3 Beer&lt;/servlet-name&gt; &lt;url-pattern&gt;/SelectBeer.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; form.html如下123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;form test&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="css/form.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 align="center"&gt;Beer Selection Page&lt;/h1&gt; &lt;div id="formT"&gt; &lt;form method="POST" action="SelectBeer.do"&gt; &lt;p&gt;Color: &lt;select name="color"&gt; &lt;option name="light"&gt;light&lt;/option&gt; &lt;option name="dark"&gt;dark&lt;/option&gt; &lt;/select&gt; &lt;p&gt; &lt;input type="submit"&gt; &lt;/p&gt; &lt;/p&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; result.jsp123456789101112131415161718192021&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;%@ page import="java.util.*" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 align="center"&gt;Bear Recommendations JSP&lt;/h1&gt; &lt;p&gt; &lt;% List styles = (List)request.getAttribute("styles"); Iterator it = styles.iterator(); while (it.hasNext()) &#123; out.print("try: " + it.next()); &#125; %&gt; &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 模型BeerExpert.java如下12345678910111213141516171819package com.example.model;import java.util.ArrayList;import java.util.List;public class BeerExpert &#123; public List getBrands(String color) &#123; List brands = new ArrayList(); if (color.equals("light")) &#123; brands.add("light a"); brands.add("light b"); &#125; else &#123; brands.add("dark1"); brands.add("dark2"); &#125; return brands; &#125;&#125; 控制器BeelSelect如下1234567891011121314151617181920212223242526272829package com.example.web;import com.example.model.BeerExpert;import javax.servlet.RequestDispatcher;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.List;@WebServlet(name = "BeerSelect")public class BeerSelect extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String c = request.getParameter("color"); BeerExpert be = new BeerExpert(); List result = be.getBrands(c); request.setAttribute("styles", result); RequestDispatcher view = request.getRequestDispatcher("result.jsp"); view.forward(request, response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125;&#125; ##作为Servlet在上述代码中，Servlet作为控制器有如下功能 获得html页面中参数color的值 创建一个模型，通过参数获得模型对应的属性 设置请求的属性并设置对应值为从模型得到的结果（键-值对应） 创建一个请求分派器对象，获得result.jsp页面 通过view.forward(request,response)把请求和响应发送给该view，view通过request.getAttribute(“key”)来得到模型发送来的结果 ###Servlet生命周期 WEB容器加载servlet类 实例化servlet（构造函数运行） init() service()调用doGet(),doPost()等等 destroy() ###HttpServletRequest API ###HttpServletResponse API ###输出字符或字节对于输出，可以选择输出字符或者字节输出字符的时候12PrintWriter writer = response.getWriter();writer.println("some text or HTML"); 输出字节的时候12ServletOutputStream out = response.getOutputStream();out.write(aByteArray); ####使用响应完成I/Oe.g.Servlet处理下载JAR文件1234567891011121314151617181920public class CodeReutrn extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123; response.setContentType("application/jar"); // 对于这里的ContentType，还有很多其他的，具体可以自行Google ServletContext ctx = getServletContext(); InputStream is = ctx.getResourceAsStream("/directory/xxx.jar"); int read = 0; byte[] bytes = new byte[1024]; OutputStream os = response.getOutputStream(); while((read = is.read(bytes)) != -1) &#123; os.write(bytes, 0, read); &#125; os.flush(); os.close(); &#125;&#125;]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>MVC</tag>
        <tag>TOMCAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet03-会话状态]]></title>
    <url>%2F2018%2F09%2F01%2FServlet03-%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%2F</url>
    <content type="text"><![CDATA[Servlet03-会话状态前言：这部分涉及到http cookie相关的知识，这里不再赘述 HttpSession一个HttpSession的例子代码摘自runoob，原网站为runoob的Session教程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869@WebServlet("/SessionTrack")public class SessionTrack extends HttpServlet &#123; private static final long serialVersionUID = 1L; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 如果不存在 session 会话，则创建一个 session 对象 HttpSession session = request.getSession(true); // 获取 session 创建时间 Date createTime = new Date(session.getCreationTime()); // 获取该网页的最后一次访问时间 Date lastAccessTime = new Date(session.getLastAccessedTime()); //设置日期输出的格式 SimpleDateFormat df=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String title = "Servlet Session 实例 - 菜鸟教程"; Integer visitCount = new Integer(0); String visitCountKey = new String("visitCount"); String userIDKey = new String("userID"); String userID = new String("Runoob"); // 检查网页上是否有新的访问者 if (session.isNew())&#123; title = "Servlet Session 实例 - 菜鸟教程"; session.setAttribute(userIDKey, userID); &#125; else &#123; visitCount = (Integer)session.getAttribute(visitCountKey); visitCount = visitCount + 1; userID = (String)session.getAttribute(userIDKey); &#125; session.setAttribute(visitCountKey, visitCount); // 设置响应内容类型 response.setContentType("text/html;charset=UTF-8"); PrintWriter out = response.getWriter(); String docType = "&lt;!DOCTYPE html&gt;\n"; out.println(docType + "&lt;html&gt;\n" + "&lt;head&gt;&lt;title&gt;" + title + "&lt;/title&gt;&lt;/head&gt;\n" + "&lt;body bgcolor=\"#f0f0f0\"&gt;\n" + "&lt;h1 align=\"center\"&gt;" + title + "&lt;/h1&gt;\n" + "&lt;h2 align=\"center\"&gt;Session 信息&lt;/h2&gt;\n" + "&lt;table border=\"1\" align=\"center\"&gt;\n" + "&lt;tr bgcolor=\"#949494\"&gt;\n" + " &lt;th&gt;Session 信息&lt;/th&gt;&lt;th&gt;值&lt;/th&gt;&lt;/tr&gt;\n" + "&lt;tr&gt;\n" + " &lt;td&gt;id&lt;/td&gt;\n" + " &lt;td&gt;" + session.getId() + "&lt;/td&gt;&lt;/tr&gt;\n" + "&lt;tr&gt;\n" + " &lt;td&gt;创建时间&lt;/td&gt;\n" + " &lt;td&gt;" + df.format(createTime) + " &lt;/td&gt;&lt;/tr&gt;\n" + "&lt;tr&gt;\n" + " &lt;td&gt;最后访问时间&lt;/td&gt;\n" + " &lt;td&gt;" + df.format(lastAccessTime) + " &lt;/td&gt;&lt;/tr&gt;\n" + "&lt;tr&gt;\n" + " &lt;td&gt;用户 ID&lt;/td&gt;\n" + " &lt;td&gt;" + userID + " &lt;/td&gt;&lt;/tr&gt;\n" + "&lt;tr&gt;\n" + " &lt;td&gt;访问统计：&lt;/td&gt;\n" + " &lt;td&gt;" + visitCount + "&lt;/td&gt;&lt;/tr&gt;\n" + "&lt;/table&gt;\n" + "&lt;/body&gt;&lt;/html&gt;"); &#125;&#125; 配置好web.xml即可 对这段代码的解释以及补充request.getSession()以及其重构方法request.getSession(false)HttpSession session = request.getSession(boolean create)返回当前reqeust中的HttpSession，如果当前reqeust中的HttpSession为null，当create为true，就创建一个新的Session，否则返回null 当向Session中存取登录信息时，一般建议：HttpSession session =request.getSession(); 当从Session中获取登录信息时，一般建议：HttpSession session =request.getSession(false); session.isNew() - 判断是否为新的用户12345if(session.isNew()) &#123; // do something with new user&#125; else &#123; // do something&#125; session.getId() - 获取当前用户的sessionID其他HttpSession API 禁用cookie的解决方法-URL重写您可以在每个 URL 末尾追加一些额外的数据来标识 session 会话，服务器会把该 session 会话标识符与已存储的有关 session 会话的数据相关联。 例如，http://w3cschool.cc/file.htm;sessionid=12345，session 会话标识符被附加为 sessionid=12345，标识符可被 Web 服务器访问以识别客户端。 URL 重写是一种更好的维持 session 会话的方式，它在浏览器不支持 cookie 时能够很好地工作，但是它的缺点是会动态生成每个 URL 来为页面分配一个 session 会话 ID，即使是在很简单的静态HTML页面中也会如此。 对URL重写，必须要先对URL进行编码可以通过以下两种方法对URL进行编码 jsp中添加&lt;% response.encodeURL(&quot;hello.jsp&quot;); %&gt; Servlet中使用response.encodeRedirectURL()与sendRedirect()，见下面 12345678910@Overrideprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; HttpSession session = request.getSession(); //下面请求重定向的路径。 String path = response.encodeRedirectURL("/BeerTest.do"); String sessionId = request.getSession().getId(); request.setAttribute("sessionId",sessionId); response.sendRedirect(path);&#125; 设置会话超时在web.xml中配置,下面例子是设置15分钟超时 123456&lt;web-app ...&gt; &lt;servlet&gt; ... &lt;/servlet&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt;&lt;/web-app&gt; 设置特定会话的会话超时session.setMaxInactiveInterval(20*60); // 设置20分钟没有做任何请求就超时 Cookie创建一个新CookieCookie cookie = new Cookie(&quot;username&quot;, name);设置cookie在客户端存活时间cookie.setMaxAge(30*60); // 30min把cookie发送给客户response.addCookie(cookie);从客户请求得到cookie 123456789Cookie[] cookies = request.getCookies();for (int i = 0; i &lt; cookies.length; i++) &#123; Cookie cookie = cookies[i]; if (cookie.getName().equals("username")) &#123; String userName = cookie.getValue(); out.println("Hello " + userName); break; &#125; 简单的cookie示例login.jsp设置表单提交账号密码，如果账号为test，则点击index.jsp的提交按钮可以显示其密码可以在F12 Application Cookies可以看到cookie web.xml 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"&gt; &lt;servlet&gt; &lt;servlet-name&gt;cookieTest&lt;/servlet-name&gt; &lt;servlet-class&gt;ServletCookie&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;cookieTest&lt;/servlet-name&gt; &lt;url-pattern&gt;/sv.html&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;cookieTest2&lt;/servlet-name&gt; &lt;servlet-class&gt;CheckCookie&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;cookieTest2&lt;/servlet-name&gt; &lt;url-pattern&gt;/result.html&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; login.jsp 1234567891011121314&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="sv.html" method="post"&gt; &lt;input type="text" name="username" /&gt; &lt;input type="password" name="password" /&gt; &lt;input type="submit" value="提交" /&gt;&lt;/form&gt;&lt;/body&gt; index.jsp 1234567891011&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="result.html" method="post"&gt; &lt;input type="submit" value="提交" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html ServletCookie.java 12345678910111213141516171819202122232425import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(name = "ServletCookie")public class ServletCookie extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String username = request.getParameter("username"); String password = request.getParameter("password"); //定义一个名为username，值为Tom的cookie Cookie cookie = new Cookie(username, password); response.addCookie(cookie); request.getRequestDispatcher("index.jsp").forward(request, response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125;&#125; CheckCookie.java 1234567891011121314151617181920212223242526272829303132import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@WebServlet(name = "CheckCookie")public class CheckCookie extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html"); PrintWriter out = response.getWriter(); Cookie[] cookies = request.getCookies(); if (cookies != null) &#123; for (Cookie cookie : cookies) &#123; if(cookie.getName().equals("test")) &#123; String userName = cookie.getValue(); out.println(userName); break; &#125; &#125; &#125; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125;&#125; HttpSessionBindingListener]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>HttpSession</tag>
        <tag>Cookie</tag>
        <tag>HttpSessionBindingListener</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript01-语法]]></title>
    <url>%2F2018%2F09%2F01%2FJavaScript01-%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[JavaScript01-语法在HTML中嵌入JavaScript有两种方法，第一种是内嵌在&lt;head&gt;标签的&lt;script&gt;标签之间123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Example&lt;/title&gt; &lt;script&gt; JavaScript goes here... &lt;/script&gt; &lt;body&gt; Mark-up goes here... &lt;/body&gt;&lt;/html&gt; 另一种更好的方法是存在.js文件中，利用&lt;script&gt;标签的src属性指向该文件12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Example&lt;/title&gt; &lt;script src="file.js"&gt;&lt;/script&gt; &lt;body&gt; Mark-up goes here... &lt;/body&gt;&lt;/html&gt; Script标签元素详解有如下6个属性 async: 可选，表示立即下载脚本，但不应妨碍页面其他操作，只对外部脚本有效。 charset: 可选，基本不用。 defer: 可选，表示脚本可以延迟到文档完全被解析和显示后再执行。只对外部脚本有效。 src: 可选，表示包含要执行代码的外部文件。 type: 可选，使用脚的脚本语言的内容类型，目前用的比较多的还是 text/javascript Script标签的位置最好的做法就是把&lt;script&gt;标签放在HTML文档的最后，&lt;body&gt;标签的前面12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Example&lt;/title&gt; &lt;body&gt; Mark-up goes here... &lt;script src="file.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; JavaScript数据类型JS有6种数据类型，可以通过关键词typeof检测。 Undefined类型 只有一个值undefined。 Null类型 只有一个值null，undefined派生于null，typeof null检测null会返回boject。 Boolean类型 只有true与false。 Number类型 NaN(Not a number)是一个特殊的数值，表示一个本来要返回数值的操作数未返回数值的情况。 String类型 与Python类似，用双引号或者单引号都OK。 Object类型 ECMAScript的对象其实就是一组数据和功能的集合，可以通过new操作符创建，后续会讲到。 JavaScript语句JS很多语句都和Java类似，这里就只列举JS独有的语句 for-in语句1234for(var propName in window) &#123; document.write(propName);&#125;// 枚举BOM中window对象的所有属性，顺序不可预测 for-in语句是一种精准的迭代语句，可以用来枚举对象的属性。 label语句与Java类似，在代码中添加标签以便将来使用，多用于for语句等循环语句1234start: for (var i=0; i &lt; count; i++)&#123; alert(i); &#125;// start标签可以在将来由break或continue语句引用 with语句将代码的作用于设置到一个特定的对象中123var qs = location.search.substring(1);var hostName = location.hostname;var url = location.href; 等价于下面代码12345with(location) &#123; var qs = search.substring(1); var hostName = hostname; var url = href;&#125; JavaScript函数123function functionName(arg0, arg1, arg2, ... ,argN) &#123; statements;&#125; 理解参数ECMAScript函数的参数与大多数其他语言函数的参数不同，ECMAScript函数不介意传递进来多少个参数，也不在乎传进来参数是什么类型的。即使你定义的函数只接受两个参数，在调用这个函数的时候传递多少个也没问题，原因是ECMAScript中参数在内部是用一个数组来表示的，函数接受到的始终都是这个数组，实际上可以在函数体内通过arguments对象来访问这个数组，从而获取传递给函数的每一个参数。 ECMAScript所有参数传递都是值传递，不可能通过引用传递参数，对于引用数据类型，其值就是其引用 没有重载对于同一名字的多个函数，该名字只属于最后定义的]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础之集合]]></title>
    <url>%2F2018%2F07%2F13%2FJava%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9B%86%E5%90%88%2F</url>
    <content type="text"></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础之初窥反射]]></title>
    <url>%2F2018%2F06%2F19%2FJava%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%9D%E7%AA%A5%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[前言:之前写安卓的时候有遇到过反射,但是当时怎么都不理解,现在正好借此机会初步了解一下反射 什么是反射 Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.The API accommodates applications that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class. It also allows programs to suppress default reflective access control. 简单来说,反射能够分析类能力,他可以做以下几件事: 在运行时分析类的能力 在运行时查看对象,例如,写一个toString方法供所有类使用 实现通用的数组操作代码 利用Method对象(类比C中的函数指针) 获得对象的Class类反射比较重要的一点是获得对象的类,对象的类是一个Class对象(但不是所有Class对象都是一种类,例如int也是Class对象) 以下是三种获得Class类的方法1234// 第一种:通过对象.getClass()获得Employee e;...Class cl = e.getClass(); 1234567// 第二种:通过Class类的静态方法forName()获得try &#123; String className = "java.util.Random"; Class cl = Class.forName(className);&#125; catch (Execption e) &#123; e.printStackTrace();&#125; 1234// 第三种:通过T.class获得(T是任意Java类型)Class cl1 = Random.class;Class cl2 = int.class;Class cl3 = Double[].class; Class类的一些常用方法getName() Returns the name of the entity (class, interface, array class, primitive type, or void) represented by this Class object, as a String. 123Employee e;...System.out.println(e.getClass().getName()); newInstance() Creates a new instance of the class represented by this Class object. 123Employee e;e.getClass().newInstance();// 调用默认的构造函数,如果要传参,请使用Constructor类的newInstance(Objcet[] args)方法 getMethod() Modifier and Type Method and Description Method getMethod(String name, Class&lt;?&gt;… parameterTypes) &nbsp; Returns a Method object that reflects the specified public member method of the class or interface represented by this Class object. e.g. 获得Employee的raiseSalary方法 Method m1 = Employee.class.getMethod(&quot;raiseSalary&quot;, double.class); getDeclaredFields() Returns an array of Field objects reflecting all the fields declared by the class or interface represented by this Class object. getDeclaredMethods() Returns an array containing Method objects reflecting all the declared methods of the class or interface represented by this Class object, including public, protected, default (package) access, and private methods, but excluding inherited methods. getDeclaredConsstructors() Returns an array of Constructor objects reflecting all the constructors declared by the class represented by this Class object. getDeclaredFields()与getFields()的区别getFields()返回一个包含Field对象的数组,这些对象记录了这个类或其超类的公有域,而getDeclaredFields()的对象记录了这个类的全部域类比Methods与Constructors 反射包中重要类的简单描述在java.lang.reflect包中有三个类Field,Method,和Constructor分别用于描述类的域,方法和构造器 FieldField用于描述类的域,常见的方法有 Modifier and Type Method and Description Object get(Object obj) &nbsp; Returns the value of the field represented by this Field, on the specified object. void set(Object obj, Object value) &nbsp; Sets the field represented by this Field object on the specified object argument to the specified new value. int getModifiers() &nbsp; Returns the Java language modifiers for the field represented by this Field object, as an integer. Class&lt;?&gt; getType() &nbsp; Returns a Class object that identifies the declared type for the field represented by this Field object. String getName() &nbsp; Returns the name of the field represented by this Field object. Method Modifier and Type Method and Description String getName() &nbsp; Returns the name of the method represented by this Method object, as a String. Class&lt;?&gt; getReturnType() &nbsp; Returns a Class object that represents the formal return type of the method represented by this Method object. int getModifiers() &nbsp; Returns the Java language modifiers for the field represented by this Field object, as an integer. Class&lt;?&gt;[] getParameterTypes() &nbsp; Returns an array of Class objects that represent the formal parameter types, in declaration order, of the executable represented by this object. Object invoke(Object obj, Object… args) &nbsp; Invokes the underlying method represented by this Method object, on the specified object with the specified parameters. Constructor Modifier and Type Method and Description String getName() &nbsp; Returns the name of this constructor, as a string. Class&lt;?&gt;[] getParameterTypes() &nbsp; Returns an array of Class objects that represent the formal parameter types, in declaration order, of the executable represented by this object. int getModifiers() &nbsp; Returns the Java language modifiers for the field represented by this Field object, as an integer. 利用反射分析类的能力12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class ReflectionTest &#123; public static void main(String[] args) &#123; String name; if (args.length &gt; 0) name = args[0]; else &#123; Scanner in = new Scanner(System.in); System.out.println("Enter class name (e.g. java.util.Date):"); name = in.next(); &#125; try &#123; Class cl = Class.forName(name); Class supercl = cl.getSuperclass(); String modifiers = Modifier.toString(cl.getModifiers()); if (modifiers.length() &gt; 0) System.out.print(modifiers + " "); System.out.print("class " + name); if (supercl != null &amp;&amp; supercl != Object.class) System.out.print(" extends " + supercl.getName()); System.out.print("\n&#123;\n"); printConstructors(cl); System.out.println(); printMethods(cl); System.out.println(); printFields(cl); System.out.println("&#125;"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.exit(0); &#125; public static void printConstructors(Class cl) &#123; Constructor[] constructors = cl.getDeclaredConstructors(); for (Constructor c : constructors) &#123; String name = c.getName(); System.out.print(" "); String modifiers = Modifier.toString(c.getModifiers()); if (modifiers.length() &gt; 0) System.out.print(modifiers + " "); System.out.print(name + "("); Class[] paramTypes = c.getParameterTypes(); // 构造器的参数是Class类型 for (int j = 0; j &lt; paramTypes.length; j++) &#123; if (j &gt; 0) System.out.print(", "); System.out.print(paramTypes[j].getName()); &#125; System.out.println(");"); &#125; &#125; public static void printMethods(Class cl) &#123; Method[] methods = cl.getDeclaredMethods(); for (Method m : methods) &#123; Class retType = m.getReturnType(); // 方法的返回值是Class类型,注意:int等基本数据类型也是Class类型 String name = m.getName(); System.out.print(" "); String modifiers = Modifier.toString(m.getModifiers()); if (modifiers.length() &gt; 0) System.out.print(modifiers + " "); System.out.print(retType.getName() + " " + name + "("); // 这里返回了int, boolean等 Class[] paramTypes = m.getParameterTypes(); for (int j = 0; j &lt; paramTypes.length; j++) &#123; if (j &gt; 0) System.out.print(", "); System.out.print(paramTypes[j].getName()); &#125; System.out.println(");"); &#125; &#125; public static void printFields(Class cl) &#123; Field[] fields = cl.getDeclaredFields(); for (Field f : fields) &#123; Class type = f.getType(); // Returns a Class object that identifies the declared type for the field represented by this Field object. String name = f.getName(); System.out.print(" "); String modifiers = Modifier.toString(f.getModifiers()); if (modifiers.length() &gt; 0) System.out.print(modifiers + " "); System.out.println(type.getName() + " " + name + ";"); &#125; &#125;&#125; 在运行时使用反射分析对象上面讲的是如何查看任意对象的数据域名称和类型,这次进一步查看数据域的实际内容12345Employee harry = new Employee("Harry Hacker", 35000, 10, 1 1989);Class cl = harry.getClass();Field f = cl.getDeclaredField("name");f.setAccessible(true);Object v = f.get(harry) // the value of v is "Harry Hacker" 上面是一个获得对象域的例子,注意反射机制默认受限于Java的访问控制,可以通过以下方法覆盖访问控制 f.setAccessible(true) Field继承自AccessibleObject,可通过其父类方法setAccessible()设置权限 AccessibleObject.setAccessible(fields, true) 调用静态方法对fields设置权限(见下面代码) 下面是一个通用的toString方法12345678910111213141516public class ObjectAnalyzerTest &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; squares = new ArrayList&lt;&gt;(); String[] ss = &#123;"a", "b", "c"&#125;; for (int i = 1; i &lt;= 5; i++) &#123; squares.add(i * i); &#125; ObjectAnalyzer objectAnalyzer = new ObjectAnalyzer();// System.out.println(objectAnalyzer.toString(ss)); System.out.println(objectAnalyzer.toString(squares));// System.out.println(new ObjectAnalyzer().toString(12345));// System.out.println(new ObjectAnalyzer().toString("test"));// System.out.println(new ObjectAnalyzer().toString(null)); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class ObjectAnalyzer &#123; private ArrayList&lt;Object&gt; visited = new ArrayList&lt;&gt;(); // 循环引用可能导致无限递归 public String toString(Object obj) &#123; if (obj == null) return "null"; if (visited.contains(obj)) return "..."; visited.add(obj); Class cl = obj.getClass(); if (cl == String.class) return (String)obj; if (cl.isArray()) &#123; String r = cl.getComponentType() + "[]&#123;"; // getComponentType() Returns the Class representing the component type of an array. for (int i = 0; i &lt; Array.getLength(obj); i++) &#123; if (i &gt; 0) r += ","; Object val = Array.get(obj, i); if (cl.getComponentType().isPrimitive()) r += val; else r += toString(val); &#125; return r + "&#125;"; &#125; String r = cl.getName(); do &#123; r += "["; Field[] fields = cl.getDeclaredFields(); AccessibleObject.setAccessible(fields, true); for (Field f : fields) &#123; if (!Modifier.isStatic((f.getModifiers()))) &#123; // 静态域舍弃 if (!r.endsWith("[")) r += ","; r += f.getName() + "="; try &#123; Class t = f.getType(); Object val = f.get(obj); if (t.isPrimitive()) r += val; // 如果为原始数据类型则直接添加 else r += toString(val); // 否则递归调用 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; r += "]"; cl = cl.getSuperclass(); &#125; while (cl != null); return r; &#125;&#125; 使用反射编写泛型数组代码123456789101112131415161718192021222324252627282930public class CopyOfTest &#123; public static void main(String[] args) &#123; int[] a = &#123; 1, 2, 3 &#125;; a = (int[]) goodCopyOf(a, 10); System.out.println(Arrays.toString(a)); String[] b = &#123; "Tom", "Dick", "Harry" &#125;; b = (String[]) goodCopyOf(b, 10); System.out.println(Arrays.toString(b)); &#125; // int[]无法转换为Object[] public static Object[] badCopyOf(Object[] a, int newLength) &#123; Object[] newArray = new Object[newLength]; System.arraycopy(a, 0, newArray, 0, Math.min(a.length, newLength)); return newArray; &#125; public static Object goodCopyOf(Object a, int newLength) &#123; Class cl = a.getClass(); if (!cl.isArray()) return null; Class componentType = cl.getComponentType(); // Returns the Class representing the component type of an array. int length = Array.getLength(a); Object newArray = Array.newInstance(componentType, newLength); System.arraycopy(a, 0, newArray, 0, Math.min(length, newLength)); return newArray; &#125;&#125; 注意getComponentType()是Class的方法而不是Array的方法Array.newInstance()返回Object对象 调用任意方法类似C语言的函数指针,通过Java的反射机制可以调用任意方法 Object invoke(Object obj, Object... args)第一个参数是隐式参数,其余的对象提供了显示参数,对于静态方法,第一个参数可以被忽略,即设置为null,e.g. ml是一个Method,代表Employee的getName方法,harry是一个Employee对象String n = (String) ml.invoke(harry) // 调用harry的getName()方法method.invoke(a, s); // 调用a的method方法,参数为smethod.invoke(null, s); // 调用静态method方法,参数为s注意invoke返回的是Object 而获得方法可以通过Class cl = harry.getClass()cl.getMethod(String name, Class&lt;?&gt;... parameterTypes) 一个使用invoke的例子123456789101112131415161718192021222324252627282930public class MethodTableTest &#123; public static void main(String[] args) &#123; try &#123; Method square = MethodTableTest.class.getMethod("square", double.class); Method sqrt = Math.class.getMethod("sqrt", double.class); printTable(1, 10, 10, square); printTable(1, 10, 10, sqrt); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static double square(double x) &#123; return x * x; &#125; public static void printTable(double from, double to, int n, Method f) &#123; System.out.println(f); double dx = (to - from) / (n - 1); for (double x = from; x &lt;= to; x += dx) &#123; try &#123; double y = (Double) f.invoke(null, x); System.out.printf("%10.4f | %10.4f%n", x, y); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 后言:这次仅仅是跟着课本尝试了一下反射,以后有了相应的基础后会深入理解反射的机制]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object,所有类的超类]]></title>
    <url>%2F2018%2F06%2F03%2FObject-%E6%89%80%E6%9C%89%E7%B1%BB%E7%9A%84%E8%B6%85%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Object类是Java中所有类的超类,在Java中每个类都由它扩展而来Object类的方法如下 其中最为关键的3个方法为equals(),hashCode()和toString() equals方法官方文档 在文档中说到,equals用于检测一个对象是否等于另一个对象,该方法必须有以下5个特性: 自反性:对任意非空引用x,&nbsp;&nbsp;&nbsp;x.equals(x)&nbsp;&nbsp;必须返回true 对称性:对任意非空引用x,y,&nbsp;&nbsp;x.equals(y)&nbsp;&nbsp;返回true当且仅当&nbsp;&nbsp;y.equals(x)&nbsp;&nbsp;返回true 传递性:对任意非空引用x,y,z,如果&nbsp;&nbsp;x.equals(y)&nbsp;&nbsp;返回true并且&nbsp;&nbsp;y.equals(x)&nbsp;&nbsp;返回true,则&nbsp;&nbsp;x.equals(z)&nbsp;&nbsp;返回true 一致性:如果x和y引用的对象没有发生变化,反复调用&nbsp;&nbsp;x.equals(y)&nbsp;&nbsp;应该返回同样的结果 对于任意非空引用x,&nbsp;&nbsp;x.equals(y)&nbsp;&nbsp;应该返回false Object类的equals方法而Object类中的默认的equals方法如下123public boolean equals(Object obj) &#123; return (this == obj);&#125; 自定义类的equals方法如果两个对象具有相同的引用,则返回true,否则返回false,这是最经济的符合以上5个特性的equals方法了,但是很多时候这种判断并没有什么意义,更多时候我们要判断对象是否相等,需要检测他们状态的相等性,如果两个对象的状态相等,则认为他们是相等的,比如有一个雇员Employee类,如果两个雇员对象的姓名,薪水和雇佣日期都相等,则认为他们是相等的,那么雇员类的equals方法可以如下(完整的Employee类请见最后)1234567891011121314 public boolean equals(Object otherObject) &#123; if (this == otherObject) return true; // 先判断这两个对象是否具有相同的引用 if (otherObject == null) return false; // 然后判断otherObject是否为null if (getClass() != otherObject.getClass()) return false; // 使用getClass()判断是否为同一类 Employee other = (Employee) otherObject; // 把Object类转换成Employee类 return Objects.equals(name, other.name) // 详细比较他们的域 &amp;&amp; salary == other.salary &amp;&amp; Objects.equals(hireDay, other.hireDay); &#125;&#125; Employee类的equals方法代码解释代码中使用&nbsp;Objects.equals(name, other.name)&nbsp;是为了防备name和hireDay可能为null的情况,下面是Objects类的equals方法,当对象a和b都是null,则返回true,如果其中一个是null则返回false,否则调用a.equals(b)123public static boolean equals(Object a, Object b) &#123; return (a == b) || (a != null &amp;&amp; a.equals(b));&#125; 在是否为同一类的比较中,,除了&nbsp;&nbsp;if (getClass() != otherObject.getClass()) return false;&nbsp;&nbsp;这个判断外,还可以使用&nbsp;&nbsp;if (!(otherObject instanceof Employee)) return false;&nbsp;&nbsp;来判断,但是使用instanceof判断没有解决otherObject是子类的情况(&nbsp;子类引用 instanceof 父类&nbsp;返回true,但反过来则返回false,不符合对称性)所以,使用getClass()与instanceof可以根据下面情况判断: 如果子类能够拥有自己的相等概念,则对称性需求将强制性采用getClass进行检测 如果由超类决定相等的概念(比如Employee与其子类Manager中使用Employee类的成员ID来判断是否相等),那么就可以使用instanceof进行检测 完美的equals方法 显示参数命名为otherObject,稍后强制类型转换为变量other 检测this与ohetObject是否引用同一对象 检测ohterObject是否为null,如果为null返回false 比较this与otherObject是否属于同一类,根据相等概念由父类还是子类决定用getClass()还是instanceof检测 将ohterObject转换为相应的类类型变量 开始对需要比较的域进行比较,对于对象的比较,用Objects.equals(field, other.field) 子类中的equals方法12345public boolean equals(Object otherObject) &#123; if (!super.equals(otherObject)) return false; Manager other = (Manager) otherObject; return bonus == other.bonus; &#125; 先调用super.equals(otherObject)检测父类元素是否相等,然后再比较子类的域 其他对于数组类型的域,使用静态方法Arrays.equals方法判断 hashCode方法散列码hashCode是由对象导出的一个整型值,不同的对象散列码一般不会相同 官方文档根据说明我们可以得知: 只要在Java应用程序执行过程中多次调用同一对象时，hashCode方法就必须始终返回相同的整数，前提是未修改对象的等同比较中使用的信息。 该整数不需要从应用程序的一次执行到同一应用程序的另一次执行保持一致。 如果两个对象由equals方法得到的结果为true，则对这两个对象中的每个对象调用hashCode方法必须产生相同的整数结果。 根据equals方法，如果两个对象不相等，则不要求对两个对象中的每一个调用hashCode方法都必须生成不同的整数结果。 但是，程序员应该意识到，为不相等的对象生成不同的整数结果可能会提高散列表的性能。 Object类中的hashCode方法在源码中,hashCode()不是由Java代码生成的,它返回的值为对象的存储地址,这里就不赘述了 自定义类的hashCode方法如果要重新定义equals方法,则必须重新定义hashCode方法equals方法与什么成员有关,hashCode也必须与该成员有关e.g:如果equals方法与Employee类的salary,hireDay,name相关,则Employee的hashCode方法可以定义如下 123456public int hashCode() &#123; return 7 * Objects.hashCode(name) + 11 * Double.hashCode(salary) + 13 * Objects.hashCode(hireDay);// 如果成员为数组,则使用Arrays.hashCode()&#125; 或者使用Objects.hash(Object… values)123public int hashCode() &#123; return Objects.hash(name, salary, hireDay);&#125; Objects.hashCode(Object o)是null安全的,当参数为null则返回0,否则返回对参数调用Object.hashCode()的结果注意:只有一个参数的时候不要使用Objects.hash(),而是Objects.hashCode(Object o)或者Doubles.hashCode(Double d) Objects.hash(Object… values)源码123public static int hash(Object... values) &#123; return Arrays.hashCode(values);&#125; Arrays.hashCode(Object a[])源码1234567891011public static int hashCode(Object a[]) &#123; if (a == null) return 0; int result = 1; for (Object element : a) result = 31 * result + (element == null ? 0 : element.hashCode()); return result; &#125; toString方法toString()方法返回表示对象值的字符串 官方文档 Object类的toString方法123public String toString() &#123; return getClass().getName() + "@" + Integer.toHexString(hashCode());&#125; 他返回 getClass().getName() + &#39;@&#39; + Integer.toHexString(hashCode()) toString()为什么随处可见只要对象与一个字符串通过操作符”+”连接起来,Java编译就会自动调用toString方法 数组的toString方法数组继承了Object类的toString,仍会像Object类那样输出字符串,大概输出如下[I@1a46e30]这不符合我们的预期,修正方法如下: Arrays.toString()调用静态方法Arrays.toString(),返回对象大概为[2,3,5,7,11,13]如果想要打印多维数组,调用 Arrays.deepToString() 测试类Employee与Manager的源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.time.LocalDate;import java.util.Objects;public class Employee &#123; private String name; private double salary; private LocalDate hireDay; public Employee(String n, double s, int year, int month, int day) &#123; name = n; salary = s; hireDay = LocalDate.of(year, month, day); &#125; public String getName() &#123; return name; &#125; public double getSalary() &#123; return salary; &#125; public LocalDate getHireDay() &#123; return hireDay; &#125; public void raiseSalary(double byPercent) &#123; double raise = salary * byPercent / 100; salary += raise; &#125; public boolean equals(Object otherObject) &#123; if (this == otherObject) return true; if (otherObject == null) return false; if (getClass() != otherObject.getClass()) return false; Employee other = (Employee) otherObject; return Objects.equals(name, other.name) &amp;&amp; salary == other.salary &amp;&amp; Objects.equals(hireDay, other.hireDay); &#125; public int hashCode() &#123; return 7 * Objects.hashCode(name) + 11 * Double.hashCode(salary) + 13 * Objects.hashCode(hireDay); &#125; /* public int hashCode() &#123; * return Objects.hash(name, salary, hireDay); * &#125; * */ public String toString() &#123; return getClass().getName() + "[name = " + name + ",salary = " + salary + ",hireDay = " + hireDay + "]"; &#125;&#125; 1234567891011121314151617181920212223242526272829303132public class Manager extends Employee &#123; private double bonus; public Manager(String n, double s, int year, int month, int day) &#123; super(n, s, year, month, day); bonus = 0; &#125; public double getSalary() &#123; double baseSalary = super.getSalary(); return baseSalary + bonus; &#125; public void setBonus(double b) &#123; bonus = b; &#125; public boolean equals(Object otherObject) &#123; if (!super.equals(otherObject)) return false; Manager other = (Manager) otherObject; return bonus == other.bonus; &#125; public int hashCode() &#123; return super.hashCode() + 17 * Double.hashCode(bonus); &#125; public String toString() &#123; return super.toString() + "[bonus = " + bonus + "]"; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java继承之子类访问父类的私有域]]></title>
    <url>%2F2018%2F06%2F01%2FJava%E7%BB%A7%E6%89%BF%E4%B9%8B%E5%AD%90%E7%B1%BB%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[在类的继承中,子类可以访问父类的公有方法和域,但对于父类的私有成员则不能访问,但很多情况下,子类也应当拥有父类的私有属性,例如一个雇员Employee有名字,薪资,雇佣时间等属性,经理Manager也属于雇员,那么经理也应当有名字,薪资,雇佣时间等,那么问题就来了,子类如何才能使用父类的私有成员?请看下面代码123456789101112131415161718public class Father &#123; private int a; // 默认构造方法,如果没有此方法,子类构造器第一句必须调用super() public Father() &#123; &#125; public Father(int a) &#123; this.a = a; &#125; public int getA() &#123; return a; &#125; public void setA(int a) &#123; this.a = a; &#125;&#125; 1234567891011121314151617public class Son extends Father&#123; public Son() &#123; // 如果子类没有显式调用super(),则自动调用父类默认(没有参数)的构造器,如果父类没有默认构造器,则报错 &#125; public Son(int a) &#123; super(a); // super()必须是子类构造器的第一句 &#125; public static void main(String[] args) &#123; Son son1 = new Son(); son1.setA(123); // 第一种给父类成员赋值的方法,调用setter() Son son2 = new Son(234); // 第二种给父类成员赋值的方法,构造器初始化 System.out.println(son.getA()); // 调用getter()获取父类成员 &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[algs之背包,队列和栈]]></title>
    <url>%2F2018%2F06%2F01%2Falgs%E4%B9%8B%E8%83%8C%E5%8C%85-%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88%2F</url>
    <content type="text"><![CDATA[背包(Bag)背包是一种不支持从中删除元素的集合数据类型—-它的目的就是帮助用例收集元素并迭代遍历所有收集到的元素(用例也可以检查背包是否为空或者获取背包中元素的数量) Bag 注释 public class Bag&lt;Item&gt; implements Iterable&lt;Item&gt; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bag() 创建一个空背包 boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isEmpty() 背包是否为空 int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size() 背包中的元素数量 具体实现(链表实现):代码均来自algs4配套代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116/** * The &#123;@code Bag&#125; class represents a bag (or multiset) of * generic items. It supports insertion and iterating over the * items in arbitrary order. * &lt;p&gt; * This implementation uses a singly linked list with a static nested class Node. * See &#123;@link LinkedBag&#125; for the version from the * textbook that uses a non-static nested class. * See &#123;@link ResizingArrayBag&#125; for a version that uses a resizing array. * The &lt;em&gt;add&lt;/em&gt;, &lt;em&gt;isEmpty&lt;/em&gt;, and &lt;em&gt;size&lt;/em&gt; operations * take constant time. Iteration takes time proportional to the number of items. * &lt;p&gt; * For additional documentation, see &lt;a href="https://algs4.cs.princeton.edu/13stacks"&gt;Section 1.3&lt;/a&gt; of * &lt;i&gt;Algorithms, 4th Edition&lt;/i&gt; by Robert Sedgewick and Kevin Wayne. * * @author Robert Sedgewick * @author Kevin Wayne * * @param &lt;Item&gt; the generic type of an item in this bag */public class Bag&lt;Item&gt; implements Iterable&lt;Item&gt; &#123; private Node&lt;Item&gt; first; // beginning of bag private int n; // number of elements in bag // helper linked list class private static class Node&lt;Item&gt; &#123; private Item item; private Node&lt;Item&gt; next; &#125; /** * Initializes an empty bag. */ public Bag() &#123; first = null; n = 0; &#125; /** * Returns true if this bag is empty. * * @return &#123;@code true&#125; if this bag is empty; * &#123;@code false&#125; otherwise */ public boolean isEmpty() &#123; return first == null; &#125; /** * Returns the number of items in this bag. * * @return the number of items in this bag */ public int size() &#123; return n; &#125; /** * Adds the item to this bag. * * @param item the item to add to this bag */ public void add(Item item) &#123; Node&lt;Item&gt; oldfirst = first; first = new Node&lt;Item&gt;(); first.item = item; first.next = oldfirst; n++; &#125; /** * Returns an iterator that iterates over the items in this bag in arbitrary order. * * @return an iterator that iterates over the items in this bag in arbitrary order */ public Iterator&lt;Item&gt; iterator() &#123; return new ListIterator&lt;Item&gt;(first); &#125; // an iterator, doesn't implement remove() since it's optional private class ListIterator&lt;Item&gt; implements Iterator&lt;Item&gt; &#123; private Node&lt;Item&gt; current; public ListIterator(Node&lt;Item&gt; first) &#123; current = first; &#125; public boolean hasNext() &#123; return current != null; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; public Item next() &#123; if (!hasNext()) throw new NoSuchElementException(); Item item = current.item; current = current.next; return item; &#125; &#125; /** * Unit tests the &#123;@code Bag&#125; data type. * * @param args the command-line arguments */ public static void main(String[] args) &#123; Bag&lt;String&gt; bag = new Bag&lt;String&gt;(); while (!StdIn.isEmpty()) &#123; String item = StdIn.readString(); bag.add(item); &#125; StdOut.println("size of bag = " + bag.size()); for (String s : bag) &#123; StdOut.println(s); &#125; &#125;&#125; 队列(Queue)先进先出队列是一种基于FIFO策略的集合类型,元素处理的顺序就是它们被添加到队列中的顺序,应用程序中使用队列的主要原因是在用集合保存元素的同时保存他们的相对顺序 Queue(FIFO) 注释 public class Queue&lt;Item&gt; implements Iterable&lt;Item&gt; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Queue() 创建一个空队列 void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enqueue(Item item) 添加一个元素 Item&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dequeue() 删除一个元素 boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isEmpty() 队列是否为空 int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size() 队列中的元素数量 具体实现(链表实现):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162/** * The &#123;@code Queue&#125; class represents a first-in-first-out (FIFO) * queue of generic items. * It supports the usual &lt;em&gt;enqueue&lt;/em&gt; and &lt;em&gt;dequeue&lt;/em&gt; * operations, along with methods for peeking at the first item, * testing if the queue is empty, and iterating through * the items in FIFO order. * &lt;p&gt; * This implementation uses a singly linked list with a static nested class for * linked-list nodes. See &#123;@link LinkedQueue&#125; for the version from the * textbook that uses a non-static nested class. * See &#123;@link ResizingArrayQueue&#125; for a version that uses a resizing array. * The &lt;em&gt;enqueue&lt;/em&gt;, &lt;em&gt;dequeue&lt;/em&gt;, &lt;em&gt;peek&lt;/em&gt;, &lt;em&gt;size&lt;/em&gt;, and &lt;em&gt;is-empty&lt;/em&gt; * operations all take constant time in the worst case. * &lt;p&gt; * For additional documentation, see &lt;a href="https://algs4.cs.princeton.edu/13stacks"&gt;Section 1.3&lt;/a&gt; of * &lt;i&gt;Algorithms, 4th Edition&lt;/i&gt; by Robert Sedgewick and Kevin Wayne. * * @author Robert Sedgewick * @author Kevin Wayne * * @param &lt;Item&gt; the generic type of an item in this queue */public class Queue&lt;Item&gt; implements Iterable&lt;Item&gt; &#123; private Node&lt;Item&gt; first; // beginning of queue private Node&lt;Item&gt; last; // end of queue private int n; // number of elements on queue // helper linked list class private static class Node&lt;Item&gt; &#123; private Item item; private Node&lt;Item&gt; next; &#125; /** * Initializes an empty queue. */ public Queue() &#123; first = null; last = null; n = 0; &#125; /** * Returns true if this queue is empty. * * @return &#123;@code true&#125; if this queue is empty; &#123;@code false&#125; otherwise */ public boolean isEmpty() &#123; return first == null; &#125; /** * Returns the number of items in this queue. * * @return the number of items in this queue */ public int size() &#123; return n; &#125; /** * Returns the item least recently added to this queue. * * @return the item least recently added to this queue * @throws NoSuchElementException if this queue is empty */ public Item peek() &#123; if (isEmpty()) throw new NoSuchElementException("Queue underflow"); return first.item; &#125; /** * Adds the item to this queue. * * @param item the item to add */ public void enqueue(Item item) &#123; Node&lt;Item&gt; oldlast = last; last = new Node&lt;Item&gt;(); last.item = item; last.next = null; if (isEmpty()) first = last; else oldlast.next = last; n++; &#125; /** * Removes and returns the item on this queue that was least recently added. * * @return the item on this queue that was least recently added * @throws NoSuchElementException if this queue is empty */ public Item dequeue() &#123; if (isEmpty()) throw new NoSuchElementException("Queue underflow"); Item item = first.item; first = first.next; n--; if (isEmpty()) last = null; // to avoid loitering return item; &#125; /** * Returns a string representation of this queue. * * @return the sequence of items in FIFO order, separated by spaces */ public String toString() &#123; StringBuilder s = new StringBuilder(); for (Item item : this) &#123; s.append(item); s.append(' '); &#125; return s.toString(); &#125; /** * Returns an iterator that iterates over the items in this queue in FIFO order. * * @return an iterator that iterates over the items in this queue in FIFO order */ public Iterator&lt;Item&gt; iterator() &#123; return new ListIterator&lt;Item&gt;(first); &#125; // an iterator, doesn't implement remove() since it's optional private class ListIterator&lt;Item&gt; implements Iterator&lt;Item&gt; &#123; private Node&lt;Item&gt; current; public ListIterator(Node&lt;Item&gt; first) &#123; current = first; &#125; public boolean hasNext() &#123; return current != null; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; public Item next() &#123; if (!hasNext()) throw new NoSuchElementException(); Item item = current.item; current = current.next; return item; &#125; &#125; /** * Unit tests the &#123;@code Queue&#125; data type. * * @param args the command-line arguments */ public static void main(String[] args) &#123; Queue&lt;String&gt; queue = new Queue&lt;String&gt;(); while (!StdIn.isEmpty()) &#123; String item = StdIn.readString(); if (!item.equals("-")) queue.enqueue(item); else if (!queue.isEmpty()) StdOut.print(queue.dequeue() + " "); &#125; StdOut.println("(" + queue.size() + " left on queue)"); &#125;&#125; 栈(Stack)下压栈是一种基于LIFO策略的集合类型,元素的处理顺序和它们被压入的顺序正好相反,应用程序中使用栈的主要原因是用集合保存元素的同时颠倒它们的相对顺序 Stack(LIFO) 注释 public class Stack&lt;Item&gt; implements Iterable&lt;Item&gt; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stack() 创建一个空栈 void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push(Item item) 添加一个元素 Item&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop() 删除一个元素 boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isEmpty() 栈是否为空 int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size() 栈中的元素数量 具体实现(链表实现):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163/** * The &#123;@code Stack&#125; class represents a last-in-first-out (LIFO) stack of generic items. * It supports the usual &lt;em&gt;push&lt;/em&gt; and &lt;em&gt;pop&lt;/em&gt; operations, along with methods * for peeking at the top item, testing if the stack is empty, and iterating through * the items in LIFO order. * &lt;p&gt; * This implementation uses a singly linked list with a static nested class for * linked-list nodes. See &#123;@link LinkedStack&#125; for the version from the * textbook that uses a non-static nested class. * See &#123;@link ResizingArrayStack&#125; for a version that uses a resizing array. * The &lt;em&gt;push&lt;/em&gt;, &lt;em&gt;pop&lt;/em&gt;, &lt;em&gt;peek&lt;/em&gt;, &lt;em&gt;size&lt;/em&gt;, and &lt;em&gt;is-empty&lt;/em&gt; * operations all take constant time in the worst case. * &lt;p&gt; * For additional documentation, * see &lt;a href="https://algs4.cs.princeton.edu/13stacks"&gt;Section 1.3&lt;/a&gt; of * &lt;i&gt;Algorithms, 4th Edition&lt;/i&gt; by Robert Sedgewick and Kevin Wayne. * * @author Robert Sedgewick * @author Kevin Wayne * * @param &lt;Item&gt; the generic type of an item in this stack */public class Stack&lt;Item&gt; implements Iterable&lt;Item&gt; &#123; private Node&lt;Item&gt; first; // top of stack private int n; // size of the stack // helper linked list class private static class Node&lt;Item&gt; &#123; private Item item; private Node&lt;Item&gt; next; &#125; /** * Initializes an empty stack. */ public Stack() &#123; first = null; n = 0; &#125; /** * Returns true if this stack is empty. * * @return true if this stack is empty; false otherwise */ public boolean isEmpty() &#123; return first == null; &#125; /** * Returns the number of items in this stack. * * @return the number of items in this stack */ public int size() &#123; return n; &#125; /** * Adds the item to this stack. * * @param item the item to add */ public void push(Item item) &#123; Node&lt;Item&gt; oldfirst = first; first = new Node&lt;Item&gt;(); first.item = item; first.next = oldfirst; n++; &#125; /** * Removes and returns the item most recently added to this stack. * * @return the item most recently added * @throws NoSuchElementException if this stack is empty */ public Item pop() &#123; if (isEmpty()) throw new NoSuchElementException("Stack underflow"); Item item = first.item; // save item to return first = first.next; // delete first node n--; return item; // return the saved item &#125; /** * Returns (but does not remove) the item most recently added to this stack. * * @return the item most recently added to this stack * @throws NoSuchElementException if this stack is empty */ public Item peek() &#123; if (isEmpty()) throw new NoSuchElementException("Stack underflow"); return first.item; &#125; /** * Returns a string representation of this stack. * * @return the sequence of items in this stack in LIFO order, separated by spaces */ public String toString() &#123; StringBuilder s = new StringBuilder(); for (Item item : this) &#123; s.append(item); s.append(' '); &#125; return s.toString(); &#125; /** * Returns an iterator to this stack that iterates through the items in LIFO order. * * @return an iterator to this stack that iterates through the items in LIFO order */ public Iterator&lt;Item&gt; iterator() &#123; return new ListIterator&lt;Item&gt;(first); &#125; // an iterator, doesn't implement remove() since it's optional private class ListIterator&lt;Item&gt; implements Iterator&lt;Item&gt; &#123; private Node&lt;Item&gt; current; public ListIterator(Node&lt;Item&gt; first) &#123; current = first; &#125; public boolean hasNext() &#123; return current != null; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; public Item next() &#123; if (!hasNext()) throw new NoSuchElementException(); Item item = current.item; current = current.next; return item; &#125; &#125; /** * Unit tests the &#123;@code Stack&#125; data type. * * @param args the command-line arguments */ public static void main(String[] args) &#123; Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); while (!StdIn.isEmpty()) &#123; String item = StdIn.readString(); if (!item.equals("-")) stack.push(item); else if (!stack.isEmpty()) StdOut.print(stack.pop() + " "); &#125; StdOut.println("(" + stack.size() + " left on stack)"); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Bag</tag>
        <tag>Queue</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让类实现for-each loop:Iterable与Iterator接口]]></title>
    <url>%2F2018%2F06%2F01%2FIterable%E4%B8%8EIterator%2F</url>
    <content type="text"><![CDATA[Interface Iterable&lt;T&gt;根据Java API上写: Implementing this interface allows an object to be the target of the “for-each loop” statement. 也就是说,实现该接口可以让类实现for循环阅读Iterable源码,该接口有3个方法 Modifier,Type and Method Description public interface Iterable&lt;T&gt; &nbsp; default void forEach(Consumer action) Performs the given action for each element of the Iterable until all elements have been processed or the action throws an exception. Iterator&lt;T&gt; iterator() Returns an iterator over elements of type T. default Spliterator spliterator() Creates a Spliterator over the elements described by this Iterable. 可以知道,实现该接口,我们只需要实现Iterator iterator()由API: Iterator iterator()Returns an iterator over elements of type T.Returns:an Iterator. 我们只需要返回一个Iterator对象就可以了 Interface IteratorJava API中说到: An iterator over a collection. Iterator takes the place of Enumeration in the Java Collections Framework. Iterators differ from enumerations in two ways:Iterators allow the caller to remove elements from the underlying collection during the iteration with well-defined semantics.Method names have been improved. 其实就是一个迭代器啦… Modifier,Type and Method Description public interface Iterator&lt;E&gt; &nbsp; default void forEachRemaining(Consumer action) Performs the given action for each remaining element until all elements have been processed or the action throws an exception. boolean hasNext() Returns true if the iteration has more elements. E next() Returns the next element in the iteration. default void remove() Removes from the underlying collection the last element returned by this iterator (optional operation). 可以知道,实现该接口,只要实现next()与hasNext(),当有remove()需求时,也要实现该方法. 下面是具体实现1.类名中加上implements Iterable1public class ClassName&lt;E&gt; implements Iterable&lt;E&gt; 2.实现Iterator iterator(),返回Iterator对象1public Iterator&lt;E&gt; iterator() &#123; return new MyIterator&lt;E&gt;(); &#125; 3.实现内部类MyIterator1234567891011121314private class MyIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123; public boolean hasNext() &#123; //return true if the iteration has more elements &#125; public E next() &#123; if (!hasNext()) throw NoSuchElementException(); // returns the next element in the iteration &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125;&#125; 对Iterator的next()与remove()方法的解释Java的迭代器认为是位于两个元素之间的,当调用next()的时候,迭代器就会越过下一个元素,并返回越过的元素的引用 即如果要用remove()连续删除2个相邻的元素1234Iterator&lt;String&gt; it = instance.iterator(); // 假设instance是实现了Iterable接口的类的实例,泛型指定为Stringit.next();it.remove();it.remove(); // error! 上面的是不行的,因为Java的迭代器并不像C++根据数组索引建模的,在Java迭代器中,查找操作与位置变更是紧密相连的,查找一个元素的唯一方法是调用next(),而执行查找操作的同时,迭代器的位置随之向前移动12345Iterator&lt;String&gt; it = instance.iterator(); // 假设instance是实现了Iterable接口的类的实例,泛型指定为Stringit.next();it.remove();it.next();it.remove(); // OK 调用next()的过程见下图]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Iterable</tag>
        <tag>Iterator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaDoc与Jar]]></title>
    <url>%2F2018%2F06%2F01%2FJavaDoc%E4%B8%8EJar%2F</url>
    <content type="text"><![CDATA[使用JavaDoc生成文档1javadoc -d 目录名 -encoding UTF-8 -charset UTF-8 xxx.java java内格式： /** 文档内容 / @author : 对类的说明，表明开发该类模块的作者 @version : 对类的说明，表明该模块版本 @see : 对类，属性，方法的说明，参考转向，也就是相关主题 @param : 对方法的说明，对方法中某参数的说明 @return : 对方法的说明，对方法返回值的说明 @exception : 对方法的说明，对方法可能抛出的异常进行说明 下为《算法》中StdRandom.java源码的注释与文档效果 使用jar打包（1）编译 javac A.java （2）打包 jar cvfm A.jar A.man A.class ——c表示创建(create)，v表示显示详情(verbose)，f表示指定文件名，m表示清单文件（3）运行 java -jar A.jar 其中A.man是清单文件（manifest），内容如下：·Manifest-Version：1.0Class-Path：.Main-Class：A]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaDoc</tag>
        <tag>Jar</tag>
      </tags>
  </entry>
</search>
