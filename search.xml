<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java基础之初窥反射]]></title>
    <url>%2F2018%2F06%2F19%2FJava%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%9D%E7%AA%A5%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[前言:之前写安卓的时候有遇到过反射,但是当时怎么都不理解,现在正好借此机会初步了解一下反射 什么是反射 Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.The API accommodates applications that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class. It also allows programs to suppress default reflective access control. 简单来说,反射能够分析类能力,他可以做以下几件事: 在运行时分析类的能力 在运行时查看对象,例如,写一个toString方法供所有类使用 实现通用的数组操作代码 利用Method对象(类比C中的函数指针) 获得对象的Class类反射比较重要的一点是获得对象的类,对象的类是一个Class对象(但不是所有Class对象都是一种类,例如int也是Class对象) 以下是三种获得Class类的方法1234// 第一种:通过对象.getClass()获得Employee e;...Class cl = e.getClass(); 1234567// 第二种:通过Class类的静态方法forName()获得try &#123; String className = "java.util.Random"; Class cl = Class.forName(className);&#125; catch (Execption e) &#123; e.printStackTrace();&#125; 1234// 第三种:通过T.class获得(T是任意Java类型)Class cl1 = Random.class;Class cl2 = int.class;Class cl3 = Double[].class; Class类的一些常用方法getName() Returns the name of the entity (class, interface, array class, primitive type, or void) represented by this Class object, as a String. 123Employee e;...System.out.println(e.getClass().getName()); newInstance() Creates a new instance of the class represented by this Class object. 123Employee e;e.getClass().newInstance();// 调用默认的构造函数,如果要传参,请使用Constructor类的newInstance(Objcet[] args)方法 getMethod() Modifier and Type Method and Description Method getMethod(String name, Class&lt;?&gt;… parameterTypes) &nbsp; Returns a Method object that reflects the specified public member method of the class or interface represented by this Class object. e.g. 获得Employee的raiseSalary方法 Method m1 = Employee.class.getMethod(&quot;raiseSalary&quot;, double.class); getDeclaredFields() Returns an array of Field objects reflecting all the fields declared by the class or interface represented by this Class object. getDeclaredMethods() Returns an array containing Method objects reflecting all the declared methods of the class or interface represented by this Class object, including public, protected, default (package) access, and private methods, but excluding inherited methods. getDeclaredConsstructors() Returns an array of Constructor objects reflecting all the constructors declared by the class represented by this Class object. getDeclaredFields()与getFields()的区别getFields()返回一个包含Field对象的数组,这些对象记录了这个类或其超类的公有域,而getDeclaredFields()的对象记录了这个类的全部域类比Methods与Constructors 反射包中重要类的简单描述在java.lang.reflect包中有三个类Field,Method,和Constructor分别用于描述类的域,方法和构造器 FieldField用于描述类的域,常见的方法有 Modifier and Type Method and Description Object get(Object obj) &nbsp; Returns the value of the field represented by this Field, on the specified object. void set(Object obj, Object value) &nbsp; Sets the field represented by this Field object on the specified object argument to the specified new value. int getModifiers() &nbsp; Returns the Java language modifiers for the field represented by this Field object, as an integer. Class&lt;?&gt; getType() &nbsp; Returns a Class object that identifies the declared type for the field represented by this Field object. String getName() &nbsp; Returns the name of the field represented by this Field object. Method Modifier and Type Method and Description String getName() &nbsp; Returns the name of the method represented by this Method object, as a String. Class&lt;?&gt; getReturnType() &nbsp; Returns a Class object that represents the formal return type of the method represented by this Method object. int getModifiers() &nbsp; Returns the Java language modifiers for the field represented by this Field object, as an integer. Class&lt;?&gt;[] getParameterTypes() &nbsp; Returns an array of Class objects that represent the formal parameter types, in declaration order, of the executable represented by this object. Object invoke(Object obj, Object… args) &nbsp; Invokes the underlying method represented by this Method object, on the specified object with the specified parameters. Constructor Modifier and Type Method and Description String getName() &nbsp; Returns the name of this constructor, as a string. Class&lt;?&gt;[] getParameterTypes() &nbsp; Returns an array of Class objects that represent the formal parameter types, in declaration order, of the executable represented by this object. int getModifiers() &nbsp; Returns the Java language modifiers for the field represented by this Field object, as an integer. 利用反射分析类的能力12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class ReflectionTest &#123; public static void main(String[] args) &#123; String name; if (args.length &gt; 0) name = args[0]; else &#123; Scanner in = new Scanner(System.in); System.out.println("Enter class name (e.g. java.util.Date):"); name = in.next(); &#125; try &#123; Class cl = Class.forName(name); Class supercl = cl.getSuperclass(); String modifiers = Modifier.toString(cl.getModifiers()); if (modifiers.length() &gt; 0) System.out.print(modifiers + " "); System.out.print("class " + name); if (supercl != null &amp;&amp; supercl != Object.class) System.out.print(" extends " + supercl.getName()); System.out.print("\n&#123;\n"); printConstructors(cl); System.out.println(); printMethods(cl); System.out.println(); printFields(cl); System.out.println("&#125;"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.exit(0); &#125; public static void printConstructors(Class cl) &#123; Constructor[] constructors = cl.getDeclaredConstructors(); for (Constructor c : constructors) &#123; String name = c.getName(); System.out.print(" "); String modifiers = Modifier.toString(c.getModifiers()); if (modifiers.length() &gt; 0) System.out.print(modifiers + " "); System.out.print(name + "("); Class[] paramTypes = c.getParameterTypes(); // 构造器的参数是Class类型 for (int j = 0; j &lt; paramTypes.length; j++) &#123; if (j &gt; 0) System.out.print(", "); System.out.print(paramTypes[j].getName()); &#125; System.out.println(");"); &#125; &#125; public static void printMethods(Class cl) &#123; Method[] methods = cl.getDeclaredMethods(); for (Method m : methods) &#123; Class retType = m.getReturnType(); // 方法的返回值是Class类型,注意:int等基本数据类型也是Class类型 String name = m.getName(); System.out.print(" "); String modifiers = Modifier.toString(m.getModifiers()); if (modifiers.length() &gt; 0) System.out.print(modifiers + " "); System.out.print(retType.getName() + " " + name + "("); // 这里返回了int, boolean等 Class[] paramTypes = m.getParameterTypes(); for (int j = 0; j &lt; paramTypes.length; j++) &#123; if (j &gt; 0) System.out.print(", "); System.out.print(paramTypes[j].getName()); &#125; System.out.println(");"); &#125; &#125; public static void printFields(Class cl) &#123; Field[] fields = cl.getDeclaredFields(); for (Field f : fields) &#123; Class type = f.getType(); // Returns a Class object that identifies the declared type for the field represented by this Field object. String name = f.getName(); System.out.print(" "); String modifiers = Modifier.toString(f.getModifiers()); if (modifiers.length() &gt; 0) System.out.print(modifiers + " "); System.out.println(type.getName() + " " + name + ";"); &#125; &#125;&#125; 在运行时使用反射分析对象上面讲的是如何查看任意对象的数据域名称和类型,这次进一步查看数据域的实际内容12345Employee harry = new Employee("Harry Hacker", 35000, 10, 1 1989);Class cl = harry.getClass();Field f = cl.getDeclaredField("name");f.setAccessible(true);Object v = f.get(harry) // the value of v is "Harry Hacker" 上面是一个获得对象域的例子,注意反射机制默认受限于Java的访问控制,可以通过以下方法覆盖访问控制 f.setAccessible(true) Field继承自AccessibleObject,可通过其父类方法setAccessible()设置权限 AccessibleObject.setAccessible(fields, true) 调用静态方法对fields设置权限(见下面代码) 下面是一个通用的toString方法12345678910111213141516public class ObjectAnalyzerTest &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; squares = new ArrayList&lt;&gt;(); String[] ss = &#123;"a", "b", "c"&#125;; for (int i = 1; i &lt;= 5; i++) &#123; squares.add(i * i); &#125; ObjectAnalyzer objectAnalyzer = new ObjectAnalyzer();// System.out.println(objectAnalyzer.toString(ss)); System.out.println(objectAnalyzer.toString(squares));// System.out.println(new ObjectAnalyzer().toString(12345));// System.out.println(new ObjectAnalyzer().toString("test"));// System.out.println(new ObjectAnalyzer().toString(null)); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class ObjectAnalyzer &#123; private ArrayList&lt;Object&gt; visited = new ArrayList&lt;&gt;(); // 循环引用可能导致无限递归 public String toString(Object obj) &#123; if (obj == null) return "null"; if (visited.contains(obj)) return "..."; visited.add(obj); Class cl = obj.getClass(); if (cl == String.class) return (String)obj; if (cl.isArray()) &#123; String r = cl.getComponentType() + "[]&#123;"; // getComponentType() Returns the Class representing the component type of an array. for (int i = 0; i &lt; Array.getLength(obj); i++) &#123; if (i &gt; 0) r += ","; Object val = Array.get(obj, i); if (cl.getComponentType().isPrimitive()) r += val; else r += toString(val); &#125; return r + "&#125;"; &#125; String r = cl.getName(); do &#123; r += "["; Field[] fields = cl.getDeclaredFields(); AccessibleObject.setAccessible(fields, true); for (Field f : fields) &#123; if (!Modifier.isStatic((f.getModifiers()))) &#123; // 静态域舍弃 if (!r.endsWith("[")) r += ","; r += f.getName() + "="; try &#123; Class t = f.getType(); Object val = f.get(obj); if (t.isPrimitive()) r += val; // 如果为原始数据类型则直接添加 else r += toString(val); // 否则递归调用 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; r += "]"; cl = cl.getSuperclass(); &#125; while (cl != null); return r; &#125;&#125; 使用反射编写泛型数组代码123456789101112131415161718192021222324252627282930public class CopyOfTest &#123; public static void main(String[] args) &#123; int[] a = &#123; 1, 2, 3 &#125;; a = (int[]) goodCopyOf(a, 10); System.out.println(Arrays.toString(a)); String[] b = &#123; "Tom", "Dick", "Harry" &#125;; b = (String[]) goodCopyOf(b, 10); System.out.println(Arrays.toString(b)); &#125; // int[]无法转换为Object[] public static Object[] badCopyOf(Object[] a, int newLength) &#123; Object[] newArray = new Object[newLength]; System.arraycopy(a, 0, newArray, 0, Math.min(a.length, newLength)); return newArray; &#125; public static Object goodCopyOf(Object a, int newLength) &#123; Class cl = a.getClass(); if (!cl.isArray()) return null; Class componentType = cl.getComponentType(); // Returns the Class representing the component type of an array. int length = Array.getLength(a); Object newArray = Array.newInstance(componentType, newLength); System.arraycopy(a, 0, newArray, 0, Math.min(length, newLength)); return newArray; &#125;&#125; 注意getComponentType()是Class的方法而不是Array的方法Array.newInstance()返回Object对象 调用任意方法类似C语言的函数指针,通过Java的反射机制可以调用任意方法 Object invoke(Object obj, Object... args)第一个参数是隐式参数,其余的对象提供了显示参数,对于静态方法,第一个参数可以被忽略,即设置为null,e.g. ml是一个Method,代表Employee的getName方法,harry是一个Employee对象String n = (String) ml.invoke(harry) // 调用harry的getName()方法method.invoke(a, s); // 调用a的method方法,参数为smethod.invoke(null, s); // 调用静态method方法,参数为s注意invoke返回的是Object 而获得方法可以通过Class cl = harry.getClass()cl.getMethod(String name, Class&lt;?&gt;... parameterTypes) 一个使用invoke的例子123456789101112131415161718192021222324252627282930public class MethodTableTest &#123; public static void main(String[] args) &#123; try &#123; Method square = MethodTableTest.class.getMethod("square", double.class); Method sqrt = Math.class.getMethod("sqrt", double.class); printTable(1, 10, 10, square); printTable(1, 10, 10, sqrt); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static double square(double x) &#123; return x * x; &#125; public static void printTable(double from, double to, int n, Method f) &#123; System.out.println(f); double dx = (to - from) / (n - 1); for (double x = from; x &lt;= to; x += dx) &#123; try &#123; double y = (Double) f.invoke(null, x); System.out.printf("%10.4f | %10.4f%n", x, y); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 后言:这次仅仅是跟着课本尝试了一下反射,以后有了相应的基础后会深入理解反射的机制]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object,所有类的超类]]></title>
    <url>%2F2018%2F06%2F03%2FObject-%E6%89%80%E6%9C%89%E7%B1%BB%E7%9A%84%E8%B6%85%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Object类是Java中所有类的超类,在Java中每个类都由它扩展而来Object类的方法如下 其中最为关键的3个方法为equals(),hashCode()和toString() equals方法官方文档 在文档中说到,equals用于检测一个对象是否等于另一个对象,该方法必须有以下5个特性: 自反性:对任意非空引用x,&nbsp;&nbsp;&nbsp;x.equals(x)&nbsp;&nbsp;必须返回true 对称性:对任意非空引用x,y,&nbsp;&nbsp;x.equals(y)&nbsp;&nbsp;返回true当且仅当&nbsp;&nbsp;y.equals(x)&nbsp;&nbsp;返回true 传递性:对任意非空引用x,y,z,如果&nbsp;&nbsp;x.equals(y)&nbsp;&nbsp;返回true并且&nbsp;&nbsp;y.equals(x)&nbsp;&nbsp;返回true,则&nbsp;&nbsp;x.equals(z)&nbsp;&nbsp;返回true 一致性:如果x和y引用的对象没有发生变化,反复调用&nbsp;&nbsp;x.equals(y)&nbsp;&nbsp;应该返回同样的结果 对于任意非空引用x,&nbsp;&nbsp;x.equals(y)&nbsp;&nbsp;应该返回false Object类的equals方法而Object类中的默认的equals方法如下123public boolean equals(Object obj) &#123; return (this == obj);&#125; 自定义类的equals方法如果两个对象具有相同的引用,则返回true,否则返回false,这是最经济的符合以上5个特性的equals方法了,但是很多时候这种判断并没有什么意义,更多时候我们要判断对象是否相等,需要检测他们状态的相等性,如果两个对象的状态相等,则认为他们是相等的,比如有一个雇员Employee类,如果两个雇员对象的姓名,薪水和雇佣日期都相等,则认为他们是相等的,那么雇员类的equals方法可以如下(完整的Employee类请见最后)1234567891011121314 public boolean equals(Object otherObject) &#123; if (this == otherObject) return true; // 先判断这两个对象是否具有相同的引用 if (otherObject == null) return false; // 然后判断otherObject是否为null if (getClass() != otherObject.getClass()) return false; // 使用getClass()判断是否为同一类 Employee other = (Employee) otherObject; // 把Object类转换成Employee类 return Objects.equals(name, other.name) // 详细比较他们的域 &amp;&amp; salary == other.salary &amp;&amp; Objects.equals(hireDay, other.hireDay); &#125;&#125; Employee类的equals方法代码解释代码中使用&nbsp;Objects.equals(name, other.name)&nbsp;是为了防备name和hireDay可能为null的情况,下面是Objects类的equals方法,当对象a和b都是null,则返回true,如果其中一个是null则返回false,否则调用a.equals(b)123public static boolean equals(Object a, Object b) &#123; return (a == b) || (a != null &amp;&amp; a.equals(b));&#125; 在是否为同一类的比较中,,除了&nbsp;&nbsp;if (getClass() != otherObject.getClass()) return false;&nbsp;&nbsp;这个判断外,还可以使用&nbsp;&nbsp;if (!(otherObject instanceof Employee)) return false;&nbsp;&nbsp;来判断,但是使用instanceof判断没有解决otherObject是子类的情况(&nbsp;子类引用 instanceof 父类&nbsp;返回true,但反过来则返回false,不符合对称性)所以,使用getClass()与instanceof可以根据下面情况判断: 如果子类能够拥有自己的相等概念,则对称性需求将强制性采用getClass进行检测 如果由超类决定相等的概念(比如Employee与其子类Manager中使用Employee类的成员ID来判断是否相等),那么就可以使用instanceof进行检测 完美的equals方法 显示参数命名为otherObject,稍后强制类型转换为变量other 检测this与ohetObject是否引用同一对象 检测ohterObject是否为null,如果为null返回false 比较this与otherObject是否属于同一类,根据相等概念由父类还是子类决定用getClass()还是instanceof检测 将ohterObject转换为相应的类类型变量 开始对需要比较的域进行比较,对于对象的比较,用Objects.equals(field, other.field) 子类中的equals方法12345public boolean equals(Object otherObject) &#123; if (!super.equals(otherObject)) return false; Manager other = (Manager) otherObject; return bonus == other.bonus; &#125; 先调用super.equals(otherObject)检测父类元素是否相等,然后再比较子类的域 其他对于数组类型的域,使用静态方法Arrays.equals方法判断 hashCode方法散列码hashCode是由对象导出的一个整型值,不同的对象散列码一般不会相同 官方文档根据说明我们可以得知: 只要在Java应用程序执行过程中多次调用同一对象时，hashCode方法就必须始终返回相同的整数，前提是未修改对象的等同比较中使用的信息。 该整数不需要从应用程序的一次执行到同一应用程序的另一次执行保持一致。 如果两个对象由equals方法得到的结果为true，则对这两个对象中的每个对象调用hashCode方法必须产生相同的整数结果。 根据equals方法，如果两个对象不相等，则不要求对两个对象中的每一个调用hashCode方法都必须生成不同的整数结果。 但是，程序员应该意识到，为不相等的对象生成不同的整数结果可能会提高散列表的性能。 Object类中的hashCode方法在源码中,hashCode()不是由Java代码生成的,它返回的值为对象的存储地址,这里就不赘述了 自定义类的hashCode方法如果要重新定义equals方法,则必须重新定义hashCode方法equals方法与什么成员有关,hashCode也必须与该成员有关e.g:如果equals方法与Employee类的salary,hireDay,name相关,则Employee的hashCode方法可以定义如下 123456public int hashCode() &#123; return 7 * Objects.hashCode(name) + 11 * Double.hashCode(salary) + 13 * Objects.hashCode(hireDay);// 如果成员为数组,则使用Arrays.hashCode()&#125; 或者使用Objects.hash(Object… values)123public int hashCode() &#123; return Objects.hash(name, salary, hireDay);&#125; Objects.hashCode(Object o)是null安全的,当参数为null则返回0,否则返回对参数调用Object.hashCode()的结果注意:只有一个参数的时候不要使用Objects.hash(),而是Objects.hashCode(Object o)或者Doubles.hashCode(Double d) Objects.hash(Object… values)源码123public static int hash(Object... values) &#123; return Arrays.hashCode(values);&#125; Arrays.hashCode(Object a[])源码1234567891011public static int hashCode(Object a[]) &#123; if (a == null) return 0; int result = 1; for (Object element : a) result = 31 * result + (element == null ? 0 : element.hashCode()); return result; &#125; toString方法toString()方法返回表示对象值的字符串 官方文档 Object类的toString方法123public String toString() &#123; return getClass().getName() + "@" + Integer.toHexString(hashCode());&#125; 他返回 getClass().getName() + &#39;@&#39; + Integer.toHexString(hashCode()) toString()为什么随处可见只要对象与一个字符串通过操作符”+”连接起来,Java编译就会自动调用toString方法 数组的toString方法数组继承了Object类的toString,仍会像Object类那样输出字符串,大概输出如下[I@1a46e30]这不符合我们的预期,修正方法如下: Arrays.toString()调用静态方法Arrays.toString(),返回对象大概为[2,3,5,7,11,13]如果想要打印多维数组,调用 Arrays.deepToString() 测试类Employee与Manager的源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.time.LocalDate;import java.util.Objects;public class Employee &#123; private String name; private double salary; private LocalDate hireDay; public Employee(String n, double s, int year, int month, int day) &#123; name = n; salary = s; hireDay = LocalDate.of(year, month, day); &#125; public String getName() &#123; return name; &#125; public double getSalary() &#123; return salary; &#125; public LocalDate getHireDay() &#123; return hireDay; &#125; public void raiseSalary(double byPercent) &#123; double raise = salary * byPercent / 100; salary += raise; &#125; public boolean equals(Object otherObject) &#123; if (this == otherObject) return true; if (otherObject == null) return false; if (getClass() != otherObject.getClass()) return false; Employee other = (Employee) otherObject; return Objects.equals(name, other.name) &amp;&amp; salary == other.salary &amp;&amp; Objects.equals(hireDay, other.hireDay); &#125; public int hashCode() &#123; return 7 * Objects.hashCode(name) + 11 * Double.hashCode(salary) + 13 * Objects.hashCode(hireDay); &#125; /* public int hashCode() &#123; * return Objects.hash(name, salary, hireDay); * &#125; * */ public String toString() &#123; return getClass().getName() + "[name = " + name + ",salary = " + salary + ",hireDay = " + hireDay + "]"; &#125;&#125; 1234567891011121314151617181920212223242526272829303132public class Manager extends Employee &#123; private double bonus; public Manager(String n, double s, int year, int month, int day) &#123; super(n, s, year, month, day); bonus = 0; &#125; public double getSalary() &#123; double baseSalary = super.getSalary(); return baseSalary + bonus; &#125; public void setBonus(double b) &#123; bonus = b; &#125; public boolean equals(Object otherObject) &#123; if (!super.equals(otherObject)) return false; Manager other = (Manager) otherObject; return bonus == other.bonus; &#125; public int hashCode() &#123; return super.hashCode() + 17 * Double.hashCode(bonus); &#125; public String toString() &#123; return super.toString() + "[bonus = " + bonus + "]"; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java继承之子类访问父类的私有域]]></title>
    <url>%2F2018%2F06%2F01%2FJava%E7%BB%A7%E6%89%BF%E4%B9%8B%E5%AD%90%E7%B1%BB%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[在类的继承中,子类可以访问父类的公有方法和域,但对于父类的私有成员则不能访问,但很多情况下,子类也应当拥有父类的私有属性,例如一个雇员Employee有名字,薪资,雇佣时间等属性,经理Manager也属于雇员,那么经理也应当有名字,薪资,雇佣时间等,那么问题就来了,子类如何才能使用父类的私有成员?请看下面代码123456789101112131415161718public class Father &#123; private int a; // 默认构造方法,如果没有此方法,子类构造器第一句必须调用super() public Father() &#123; &#125; public Father(int a) &#123; this.a = a; &#125; public int getA() &#123; return a; &#125; public void setA(int a) &#123; this.a = a; &#125;&#125; 1234567891011121314151617public class Son extends Father&#123; public Son() &#123; // 如果子类没有显式调用super(),则自动调用父类默认(没有参数)的构造器,如果父类没有默认构造器,则报错 &#125; public Son(int a) &#123; super(a); // super()必须是子类构造器的第一句 &#125; public static void main(String[] args) &#123; Son son1 = new Son(); son1.setA(123); // 第一种给父类成员赋值的方法,调用setter() Son son2 = new Son(234); // 第二种给父类成员赋值的方法,构造器初始化 System.out.println(son.getA()); // 调用getter()获取父类成员 &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[algs之背包,队列和栈]]></title>
    <url>%2F2018%2F06%2F01%2Falgs%E4%B9%8B%E8%83%8C%E5%8C%85-%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88%2F</url>
    <content type="text"><![CDATA[背包(Bag)背包是一种不支持从中删除元素的集合数据类型—-它的目的就是帮助用例收集元素并迭代遍历所有收集到的元素(用例也可以检查背包是否为空或者获取背包中元素的数量) Bag 注释 public class Bag&lt;Item&gt; implements Iterable&lt;Item&gt; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bag() 创建一个空背包 boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isEmpty() 背包是否为空 int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size() 背包中的元素数量 具体实现(链表实现):代码均来自algs4配套代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116/** * The &#123;@code Bag&#125; class represents a bag (or multiset) of * generic items. It supports insertion and iterating over the * items in arbitrary order. * &lt;p&gt; * This implementation uses a singly linked list with a static nested class Node. * See &#123;@link LinkedBag&#125; for the version from the * textbook that uses a non-static nested class. * See &#123;@link ResizingArrayBag&#125; for a version that uses a resizing array. * The &lt;em&gt;add&lt;/em&gt;, &lt;em&gt;isEmpty&lt;/em&gt;, and &lt;em&gt;size&lt;/em&gt; operations * take constant time. Iteration takes time proportional to the number of items. * &lt;p&gt; * For additional documentation, see &lt;a href="https://algs4.cs.princeton.edu/13stacks"&gt;Section 1.3&lt;/a&gt; of * &lt;i&gt;Algorithms, 4th Edition&lt;/i&gt; by Robert Sedgewick and Kevin Wayne. * * @author Robert Sedgewick * @author Kevin Wayne * * @param &lt;Item&gt; the generic type of an item in this bag */public class Bag&lt;Item&gt; implements Iterable&lt;Item&gt; &#123; private Node&lt;Item&gt; first; // beginning of bag private int n; // number of elements in bag // helper linked list class private static class Node&lt;Item&gt; &#123; private Item item; private Node&lt;Item&gt; next; &#125; /** * Initializes an empty bag. */ public Bag() &#123; first = null; n = 0; &#125; /** * Returns true if this bag is empty. * * @return &#123;@code true&#125; if this bag is empty; * &#123;@code false&#125; otherwise */ public boolean isEmpty() &#123; return first == null; &#125; /** * Returns the number of items in this bag. * * @return the number of items in this bag */ public int size() &#123; return n; &#125; /** * Adds the item to this bag. * * @param item the item to add to this bag */ public void add(Item item) &#123; Node&lt;Item&gt; oldfirst = first; first = new Node&lt;Item&gt;(); first.item = item; first.next = oldfirst; n++; &#125; /** * Returns an iterator that iterates over the items in this bag in arbitrary order. * * @return an iterator that iterates over the items in this bag in arbitrary order */ public Iterator&lt;Item&gt; iterator() &#123; return new ListIterator&lt;Item&gt;(first); &#125; // an iterator, doesn't implement remove() since it's optional private class ListIterator&lt;Item&gt; implements Iterator&lt;Item&gt; &#123; private Node&lt;Item&gt; current; public ListIterator(Node&lt;Item&gt; first) &#123; current = first; &#125; public boolean hasNext() &#123; return current != null; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; public Item next() &#123; if (!hasNext()) throw new NoSuchElementException(); Item item = current.item; current = current.next; return item; &#125; &#125; /** * Unit tests the &#123;@code Bag&#125; data type. * * @param args the command-line arguments */ public static void main(String[] args) &#123; Bag&lt;String&gt; bag = new Bag&lt;String&gt;(); while (!StdIn.isEmpty()) &#123; String item = StdIn.readString(); bag.add(item); &#125; StdOut.println("size of bag = " + bag.size()); for (String s : bag) &#123; StdOut.println(s); &#125; &#125;&#125; 队列(Queue)先进先出队列是一种基于FIFO策略的集合类型,元素处理的顺序就是它们被添加到队列中的顺序,应用程序中使用队列的主要原因是在用集合保存元素的同时保存他们的相对顺序 Queue(FIFO) 注释 public class Queue&lt;Item&gt; implements Iterable&lt;Item&gt; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Queue() 创建一个空队列 void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enqueue(Item item) 添加一个元素 Item&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dequeue() 删除一个元素 boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isEmpty() 队列是否为空 int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size() 队列中的元素数量 具体实现(链表实现):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162/** * The &#123;@code Queue&#125; class represents a first-in-first-out (FIFO) * queue of generic items. * It supports the usual &lt;em&gt;enqueue&lt;/em&gt; and &lt;em&gt;dequeue&lt;/em&gt; * operations, along with methods for peeking at the first item, * testing if the queue is empty, and iterating through * the items in FIFO order. * &lt;p&gt; * This implementation uses a singly linked list with a static nested class for * linked-list nodes. See &#123;@link LinkedQueue&#125; for the version from the * textbook that uses a non-static nested class. * See &#123;@link ResizingArrayQueue&#125; for a version that uses a resizing array. * The &lt;em&gt;enqueue&lt;/em&gt;, &lt;em&gt;dequeue&lt;/em&gt;, &lt;em&gt;peek&lt;/em&gt;, &lt;em&gt;size&lt;/em&gt;, and &lt;em&gt;is-empty&lt;/em&gt; * operations all take constant time in the worst case. * &lt;p&gt; * For additional documentation, see &lt;a href="https://algs4.cs.princeton.edu/13stacks"&gt;Section 1.3&lt;/a&gt; of * &lt;i&gt;Algorithms, 4th Edition&lt;/i&gt; by Robert Sedgewick and Kevin Wayne. * * @author Robert Sedgewick * @author Kevin Wayne * * @param &lt;Item&gt; the generic type of an item in this queue */public class Queue&lt;Item&gt; implements Iterable&lt;Item&gt; &#123; private Node&lt;Item&gt; first; // beginning of queue private Node&lt;Item&gt; last; // end of queue private int n; // number of elements on queue // helper linked list class private static class Node&lt;Item&gt; &#123; private Item item; private Node&lt;Item&gt; next; &#125; /** * Initializes an empty queue. */ public Queue() &#123; first = null; last = null; n = 0; &#125; /** * Returns true if this queue is empty. * * @return &#123;@code true&#125; if this queue is empty; &#123;@code false&#125; otherwise */ public boolean isEmpty() &#123; return first == null; &#125; /** * Returns the number of items in this queue. * * @return the number of items in this queue */ public int size() &#123; return n; &#125; /** * Returns the item least recently added to this queue. * * @return the item least recently added to this queue * @throws NoSuchElementException if this queue is empty */ public Item peek() &#123; if (isEmpty()) throw new NoSuchElementException("Queue underflow"); return first.item; &#125; /** * Adds the item to this queue. * * @param item the item to add */ public void enqueue(Item item) &#123; Node&lt;Item&gt; oldlast = last; last = new Node&lt;Item&gt;(); last.item = item; last.next = null; if (isEmpty()) first = last; else oldlast.next = last; n++; &#125; /** * Removes and returns the item on this queue that was least recently added. * * @return the item on this queue that was least recently added * @throws NoSuchElementException if this queue is empty */ public Item dequeue() &#123; if (isEmpty()) throw new NoSuchElementException("Queue underflow"); Item item = first.item; first = first.next; n--; if (isEmpty()) last = null; // to avoid loitering return item; &#125; /** * Returns a string representation of this queue. * * @return the sequence of items in FIFO order, separated by spaces */ public String toString() &#123; StringBuilder s = new StringBuilder(); for (Item item : this) &#123; s.append(item); s.append(' '); &#125; return s.toString(); &#125; /** * Returns an iterator that iterates over the items in this queue in FIFO order. * * @return an iterator that iterates over the items in this queue in FIFO order */ public Iterator&lt;Item&gt; iterator() &#123; return new ListIterator&lt;Item&gt;(first); &#125; // an iterator, doesn't implement remove() since it's optional private class ListIterator&lt;Item&gt; implements Iterator&lt;Item&gt; &#123; private Node&lt;Item&gt; current; public ListIterator(Node&lt;Item&gt; first) &#123; current = first; &#125; public boolean hasNext() &#123; return current != null; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; public Item next() &#123; if (!hasNext()) throw new NoSuchElementException(); Item item = current.item; current = current.next; return item; &#125; &#125; /** * Unit tests the &#123;@code Queue&#125; data type. * * @param args the command-line arguments */ public static void main(String[] args) &#123; Queue&lt;String&gt; queue = new Queue&lt;String&gt;(); while (!StdIn.isEmpty()) &#123; String item = StdIn.readString(); if (!item.equals("-")) queue.enqueue(item); else if (!queue.isEmpty()) StdOut.print(queue.dequeue() + " "); &#125; StdOut.println("(" + queue.size() + " left on queue)"); &#125;&#125; 栈(Stack)下压栈是一种基于LIFO策略的集合类型,元素的处理顺序和它们被压入的顺序正好相反,应用程序中使用栈的主要原因是用集合保存元素的同时颠倒它们的相对顺序 Stack(LIFO) 注释 public class Stack&lt;Item&gt; implements Iterable&lt;Item&gt; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stack() 创建一个空栈 void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push(Item item) 添加一个元素 Item&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop() 删除一个元素 boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isEmpty() 栈是否为空 int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size() 栈中的元素数量 具体实现(链表实现):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163/** * The &#123;@code Stack&#125; class represents a last-in-first-out (LIFO) stack of generic items. * It supports the usual &lt;em&gt;push&lt;/em&gt; and &lt;em&gt;pop&lt;/em&gt; operations, along with methods * for peeking at the top item, testing if the stack is empty, and iterating through * the items in LIFO order. * &lt;p&gt; * This implementation uses a singly linked list with a static nested class for * linked-list nodes. See &#123;@link LinkedStack&#125; for the version from the * textbook that uses a non-static nested class. * See &#123;@link ResizingArrayStack&#125; for a version that uses a resizing array. * The &lt;em&gt;push&lt;/em&gt;, &lt;em&gt;pop&lt;/em&gt;, &lt;em&gt;peek&lt;/em&gt;, &lt;em&gt;size&lt;/em&gt;, and &lt;em&gt;is-empty&lt;/em&gt; * operations all take constant time in the worst case. * &lt;p&gt; * For additional documentation, * see &lt;a href="https://algs4.cs.princeton.edu/13stacks"&gt;Section 1.3&lt;/a&gt; of * &lt;i&gt;Algorithms, 4th Edition&lt;/i&gt; by Robert Sedgewick and Kevin Wayne. * * @author Robert Sedgewick * @author Kevin Wayne * * @param &lt;Item&gt; the generic type of an item in this stack */public class Stack&lt;Item&gt; implements Iterable&lt;Item&gt; &#123; private Node&lt;Item&gt; first; // top of stack private int n; // size of the stack // helper linked list class private static class Node&lt;Item&gt; &#123; private Item item; private Node&lt;Item&gt; next; &#125; /** * Initializes an empty stack. */ public Stack() &#123; first = null; n = 0; &#125; /** * Returns true if this stack is empty. * * @return true if this stack is empty; false otherwise */ public boolean isEmpty() &#123; return first == null; &#125; /** * Returns the number of items in this stack. * * @return the number of items in this stack */ public int size() &#123; return n; &#125; /** * Adds the item to this stack. * * @param item the item to add */ public void push(Item item) &#123; Node&lt;Item&gt; oldfirst = first; first = new Node&lt;Item&gt;(); first.item = item; first.next = oldfirst; n++; &#125; /** * Removes and returns the item most recently added to this stack. * * @return the item most recently added * @throws NoSuchElementException if this stack is empty */ public Item pop() &#123; if (isEmpty()) throw new NoSuchElementException("Stack underflow"); Item item = first.item; // save item to return first = first.next; // delete first node n--; return item; // return the saved item &#125; /** * Returns (but does not remove) the item most recently added to this stack. * * @return the item most recently added to this stack * @throws NoSuchElementException if this stack is empty */ public Item peek() &#123; if (isEmpty()) throw new NoSuchElementException("Stack underflow"); return first.item; &#125; /** * Returns a string representation of this stack. * * @return the sequence of items in this stack in LIFO order, separated by spaces */ public String toString() &#123; StringBuilder s = new StringBuilder(); for (Item item : this) &#123; s.append(item); s.append(' '); &#125; return s.toString(); &#125; /** * Returns an iterator to this stack that iterates through the items in LIFO order. * * @return an iterator to this stack that iterates through the items in LIFO order */ public Iterator&lt;Item&gt; iterator() &#123; return new ListIterator&lt;Item&gt;(first); &#125; // an iterator, doesn't implement remove() since it's optional private class ListIterator&lt;Item&gt; implements Iterator&lt;Item&gt; &#123; private Node&lt;Item&gt; current; public ListIterator(Node&lt;Item&gt; first) &#123; current = first; &#125; public boolean hasNext() &#123; return current != null; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; public Item next() &#123; if (!hasNext()) throw new NoSuchElementException(); Item item = current.item; current = current.next; return item; &#125; &#125; /** * Unit tests the &#123;@code Stack&#125; data type. * * @param args the command-line arguments */ public static void main(String[] args) &#123; Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); while (!StdIn.isEmpty()) &#123; String item = StdIn.readString(); if (!item.equals("-")) stack.push(item); else if (!stack.isEmpty()) StdOut.print(stack.pop() + " "); &#125; StdOut.println("(" + stack.size() + " left on stack)"); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Bag</tag>
        <tag>Queue</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让类实现for-each loop:Iterable与Iterator接口]]></title>
    <url>%2F2018%2F06%2F01%2FIterable%E4%B8%8EIterator%2F</url>
    <content type="text"><![CDATA[Interface Iterable&lt;T&gt;根据Java API上写: Implementing this interface allows an object to be the target of the “for-each loop” statement. 也就是说,实现该接口可以让类实现for循环阅读Iterable源码,该接口有3个方法 Modifier,Type and Method Description public interface Iterable&lt;T&gt; &nbsp; default void forEach(Consumer action) Performs the given action for each element of the Iterable until all elements have been processed or the action throws an exception. Iterator iterator() Returns an iterator over elements of type T. default Spliterator spliterator() Creates a Spliterator over the elements described by this Iterable. 可以知道,实现该接口,我们只需要实现Iterator iterator()由API: Iterator iterator()Returns an iterator over elements of type T.Returns:an Iterator. 我们只需要返回一个Iterator对象就可以了 Interface IteratorJava API中说到: An iterator over a collection. Iterator takes the place of Enumeration in the Java Collections Framework. Iterators differ from enumerations in two ways:Iterators allow the caller to remove elements from the underlying collection during the iteration with well-defined semantics.Method names have been improved. 其实就是一个迭代器啦… Modifier,Type and Method Description public interface Iterator&lt;E&gt; &nbsp; default void forEachRemaining(Consumer action) Performs the given action for each remaining element until all elements have been processed or the action throws an exception. boolean hasNext() Returns true if the iteration has more elements. E next() Returns the next element in the iteration. default void remove() Removes from the underlying collection the last element returned by this iterator (optional operation). 可以知道,实现该接口,只要实现next()与hasNext(),当有remove()需求时,也要实现该方法. 下面是具体实现1.类名中加上implements Iterable1public class ClassName&lt;E&gt; implements Iterable&lt;E&gt; 2.实现Iterator iterator(),返回Iterator对象1public Iterator&lt;E&gt; iterator() &#123; return new MyIterator&lt;E&gt;(); &#125; 3.实现内部类MyIterator1234567891011121314private class MyIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123; public boolean hasNext() &#123; //return true if the iteration has more elements &#125; public E next() &#123; if (!hasNext()) throw NoSuchElementException(); // returns the next element in the iteration &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Iterable</tag>
        <tag>Iterator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaDoc与Jar]]></title>
    <url>%2F2018%2F06%2F01%2FJavaDoc%E4%B8%8EJar%2F</url>
    <content type="text"><![CDATA[使用JavaDoc生成文档1javadoc -d 目录名 -encoding UTF-8 -charset UTF-8 xxx.java java内格式： /** 文档内容 / @author : 对类的说明，表明开发该类模块的作者 @version : 对类的说明，表明该模块版本 @see : 对类，属性，方法的说明，参考转向，也就是相关主题 @param : 对方法的说明，对方法中某参数的说明 @return : 对方法的说明，对方法返回值的说明 @exception : 对方法的说明，对方法可能抛出的异常进行说明 下为《算法》中StdRandom.java源码的注释与文档效果 使用jar打包（1）编译 javac A.java （2）打包 jar cvfm A.jar A.man A.class ——c表示创建(create)，v表示显示详情(verbose)，f表示指定文件名，m表示清单文件（3）运行 java -jar A.jar 其中A.man是清单文件（manifest），内容如下：·Manifest-Version：1.0Class-Path：.Main-Class：A]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JavaDoc</tag>
        <tag>Jar</tag>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
